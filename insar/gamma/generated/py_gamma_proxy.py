from typing import Sequence, NamedTuple, Dict, Optional, Any, Tuple, Union, List
from collections import Counter
from pathlib import Path
from copy import copy
import inspect

GammaCall = NamedTuple(
    "GammaCall",
    [("module", str), ("program", str), ("parameters", List[str]), ("status", int)],
)

class SimpleParFile(object):
   values : Dict[str, str] = {}

   def __init__(self, path : Path) -> None:
       with open(path, 'r') as file:
           lines = file.read().splitlines()[1:]  # Skip header lines

           for line in lines:
               value_id = line.split(':')[0]
               if len(value_id.strip()) == 0:
                   continue

               value_data = line[len(value_id)+2:].strip()

               self.values[value_id] = value_data

   def get_value(self, value_id: str, dtype : Any = str, index: Optional[int] = None) -> Union[Any, List[Any]]:
       def attempt_convert(val : Any) -> Any:
           try:
               return dtype(val)
           except:
               return val

       if index is not None:
           return attempt_convert(self.values[value_id].split()[index])
       else:
           return [attempt_convert(i) for i in self.values[value_id].split()]


class GammaProxy(object):
    ParFile = SimpleParFile

    validate_inputs: bool = True
    mock_outputs: bool = False

    call_sequence: List[GammaCall]
    call_count: Counter
    error_count: int

    exception_type: Optional[type]
    wraps: Optional[object]
    fail_reason: Optional[str]

    def __init__(
        self, exception_type: Optional[type] = None, wraps: Optional[object] = None
    ) -> None:
        self.reset_proxy()
        self.exception_type = exception_type
        self.wraps = wraps

    def reset_proxy(self) -> None:
        self.call_sequence = []
        self.call_count = Counter()
        self.error_count = 0
        self.fail_reason = None

    def _on_error(
        self, cmd: str, params: List[str], status: Optional[int] = None
    ) -> None:
        if status is None or status == 0:
            return

        if self.exception_type is None:
            return

        raise self.exception_type(f"Failed to execute pg.{cmd} ({self.fail_reason})")

    def _gamma_call(
        self, gamma_module: str, gamma_program: str, program_args: List[str]
    ) -> Tuple[int, List[str], List[str]]:
        result = (0, [""], [""])

        if self.wraps is not None:
            result = getattr(self.wraps, gamma_program)(*program_args)

        self.call_count[gamma_program] += 1
        self.call_sequence.append(
            GammaCall(gamma_module, gamma_program, program_args, result[0])
        )
        self._on_error(gamma_program, program_args, result[0])

        return result

    def _clean_args(self, values: Dict[str, Any], sig: inspect.Signature) -> List[str]:
        cleaned = []
        for arg in sig.parameters.keys():
            value = copy(values[arg])
            if value is None:
                cleaned.append("-")
            else:
                cleaned.append(str(value))
        while cleaned[-1] == "-":
            cleaned.pop()
        return cleaned

    def _check_tab_file(self, tabfile: Path, param: str) -> None:
        with open(tabfile, "r") as fd:
            for line in fd.readlines():
                for el in line.split():
                    try:
                        int(el)
                        continue
                    except ValueError:
                        fn = Path(el)
                        assert (
                            fn.exists()
                        ), f"{fn} does not exist, referenced in {param}={tabfile}"
                        assert (
                            fn.stat().st_size > 0
                        ), f"{fn} has zero file size, referenced by {param}={tabfile}"

    def _validate_gc_map_fine(
        self,
        gc_in: Path,
        width: int,
        DIFF_par: Path,
        gc_out: Path,
        ref_flg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gc_map_fine.

        """

        assert gc_in.exists(), f"{gc_in} does not exist"
        assert gc_in.stat().st_size > 0, f"{gc_in} has zero file size"

        assert not gc_out.exists(), f"{gc_out} should _not_ exist!"

    def _mock_gc_map_fine_outputs(
        self,
        gc_in: Path,
        width: int,
        DIFF_par: Path,
        gc_out: Path,
        ref_flg: Optional[int] = None,
    ) -> None:
        """

        Mock the program gc_map_fine.

        """

        if gc_out is not None and str(gc_out) != "-":
            gc_out.touch()

    def gc_map_fine(
        self,
        gc_in: Path,
        width: int,
        DIFF_par: Path,
        gc_out: Path,
        ref_flg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Geocoding lookup table refinement using DIFF_par offset polynomials


        input parameters:
          gc_in     (input) geocoding lookup table
          width     width of geocoding lookup table (samples)
          DIFF_par  DIFF/GEO parameter file containing offset polynomial coefficients
          gc_out    (output) refined geocoding lookup table
          ref_flg   reference image flag (offsets are measured relative to the reference image):
                      0: actual SAR image
                      1: simulated SAR image (default)

        """

        if self.validate_inputs:
            self._validate_gc_map_fine(gc_in, width, DIFF_par, gc_out, ref_flg)

        if self.mock_outputs:
            self._mock_gc_map_fine_outputs(gc_in, width, DIFF_par, gc_out, ref_flg)

        ca = self._clean_args(locals(), inspect.signature(self.gc_map_fine))
        result = self._gamma_call("DIFF", "gc_map_fine", ca)

        assert gc_out.exists(), f"{gc_out} does not exist"
        assert gc_out.stat().st_size > 0, f"{gc_out} has zero file size"

        return result

    def _validate_diff_ls_fit(
        self,
        unw_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to diff_ls_fit.

        """

        assert unw_1.exists(), f"{unw_1} does not exist"
        assert unw_1.stat().st_size > 0, f"{unw_1} has zero file size"

        assert unw_2.exists(), f"{unw_2} does not exist"
        assert unw_2.stat().st_size > 0, f"{unw_2} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        if plot_data is not None:
            assert not plot_data.exists(), f"{plot_data} should _not_ exist!"

    def _mock_diff_ls_fit_outputs(
        self,
        unw_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
    ) -> None:
        """

        Mock the program diff_ls_fit.

        """

        if plot_data is not None and str(plot_data) != "-":
            plot_data.touch()

    def diff_ls_fit(
        self,
        unw_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Three-pass differential interferometry SVD to solve for the the L.S.offset


        input parameters:
          unw-1      (input) unwrapped interferogram 1
          unw-2      (input) unwrapped interferogram 2
          DIFF_par   (input)) DIFF/GEO parameter file for the scene
          nr         number of range samples (default=32)
          naz        number of azimuth samples (default=32)
          mask       mask (SUN/BMP/TIFF raster format), 0 valued pixels are excluded for fit (enter - for none)
          plot_data  (output) plot data file compatible with xmgr


        """

        if self.validate_inputs:
            self._validate_diff_ls_fit(unw_1, unw_2, DIFF_par, nr, naz, mask, plot_data)

        if self.mock_outputs:
            self._mock_diff_ls_fit_outputs(
                unw_1, unw_2, DIFF_par, nr, naz, mask, plot_data
            )

        ca = self._clean_args(locals(), inspect.signature(self.diff_ls_fit))
        result = self._gamma_call("DIFF", "diff_ls_fit", ca)

        if plot_data is not None:
            assert plot_data.exists(), f"{plot_data} does not exist"
            assert plot_data.stat().st_size > 0, f"{plot_data} has zero file size"

        return result

    def _validate_WSS_mosaic(
        self, WSS_tab: Path, MLI_par: Path, WSS_data: Path, type: int
    ) -> None:
        """

        Validate the arguments to WSS_mosaic.

        """

        assert WSS_tab.exists(), f"{WSS_tab} does not exist"
        assert WSS_tab.stat().st_size > 0, f"{WSS_tab} has zero file size"

        self._check_tab_file(WSS_tab, "WSS_tab")

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        assert not WSS_data.exists(), f"{WSS_data} should _not_ exist!"

    def _mock_WSS_mosaic_outputs(
        self, WSS_tab: Path, MLI_par: Path, WSS_data: Path, type: int
    ) -> None:
        """

        Mock the program WSS_mosaic.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if WSS_data is not None and str(WSS_data) != "-":
            WSS_data.touch()

    def WSS_mosaic(
        self, WSS_tab: Path, MLI_par: Path, WSS_data: Path, type: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        Mosaic ASAR WSS interferograms and MLI data


        input parameters:
          WSS_tab   (input) two column list of MLI data files and MLI image parameter files for each sub-swath (including paths)
                            required file order: SS1, SS2, SS3, SS4, SS5
          MLI_par   (output) ISP image parameter file for the mosaicked WSS MLI image or interferogram
          WSS_data  (output) WSS mosaicked MLI image or interferogram
          type      WSS data type:
                      0: FLOAT
                      1: FCOMPLEX


        """

        if self.validate_inputs:
            self._validate_WSS_mosaic(WSS_tab, MLI_par, WSS_data, type)

        if self.mock_outputs:
            self._mock_WSS_mosaic_outputs(WSS_tab, MLI_par, WSS_data, type)

        ca = self._clean_args(locals(), inspect.signature(self.WSS_mosaic))
        result = self._gamma_call("DIFF", "WSS_mosaic", ca)

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert WSS_data.exists(), f"{WSS_data} does not exist"
        assert WSS_data.stat().st_size > 0, f"{WSS_data} has zero file size"

        return result

    def _validate_dispmap_vec_offset(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap_r: Path,
        dispmap_az: Path,
        lv_theta: Path,
        lv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Path] = None,
        mode: Optional[int] = None,
        ax_north: Optional[int] = None,
        ax_east: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dispmap_vec_offset.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert dispmap_r.exists(), f"{dispmap_r} does not exist"
        assert dispmap_r.stat().st_size > 0, f"{dispmap_r} has zero file size"

        assert dispmap_az.exists(), f"{dispmap_az} does not exist"
        assert dispmap_az.stat().st_size > 0, f"{dispmap_az} has zero file size"

        assert lv_theta.exists(), f"{lv_theta} does not exist"
        assert lv_theta.stat().st_size > 0, f"{lv_theta} has zero file size"

        assert lv_phi.exists(), f"{lv_phi} does not exist"
        assert lv_phi.stat().st_size > 0, f"{lv_phi} has zero file size"

        assert not dv_norm.exists(), f"{dv_norm} should _not_ exist!"

        if dv_theta is not None:
            assert not dv_theta.exists(), f"{dv_theta} should _not_ exist!"

        if dv_phi is not None:
            assert not dv_phi.exists(), f"{dv_phi} should _not_ exist!"

        if dv_x is not None:
            assert not dv_x.exists(), f"{dv_x} should _not_ exist!"

        if dv_y is not None:
            assert not dv_y.exists(), f"{dv_y} should _not_ exist!"

        if dv_z is not None:
            assert not dv_z.exists(), f"{dv_z} should _not_ exist!"

    def _mock_dispmap_vec_offset_outputs(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap_r: Path,
        dispmap_az: Path,
        lv_theta: Path,
        lv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Path] = None,
        mode: Optional[int] = None,
        ax_north: Optional[int] = None,
        ax_east: Optional[int] = None,
    ) -> None:
        """

        Mock the program dispmap_vec_offset.

        """

        if dv_norm is not None and str(dv_norm) != "-":
            dv_norm.touch()

        if dv_theta is not None and str(dv_theta) != "-":
            dv_theta.touch()

        if dv_phi is not None and str(dv_phi) != "-":
            dv_phi.touch()

        if dv_x is not None and str(dv_x) != "-":
            dv_x.touch()

        if dv_y is not None and str(dv_y) != "-":
            dv_y.touch()

        if dv_z is not None and str(dv_z) != "-":
            dv_z.touch()

    def dispmap_vec_offset(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap_r: Path,
        dispmap_az: Path,
        lv_theta: Path,
        lv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Path] = None,
        mode: Optional[int] = None,
        ax_north: Optional[int] = None,
        ax_east: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculation of displacement vector field from slant-range/azimuth offsets (slant-range/azimuth)


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          DEM         (input) DEM data file (or constant height value)
          dispmap_r   (input) slant-range displacement map (m) (float)
          dispmap_az  (input) azimuth displacement map (m) (float)
          lv_theta    (input) look-vector elevation angle file or constant value in deg. (float)
          lv_phi      (input) look-vector orientation angle file or constant value in deg. (float)
          dv_norm     (output) norm of 3-dim displacement vector (float)
          dv_theta    (output) elevation angle of 3-dim displacement vector (float)
          dv_phi      (output) orientation angle of 3-dim displacement vector file or constant value deg. (float)
          dv_x        (output) easting  component of 3-dim displacement vector (float)
          dv_y        (output) northing component of 3-dim displacement vector (float)
          dv_z        (output) vertical component of 3-dim displacement vector (float)
          mask_angle  cutoff angle in degrees between the look and normal vectors to mask inaccurate results (default: 2)
          mode        displacement model mode (default=0):
                        0: displacement along terrain surface
                        1: displacement towards center axis
          ax_north    displacement center axis northing or latitude S
          ax_east     displacement center axis easting or longitude S

          NOTE: select - to avoid creation of the corresponding output file


        """

        if self.validate_inputs:
            self._validate_dispmap_vec_offset(
                DEM_par,
                DEM,
                dispmap_r,
                dispmap_az,
                lv_theta,
                lv_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
                mode,
                ax_north,
                ax_east,
            )

        if self.mock_outputs:
            self._mock_dispmap_vec_offset_outputs(
                DEM_par,
                DEM,
                dispmap_r,
                dispmap_az,
                lv_theta,
                lv_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
                mode,
                ax_north,
                ax_east,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dispmap_vec_offset))
        result = self._gamma_call("DIFF", "dispmap_vec_offset", ca)

        assert dv_norm.exists(), f"{dv_norm} does not exist"
        assert dv_norm.stat().st_size > 0, f"{dv_norm} has zero file size"

        if dv_theta is not None:
            assert dv_theta.exists(), f"{dv_theta} does not exist"
            assert dv_theta.stat().st_size > 0, f"{dv_theta} has zero file size"

        if dv_phi is not None:
            assert dv_phi.exists(), f"{dv_phi} does not exist"
            assert dv_phi.stat().st_size > 0, f"{dv_phi} has zero file size"

        if dv_x is not None:
            assert dv_x.exists(), f"{dv_x} does not exist"
            assert dv_x.stat().st_size > 0, f"{dv_x} has zero file size"

        if dv_y is not None:
            assert dv_y.exists(), f"{dv_y} does not exist"
            assert dv_y.stat().st_size > 0, f"{dv_y} has zero file size"

        if dv_z is not None:
            assert dv_z.exists(), f"{dv_z} does not exist"
            assert dv_z.stat().st_size > 0, f"{dv_z} has zero file size"

        return result

    def _validate_create_diff_par(
        self,
        PAR_1: Path,
        PAR_2: Optional[Path],
        DIFF_par: Path,
        PAR_type: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to create_diff_par.

        """

        assert PAR_1.exists(), f"{PAR_1} does not exist"
        assert PAR_1.stat().st_size > 0, f"{PAR_1} has zero file size"

        if PAR_2 is not None:
            assert PAR_2.exists(), f"{PAR_2} does not exist"
            assert PAR_2.stat().st_size > 0, f"{PAR_2} has zero file size"

    def _mock_create_diff_par_outputs(
        self,
        PAR_1: Path,
        PAR_2: Optional[Path],
        DIFF_par: Path,
        PAR_type: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program create_diff_par.

        """

        if not DIFF_par.exists():
            DIFF_par.touch()

    def create_diff_par(
        self,
        PAR_1: Path,
        PAR_2: Optional[Path],
        DIFF_par: Path,
        PAR_type: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Create DIFF/GEO parameter file for geocoding and differential interferometry


        input parameters:
          PAR-1     (input) image parameter file 1 (see PAR_type option)
          PAR-2     (input) image parameter file 2 (or - if not provided)
          DIFF_par  (input/output) DIFF/GEO parameter file
          PAR_type  PAR-1 and PAR-2 parameter file type (enter - for default):
                      0: OFF_par     ISP offset and interferogram parameters  (default)
                      1: SLC/MLI_par ISP SLC/MLI parameters
                      2: DEM_par     DIFF/GEO DEM parameters
          iflg      interactive mode flag (enter -  for default)
                      0: non-interactive
                      1: interactive (default)


        """

        if self.validate_inputs:
            self._validate_create_diff_par(PAR_1, PAR_2, DIFF_par, PAR_type, iflg)

        if self.mock_outputs:
            self._mock_create_diff_par_outputs(PAR_1, PAR_2, DIFF_par, PAR_type, iflg)

        ca = self._clean_args(locals(), inspect.signature(self.create_diff_par))
        result = self._gamma_call("DIFF", "create_diff_par", ca)

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        return result

    def _validate_gc_map_grd(
        self,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Path,
        DEM_seg: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        inc: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        ls_map: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_mode: Optional[int] = None,
        r_ovr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gc_map_grd.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert not DEM_seg.exists(), f"{DEM_seg} should _not_ exist!"

        assert not lookup_table.exists(), f"{lookup_table} should _not_ exist!"

        if sim_sar is not None:
            assert not sim_sar.exists(), f"{sim_sar} should _not_ exist!"

        if u is not None:
            assert not u.exists(), f"{u} should _not_ exist!"

        if v is not None:
            assert not v.exists(), f"{v} should _not_ exist!"

        if inc is not None:
            assert not inc.exists(), f"{inc} should _not_ exist!"

        if psi is not None:
            assert not psi.exists(), f"{psi} should _not_ exist!"

        if pix is not None:
            assert not pix.exists(), f"{pix} should _not_ exist!"

        if ls_map is not None:
            assert not ls_map.exists(), f"{ls_map} should _not_ exist!"

    def _mock_gc_map_grd_outputs(
        self,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Path,
        DEM_seg: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        inc: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        ls_map: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_mode: Optional[int] = None,
        r_ovr: Optional[int] = None,
    ) -> None:
        """

        Mock the program gc_map_grd.

        """

        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

        if DEM_seg is not None and str(DEM_seg) != "-":
            DEM_seg.touch()

        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

        if sim_sar is not None and str(sim_sar) != "-":
            sim_sar.touch()

        if u is not None and str(u) != "-":
            u.touch()

        if v is not None and str(v) != "-":
            v.touch()

        if inc is not None and str(inc) != "-":
            inc.touch()

        if psi is not None and str(psi) != "-":
            psi.touch()

        if pix is not None and str(pix) != "-":
            pix.touch()

        if ls_map is not None and str(ls_map) != "-":
            ls_map.touch()

    def gc_map_grd(
        self,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Path,
        DEM_seg: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        inc: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        ls_map: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_mode: Optional[int] = None,
        r_ovr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate lookup table and DEM related products for terrain-corrected geocoding of ground range images
        Derive DEM products in DEM/MAP geometry:
                   local normal spherical angles, u, v
                   simulated SAR intensity (in map geometry), simsar
                   local incidence angle, linc
                   projection angle, psi
                   pixel area normalization factor, pix
                   layover / shadow map, ls_map


        input parameters:
          GRD_par         (input) ground-range image ISP parameter file (format as SLC/MLI_par)
          DEM_par         (input) DEM/MAP parameter file
          DEM             (input) DEM data file (or constant height value)
          DEM_seg_par     (input/output) DEM/MAP segment parameter file used for output products

          NOTE: If the DEM_seg_par already exists, then the output DEM parameters will be read from this file
                otherwise they are estimated from the image data.

          DEM_seg         (output) DEM segment used for output products, interpolated if lat_ovr > 1.0  or lon_ovr > 1.0
          lookup_table    (output) geocoding lookup table (fcomplex)
          lat_ovr         latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr         longitude or easting output DEM oversampling factor (enter - for default: 1.0)
          sim_sar         (output) simulated SAR backscatter image in DEM geometry
          u               (output) zenith angle of surface normal vector n (angle between z and n)
          v               (output) orientation angle of n (between x and projection of n in xy plane)
          inc             (output) local incidence angle (between surface normal and look vector)
          psi             (output) projection angle (between surface normal and image plane normal)
          pix             (output) pixel area normalization factor
          ls_map          (output) layover and shadow map (in map projection)
          frame           number of DEM pixels to add around area covered by SAR image (enter - for default = 8)
          ls_mode         output lookup table values in regions of layover, shadow, or DEM gaps (enter - for default)
                            0: set to (0.,0.)
                            1: linear interpolation across these regions (default)
                            2: actual value
                            3: nn-thinned
          r_ovr           range over-sampling factor for nn-thinned layover/shadow mode(enter - for default: 2.0)

        NOTE: enter - as output filename to avoid creating the corresponding output file


        """

        if self.validate_inputs:
            self._validate_gc_map_grd(
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                sim_sar,
                u,
                v,
                inc,
                psi,
                pix,
                ls_map,
                frame,
                ls_mode,
                r_ovr,
            )

        if self.mock_outputs:
            self._mock_gc_map_grd_outputs(
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                sim_sar,
                u,
                v,
                inc,
                psi,
                pix,
                ls_map,
                frame,
                ls_mode,
                r_ovr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.gc_map_grd))
        result = self._gamma_call("DIFF", "gc_map_grd", ca)

        assert DEM_seg_par.exists(), f"{DEM_seg_par} does not exist"
        assert DEM_seg_par.stat().st_size > 0, f"{DEM_seg_par} has zero file size"

        assert DEM_seg.exists(), f"{DEM_seg} does not exist"
        assert DEM_seg.stat().st_size > 0, f"{DEM_seg} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        if sim_sar is not None:
            assert sim_sar.exists(), f"{sim_sar} does not exist"
            assert sim_sar.stat().st_size > 0, f"{sim_sar} has zero file size"

        if u is not None:
            assert u.exists(), f"{u} does not exist"
            assert u.stat().st_size > 0, f"{u} has zero file size"

        if v is not None:
            assert v.exists(), f"{v} does not exist"
            assert v.stat().st_size > 0, f"{v} has zero file size"

        if inc is not None:
            assert inc.exists(), f"{inc} does not exist"
            assert inc.stat().st_size > 0, f"{inc} has zero file size"

        if psi is not None:
            assert psi.exists(), f"{psi} does not exist"
            assert psi.stat().st_size > 0, f"{psi} has zero file size"

        if pix is not None:
            assert pix.exists(), f"{pix} does not exist"
            assert pix.stat().st_size > 0, f"{pix} has zero file size"

        if ls_map is not None:
            assert ls_map.exists(), f"{ls_map} does not exist"
            assert ls_map.stat().st_size > 0, f"{ls_map} has zero file size"

        return result

    def _validate_coord_trans_list(
        self,
        c_in_list: Path,
        c_out_list: Path,
        DEM1_par: Path,
        DEM2_par: Path,
        geoid1: Optional[Path] = None,
        geoid1_par: Optional[Path] = None,
        geoid1_type: Optional[int] = None,
        geoid2: Optional[Path] = None,
        geoid2_par: Optional[Path] = None,
        geoid2_type: Optional[int] = None,
        c_xyz_list: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to coord_trans_list.

        """

        assert c_in_list.exists(), f"{c_in_list} does not exist"
        assert c_in_list.stat().st_size > 0, f"{c_in_list} has zero file size"

        assert not c_out_list.exists(), f"{c_out_list} should _not_ exist!"

        assert DEM1_par.exists(), f"{DEM1_par} does not exist"
        assert DEM1_par.stat().st_size > 0, f"{DEM1_par} has zero file size"

        assert DEM2_par.exists(), f"{DEM2_par} does not exist"
        assert DEM2_par.stat().st_size > 0, f"{DEM2_par} has zero file size"

        if geoid1 is not None:
            assert geoid1.exists(), f"{geoid1} does not exist"
            assert geoid1.stat().st_size > 0, f"{geoid1} has zero file size"

        if geoid1_par is not None:
            assert geoid1_par.exists(), f"{geoid1_par} does not exist"
            assert geoid1_par.stat().st_size > 0, f"{geoid1_par} has zero file size"

        if geoid2 is not None:
            assert geoid2.exists(), f"{geoid2} does not exist"
            assert geoid2.stat().st_size > 0, f"{geoid2} has zero file size"

        if geoid2_par is not None:
            assert geoid2_par.exists(), f"{geoid2_par} does not exist"
            assert geoid2_par.stat().st_size > 0, f"{geoid2_par} has zero file size"

        if c_xyz_list is not None:
            assert not c_xyz_list.exists(), f"{c_xyz_list} should _not_ exist!"

    def _mock_coord_trans_list_outputs(
        self,
        c_in_list: Path,
        c_out_list: Path,
        DEM1_par: Path,
        DEM2_par: Path,
        geoid1: Optional[Path] = None,
        geoid1_par: Optional[Path] = None,
        geoid1_type: Optional[int] = None,
        geoid2: Optional[Path] = None,
        geoid2_par: Optional[Path] = None,
        geoid2_type: Optional[int] = None,
        c_xyz_list: Optional[Path] = None,
    ) -> None:
        """

        Mock the program coord_trans_list.

        """

        if c_out_list is not None and str(c_out_list) != "-":
            c_out_list.touch()

        if c_xyz_list is not None and str(c_xyz_list) != "-":
            c_xyz_list.touch()

    def coord_trans_list(
        self,
        c_in_list: Path,
        c_out_list: Path,
        DEM1_par: Path,
        DEM2_par: Path,
        geoid1: Optional[Path] = None,
        geoid1_par: Optional[Path] = None,
        geoid1_type: Optional[int] = None,
        geoid2: Optional[Path] = None,
        geoid2_par: Optional[Path] = None,
        geoid2_type: Optional[int] = None,
        c_xyz_list: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Coordinate transformation between map projections for list of points


        input parameters:
          c_in_list     (input) list of map coordinates and heights with 3 columns:
                          northing/latitude  easting/longitude  height
          c_out_list    (output) list of map coordinates and heights with 3 columns:
                          northing/latitude  easting/longitude  height
          DEM1_par      (input) DIFF/GEO DEM parameter file with definition of input coordinate system
          DEM2_par      (input) DIFF/GEO DEM parameter file with definition of output coordinate system
          geoid1        (input) geoid or constant geoid height value of input coordinate system (enter - for none)
          geoid1_par    (input) geoid DEM_par file of input coordinate system (enter - for none)
          geoid1_type   geoid1 type (enter - for default)
                          0: global geoid in EQA coordinates (default)
                          1: local geoid in the same coordinate system as the input coordinates (DEM1_par)
          geoid2        (input) geoid or constant geoid height value of output coordinate system (enter - for none)
          geoid2_par    (input) geoid DEM_par file of output coordinate system (enter - for none)
          geoid2_type   geoid2 type (enter - for default)
                          0: global geoid in EQA coordinates (default)
                          1: local geoid in the same coordinate system as the output coordinates (DEM2_par)
          c_xyz_list    (output) list of global (WGS84) Cartesian coordinates with 3 columns:
                          X  Y  Z (enter - for none)
          NOTE: geoid1 and geoid2 are used to transform the height from an altitude relative to the sea level
                (i.e. above the geoid) to an altitude relative to the ellipsoid of the coordinate system and vice versa
                EGM96 global geoid is available as "$DIFF_HOME/scripts/egm96.dem" and "$DIFF_HOME/scripts/egm96.dem_par"
                EGM2008 global geoid is available as "$DIFF_HOME/scripts/egm2008-5.dem" and "$DIFF_HOME/scripts/egm2008-5.dem_par"


        """

        if self.validate_inputs:
            self._validate_coord_trans_list(
                c_in_list,
                c_out_list,
                DEM1_par,
                DEM2_par,
                geoid1,
                geoid1_par,
                geoid1_type,
                geoid2,
                geoid2_par,
                geoid2_type,
                c_xyz_list,
            )

        if self.mock_outputs:
            self._mock_coord_trans_list_outputs(
                c_in_list,
                c_out_list,
                DEM1_par,
                DEM2_par,
                geoid1,
                geoid1_par,
                geoid1_type,
                geoid2,
                geoid2_par,
                geoid2_type,
                c_xyz_list,
            )

        ca = self._clean_args(locals(), inspect.signature(self.coord_trans_list))
        result = self._gamma_call("DIFF", "coord_trans_list", ca)

        assert c_out_list.exists(), f"{c_out_list} does not exist"
        assert c_out_list.stat().st_size > 0, f"{c_out_list} has zero file size"

        if c_xyz_list is not None:
            assert c_xyz_list.exists(), f"{c_xyz_list} does not exist"
            assert c_xyz_list.stat().st_size > 0, f"{c_xyz_list} has zero file size"

        return result

    def _validate_multi_mosaic(
        self,
        data_tab: Path,
        data_out: Path,
        DEM_par_out: Path,
        mode: int,
        format_flag: int,
    ) -> None:
        """

        Validate the arguments to multi_mosaic.

        """

        assert data_tab.exists(), f"{data_tab} does not exist"
        assert data_tab.stat().st_size > 0, f"{data_tab} has zero file size"

        self._check_tab_file(data_tab, "data_tab")

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

        assert not DEM_par_out.exists(), f"{DEM_par_out} should _not_ exist!"

    def _mock_multi_mosaic_outputs(
        self,
        data_tab: Path,
        data_out: Path,
        DEM_par_out: Path,
        mode: int,
        format_flag: int,
    ) -> None:
        """

        Mock the program multi_mosaic.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

        if DEM_par_out is not None and str(DEM_par_out) != "-":
            DEM_par_out.touch()

    def multi_mosaic(
        self,
        data_tab: Path,
        data_out: Path,
        DEM_par_out: Path,
        mode: int,
        format_flag: int,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Mosaic geocoded images or DEM data with same format, map projection, and pixel spacing parameters
        Supported formats: float, fcomplex, int, short, unsigned char, SUN raster, and BMP image files


        input parameters:
          data_tab     (input) list of data to mosaic (2 columns), one line for each input data file (text format):
                         data   DEM_par
          data_out     (output) output data file
          DEM_par_out  (output) DEM parameter file of output data file
                         NOTE: If this file exists, then the bounds of the mosaic are read from the parameter file,
                         otherwise bounds including all input data will be computed and written to the parameter file
          mode         mosaic processing mode
                         0: value of prior image preferred in the case of multiple valid input values
                         1: average of multiple valid input values calculated
          format_flag  input/output data format flag
                         0: FLOAT (REAL*4)
                         1: FCOMPLEX (pairs of float)
                         2: INTEGER (INTEGER*4)
                         3: SHORT (INTEGER*2)
                         4: UNSIGNED CHAR
                         5: SUN raster, BMP, or TIFF image files (8 or 24 bit)


        """

        if self.validate_inputs:
            self._validate_multi_mosaic(
                data_tab, data_out, DEM_par_out, mode, format_flag
            )

        if self.mock_outputs:
            self._mock_multi_mosaic_outputs(
                data_tab, data_out, DEM_par_out, mode, format_flag
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_mosaic))
        result = self._gamma_call("DIFF", "multi_mosaic", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        assert DEM_par_out.exists(), f"{DEM_par_out} does not exist"
        assert DEM_par_out.stat().st_size > 0, f"{DEM_par_out} has zero file size"

        return result

    def _validate_gc_map1(
        self,
        MLI_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Path,
        DEM_seg: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        inc: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        ls_map: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_mode: Optional[int] = None,
        r_ovr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gc_map1.

        """

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert not DEM_seg.exists(), f"{DEM_seg} should _not_ exist!"

        assert not lookup_table.exists(), f"{lookup_table} should _not_ exist!"

        if sim_sar is not None:
            assert not sim_sar.exists(), f"{sim_sar} should _not_ exist!"

        if u is not None:
            assert not u.exists(), f"{u} should _not_ exist!"

        if v is not None:
            assert not v.exists(), f"{v} should _not_ exist!"

        if inc is not None:
            assert not inc.exists(), f"{inc} should _not_ exist!"

        if psi is not None:
            assert not psi.exists(), f"{psi} should _not_ exist!"

        if pix is not None:
            assert not pix.exists(), f"{pix} should _not_ exist!"

        if ls_map is not None:
            assert not ls_map.exists(), f"{ls_map} should _not_ exist!"

    def _mock_gc_map1_outputs(
        self,
        MLI_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Path,
        DEM_seg: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        inc: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        ls_map: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_mode: Optional[int] = None,
        r_ovr: Optional[int] = None,
    ) -> None:
        """

        Mock the program gc_map1.

        """

        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

        if DEM_seg is not None and str(DEM_seg) != "-":
            DEM_seg.touch()

        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

        if sim_sar is not None and str(sim_sar) != "-":
            sim_sar.touch()

        if u is not None and str(u) != "-":
            u.touch()

        if v is not None and str(v) != "-":
            v.touch()

        if inc is not None and str(inc) != "-":
            inc.touch()

        if psi is not None and str(psi) != "-":
            psi.touch()

        if pix is not None and str(pix) != "-":
            pix.touch()

        if ls_map is not None and str(ls_map) != "-":
            ls_map.touch()

    def gc_map1(
        self,
        MLI_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Path,
        DEM_seg: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        inc: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        ls_map: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_mode: Optional[int] = None,
        r_ovr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate terrain-geocoding lookup table and DEM derived data products


        input parameters:
          MLI_par         (input) ISP MLI or SLC image parameter file (slant range geometry)
          OFF_par         (input) ISP offset/interferogram parameter file (enter - if geocoding SLC or MLI data)
          DEM_par         (input) DEM/MAP parameter file
          DEM             (input) DEM data file (or constant height value)
          DEM_seg_par     (input/output) DEM/MAP segment parameter file used for output products

          NOTE: If <DEM_seg_par> already exists, then the output DEM parameters will be read
                from this file, otherwise they are estimated from the image data.
                If <DEM_par> and <DEM_seg_par> are the same file, <DEM_seg> is ignored.

          DEM_seg         (output) DEM segment used for output products, interpolated if lat_ovr > 1.0 or lon_ovr > 1.0
          lookup_table    (output) geocoding lookup table (fcomplex)
          lat_ovr         latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr         longitude or easting output DEM oversampling factor (enter - for default: 1.0)
          sim_sar         (output) simulated SAR backscatter image in DEM geometry
          u               (output) zenith angle of surface normal vector n (angle between z and n)
          v               (output) orientation angle of n (between x and projection of n in xy plane)
          inc             (output) local incidence angle (between surface normal and look vector)
          psi             (output) projection angle (between surface normal and image plane normal)
          pix             (output) pixel area normalization factor
          ls_map          (output) layover and shadow map (in map projection)
          frame           number of DEM pixels to add around area covered by SAR image (enter - for default = 8)
          ls_mode         output lookup table values in regions of layover, shadow, or DEM gaps (enter - for default)
                            0: set to (0.,0.)
                            1: linear interpolation across these regions
                            2: actual value (default)
                            3: nn-thinned
          r_ovr           range over-sampling factor for nn-thinned layover/shadow mode(enter - for default: 2.0)

        NOTE: enter - as output filename to avoid creating the corresponding output file


        """

        if self.validate_inputs:
            self._validate_gc_map1(
                MLI_par,
                OFF_par,
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                sim_sar,
                u,
                v,
                inc,
                psi,
                pix,
                ls_map,
                frame,
                ls_mode,
                r_ovr,
            )

        if self.mock_outputs:
            self._mock_gc_map1_outputs(
                MLI_par,
                OFF_par,
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                sim_sar,
                u,
                v,
                inc,
                psi,
                pix,
                ls_map,
                frame,
                ls_mode,
                r_ovr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.gc_map1))
        result = self._gamma_call("DIFF", "gc_map1", ca)

        assert DEM_seg_par.exists(), f"{DEM_seg_par} does not exist"
        assert DEM_seg_par.stat().st_size > 0, f"{DEM_seg_par} has zero file size"

        assert DEM_seg.exists(), f"{DEM_seg} does not exist"
        assert DEM_seg.stat().st_size > 0, f"{DEM_seg} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        if sim_sar is not None:
            assert sim_sar.exists(), f"{sim_sar} does not exist"
            assert sim_sar.stat().st_size > 0, f"{sim_sar} has zero file size"

        if u is not None:
            assert u.exists(), f"{u} does not exist"
            assert u.stat().st_size > 0, f"{u} has zero file size"

        if v is not None:
            assert v.exists(), f"{v} does not exist"
            assert v.stat().st_size > 0, f"{v} has zero file size"

        if inc is not None:
            assert inc.exists(), f"{inc} does not exist"
            assert inc.stat().st_size > 0, f"{inc} has zero file size"

        if psi is not None:
            assert psi.exists(), f"{psi} does not exist"
            assert psi.stat().st_size > 0, f"{psi} has zero file size"

        if pix is not None:
            assert pix.exists(), f"{pix} does not exist"
            assert pix.stat().st_size > 0, f"{pix} has zero file size"

        if ls_map is not None:
            assert ls_map.exists(), f"{ls_map} does not exist"
            assert ls_map.stat().st_size > 0, f"{ls_map} has zero file size"

        return result

    def _validate_SLC_diff_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        sim_unw: Path,
        diff_int: Path,
        rlks: int,
        azlks: int,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rbw_min: Optional[float] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_diff_intf.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2R.exists(), f"{SLC_2R} does not exist"
        assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert sim_unw.exists(), f"{sim_unw} does not exist"
        assert sim_unw.stat().st_size > 0, f"{sim_unw} has zero file size"

        assert not diff_int.exists(), f"{diff_int} should _not_ exist!"

    def _mock_SLC_diff_intf_outputs(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        sim_unw: Path,
        diff_int: Path,
        rlks: int,
        azlks: int,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rbw_min: Optional[float] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_diff_intf.

        """

        if diff_int is not None and str(diff_int) != "-":
            diff_int.touch()

    def SLC_diff_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        sim_unw: Path,
        diff_int: Path,
        rlks: int,
        azlks: int,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rbw_min: Optional[float] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Differential interferogram generation from co-registered SLCs and a simulated interferogram


        input parameters:
          SLC-1      (input) single-look complex image 1 (reference)
          SLC-2R     (input) single-look complex image 2 coregistered to SLC-1
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2R_par  (input) SLC-2R ISP image parameter file for the co-registered image
          OFF_par    (input) ISP offset/interferogram parameter file
          sim_unw    (input) simulated unflattened and unwrapped interferogram, same width as output interferogram (float)
          diff_int   (output) differential interferogram (complex)
          rlks       number of range looks for the output interferogram
          azlks      number of azimuth looks for the simulated and output interferogram
          sps_flg    range spectral shift flag (enter - for default)
                       1: apply range spectral shift filter (default)
                       0: do not apply range spectral shift filter
          azf_flg    azimuth common band filter flag (enter - for default)
                       1: apply azimuth common band filter (default)
                       0: do not apply azimuth common band filter
          rbw_min    minimum range bandwidth fraction (0.1 --> 1.0) (enter - for default:  0.250)
          rp1_flg    SLC-1 range phase mode (enter - for default)
                       0: nearest approach (0-Doppler) phase
                       1: ref. function center (Doppler centroid) (default)
          rp2_flg    SLC-2 range phase mode (enter - for default)
                       0: nearest approach (0-Doppler) phase
                       1: ref. function center (Doppler centroid) (default)


        """

        if self.validate_inputs:
            self._validate_SLC_diff_intf(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                sim_unw,
                diff_int,
                rlks,
                azlks,
                sps_flg,
                azf_flg,
                rbw_min,
                rp1_flg,
                rp2_flg,
            )

        if self.mock_outputs:
            self._mock_SLC_diff_intf_outputs(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                sim_unw,
                diff_int,
                rlks,
                azlks,
                sps_flg,
                azf_flg,
                rbw_min,
                rp1_flg,
                rp2_flg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_diff_intf))
        result = self._gamma_call("DIFF", "SLC_diff_intf", ca)

        assert diff_int.exists(), f"{diff_int} does not exist"
        assert diff_int.stat().st_size > 0, f"{diff_int} has zero file size"

        return result

    def _validate_pixel_area(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lookup_table: Path,
        ls_map: Path,
        inc_map: Optional[Path] = None,
        pix_sigma0: Optional[Path] = None,
        pix_gamma0: Optional[Path] = None,
        nstep: Optional[Path] = None,
        area_fact: Optional[int] = None,
        sigma0_ratio: Optional[Path] = None,
        gamma0_ratio: Optional[Path] = None,
        sig2gam_ratio: Optional[Path] = None,
        hgt: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to pixel_area.

        """

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        assert ls_map.exists(), f"{ls_map} does not exist"
        assert ls_map.stat().st_size > 0, f"{ls_map} has zero file size"

        if inc_map is not None:
            assert inc_map.exists(), f"{inc_map} does not exist"
            assert inc_map.stat().st_size > 0, f"{inc_map} has zero file size"

        if pix_sigma0 is not None:
            assert not pix_sigma0.exists(), f"{pix_sigma0} should _not_ exist!"

        if pix_gamma0 is not None:
            assert not pix_gamma0.exists(), f"{pix_gamma0} should _not_ exist!"

        if sigma0_ratio is not None:
            assert not sigma0_ratio.exists(), f"{sigma0_ratio} should _not_ exist!"

        if gamma0_ratio is not None:
            assert not gamma0_ratio.exists(), f"{gamma0_ratio} should _not_ exist!"

        if sig2gam_ratio is not None:
            assert not sig2gam_ratio.exists(), f"{sig2gam_ratio} should _not_ exist!"

        if hgt is not None:
            assert not hgt.exists(), f"{hgt} should _not_ exist!"

    def _mock_pixel_area_outputs(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lookup_table: Path,
        ls_map: Path,
        inc_map: Optional[Path] = None,
        pix_sigma0: Optional[Path] = None,
        pix_gamma0: Optional[Path] = None,
        nstep: Optional[Path] = None,
        area_fact: Optional[int] = None,
        sigma0_ratio: Optional[Path] = None,
        gamma0_ratio: Optional[Path] = None,
        sig2gam_ratio: Optional[Path] = None,
        hgt: Optional[Path] = None,
    ) -> None:
        """

        Mock the program pixel_area.

        """

        if pix_sigma0 is not None and str(pix_sigma0) != "-":
            pix_sigma0.touch()

        if pix_gamma0 is not None and str(pix_gamma0) != "-":
            pix_gamma0.touch()

        if sigma0_ratio is not None and str(sigma0_ratio) != "-":
            sigma0_ratio.touch()

        if gamma0_ratio is not None and str(gamma0_ratio) != "-":
            gamma0_ratio.touch()

        if sig2gam_ratio is not None and str(sig2gam_ratio) != "-":
            sig2gam_ratio.touch()

        if hgt is not None and str(hgt) != "-":
            hgt.touch()

    def pixel_area(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lookup_table: Path,
        ls_map: Path,
        inc_map: Optional[Path] = None,
        pix_sigma0: Optional[Path] = None,
        pix_gamma0: Optional[Path] = None,
        nstep: Optional[Path] = None,
        area_fact: Optional[int] = None,
        sigma0_ratio: Optional[Path] = None,
        gamma0_ratio: Optional[Path] = None,
        sig2gam_ratio: Optional[Path] = None,
        hgt: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate terrain-based sigma0 and gammma0 normalization area in slant-range geometry


        input parameters:
          MLI_par       (input) ISP MLI or SLC image parameter file (slant-range geometry)
          DEM_par       (input) DEM/MAP parameter file
          DEM           (input) DEM data file (or constant height value)
          lookup_table  (input) geocoding lookup table (FCOMPLEX)
          ls_map        (input) layover and shadow map in map geometry
          inc_map       (input) local incidence angle map in map geometry (enter - for none)
                        NOTE: required for calculation of pix_gamma0, gamma0_ratio, and sig2gam_ratio
          pix_sigma0    (output) sigma0 normalization area in RDC geometry (enter - for none)
          pix_gamma0    (output) gamma0 normalization area in RDC geometry (enter - for none)
          nstep         number of steps to divide each dimension of the map pixels (enter - for default: 16)
          area_fact     area factor that is multiplied with the rg/az pixel size to set a lower
                        threshold for the minimal pixel area that is accepted (enter - for default: 1.00)
          sigma0_ratio  (output) ratio between ellipsoid and DEM-based sigma0 normalization areas (enter - for none)
          gamma0_ratio  (output) ratio between ellipsoid and DEM-based gamma0 normalization areas (enter - for none)
          sig2gam_ratio (output) ratio of ellipsoid sigma0 and DEM-based gamma0 normalization areas (enter - for none)
          hgt           (output) height map in RDC geometry (enter - for none)


        """

        if self.validate_inputs:
            self._validate_pixel_area(
                MLI_par,
                DEM_par,
                DEM,
                lookup_table,
                ls_map,
                inc_map,
                pix_sigma0,
                pix_gamma0,
                nstep,
                area_fact,
                sigma0_ratio,
                gamma0_ratio,
                sig2gam_ratio,
                hgt,
            )

        if self.mock_outputs:
            self._mock_pixel_area_outputs(
                MLI_par,
                DEM_par,
                DEM,
                lookup_table,
                ls_map,
                inc_map,
                pix_sigma0,
                pix_gamma0,
                nstep,
                area_fact,
                sigma0_ratio,
                gamma0_ratio,
                sig2gam_ratio,
                hgt,
            )

        ca = self._clean_args(locals(), inspect.signature(self.pixel_area))
        result = self._gamma_call("DIFF", "pixel_area", ca)

        if pix_sigma0 is not None:
            assert pix_sigma0.exists(), f"{pix_sigma0} does not exist"
            assert pix_sigma0.stat().st_size > 0, f"{pix_sigma0} has zero file size"

        if pix_gamma0 is not None:
            assert pix_gamma0.exists(), f"{pix_gamma0} does not exist"
            assert pix_gamma0.stat().st_size > 0, f"{pix_gamma0} has zero file size"

        if sigma0_ratio is not None:
            assert sigma0_ratio.exists(), f"{sigma0_ratio} does not exist"
            assert sigma0_ratio.stat().st_size > 0, f"{sigma0_ratio} has zero file size"

        if gamma0_ratio is not None:
            assert gamma0_ratio.exists(), f"{gamma0_ratio} does not exist"
            assert gamma0_ratio.stat().st_size > 0, f"{gamma0_ratio} has zero file size"

        if sig2gam_ratio is not None:
            assert sig2gam_ratio.exists(), f"{sig2gam_ratio} does not exist"
            assert sig2gam_ratio.stat().st_size > 0, f"{sig2gam_ratio} has zero file size"

        if hgt is not None:
            assert hgt.exists(), f"{hgt} does not exist"
            assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        return result

    def _validate_extract_gcp(
        self,
        DEM_rdc: Path,
        OFF_par: Path,
        GCP: Path,
        nr: int,
        naz: int,
        mask: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to extract_gcp.

        """

        assert DEM_rdc.exists(), f"{DEM_rdc} does not exist"
        assert DEM_rdc.stat().st_size > 0, f"{DEM_rdc} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not GCP.exists(), f"{GCP} should _not_ exist!"

        if mask is not None:
            assert mask.exists(), f"{mask} does not exist"
            assert mask.stat().st_size > 0, f"{mask} has zero file size"

    def _mock_extract_gcp_outputs(
        self,
        DEM_rdc: Path,
        OFF_par: Path,
        GCP: Path,
        nr: int,
        naz: int,
        mask: Optional[Path] = None,
    ) -> None:
        """

        Mock the program extract_gcp.

        """

        if GCP is not None and str(GCP) != "-":
            GCP.touch()

    def extract_gcp(
        self,
        DEM_rdc: Path,
        OFF_par: Path,
        GCP: Path,
        nr: int,
        naz: int,
        mask: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract GCPs from a DEM in range-Doppler coordinates


        input parameters:
          DEM_rdc  (input) DEM in range-Doppler coordinates
          OFF_par  (input) ISP offset/interferogram parameter file
          GCP      (output) GCP height data file (text format)
          nr       number of GCP locations in range (default: 32)
          naz      number of GCP azimuth locations (default: 32)
          mask     (input) GCP selection mask (SUN raster, BMP, or TIFF format)
                   NOTE: GCPs are excluded from regions where the mask = 0


        """

        if self.validate_inputs:
            self._validate_extract_gcp(DEM_rdc, OFF_par, GCP, nr, naz, mask)

        if self.mock_outputs:
            self._mock_extract_gcp_outputs(DEM_rdc, OFF_par, GCP, nr, naz, mask)

        ca = self._clean_args(locals(), inspect.signature(self.extract_gcp))
        result = self._gamma_call("DIFF", "extract_gcp", ca)

        assert GCP.exists(), f"{GCP} does not exist"
        assert GCP.stat().st_size > 0, f"{GCP} has zero file size"

        return result

    def _validate_gc_map2(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Optional[Path] = None,
        DEM_seg: Optional[Path] = None,
        lookup_table: Optional[Path] = None,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        ls_map: Optional[Path] = None,
        ls_map_rdc: Optional[Path] = None,
        inc: Optional[Path] = None,
        res: Optional[Path] = None,
        offnadir: Optional[Path] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        r_ovr: Optional[int] = None,
        az_dec: Optional[int] = None,
        mask: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_scaling: Optional[Path] = None,
        DIFF_par: Optional[Path] = None,
        ref_flg: Optional[int] = None,
        inc_flg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gc_map2.

        """

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        if DEM_seg_par is not None:
            assert not DEM_seg_par.exists(), f"{DEM_seg_par} should _not_ exist!"

        if DEM_seg is not None:
            assert not DEM_seg.exists(), f"{DEM_seg} should _not_ exist!"

        if lookup_table is not None:
            assert not lookup_table.exists(), f"{lookup_table} should _not_ exist!"

        if ls_map is not None:
            assert not ls_map.exists(), f"{ls_map} should _not_ exist!"

        if ls_map_rdc is not None:
            assert not ls_map_rdc.exists(), f"{ls_map_rdc} should _not_ exist!"

        if inc is not None:
            assert not inc.exists(), f"{inc} should _not_ exist!"

        if res is not None:
            assert not res.exists(), f"{res} should _not_ exist!"

        if offnadir is not None:
            assert not offnadir.exists(), f"{offnadir} should _not_ exist!"

        if sim_sar is not None:
            assert not sim_sar.exists(), f"{sim_sar} should _not_ exist!"

        if u is not None:
            assert not u.exists(), f"{u} should _not_ exist!"

        if v is not None:
            assert not v.exists(), f"{v} should _not_ exist!"

        if psi is not None:
            assert not psi.exists(), f"{psi} should _not_ exist!"

        if pix is not None:
            assert not pix.exists(), f"{pix} should _not_ exist!"

        if DIFF_par is not None:
            assert DIFF_par.exists(), f"{DIFF_par} does not exist"
            assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

    def _mock_gc_map2_outputs(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Optional[Path] = None,
        DEM_seg: Optional[Path] = None,
        lookup_table: Optional[Path] = None,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        ls_map: Optional[Path] = None,
        ls_map_rdc: Optional[Path] = None,
        inc: Optional[Path] = None,
        res: Optional[Path] = None,
        offnadir: Optional[Path] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        r_ovr: Optional[int] = None,
        az_dec: Optional[int] = None,
        mask: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_scaling: Optional[Path] = None,
        DIFF_par: Optional[Path] = None,
        ref_flg: Optional[int] = None,
        inc_flg: Optional[int] = None,
    ) -> None:
        """

        Mock the program gc_map2.

        """

        if DEM_seg_par is not None and str(DEM_seg_par) != "-":
            DEM_seg_par.touch()

        if DEM_seg is not None and str(DEM_seg) != "-":
            DEM_seg.touch()

        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

        if ls_map is not None and str(ls_map) != "-":
            ls_map.touch()

        if ls_map_rdc is not None and str(ls_map_rdc) != "-":
            ls_map_rdc.touch()

        if inc is not None and str(inc) != "-":
            inc.touch()

        if res is not None and str(res) != "-":
            res.touch()

        if offnadir is not None and str(offnadir) != "-":
            offnadir.touch()

        if sim_sar is not None and str(sim_sar) != "-":
            sim_sar.touch()

        if u is not None and str(u) != "-":
            u.touch()

        if v is not None and str(v) != "-":
            v.touch()

        if psi is not None and str(psi) != "-":
            psi.touch()

        if pix is not None and str(pix) != "-":
            pix.touch()

    def gc_map2(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Optional[Path] = None,
        DEM_seg: Optional[Path] = None,
        lookup_table: Optional[Path] = None,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        ls_map: Optional[Path] = None,
        ls_map_rdc: Optional[Path] = None,
        inc: Optional[Path] = None,
        res: Optional[Path] = None,
        offnadir: Optional[Path] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        r_ovr: Optional[int] = None,
        az_dec: Optional[int] = None,
        mask: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_scaling: Optional[Path] = None,
        DIFF_par: Optional[Path] = None,
        ref_flg: Optional[int] = None,
        inc_flg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate lookup table and DEM related products (layover and shadow, incidence angle, local resolution, offnadir angle)
        Generate accurate layover and shadow map for any platform heading


        input parameters:
          MLI_par         (input) MLI or SLC image parameter file (slant range geometry)
          DEM_par         (input) DEM/MAP parameter file
          DEM             (input) DEM data file (or constant height value)
          DEM_seg_par     (output) DEM segment parameter file (enter - for none)
          DEM_seg         (output) DEM segment file (FLOAT, enter - for none)
          lookup_table    (output) geocoding lookup table (FCOMPLEX, original DEM geometry) (enter - for none)
          lat_ovr         latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr         longitude or easting output DEM oversampling factor (enter - for default: 1.0)
          ls_map          (output) layover and shadow map (UCHAR, original DEM geometry) (enter - for none)
          ls_map_rdc      (output) layover and shadow map (UCHAR, slant range geometry) (enter - for none)
          inc             (output) local incidence angle map (FLOAT, between surface normal and look vector, original DEM geometry) (enter - for none)
          res             (output) local resolution map (FCOMPLEX, original DEM geometry) (enter - for none)
          offnadir        (output) local offnadir (or look) angle map (FLOAT, original DEM geometry) (enter - for none)
          sim_sar         (output) simulated SAR backscatter image (FLOAT, original DEM geometry) (enter - for none)
          u               (output) zenith angle map of surface normal vector n (FLOAT, angle between z and n, original DEM geometry) (enter - for none)
          v               (output) orientation angle map of n (FLOAT, between x and projection of n in xy plane, original DEM geometry) (enter - for none)
          psi             (output) projection angle map (FLOAT, between surface normal and image plane normal, original DEM geometry) (enter - for none)
          pix             (output) pixel area normalization factor map (FLOAT, enter - for none)
          r_ovr           range oversampling factor (for layover-shadow calculations, enter - for default: automatic value)
          az_dec          azimuth decimation factor (for layover-shadow calculations, enter - for default: automatic value)
          mask            mask values outside swath, use layover and shadow map as a mask (enter - for default)
                            0: no masking (default)
                            1: masking values outside swath
                            2: masking shadow and values outside swath
                            3: masking layover, shadow and values outside swath
          frame           number of DEM pixels to add around area covered by SAR image (enter - for default: 8)
          ls_scaling      scaling of the layover and shadow maps (enter - for default)
                            0: standard values for further processing (default)
                            1: scaling optimized for visualization
          DIFF_par        (input) DIFF/GEO parameter file containing offset polynomial coefficients, for LUT and ls_map_rdc refinement (enter - for none)
          ref_flg         reference image flag (offsets are measured relative to the reference image) (enter - for default)
                            0: reference image is the actual SAR image
                            1: reference image is the simulated SAR image (default)
          inc_flg         incidence angle flag (enter - for default)
                            0: [inc] defined as local incidence angle (angle between surface normal and look vector) (default)
                            1: [inc] defined as incidence angle (angle between ellipsoid normal and look vector)


        """

        if self.validate_inputs:
            self._validate_gc_map2(
                MLI_par,
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                ls_map,
                ls_map_rdc,
                inc,
                res,
                offnadir,
                sim_sar,
                u,
                v,
                psi,
                pix,
                r_ovr,
                az_dec,
                mask,
                frame,
                ls_scaling,
                DIFF_par,
                ref_flg,
                inc_flg,
            )

        if self.mock_outputs:
            self._mock_gc_map2_outputs(
                MLI_par,
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                ls_map,
                ls_map_rdc,
                inc,
                res,
                offnadir,
                sim_sar,
                u,
                v,
                psi,
                pix,
                r_ovr,
                az_dec,
                mask,
                frame,
                ls_scaling,
                DIFF_par,
                ref_flg,
                inc_flg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.gc_map2))
        result = self._gamma_call("DIFF", "gc_map2", ca)

        if DEM_seg_par is not None:
            assert DEM_seg_par.exists(), f"{DEM_seg_par} does not exist"
            assert DEM_seg_par.stat().st_size > 0, f"{DEM_seg_par} has zero file size"

        if DEM_seg is not None:
            assert DEM_seg.exists(), f"{DEM_seg} does not exist"
            assert DEM_seg.stat().st_size > 0, f"{DEM_seg} has zero file size"

        if lookup_table is not None:
            assert lookup_table.exists(), f"{lookup_table} does not exist"
            assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        if ls_map is not None:
            assert ls_map.exists(), f"{ls_map} does not exist"
            assert ls_map.stat().st_size > 0, f"{ls_map} has zero file size"

        if ls_map_rdc is not None:
            assert ls_map_rdc.exists(), f"{ls_map_rdc} does not exist"
            assert ls_map_rdc.stat().st_size > 0, f"{ls_map_rdc} has zero file size"

        if inc is not None:
            assert inc.exists(), f"{inc} does not exist"
            assert inc.stat().st_size > 0, f"{inc} has zero file size"

        if res is not None:
            assert res.exists(), f"{res} does not exist"
            assert res.stat().st_size > 0, f"{res} has zero file size"

        if offnadir is not None:
            assert offnadir.exists(), f"{offnadir} does not exist"
            assert offnadir.stat().st_size > 0, f"{offnadir} has zero file size"

        if sim_sar is not None:
            assert sim_sar.exists(), f"{sim_sar} does not exist"
            assert sim_sar.stat().st_size > 0, f"{sim_sar} has zero file size"

        if u is not None:
            assert u.exists(), f"{u} does not exist"
            assert u.stat().st_size > 0, f"{u} has zero file size"

        if v is not None:
            assert v.exists(), f"{v} does not exist"
            assert v.stat().st_size > 0, f"{v} has zero file size"

        if psi is not None:
            assert psi.exists(), f"{psi} does not exist"
            assert psi.stat().st_size > 0, f"{psi} has zero file size"

        if pix is not None:
            assert pix.exists(), f"{pix} does not exist"
            assert pix.stat().st_size > 0, f"{pix} has zero file size"

        return result

    def _validate_dem_trans(
        self,
        DEM1_par: Path,
        DEM1: Path,
        DEM2_par: Path,
        DEM2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Path] = None,
        datum_shift: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dem_trans.

        """

        assert DEM1_par.exists(), f"{DEM1_par} does not exist"
        assert DEM1_par.stat().st_size > 0, f"{DEM1_par} has zero file size"

        assert DEM1.exists(), f"{DEM1} does not exist"
        assert DEM1.stat().st_size > 0, f"{DEM1} has zero file size"

        assert not DEM2.exists(), f"{DEM2} should _not_ exist!"

        if lookup_table is not None:
            assert not lookup_table.exists(), f"{lookup_table} should _not_ exist!"

    def _mock_dem_trans_outputs(
        self,
        DEM1_par: Path,
        DEM1: Path,
        DEM2_par: Path,
        DEM2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Path] = None,
        datum_shift: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Mock the program dem_trans.

        """

        if not DEM2_par.exists():
            DEM2_par.touch()

        if DEM2 is not None and str(DEM2) != "-":
            DEM2.touch()

        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

    def dem_trans(
        self,
        DEM1_par: Path,
        DEM1: Path,
        DEM2_par: Path,
        DEM2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Path] = None,
        datum_shift: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DEM resampling from one map projection to another map projection


        input parameters:
          DEM1_par      (input) DEM parameter file of the input DEM
          DEM1          (input) input DEM data
          DEM2_par      (input/output) DEM parameter file of the resampled input DEM
                        NOTE: if DEM2_par does not exist, it is created using the projection parameters from DEM1_par
          DEM2          (output) DEM in transformed coordinates specified by DEM2_par
          lat_ovr       lat, northing, or S map projection oversampling factor (enter - for default: 2.0)
          lon_ovr       lon, easting, or C map projection oversampling factor (enter - for default: 2.0)
                        NOTE: lat_ovr and lon_ovr are only considered if DEM2_par does not exist
          datum_shift   vertical datum shift flag, enter - for default:
                          0: output DEM heights not corrected for datum shift between projections (default)
                          1: output DEM heights corrected for datum shift between projections
          bflg          output DEM bounds flag (enter - for default):
                          0: use DEM bounds specified by DEM2_par (default)
                          1: determine bounds from DEM1_par in the projection specified by DEM2_par
          lookup_table  (output) complex-valued lookup table (DEM2 -> DEM1) (enter - for none)
          interp_mode   interpolation mode (enter - for default):
                          0: nearest neighbor
                          1: bicubic spline (default)
                          2: B-spline interpolation (default B-spline degree: 3)
          order         B-spline degree (2->5) (enter - for default: 3)


        """

        if self.validate_inputs:
            self._validate_dem_trans(
                DEM1_par,
                DEM1,
                DEM2_par,
                DEM2,
                lat_ovr,
                lon_ovr,
                datum_shift,
                bflg,
                lookup_table,
                interp_mode,
                order,
            )

        if self.mock_outputs:
            self._mock_dem_trans_outputs(
                DEM1_par,
                DEM1,
                DEM2_par,
                DEM2,
                lat_ovr,
                lon_ovr,
                datum_shift,
                bflg,
                lookup_table,
                interp_mode,
                order,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dem_trans))
        result = self._gamma_call("DIFF", "dem_trans", ca)

        assert DEM2_par.exists(), f"{DEM2_par} does not exist"
        assert DEM2_par.stat().st_size > 0, f"{DEM2_par} has zero file size"

        assert DEM2.exists(), f"{DEM2} does not exist"
        assert DEM2.stat().st_size > 0, f"{DEM2} has zero file size"

        if lookup_table is not None:
            assert lookup_table.exists(), f"{lookup_table} does not exist"
            assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        return result

    def _validate_quad_sub(
        self,
        int_1: Path,
        DIFF_par: Path,
        int_2: Path,
        int_type: int,
        mode: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to quad_sub.

        """

        assert int_1.exists(), f"{int_1} does not exist"
        assert int_1.stat().st_size > 0, f"{int_1} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert int_2.exists(), f"{int_2} does not exist"
        assert int_2.stat().st_size > 0, f"{int_2} has zero file size"

    def _mock_quad_sub_outputs(
        self,
        int_1: Path,
        DIFF_par: Path,
        int_2: Path,
        int_type: int,
        mode: Optional[int] = None,
    ) -> None:
        """

        Mock the program quad_sub.

        """
        pass

    def quad_sub(
        self,
        int_1: Path,
        DIFF_par: Path,
        int_2: Path,
        int_type: int,
        mode: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Add or subtract quadratic polynomial phase model from a differential interferogram


        input parameters:
          int-1     (input) differential interferogram (float or fcomplex)
          DIFF_par  (input) DIFF parameter file
          int-2     (output) output interferogram
          int_type  interferogam type:
                      0: unwrapped interferometric phase (float)
                      1: fcomplex interferogram
          mode      add or subtract phase model:
                      0: subtract phase model (default)
                      1: add phase model

        """

        if self.validate_inputs:
            self._validate_quad_sub(int_1, DIFF_par, int_2, int_type, mode)

        if self.mock_outputs:
            self._mock_quad_sub_outputs(int_1, DIFF_par, int_2, int_type, mode)

        ca = self._clean_args(locals(), inspect.signature(self.quad_sub))
        result = self._gamma_call("DIFF", "quad_sub", ca)
        return result

    def _validate_phase_sum(
        self,
        im_list: Path,
        width: int,
        sum: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to phase_sum.

        """

        assert im_list.exists(), f"{im_list} does not exist"
        assert im_list.stat().st_size > 0, f"{im_list} has zero file size"

        assert not sum.exists(), f"{sum} should _not_ exist!"

    def _mock_phase_sum_outputs(
        self,
        im_list: Path,
        width: int,
        sum: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        """

        Mock the program phase_sum.

        """

        if sum is not None and str(sum) != "-":
            sum.touch()

    def phase_sum(
        self,
        im_list: Path,
        width: int,
        sum: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate sum of a stack of images (FLOAT format)


        input parameters:
          im_list  (input) list of coregistered images (FLOAT)
          width    number of samples/line
          sum      (output) sum of input image data files (FLOAT)
          start    starting line (enter - for default: 1)
          nlines   number of lines to process (enter -  for default: entire file)
          pixav_x  number of pixels to average in width (enter - for default: 1)
          pixav_y  number of pixels to average in height (enter - for default: 1)
          zflag    zero flag (enter - for default)
                     0: interpret 0.0 as missing data value (default)
                        NOTE: output pixels are set to 0.0 if any of the corresponding input pixels has 0.0
                     1: interpret 0.0 as valid data


        """

        if self.validate_inputs:
            self._validate_phase_sum(
                im_list, width, sum, start, nlines, pixav_x, pixav_y, zflag
            )

        if self.mock_outputs:
            self._mock_phase_sum_outputs(
                im_list, width, sum, start, nlines, pixav_x, pixav_y, zflag
            )

        ca = self._clean_args(locals(), inspect.signature(self.phase_sum))
        result = self._gamma_call("DIFF", "phase_sum", ca)

        assert sum.exists(), f"{sum} does not exist"
        assert sum.stat().st_size > 0, f"{sum} has zero file size"

        return result

    def _validate_base_add(
        self, base_1: Path, base_2: Path, base_out: Path, mode: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to base_add.

        """

        assert base_1.exists(), f"{base_1} does not exist"
        assert base_1.stat().st_size > 0, f"{base_1} has zero file size"

        assert base_2.exists(), f"{base_2} does not exist"
        assert base_2.stat().st_size > 0, f"{base_2} has zero file size"

        assert not base_out.exists(), f"{base_out} should _not_ exist!"

    def _mock_base_add_outputs(
        self, base_1: Path, base_2: Path, base_out: Path, mode: Optional[int] = None
    ) -> None:
        """

        Mock the program base_add.

        """

        if base_out is not None and str(base_out) != "-":
            base_out.touch()

    def base_add(
        self, base_1: Path, base_2: Path, base_out: Path, mode: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Addition/subtraction of 2 baseline files


        input parameters:
          base_1    (input) input baseline file 1
          base_2    (input) input baseline file 2
          base_out  (output) output baseline file
          mode      add/subtract mode (default=1: add, -1: subtract (base_1-base_2))


        """

        if self.validate_inputs:
            self._validate_base_add(base_1, base_2, base_out, mode)

        if self.mock_outputs:
            self._mock_base_add_outputs(base_1, base_2, base_out, mode)

        ca = self._clean_args(locals(), inspect.signature(self.base_add))
        result = self._gamma_call("DIFF", "base_add", ca)

        assert base_out.exists(), f"{base_out} does not exist"
        assert base_out.stat().st_size > 0, f"{base_out} has zero file size"

        return result

    def _validate_gec_map_grd(
        self,
        GRD_par: Path,
        DEM_par: Path,
        href: Path,
        DEM_seg_par: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gec_map_grd.

        """

        assert GRD_par.exists(), f"{GRD_par} does not exist"
        assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert href.exists(), f"{href} does not exist"
        assert href.stat().st_size > 0, f"{href} has zero file size"

        assert not lookup_table.exists(), f"{lookup_table} should _not_ exist!"

    def _mock_gec_map_grd_outputs(
        self,
        GRD_par: Path,
        DEM_par: Path,
        href: Path,
        DEM_seg_par: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
    ) -> None:
        """

        Mock the program gec_map_grd.

        """

        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

    def gec_map_grd(
        self,
        GRD_par: Path,
        DEM_par: Path,
        href: Path,
        DEM_seg_par: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate geocoding lookup table for ellipsoid correction of ground-range images


        input parameters:
          GRD_par       (input) ground-range ISP image parameter file
          DEM_par       (input) DEM parameter file
          href          (input) elevation reference [m]
          DEM_seg_par   (input/output) DEM segment parameter file used for geocoding

          NOTE: If the DEM_seg_par already exists, then the output DEM parameters will be read from this file
                otherwise they are estimated from the image data.

          lookup_table  (output) geocoding lookup table
          lat_ovr       latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr       longitude or easting output DEM oversampling factor (enter - for default: 1.0)

        """

        if self.validate_inputs:
            self._validate_gec_map_grd(
                GRD_par, DEM_par, href, DEM_seg_par, lookup_table, lat_ovr, lon_ovr
            )

        if self.mock_outputs:
            self._mock_gec_map_grd_outputs(
                GRD_par, DEM_par, href, DEM_seg_par, lookup_table, lat_ovr, lon_ovr
            )

        ca = self._clean_args(locals(), inspect.signature(self.gec_map_grd))
        result = self._gamma_call("DIFF", "gec_map_grd", ca)

        assert DEM_seg_par.exists(), f"{DEM_seg_par} does not exist"
        assert DEM_seg_par.stat().st_size > 0, f"{DEM_seg_par} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        return result

    def _validate_sarpix_coord_list(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Path,
        SAR_coord: Path,
        MAP_coord: Path,
    ) -> None:
        """

        Validate the arguments to sarpix_coord_list.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert SAR_coord.exists(), f"{SAR_coord} does not exist"
        assert SAR_coord.stat().st_size > 0, f"{SAR_coord} has zero file size"

        assert not MAP_coord.exists(), f"{MAP_coord} should _not_ exist!"

    def _mock_sarpix_coord_list_outputs(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Path,
        SAR_coord: Path,
        MAP_coord: Path,
    ) -> None:
        """

        Mock the program sarpix_coord_list.

        """

        if MAP_coord is not None and str(MAP_coord) != "-":
            MAP_coord.touch()

    def sarpix_coord_list(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Path,
        SAR_coord: Path,
        MAP_coord: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Transform SAR image coordinates to map projection and geographic (lat/lon) coordinates for a list of points


        input parameters:
          SLC_par    (input) ISP SLC/MLI parameter file
          OFF_par    (input) ISP offset/interferogram parameter file, enter - for SLC or MLI data
          DEM_par    (input) DEM parameter file, enter - for WGS84 lat/lon
          SAR_coord  (input) list of pixel and line coordinates in the geometry defined by the SLC_par:
                       azimuth_line  range_pixel   height (m) in the desired datum defined in the DEM_par
          MAP_coord  (output) list of map coordinates and heights with 5 columns:
                       north/lat/S   east/lon/C   height (m)   map_line   map_pixel


        """

        if self.validate_inputs:
            self._validate_sarpix_coord_list(
                SLC_par, OFF_par, DEM_par, SAR_coord, MAP_coord
            )

        if self.mock_outputs:
            self._mock_sarpix_coord_list_outputs(
                SLC_par, OFF_par, DEM_par, SAR_coord, MAP_coord
            )

        ca = self._clean_args(locals(), inspect.signature(self.sarpix_coord_list))
        result = self._gamma_call("DIFF", "sarpix_coord_list", ca)

        assert MAP_coord.exists(), f"{MAP_coord} does not exist"
        assert MAP_coord.stat().st_size > 0, f"{MAP_coord} has zero file size"

        return result

    def _validate_dispmap_vec(
        self,
        DEM_par: Path,
        dispmap: Path,
        lv_theta: Path,
        lv_phi: Path,
        fv_theta: Path,
        fv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to dispmap_vec.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert dispmap.exists(), f"{dispmap} does not exist"
        assert dispmap.stat().st_size > 0, f"{dispmap} has zero file size"

        assert lv_theta.exists(), f"{lv_theta} does not exist"
        assert lv_theta.stat().st_size > 0, f"{lv_theta} has zero file size"

        assert lv_phi.exists(), f"{lv_phi} does not exist"
        assert lv_phi.stat().st_size > 0, f"{lv_phi} has zero file size"

        assert fv_theta.exists(), f"{fv_theta} does not exist"
        assert fv_theta.stat().st_size > 0, f"{fv_theta} has zero file size"

        assert fv_phi.exists(), f"{fv_phi} does not exist"
        assert fv_phi.stat().st_size > 0, f"{fv_phi} has zero file size"

        assert not dv_norm.exists(), f"{dv_norm} should _not_ exist!"

        if dv_theta is not None:
            assert not dv_theta.exists(), f"{dv_theta} should _not_ exist!"

        if dv_phi is not None:
            assert not dv_phi.exists(), f"{dv_phi} should _not_ exist!"

        if dv_x is not None:
            assert not dv_x.exists(), f"{dv_x} should _not_ exist!"

        if dv_y is not None:
            assert not dv_y.exists(), f"{dv_y} should _not_ exist!"

        if dv_z is not None:
            assert not dv_z.exists(), f"{dv_z} should _not_ exist!"

    def _mock_dispmap_vec_outputs(
        self,
        DEM_par: Path,
        dispmap: Path,
        lv_theta: Path,
        lv_phi: Path,
        fv_theta: Path,
        fv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Path] = None,
    ) -> None:
        """

        Mock the program dispmap_vec.

        """

        if dv_norm is not None and str(dv_norm) != "-":
            dv_norm.touch()

        if dv_theta is not None and str(dv_theta) != "-":
            dv_theta.touch()

        if dv_phi is not None and str(dv_phi) != "-":
            dv_phi.touch()

        if dv_x is not None and str(dv_x) != "-":
            dv_x.touch()

        if dv_y is not None and str(dv_y) != "-":
            dv_y.touch()

        if dv_z is not None and str(dv_z) != "-":
            dv_z.touch()

    def dispmap_vec(
        self,
        DEM_par: Path,
        dispmap: Path,
        lv_theta: Path,
        lv_phi: Path,
        fv_theta: Path,
        fv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculation of displacement vector field from displacement direction and measured component


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          dispmap     (input) displacement observation (along look-vector) (float)
          lv_theta    (input) look-vector elevation angle (file  or constant value in deg.)
          lv_phi      (input) look-vector orientation angle (file or constant value in deg.)
          fv_theta    (input) flow-vector elevation angle (file or constant value in deg.)
          fv_phi      (input) flow-vector orientation angle (file or constant value in deg.)
          dv_norm     (output) norm of 3-dim displacement vector (float)
          dv_theta    (output) elevation angle of 3-dim displacement vector (float)
          dv_phi      (output) orientation angle of 3-dim displacement vector (float)
          dv_x        (output) easting  component of 3-dim displacement vector (float)
          dv_y        (output) northing component of 3-dim displacement vector (float)
          dv_z        (output) vertical component of 3-dim displacement vector (float)
          mask_angle  cutoff angle in degrees between the look and normal vector to mask instable results (default=5)

          NOTE: select - to avoid creation of the corresponding output file
          NOTE: In the case where the dv_theta file is not specified, the sign of the displacement is conserved


        """

        if self.validate_inputs:
            self._validate_dispmap_vec(
                DEM_par,
                dispmap,
                lv_theta,
                lv_phi,
                fv_theta,
                fv_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
            )

        if self.mock_outputs:
            self._mock_dispmap_vec_outputs(
                DEM_par,
                dispmap,
                lv_theta,
                lv_phi,
                fv_theta,
                fv_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dispmap_vec))
        result = self._gamma_call("DIFF", "dispmap_vec", ca)

        assert dv_norm.exists(), f"{dv_norm} does not exist"
        assert dv_norm.stat().st_size > 0, f"{dv_norm} has zero file size"

        if dv_theta is not None:
            assert dv_theta.exists(), f"{dv_theta} does not exist"
            assert dv_theta.stat().st_size > 0, f"{dv_theta} has zero file size"

        if dv_phi is not None:
            assert dv_phi.exists(), f"{dv_phi} does not exist"
            assert dv_phi.stat().st_size > 0, f"{dv_phi} has zero file size"

        if dv_x is not None:
            assert dv_x.exists(), f"{dv_x} does not exist"
            assert dv_x.stat().st_size > 0, f"{dv_x} has zero file size"

        if dv_y is not None:
            assert dv_y.exists(), f"{dv_y} does not exist"
            assert dv_y.stat().st_size > 0, f"{dv_y} has zero file size"

        if dv_z is not None:
            assert dv_z.exists(), f"{dv_z} does not exist"
            assert dv_z.stat().st_size > 0, f"{dv_z} has zero file size"

        return result

    def _validate_scale_base(
        self,
        unw_2: Path,
        scaled_unw_2: Path,
        baseline_1: Path,
        SLC1_par_1: Path,
        OFF_par_1: Path,
        baseline_2: Path,
        OFF_par_2: Path,
        int_type: int,
    ) -> None:
        """

        Validate the arguments to scale_base.

        """

        assert unw_2.exists(), f"{unw_2} does not exist"
        assert unw_2.stat().st_size > 0, f"{unw_2} has zero file size"

        assert not scaled_unw_2.exists(), f"{scaled_unw_2} should _not_ exist!"

        assert baseline_1.exists(), f"{baseline_1} does not exist"
        assert baseline_1.stat().st_size > 0, f"{baseline_1} has zero file size"

        assert SLC1_par_1.exists(), f"{SLC1_par_1} does not exist"
        assert SLC1_par_1.stat().st_size > 0, f"{SLC1_par_1} has zero file size"

        assert OFF_par_1.exists(), f"{OFF_par_1} does not exist"
        assert OFF_par_1.stat().st_size > 0, f"{OFF_par_1} has zero file size"

        assert baseline_2.exists(), f"{baseline_2} does not exist"
        assert baseline_2.stat().st_size > 0, f"{baseline_2} has zero file size"

        assert OFF_par_2.exists(), f"{OFF_par_2} does not exist"
        assert OFF_par_2.stat().st_size > 0, f"{OFF_par_2} has zero file size"

    def _mock_scale_base_outputs(
        self,
        unw_2: Path,
        scaled_unw_2: Path,
        baseline_1: Path,
        SLC1_par_1: Path,
        OFF_par_1: Path,
        baseline_2: Path,
        OFF_par_2: Path,
        int_type: int,
    ) -> None:
        """

        Mock the program scale_base.

        """

        if scaled_unw_2 is not None and str(scaled_unw_2) != "-":
            scaled_unw_2.touch()

    def scale_base(
        self,
        unw_2: Path,
        scaled_unw_2: Path,
        baseline_1: Path,
        SLC1_par_1: Path,
        OFF_par_1: Path,
        baseline_2: Path,
        OFF_par_2: Path,
        int_type: int,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Scale unwrapped phase according to baseline ratio


        input parameters:
          unw-2         (input) unwrapped interferogram file (to be scaled)
          scaled_unw-2  (output) scaled unwrapped interferogram 2
          baseline-1    (input) baseline file of interferogram 1
          SLC1_par-1    (input) parameter file of SLC-1 in interferogram 1
          OFF_par-1     (input) ISP interferogram/offset parameters of interferogram 1
          baseline-2    (input) baseline file of interferogram 2 (to be scaled)
          SLC1_par-2    (input) parameter file of SLC-1 in interferogram 2 (to be scaled)
          OFF_par-2     (input) ISP interferogram/offset parameters of interferogram 2 (to be scaled)
          int_type      interferogram type 0: unflattened (default)  1: flattened (*.flt)


        """

        if self.validate_inputs:
            self._validate_scale_base(
                unw_2,
                scaled_unw_2,
                baseline_1,
                SLC1_par_1,
                OFF_par_1,
                baseline_2,
                OFF_par_2,
                int_type,
            )

        if self.mock_outputs:
            self._mock_scale_base_outputs(
                unw_2,
                scaled_unw_2,
                baseline_1,
                SLC1_par_1,
                OFF_par_1,
                baseline_2,
                OFF_par_2,
                int_type,
            )

        ca = self._clean_args(locals(), inspect.signature(self.scale_base))
        result = self._gamma_call("DIFF", "scale_base", ca)

        assert scaled_unw_2.exists(), f"{scaled_unw_2} does not exist"
        assert scaled_unw_2.stat().st_size > 0, f"{scaled_unw_2} has zero file size"

        return result

    def _validate_par_EORC_PALSAR_geo(
        self,
        CEOS_leader: Path,
        MLI_par: Path,
        DEM_par: Path,
        CEOS_data: Path,
        MLI: Optional[Path] = None,
        cal: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_EORC_PALSAR_geo.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        assert not DEM_par.exists(), f"{DEM_par} should _not_ exist!"

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        if MLI is not None:
            assert not MLI.exists(), f"{MLI} should _not_ exist!"

    def _mock_par_EORC_PALSAR_geo_outputs(
        self,
        CEOS_leader: Path,
        MLI_par: Path,
        DEM_par: Path,
        CEOS_data: Path,
        MLI: Optional[Path] = None,
        cal: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_EORC_PALSAR_geo.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

    def par_EORC_PALSAR_geo(
        self,
        CEOS_leader: Path,
        MLI_par: Path,
        DEM_par: Path,
        CEOS_data: Path,
        MLI: Optional[Path] = None,
        cal: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Process EORC PALSAR + PALSAR2 Level 1.5 CEOS Ellipsoid Geocoded (GEC) data


        input parameters:
          CEOS_leader  (input) CEOS leader file for PALSAR Level 1.5 ellipsoid geocoded (GEC) data (LED...P1.5GUA)
          MLI_par      (output) ISP image parameter file (example: yyyymmdd_map.mli.par)
          DEM_par      (output) DIFF/GEO DEM parameter file (example: yyyymmdd_map.dem_par)
          CEOS_data    (input) PALSAR CEOS format Level 1.5 GEC MLI data (IMG...P1.5GUA)
          MLI          (output) reformatted PALSAR GEC MLI image (example: yyyymmdd_map.mli, enter - for none)
          cal          radiometric calibration factor in dB (enter - for default: read from CEOS data)


        """

        if self.validate_inputs:
            self._validate_par_EORC_PALSAR_geo(
                CEOS_leader, MLI_par, DEM_par, CEOS_data, MLI, cal
            )

        if self.mock_outputs:
            self._mock_par_EORC_PALSAR_geo_outputs(
                CEOS_leader, MLI_par, DEM_par, CEOS_data, MLI, cal
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_EORC_PALSAR_geo))
        result = self._gamma_call("DIFF", "par_EORC_PALSAR_geo", ca)

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        if MLI is not None:
            assert MLI.exists(), f"{MLI} does not exist"
            assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        return result

    def _validate_SLC_intf_geo(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        MLI_1: Optional[Path] = None,
        MLI_2: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to SLC_intf_geo.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert not interf.exists(), f"{interf} should _not_ exist!"

        assert not DEM_par2.exists(), f"{DEM_par2} should _not_ exist!"

        if MLI_1 is not None:
            assert not MLI_1.exists(), f"{MLI_1} should _not_ exist!"

        if MLI_2 is not None:
            assert not MLI_2.exists(), f"{MLI_2} should _not_ exist!"

    def _mock_SLC_intf_geo_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        MLI_1: Optional[Path] = None,
        MLI_2: Optional[Path] = None,
    ) -> None:
        """

        Mock the program SLC_intf_geo.

        """

        if interf is not None and str(interf) != "-":
            interf.touch()

        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

        if MLI_1 is not None and str(MLI_1) != "-":
            MLI_1.touch()

        if MLI_2 is not None and str(MLI_2) != "-":
            MLI_2.touch()

    def SLC_intf_geo(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        MLI_1: Optional[Path] = None,
        MLI_2: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate a multi-look interferogram from geocoded and co-registered SLC images


        input parameters:
          SLC-1      (input) single-look complex geocoded image 1 (FCOMPLEX format, reference scene)
          SLC-2      (input) single-look complex geocoded image 2 coregistered to SLC-1 (FCOMPLEX format)
          DEM_par    (input) DEM parameter file describing the input geocoded and coregistered SLC images
          interf     (output) multi-look interferogram from SLC-1 and SLC-2
          DEM_par2   (output) DEM parameter file for the output interferogram and MLI files
          e_lks      number of easting looks (longitude, cross-track)
          n_lks      number of northing looks (latitude, along-track)
          MLI-1      (output) multi-look intensity image from SLC-1 (enter - for none)
          MLI-2      (output) multi-look intensity image from SLC-2 (enter - for none)


        """

        if self.validate_inputs:
            self._validate_SLC_intf_geo(
                SLC_1, SLC_2, DEM_par, interf, DEM_par2, e_lks, n_lks, MLI_1, MLI_2
            )

        if self.mock_outputs:
            self._mock_SLC_intf_geo_outputs(
                SLC_1, SLC_2, DEM_par, interf, DEM_par2, e_lks, n_lks, MLI_1, MLI_2
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_intf_geo))
        result = self._gamma_call("DIFF", "SLC_intf_geo", ca)

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        assert DEM_par2.exists(), f"{DEM_par2} does not exist"
        assert DEM_par2.stat().st_size > 0, f"{DEM_par2} has zero file size"

        if MLI_1 is not None:
            assert MLI_1.exists(), f"{MLI_1} does not exist"
            assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        if MLI_2 is not None:
            assert MLI_2.exists(), f"{MLI_2} does not exist"
            assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

        return result

    def _validate_map_trans(
        self,
        DEM1_par: Path,
        data1: Path,
        DEM2_par: Path,
        data2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to map_trans.

        """

        assert DEM1_par.exists(), f"{DEM1_par} does not exist"
        assert DEM1_par.stat().st_size > 0, f"{DEM1_par} has zero file size"

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert not data2.exists(), f"{data2} should _not_ exist!"

        if lookup_table is not None:
            assert not lookup_table.exists(), f"{lookup_table} should _not_ exist!"

    def _mock_map_trans_outputs(
        self,
        DEM1_par: Path,
        data1: Path,
        DEM2_par: Path,
        data2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Mock the program map_trans.

        """

        if not DEM2_par.exists():
            DEM2_par.touch()

        if data2 is not None and str(data2) != "-":
            data2.touch()

        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

    def map_trans(
        self,
        DEM1_par: Path,
        data1: Path,
        DEM2_par: Path,
        data2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Data resampling from one map projection to another map projection


        input parameters:
          DEM1_par      (input) DEM parameter file of input data
          data1         (input) input data in the geometry of DEM1_par
          DEM2_par      (input/output) DEM parameter file of the output data
                        NOTE: if DEM2_par does not exist, it is created using the map projection parameters from DEM1_par
          data2         (output) input data1 resampled into the geometry of DEM2_par
          lat_ovr       lat, northing, or S map projection oversampling factor (enter - for default: 2.0)
          lon_ovr       lon, easting, or C map projection oversampling factor (enter - for default: 2.0)
                        NOTE: lat_ovr and lon_ovr are only considered if DEM2_par does not exist
          interp_mode   interpolation mode (enter - for default):
                          0: nearest neighbor
                          1: bicubic spline (default)
                          2: bicubic spline log(x)
                          3: bicubic spline sqrt(x)
                          4: B-spline interpolation (default B-spline degree: 5)
                          5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                          6: Lanczos interpolation (default Lanczos function order: 5)
                          7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                        NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype         data format (enter - for default):
                          0: FLOAT (default)
                          1: FCOMPLEX or geocoding lookup table
                          2: SUN/BMP/TIFF raster file
                          3: UNSIGNED CHAR
                          4: SHORT INTEGER
                          5: DOUBLE
          bflg          output DEM bounds flag (enter - for default):
                          0: use DEM bounds specified by DEM2_par (default)
                          1: determine bounds from DEM1_par in the projection specified by DEM2_par
          lookup_table  (output) complex-valued lookup table (enter - for none, DEM2 -> DEM1)
          order         Lanczos function order or B-spline degree (2->9) (enter - default: 5)


        """

        if self.validate_inputs:
            self._validate_map_trans(
                DEM1_par,
                data1,
                DEM2_par,
                data2,
                lat_ovr,
                lon_ovr,
                interp_mode,
                dtype,
                bflg,
                lookup_table,
                order,
            )

        if self.mock_outputs:
            self._mock_map_trans_outputs(
                DEM1_par,
                data1,
                DEM2_par,
                data2,
                lat_ovr,
                lon_ovr,
                interp_mode,
                dtype,
                bflg,
                lookup_table,
                order,
            )

        ca = self._clean_args(locals(), inspect.signature(self.map_trans))
        result = self._gamma_call("DIFF", "map_trans", ca)

        assert DEM2_par.exists(), f"{DEM2_par} does not exist"
        assert DEM2_par.stat().st_size > 0, f"{DEM2_par} has zero file size"

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

        if lookup_table is not None:
            assert lookup_table.exists(), f"{lookup_table} does not exist"
            assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        return result

    def _validate_gc_map_inversion(
        self,
        gc_map: Path,
        width_in: int,
        gc_map_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        n_ovr: Optional[int] = None,
        rad_max: Optional[int] = None,
        nintr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gc_map_inversion.

        """

        assert gc_map.exists(), f"{gc_map} does not exist"
        assert gc_map.stat().st_size > 0, f"{gc_map} has zero file size"

        assert not gc_map_out.exists(), f"{gc_map_out} should _not_ exist!"

    def _mock_gc_map_inversion_outputs(
        self,
        gc_map: Path,
        width_in: int,
        gc_map_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        n_ovr: Optional[int] = None,
        rad_max: Optional[int] = None,
        nintr: Optional[int] = None,
    ) -> None:
        """

        Mock the program gc_map_inversion.

        """

        if gc_map_out is not None and str(gc_map_out) != "-":
            gc_map_out.touch()

    def gc_map_inversion(
        self,
        gc_map: Path,
        width_in: int,
        gc_map_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        n_ovr: Optional[int] = None,
        rad_max: Optional[int] = None,
        nintr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Invert geocoding lookup table


        input parameters:
          gc_map         lookup table containing pairs of real-valued coordinates (fcomplex)
          width_in       width of input lookup table lines
          gc_map_out     inverted geocoding lookup table
          width_out      width of output data file
          nlines_out     number of lines of output data file (enter - or 0 for default: all lines up to highest value)
          interp_mode    resampling interpolation mode (enter - for default)
                           0: 1/dist (default)
                           1: nearest-neighbor
                           2: 1/dist**2
                           3: constant
                           4: Gaussian
          n_ovr          interpolation oversampling factor (enter - for default: 2)
          rad_max        maximum interpolation search radius (enter - for default: 4*n_ovr = 8)
          nintr          number of points required for interpolation when not nearest-neighbor (enter - for default: 4)


        """

        if self.validate_inputs:
            self._validate_gc_map_inversion(
                gc_map,
                width_in,
                gc_map_out,
                width_out,
                nlines_out,
                interp_mode,
                n_ovr,
                rad_max,
                nintr,
            )

        if self.mock_outputs:
            self._mock_gc_map_inversion_outputs(
                gc_map,
                width_in,
                gc_map_out,
                width_out,
                nlines_out,
                interp_mode,
                n_ovr,
                rad_max,
                nintr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.gc_map_inversion))
        result = self._gamma_call("DIFF", "gc_map_inversion", ca)

        assert gc_map_out.exists(), f"{gc_map_out} does not exist"
        assert gc_map_out.stat().st_size > 0, f"{gc_map_out} has zero file size"

        return result

    def _validate_par_JERS_geo(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        MLI_par: Path,
        DEM_par: Path,
        GEO: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_JERS_geo.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        assert not DEM_par.exists(), f"{DEM_par} should _not_ exist!"

        if GEO is not None:
            assert not GEO.exists(), f"{GEO} should _not_ exist!"

    def _mock_par_JERS_geo_outputs(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        MLI_par: Path,
        DEM_par: Path,
        GEO: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_JERS_geo.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()

        if GEO is not None and str(GEO) != "-":
            GEO.touch()

    def par_JERS_geo(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        MLI_par: Path,
        DEM_par: Path,
        GEO: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Import JERS-1 L2.1 CEOS data (geocoded)


        input parameters:
        CEOS_leader  (input) CEOS leader file for JERS-1 L2 geocoded data (SARL_*.DAT)
        CEOS_data    (input) JERS-1 CEOS format L2 terrain-geocoded MLI data (IMOP_*.DAT)
        MLI_par      (output) ISP image parameter file (example: yyyymmdd_map.mli.par)
        DEM_par      (output) DIFF/GEO DEM parameter file (example: yyyymmdd.dem_par)
        GEO          (output) calibrated and geocoded JERS-1 image (example: yyyymmdd_map.mli, enter - for none)


        """

        if self.validate_inputs:
            self._validate_par_JERS_geo(CEOS_leader, CEOS_data, MLI_par, DEM_par, GEO)

        if self.mock_outputs:
            self._mock_par_JERS_geo_outputs(CEOS_leader, CEOS_data, MLI_par, DEM_par, GEO)

        ca = self._clean_args(locals(), inspect.signature(self.par_JERS_geo))
        result = self._gamma_call("DIFF", "par_JERS_geo", ca)

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        if GEO is not None:
            assert GEO.exists(), f"{GEO} does not exist"
            assert GEO.stat().st_size > 0, f"{GEO} has zero file size"

        return result

    def _validate_interp_data(
        self,
        data2: Path,
        DIFF_par: Path,
        data2_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to interp_data.

        """

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not data2_out.exists(), f"{data2_out} should _not_ exist!"

    def _mock_interp_data_outputs(
        self,
        data2: Path,
        DIFF_par: Path,
        data2_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Mock the program interp_data.

        """

        if data2_out is not None and str(data2_out) != "-":
            data2_out.touch()

    def interp_data(
        self,
        data2: Path,
        DIFF_par: Path,
        data2_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Resample 2D data using DIFF_par polynomials


        input parameters:
          data2        (input) input data file (format as specified by format_flag parameter)
          DIFF_par     (input) DIFF/GEO parameter file containing range and azimuth offset polynomial coefficients
          data2_out    (output) resampled data2, dimensions determined by data1 in the DIFF_par
          interp_mode  interpolation mode:
                         0: nearest-neighbor
                         1: bicubic spline (default)
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 5)
                         5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                         6: Lanczos interpolation (default Lanczos function order: 5)
                         7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype        input and output data format
                         0: FLOAT (default)
                         1: FCOMPLEX
                         2: SUN/BMP/TIFF format raster image
                         3: UNSIGNED CHAR
                         4: SHORT
                         5: DOUBLE
                         6: SCOMPLEX
          order        Lanczos function order or B-spline degree (2->9) (enter - default: 5)

          NOTE: see documentation for information on recommended interpolation modes for different data types


        """

        if self.validate_inputs:
            self._validate_interp_data(
                data2, DIFF_par, data2_out, interp_mode, dtype, order
            )

        if self.mock_outputs:
            self._mock_interp_data_outputs(
                data2, DIFF_par, data2_out, interp_mode, dtype, order
            )

        ca = self._clean_args(locals(), inspect.signature(self.interp_data))
        result = self._gamma_call("DIFF", "interp_data", ca)

        assert data2_out.exists(), f"{data2_out} does not exist"
        assert data2_out.stat().st_size > 0, f"{data2_out} has zero file size"

        return result

    def _validate_rdc_trans(
        self, MLI1_par: Path, DEM_RDC: Path, MLI2_par: Path, lt: Path
    ) -> None:
        """

        Validate the arguments to rdc_trans.

        """

        assert MLI1_par.exists(), f"{MLI1_par} does not exist"
        assert MLI1_par.stat().st_size > 0, f"{MLI1_par} has zero file size"

        assert DEM_RDC.exists(), f"{DEM_RDC} does not exist"
        assert DEM_RDC.stat().st_size > 0, f"{DEM_RDC} has zero file size"

        assert MLI2_par.exists(), f"{MLI2_par} does not exist"
        assert MLI2_par.stat().st_size > 0, f"{MLI2_par} has zero file size"

        assert not lt.exists(), f"{lt} should _not_ exist!"

    def _mock_rdc_trans_outputs(
        self, MLI1_par: Path, DEM_RDC: Path, MLI2_par: Path, lt: Path
    ) -> None:
        """

        Mock the program rdc_trans.

        """

        if lt is not None and str(lt) != "-":
            lt.touch()

    def rdc_trans(
        self, MLI1_par: Path, DEM_RDC: Path, MLI2_par: Path, lt: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Derive lookup table for SLC/MLI coregistration (considering terrain heights)


        input parameters:
          MLI1_par  (input) SLC/MLI ISP image parameter file of the reference scene (lookup table and DEM_RDC dimensions)
          DEM_RDC   (input) height map in RDC of MLI-1 (float, or constant height value)
                    NOTE: The terrain heights must be referenced to the WGS84 datum
          MLI2_par  (input) SLC/MLI ISP image parameter file of MLI-2
          lt        (output) lookup table to resample MLI-2 to the geometry of MLI-1 (FCOMPLEX)


        """

        if self.validate_inputs:
            self._validate_rdc_trans(MLI1_par, DEM_RDC, MLI2_par, lt)

        if self.mock_outputs:
            self._mock_rdc_trans_outputs(MLI1_par, DEM_RDC, MLI2_par, lt)

        ca = self._clean_args(locals(), inspect.signature(self.rdc_trans))
        result = self._gamma_call("DIFF", "rdc_trans", ca)

        assert lt.exists(), f"{lt} does not exist"
        assert lt.stat().st_size > 0, f"{lt} has zero file size"

        return result

    def _validate_SLC_interp_lt_ScanSAR(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Optional[Path],
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_interp_lt_ScanSAR.

        """

        assert SLC2_tab.exists(), f"{SLC2_tab} does not exist"
        assert SLC2_tab.stat().st_size > 0, f"{SLC2_tab} has zero file size"

        self._check_tab_file(SLC2_tab, "SLC2_tab")

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert SLC1_tab.exists(), f"{SLC1_tab} does not exist"
        assert SLC1_tab.stat().st_size > 0, f"{SLC1_tab} has zero file size"

        self._check_tab_file(SLC1_tab, "SLC1_tab")

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        assert MLI1_par.exists(), f"{MLI1_par} does not exist"
        assert MLI1_par.stat().st_size > 0, f"{MLI1_par} has zero file size"

        assert MLI2_par.exists(), f"{MLI2_par} does not exist"
        assert MLI2_par.stat().st_size > 0, f"{MLI2_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        if SLC_2R is not None:
            assert not SLC_2R.exists(), f"{SLC_2R} should _not_ exist!"

        if SLC2R_par is not None:
            assert not SLC2R_par.exists(), f"{SLC2R_par} should _not_ exist!"

    def _mock_SLC_interp_lt_ScanSAR_outputs(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Optional[Path],
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_interp_lt_ScanSAR.

        """

        if not SLC2R_tab.exists():
            SLC2R_tab.touch()

        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()

        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp_lt_ScanSAR(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Optional[Path],
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Resample ScanSAR burst mode SLC using a lookup table and SLC offset polynomials for refinement


        input parameters:
          SLC2_tab      (input) 3 column list of ScanSAR SLC-2 swaths to be resampled into the geometry of SLC-1 listed in order from near to far range
                        SLC2_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_par      (input) SLC parameter file of the mosaic of the ScanSAR SLC-2 data, SLC-2 is generated from the ScanSAR swaths listed in SLC2_tab
          SLC1_tab      (input) 3 column list of the reference ScanSAR SLC-1 swaths listed in order from near to far range
          SLC1_par      (input) SLC parameter file of the mosaic of the reference ScanSAR SLC-1 data, SLC-1 is generated from the ScanSAR swaths listed in SLC1_tab
          lookup_table  (input) lookup table relating the mosaic image coordinates of MLI-1 to MLI-2
          MLI1_par      (input) SLC/MLI ISP image parameter file of reference MLI-1 (lookup table dimension)
          MLI2_par      (input) SLC/MLI ISP image parameter file of MLI12 (lookup table values)
          OFF_par       (input) ISP offset and interferogram parameter file determined from the ScanSAR SLC mosaics (enter - for none)
          SLC2R_tab     (input/output) 3 column list of the resampled ScanSAR SLC-2R swaths listed in order from near to far range
                        NOTES: 1. If the SLC2R_tab does not yet exist, the file entries will be created with names derived from the SLC2_tab entries and the SLC2R_dir
                               2. The file extensions of the new entries are rslc, rslc.par, and rslc.tops_par
          SLC-2R        (output) mosaic generated from the resampled swaths listed in SLC2R_tab, coregisted to the reference SLC-1 mosaic (enter - for none)
          SLC2R_par     (output) SLC parameter file associated with the mosaic of the resampled ScanSAR SLC-2R data (enter - for none)
          mode          interpolation mode (enter - for default)
                          0: Lanczos (default)
                          1: B-spline
          order         Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)
          SLC2R_dir     directory for resampled burst SLC2R data, ignored if the DIFF_tab already exists (enter - for default: current directory)


        """

        if self.validate_inputs:
            self._validate_SLC_interp_lt_ScanSAR(
                SLC2_tab,
                SLC2_par,
                SLC1_tab,
                SLC1_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                OFF_par,
                SLC2R_tab,
                SLC_2R,
                SLC2R_par,
                mode,
                order,
                SLC2R_dir,
            )

        if self.mock_outputs:
            self._mock_SLC_interp_lt_ScanSAR_outputs(
                SLC2_tab,
                SLC2_par,
                SLC1_tab,
                SLC1_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                OFF_par,
                SLC2R_tab,
                SLC_2R,
                SLC2R_par,
                mode,
                order,
                SLC2R_dir,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_interp_lt_ScanSAR))
        result = self._gamma_call("DIFF", "SLC_interp_lt_ScanSAR", ca)

        assert SLC2R_tab.exists(), f"{SLC2R_tab} does not exist"
        assert SLC2R_tab.stat().st_size > 0, f"{SLC2R_tab} has zero file size"

        if SLC_2R is not None:
            assert SLC_2R.exists(), f"{SLC_2R} does not exist"
            assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        if SLC2R_par is not None:
            assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
            assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        return result

    def _validate_par_CS_geo(
        self,
    ) -> None:
        """

        Validate the arguments to par_CS_geo.

        """

        pass

    def _mock_par_CS_geo_outputs(
        self,
    ) -> None:
        """

        Mock the program par_CS_geo.

        """
        pass

    def par_CS_geo(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        dyld[70492]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/par_CS_geo'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)

        """

        if self.validate_inputs:
            self._validate_par_CS_geo()

        if self.mock_outputs:
            self._mock_par_CS_geo_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.par_CS_geo))
        result = self._gamma_call("DIFF", "par_CS_geo", ca)
        return result

    def _validate_offset_pwr_trackingm2(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        DIFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwr_trackingm2.

        """

        assert MLI_1.exists(), f"{MLI_1} does not exist"
        assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        assert MLI_2.exists(), f"{MLI_2} does not exist"
        assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not ccp.exists(), f"{ccp} should _not_ exist!"

        if DIFF_par2 is not None:
            assert DIFF_par2.exists(), f"{DIFF_par2} does not exist"
            assert DIFF_par2.stat().st_size > 0, f"{DIFF_par2} has zero file size"

        if offs2 is not None:
            assert offs2.exists(), f"{offs2} does not exist"
            assert offs2.stat().st_size > 0, f"{offs2} has zero file size"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

        if ccs is not None:
            assert not ccs.exists(), f"{ccs} should _not_ exist!"

    def _mock_offset_pwr_trackingm2_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        DIFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_pwr_trackingm2.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if ccp is not None and str(ccp) != "-":
            ccp.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_trackingm2(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        DIFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offset tracking between MLI images using intensity cross-correlation with the initial offset for each patch determined from an input offset map


        input parameters:
          MLI-1      (input) real valued intensity image 1 (reference)
          MLI-2      (input) real valued intensity image 2
          DIFF_par   (input) DIFF/GEO parameter file
          offs       (output) offset estimates in range and azimuth (fcomplex)
          ccp        (output) cross-correlation of each patch (0.0->1.0) (float)
          DIFF_par2  (input) DIFF/GEO parameter file of the offset map to determine initial offsets (enter - for none)
          offs2      (input) input range and azimuth offset map to determine initial offsets (enter - for none)
          rwin       range patch size (range pixels, enter - for default from offset parameter file)
          azwin      azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets    (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr      MLI oversampling factor (integer 2**N (1,2,4), enter - for default: 1)
          thres      cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep      step in range pixels (enter - for default: rwin/2)
          azstep     step in azimuth pixels (enter - for default: azwin/2)
          rstart     offset to starting range pixel (enter - for default: 0)
          rstop      offset to ending range pixel (enter - for default: nr-1)
          azstart    offset to starting azimuth line (enter - for default: 0)
          azstop     offset to ending azimuth line  (enter - for default: nlines-1)
          bw_frac    bandwidth fraction of low-pass filter on intensity data (0.0->1.0) (enter - for default: 0.8)
          pflag      print flag (enter - for default)
                       0: print offset summary (default)
                       1: print all offset data
          pltflg     plotting flag (enter - for default)
                       0: none (default)
                       1: screen output
                       2: screen output and PNG format plots
                       3: output plots in PDF format
          ccs        (output) cross-correlation standard deviation of each patch (float)
          std_mean   patch minimum standard deviation/mean ratio (enter - for default: 0.01)


        """

        if self.validate_inputs:
            self._validate_offset_pwr_trackingm2(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                DIFF_par2,
                offs2,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )

        if self.mock_outputs:
            self._mock_offset_pwr_trackingm2_outputs(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                DIFF_par2,
                offs2,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_pwr_trackingm2))
        result = self._gamma_call("DIFF", "offset_pwr_trackingm2", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        if ccs is not None:
            assert ccs.exists(), f"{ccs} does not exist"
            assert ccs.stat().st_size > 0, f"{ccs} has zero file size"

        return result

    def _validate_init_offset_orbitm(
        self,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par: Path,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        cflag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to init_offset_orbitm.

        """

        assert MLI1_par.exists(), f"{MLI1_par} does not exist"
        assert MLI1_par.stat().st_size > 0, f"{MLI1_par} has zero file size"

        assert MLI2_par.exists(), f"{MLI2_par} does not exist"
        assert MLI2_par.stat().st_size > 0, f"{MLI2_par} has zero file size"

    def _mock_init_offset_orbitm_outputs(
        self,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par: Path,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        cflag: Optional[int] = None,
    ) -> None:
        """

        Mock the program init_offset_orbitm.

        """

        if not DIFF_par.exists():
            DIFF_par.touch()

    def init_offset_orbitm(
        self,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par: Path,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        cflag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Initial image offset estimation using orbit state-vectors and image parameters


        input parameters:
          MLI1_par  (input) MLI-1 image parameter file
          MLI2_par  (input) MLI-2 image parameter file
          DIFF_par  (input/output) DIFF/GEO parameter file
          rpos      range position for offset estimation (enter - for default: center of MLI-1)
          azpos     azimuth position for offset estimation (enter - for default: center of MLI-1)
          cflag     copy offsets to the range and azimuth offset polynomials in the DIFF_par
                      0: do not copy
                      1: copy constant range and azimuth offsets (default)


        """

        if self.validate_inputs:
            self._validate_init_offset_orbitm(
                MLI1_par, MLI2_par, DIFF_par, rpos, azpos, cflag
            )

        if self.mock_outputs:
            self._mock_init_offset_orbitm_outputs(
                MLI1_par, MLI2_par, DIFF_par, rpos, azpos, cflag
            )

        ca = self._clean_args(locals(), inspect.signature(self.init_offset_orbitm))
        result = self._gamma_call("DIFF", "init_offset_orbitm", ca)

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        return result

    def _validate_quad_fit(
        self,
        unw: Path,
        DIFF_par: Path,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
        model: Optional[int] = None,
        pmodel: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to quad_fit.

        """

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        if plot_data is not None:
            assert not plot_data.exists(), f"{plot_data} should _not_ exist!"

        if pmodel is not None:
            assert not pmodel.exists(), f"{pmodel} should _not_ exist!"

    def _mock_quad_fit_outputs(
        self,
        unw: Path,
        DIFF_par: Path,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
        model: Optional[int] = None,
        pmodel: Optional[Path] = None,
    ) -> None:
        """

        Mock the program quad_fit.

        """

        if plot_data is not None and str(plot_data) != "-":
            plot_data.touch()

        if pmodel is not None and str(pmodel) != "-":
            pmodel.touch()

    def quad_fit(
        self,
        unw: Path,
        DIFF_par: Path,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
        model: Optional[int] = None,
        pmodel: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate L.S quadratic polynomial model from unwrapped phase


        input parameters:
          unw        (input) unwrapped differential interferogram (float)
          DIFF_par   (input) differential interferogram parameters
          dr         range spacing in pixels between phase samples (enter - for default: 4)
          daz        azimuth spacing in lines between phase samples (enter - for default: 4)
          mask       mask (SUN/BMP/TIFF raster format), 0 valued pixels are excluded from being included in the model fit (enter - for none)
          plot_data  (output) plot data file (enter - for none)
          model      polynomial phase model (x->range, y->azimuth):
                       0: a0 + a1*y + a2*x + a3*x*y + a4*x^2 + a5*y^2 (default)
                       1: a0 + a4*x^2 + a5*y^2
                       2: a0 + a1*y + a2*x + a3*x*y
                       3: a0 + a1*y + a2*x
                       4: a0 + a2*x + a4*x^2
                       5: a0 + a2*x
                       6: a0 + a1*y + a5*y^2
                       7: a0 + a1*y
          pmodel     (output) 2D phase calculated using the model (float)


        """

        if self.validate_inputs:
            self._validate_quad_fit(
                unw, DIFF_par, dr, daz, mask, plot_data, model, pmodel
            )

        if self.mock_outputs:
            self._mock_quad_fit_outputs(
                unw, DIFF_par, dr, daz, mask, plot_data, model, pmodel
            )

        ca = self._clean_args(locals(), inspect.signature(self.quad_fit))
        result = self._gamma_call("DIFF", "quad_fit", ca)

        if plot_data is not None:
            assert plot_data.exists(), f"{plot_data} does not exist"
            assert plot_data.stat().st_size > 0, f"{plot_data} has zero file size"

        if pmodel is not None:
            assert pmodel.exists(), f"{pmodel} does not exist"
            assert pmodel.stat().st_size > 0, f"{pmodel} has zero file size"

        return result

    def _validate_stacking(
        self,
        DIFF_tab: Path,
        width: int,
        ph_rate: Path,
        sig_ph_rate: Path,
        sig_ph: Optional[Path],
        xoff: int,
        yoff: int,
        nx: Optional[int] = None,
        ny: Optional[int] = None,
        np_min: Optional[int] = None,
        tscale: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to stacking.

        """

        assert DIFF_tab.exists(), f"{DIFF_tab} does not exist"
        assert DIFF_tab.stat().st_size > 0, f"{DIFF_tab} has zero file size"

        self._check_tab_file(DIFF_tab, "DIFF_tab")

        assert not ph_rate.exists(), f"{ph_rate} should _not_ exist!"

        assert not sig_ph_rate.exists(), f"{sig_ph_rate} should _not_ exist!"

        if sig_ph is not None:
            assert not sig_ph.exists(), f"{sig_ph} should _not_ exist!"

    def _mock_stacking_outputs(
        self,
        DIFF_tab: Path,
        width: int,
        ph_rate: Path,
        sig_ph_rate: Path,
        sig_ph: Optional[Path],
        xoff: int,
        yoff: int,
        nx: Optional[int] = None,
        ny: Optional[int] = None,
        np_min: Optional[int] = None,
        tscale: Optional[int] = None,
    ) -> None:
        """

        Mock the program stacking.

        """

        if ph_rate is not None and str(ph_rate) != "-":
            ph_rate.touch()

        if sig_ph_rate is not None and str(sig_ph_rate) != "-":
            sig_ph_rate.touch()

        if sig_ph is not None and str(sig_ph) != "-":
            sig_ph.touch()

    def stacking(
        self,
        DIFF_tab: Path,
        width: int,
        ph_rate: Path,
        sig_ph_rate: Path,
        sig_ph: Optional[Path],
        xoff: int,
        yoff: int,
        nx: Optional[int] = None,
        ny: Optional[int] = None,
        np_min: Optional[int] = None,
        tscale: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DIFF: Program stacking.c
        Estimate phase rate by stacking of multiple unwrapped differential interferograms


        input parameters:
          DIFF_tab    (input) 2 column list of unwrapped differential interferograms and delta_T values in days (text)
          width       number of sample/line for the unwrapped interferograms in the stack
          ph_rate     (output) average phase rate determined from a weighted sum of phases (radians/year, float)
          sig_ph_rate (output) standard deviation of the estimated phase rate (radians/year, float)
          sig_ph      (output) standard deviation of the residual phases (enter - for none, radians, float)
          xoff        x-offset (across) samples to the center of the phase reference region
          yoff        y-offset (down) lines to the center of the phase reference region
          nx          width (samples) of the phase reference region (enter - for default: 15)
          ny          height (lines) of the phase reference region (enter - for default: 15)
          np_min      min. number of phase values required to accept phase rate estimate (enter - for default: all files)
          tscale      time scale used for calculation of the phase rate:
                        0: radians/day
                        1: radians/year (default)


        """

        if self.validate_inputs:
            self._validate_stacking(
                DIFF_tab,
                width,
                ph_rate,
                sig_ph_rate,
                sig_ph,
                xoff,
                yoff,
                nx,
                ny,
                np_min,
                tscale,
            )

        if self.mock_outputs:
            self._mock_stacking_outputs(
                DIFF_tab,
                width,
                ph_rate,
                sig_ph_rate,
                sig_ph,
                xoff,
                yoff,
                nx,
                ny,
                np_min,
                tscale,
            )

        ca = self._clean_args(locals(), inspect.signature(self.stacking))
        result = self._gamma_call("DIFF", "stacking", ca)

        assert ph_rate.exists(), f"{ph_rate} does not exist"
        assert ph_rate.stat().st_size > 0, f"{ph_rate} has zero file size"

        assert sig_ph_rate.exists(), f"{sig_ph_rate} does not exist"
        assert sig_ph_rate.stat().st_size > 0, f"{sig_ph_rate} has zero file size"

        if sig_ph is not None:
            assert sig_ph.exists(), f"{sig_ph} does not exist"
            assert sig_ph.stat().st_size > 0, f"{sig_ph} has zero file size"

        return result

    def _validate_atm_mod2(
        self,
        diff_unw: Path,
        hgt: Optional[Path],
        MLI_par: Path,
        atm_phase: Path,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to atm_mod2.

        """

        assert diff_unw.exists(), f"{diff_unw} does not exist"
        assert diff_unw.stat().st_size > 0, f"{diff_unw} has zero file size"

        if hgt is not None:
            assert hgt.exists(), f"{hgt} does not exist"
            assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert not atm_phase.exists(), f"{atm_phase} should _not_ exist!"

        if mask is not None:
            assert mask.exists(), f"{mask} does not exist"
            assert mask.stat().st_size > 0, f"{mask} has zero file size"

    def _mock_atm_mod2_outputs(
        self,
        diff_unw: Path,
        hgt: Optional[Path],
        MLI_par: Path,
        atm_phase: Path,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
    ) -> None:
        """

        Mock the program atm_mod2.

        """

        if atm_phase is not None and str(atm_phase) != "-":
            atm_phase.touch()

    def atm_mod2(
        self,
        diff_unw: Path,
        hgt: Optional[Path],
        MLI_par: Path,
        atm_phase: Path,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate atmospheric phase trend with respect to height, slant-range, and incidence angle


        input parameters:
          diff_unw  (input) unwrapped differential interferogram including atmospheric phase signal (FLOAT)
          hgt       (input) height coregistered to the interferogram in Range-Doppler Coordinates (enter - for none)
          MLI_par   (input) MLI image parameter file with same dimensions as the interferogram
          atm_phase (output) estimated atmospheric phase (FLOAT)
          dr        range sample increment (enter - for default: 1)
          daz       azimuth sample increment (enter - for default: 1)
          mask      (input) 8-bit raster image (SUN raster, BMP, or TIFF), (enter - for default: none)
                    NOTE: regions with (R,G,B)=0 in the mask are excluded
          model     atmospheric phase model (enter - for default)
                      0: height (default)
                      1: slant range (GPRI)
                      2: height and cosine(inc_ang) for wide swath data, e.g. Sentinel-1
                      3: slant range and height (GPRI)
          roff      reference point range sample offset (enter - for none)
          loff      reference point line offset (enter - for none)

          NOTE: unwrapped phase and height data must provided in range-doppler coordinates (RDC) as specified in the MLI parameter file


        """

        if self.validate_inputs:
            self._validate_atm_mod2(
                diff_unw, hgt, MLI_par, atm_phase, dr, daz, mask, model, roff, loff
            )

        if self.mock_outputs:
            self._mock_atm_mod2_outputs(
                diff_unw, hgt, MLI_par, atm_phase, dr, daz, mask, model, roff, loff
            )

        ca = self._clean_args(locals(), inspect.signature(self.atm_mod2))
        result = self._gamma_call("DIFF", "atm_mod2", ca)

        assert atm_phase.exists(), f"{atm_phase} does not exist"
        assert atm_phase.stat().st_size > 0, f"{atm_phase} has zero file size"

        return result

    def _validate_par_UAVSAR_geo(self, ann: Path, SLC_par: Path, DEM_par: Path) -> None:
        """

        Validate the arguments to par_UAVSAR_geo.

        """

        assert ann.exists(), f"{ann} does not exist"
        assert ann.stat().st_size > 0, f"{ann} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        assert not DEM_par.exists(), f"{DEM_par} should _not_ exist!"

    def _mock_par_UAVSAR_geo_outputs(
        self, ann: Path, SLC_par: Path, DEM_par: Path
    ) -> None:
        """

        Mock the program par_UAVSAR_geo.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()

    def par_UAVSAR_geo(
        self, ann: Path, SLC_par: Path, DEM_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate DEM parameter file for GRD products from UAVSAR annotation file (ann)


        input parameters:
          ann           (input) UAVSAR annotation file (*ann.txt)
          SLC/MLI_par   (output) ISP image parameter file for FLOAT format MLC products
          DEM_par       (output) DIFF/GEO DEM parameter file

        """

        if self.validate_inputs:
            self._validate_par_UAVSAR_geo(ann, SLC_par, DEM_par)

        if self.mock_outputs:
            self._mock_par_UAVSAR_geo_outputs(ann, SLC_par, DEM_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_UAVSAR_geo))
        result = self._gamma_call("DIFF", "par_UAVSAR_geo", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        return result

    def _validate_multi_look_geo2(
        self,
        SLC: Path,
        DEM_par: Path,
        MLI: Path,
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to multi_look_geo2.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert not MLI.exists(), f"{MLI} should _not_ exist!"

        assert not DEM_par2.exists(), f"{DEM_par2} should _not_ exist!"

    def _mock_multi_look_geo2_outputs(
        self,
        SLC: Path,
        DEM_par: Path,
        MLI: Path,
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Mock the program multi_look_geo2.

        """

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

    def multi_look_geo2(
        self,
        SLC: Path,
        DEM_par: Path,
        MLI: Path,
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate a geocoded MLI image from a geocoded SLC with separate averaging window dimensions and decimation factors


        input parameters:
          SLC       (input) geocoded SLC image (SCOMPLEX or FCOMPLEX)
          DEM_par   (input) geocoded SLC DEM parameter file
          MLI       (output) geocoded MLI image
          DEM_par2  (output) MLI DEM parameter file
          e_dec      easting decimation factor (int)
          n_dec      northing decimation factor (int)
          e_win      easting averaging window width (int) (enter - for default: e_dec)
          n_win      northing averaging window height (int)(enter - for default: n_dec)
          wflg       window weighting function (enter - for default):
                       0: rectangular (default)
                       1: Kaiser
                       2: circular Gaussian
          n_ovr      oversampling factor 1 -> 2 (enter - for default: 1)
          lanczos    Lanczos interpolator order 5 -> 9 (enter - for default: 7)
          beta       Gaussian or Kaiser window parameter (enter - for default: 2.0)
          scale      scale factor for output MLI (enter - for default: 1.0)
          exp        exponent for the output MLI (enter - for default: 1.0)


        """

        if self.validate_inputs:
            self._validate_multi_look_geo2(
                SLC,
                DEM_par,
                MLI,
                DEM_par2,
                e_dec,
                n_dec,
                e_win,
                n_win,
                wflg,
                n_ovr,
                lanczos,
                beta,
                scale,
                exp,
            )

        if self.mock_outputs:
            self._mock_multi_look_geo2_outputs(
                SLC,
                DEM_par,
                MLI,
                DEM_par2,
                e_dec,
                n_dec,
                e_win,
                n_win,
                wflg,
                n_ovr,
                lanczos,
                beta,
                scale,
                exp,
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_look_geo2))
        result = self._gamma_call("DIFF", "multi_look_geo2", ca)

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        assert DEM_par2.exists(), f"{DEM_par2} does not exist"
        assert DEM_par2.stat().st_size > 0, f"{DEM_par2} has zero file size"

        return result

    def _validate_dem_import(
        self,
        input_DEM: Path,
        DEM: Path,
        DEM_par: Path,
        input_type: Optional[int] = None,
        priority: Optional[int] = None,
        geoid: Optional[Path] = None,
        geoid_par: Optional[Path] = None,
        geoid_type: Optional[int] = None,
        latN_shift: Optional[float] = None,
        lonE_shift: Optional[float] = None,
        zflg: Optional[int] = None,
        no_data: Optional[float] = None,
        GTF_direct: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dem_import.

        """

        assert input_DEM.exists(), f"{input_DEM} does not exist"
        assert input_DEM.stat().st_size > 0, f"{input_DEM} has zero file size"

        assert not DEM.exists(), f"{DEM} should _not_ exist!"

        if geoid is not None:
            assert geoid.exists(), f"{geoid} does not exist"
            assert geoid.stat().st_size > 0, f"{geoid} has zero file size"

        if geoid_par is not None:
            assert geoid_par.exists(), f"{geoid_par} does not exist"
            assert geoid_par.stat().st_size > 0, f"{geoid_par} has zero file size"

    def _mock_dem_import_outputs(
        self,
        input_DEM: Path,
        DEM: Path,
        DEM_par: Path,
        input_type: Optional[int] = None,
        priority: Optional[int] = None,
        geoid: Optional[Path] = None,
        geoid_par: Optional[Path] = None,
        geoid_type: Optional[int] = None,
        latN_shift: Optional[float] = None,
        lonE_shift: Optional[float] = None,
        zflg: Optional[int] = None,
        no_data: Optional[float] = None,
        GTF_direct: Optional[int] = None,
    ) -> None:
        """

        Mock the program dem_import.

        """

        if DEM is not None and str(DEM) != "-":
            DEM.touch()

        if not DEM_par.exists():
            DEM_par.touch()

    def dem_import(
        self,
        input_DEM: Path,
        DEM: Path,
        DEM_par: Path,
        input_type: Optional[int] = None,
        priority: Optional[int] = None,
        geoid: Optional[Path] = None,
        geoid_par: Optional[Path] = None,
        geoid_type: Optional[int] = None,
        latN_shift: Optional[float] = None,
        lonE_shift: Optional[float] = None,
        zflg: Optional[int] = None,
        no_data: Optional[float] = None,
        GTF_direct: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Convert original DEM file format into Gamma format, transform geoid heights into ellipsoid heights


        input parameters:
          input_DEM   (input) input DEM in original file format
          DEM         (output) DEM in binary format (float, enter - for none)
          DEM_par     (input/output) DEM parameter file corresponding to output DEM

          NOTE: if the DEM_par file does not exist and input_type is 0, 1, or 2, dem_import will try to
                automatically extract the ellipsoid, datum, and map projection parameters.

          input_type  input DEM type: (enter - for default)
                        0: GeoTIFF or any other GDAL supported raster format (default)
                        1: xyz triplets
                        2: ascii grid (ESRI)
                        3: UZH RSL (a pair of *.dem and *.dem.hdr files, only write the *.dem file in the command line)
                        4: Gamma binary file (to be used for converting the DEM height from a geoid height into an ellipsoid height)
          priority    priority flag: (enter - for default)
                        0: DEM_par parameters have priority
                        1: input DEM parameters have priority (default)

          NOTE: flexible parameters are the origin, size and pixel spacing. The other parameters must be consistent
                in both input_DEM and DEM_par files.

          geoid       (input) geoid or constant geoid height value (enter - for none)
          geoid_par   (input) geoid DEM_par file (enter - for none)
          geoid_type  geoid type: (enter - for default)
                        0: global geoid in EQA coordinates (default)
                        1: local geoid in the same coordinate system as the DEM

          NOTE: the geoid is used to transform the DEM height from an altitude above sea level (i.e. above the geoid) to an altitude
                above the ellipsoid. EGM96 global geoid is available as "$DIFF_HOME/scripts/egm96.dem" and "$DIFF_HOME/scripts/egm96.dem_par"
                EGM2008 global geoid is available as "$DIFF_HOME/scripts/egm2008-5.dem" and "$DIFF_HOME/scripts/egm2008-5.dem_par"

          latN_shift  latitude or Northing constant shift to apply on the input data (in degree / meter, enter - for default: 0.0)
          lonE_shift  longitude or Easting constant shift to apply on the input data (in degree / meter, enter - for default: 0.0)
          zflg        interpretation of no_data values in real data (enter - for default)
                        0: no_data values in the input file are kept as no_data values (0.0) in the output file (default)
                        1: no_data values in the input file are converted to valid near-zero values in the output file
          no_data     no_data value in the input file (enter - for default: value either defined in the input metadata or 0.0 if not found)
          GTF_direct  direction of GeoTIFF / GDAL supported raster format reading (enter - for default)
                        0: vertically
                        1: horizontally (default)


        """

        if self.validate_inputs:
            self._validate_dem_import(
                input_DEM,
                DEM,
                DEM_par,
                input_type,
                priority,
                geoid,
                geoid_par,
                geoid_type,
                latN_shift,
                lonE_shift,
                zflg,
                no_data,
                GTF_direct,
            )

        if self.mock_outputs:
            self._mock_dem_import_outputs(
                input_DEM,
                DEM,
                DEM_par,
                input_type,
                priority,
                geoid,
                geoid_par,
                geoid_type,
                latN_shift,
                lonE_shift,
                zflg,
                no_data,
                GTF_direct,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dem_import))
        result = self._gamma_call("DIFF", "dem_import", ca)

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        return result

    def _validate_SLC_interp_lt(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Optional[Path],
        SLC_2R: Path,
        SLC2R_par: Path,
    ) -> None:
        """

        Validate the arguments to SLC_interp_lt.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        assert MLI1_par.exists(), f"{MLI1_par} does not exist"
        assert MLI1_par.stat().st_size > 0, f"{MLI1_par} has zero file size"

        assert MLI2_par.exists(), f"{MLI2_par} does not exist"
        assert MLI2_par.stat().st_size > 0, f"{MLI2_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not SLC_2R.exists(), f"{SLC_2R} should _not_ exist!"

        assert not SLC2R_par.exists(), f"{SLC2R_par} should _not_ exist!"

    def _mock_SLC_interp_lt_outputs(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Optional[Path],
        SLC_2R: Path,
        SLC2R_par: Path,
    ) -> None:
        """

        Mock the program SLC_interp_lt.

        """

        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()

        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp_lt(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Optional[Path],
        SLC_2R: Path,
        SLC2R_par: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Resample SLC image using a lookup table and a refinement offset polynomial if available


        input parameters:
          SLC2          (input) SLC-2 image to be resampled to the geometry of the SLC-1 reference image
          SLC1_par      (input) SLC/MLI ISP image parameter file of the SLC-1 reference
          SLC2_par      (input) SLC/MLI ISP image parameter file of SLC-2
          lookup_table  (input) lookup_table relating SLC-2 to SLC-1
          MLI1_par      (input) SLC/MLI ISP image parameter file of reference MLI (lookup table dimension)
          MLI2_par      (input) SLC/MLI ISP image parameter file of MLI2 (lookup table values)
          OFF_par       (input) ISP offset/interferogram parameter file used for refinement (enter - for none)
          SLC-2R        (output) single-look complex image 2 coregistered to SLC-1
          SLC2R_par     (output) SLC-2R ISP image parameter file for coregistered image
          blksz         number of lines/block (enter - for default, minimum value: 128)
          mode          interpolation mode (enter - for default)
                          0: Lanczos (default)
                          1: B-spline
          order         Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)


        """

        if self.validate_inputs:
            self._validate_SLC_interp_lt(
                SLC1_par,
                SLC2_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                OFF_par,
                SLC_2R,
                SLC2R_par,
            )

        if self.mock_outputs:
            self._mock_SLC_interp_lt_outputs(
                SLC1_par,
                SLC2_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                OFF_par,
                SLC_2R,
                SLC2R_par,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_interp_lt))
        result = self._gamma_call("DIFF", "SLC_interp_lt", ca)

        assert SLC_2R.exists(), f"{SLC_2R} does not exist"
        assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        return result

    def _validate_dispmap(
        self,
        unw: Path,
        hgt: Optional[Path],
        MLI_par: Path,
        OFF_par: Optional[Path],
        disp_map: Path,
        mode: Optional[int] = None,
        sflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dispmap.

        """

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        if hgt is not None:
            assert hgt.exists(), f"{hgt} does not exist"
            assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not disp_map.exists(), f"{disp_map} should _not_ exist!"

    def _mock_dispmap_outputs(
        self,
        unw: Path,
        hgt: Optional[Path],
        MLI_par: Path,
        OFF_par: Optional[Path],
        disp_map: Path,
        mode: Optional[int] = None,
        sflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program dispmap.

        """

        if disp_map is not None and str(disp_map) != "-":
            disp_map.touch()

    def dispmap(
        self,
        unw: Path,
        hgt: Optional[Path],
        MLI_par: Path,
        OFF_par: Optional[Path],
        disp_map: Path,
        mode: Optional[int] = None,
        sflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Conversion of unwrapped differential phase to displacement (m)


        input parameters:
          unw       (input) unwrapped phase (radians), (float)
          hgt       (input) height map (enter - for none, reference height set to 0.0) (float)
          MLI_par   (input) SLC/MLI image parameter file of the reference scene
                    NOTE: use the SLC_par if the OFF_par is provided, otherwise use the MLI_par
          OFF_par   (input) ISP offset/interferogram parameter file (enter - for none)
                    NOTE: geometry and pixel spacing are determined from the MLI_par, if the OFF_par is not provided
          disp_map  (output) displacement map (float)
          mode      displacement mode (enter - for default):
                      0: calculate line of sight (LOS) deformation by scaling the unwrapped phase (default)
                      1: calculate the vertical displacement assuming that all the displacement is vertical
                      2: calculate the horizontal displacement assuming that all displacement is in the direction
                         of the look vector projected on the ground
          sflg      sign flag (enter - for default):
                      0: motion away from the radar is negative: unwrapped phase and deformation have opposite sign (default)
                      1: motion away from the radar is positive: unwrapped phase and deformation have the same sign
                         This is consistent with the look vector that points from the radar to the target on the ground


        """

        if self.validate_inputs:
            self._validate_dispmap(unw, hgt, MLI_par, OFF_par, disp_map, mode, sflg)

        if self.mock_outputs:
            self._mock_dispmap_outputs(unw, hgt, MLI_par, OFF_par, disp_map, mode, sflg)

        ca = self._clean_args(locals(), inspect.signature(self.dispmap))
        result = self._gamma_call("DIFF", "dispmap", ca)

        assert disp_map.exists(), f"{disp_map} does not exist"
        assert disp_map.stat().st_size > 0, f"{disp_map} has zero file size"

        return result

    def _validate_atm_mod(
        self,
        diff_unw: Path,
        hgt: Optional[Path],
        DIFF_par: Path,
        atm_phase: Path,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to atm_mod.

        """

        assert diff_unw.exists(), f"{diff_unw} does not exist"
        assert diff_unw.stat().st_size > 0, f"{diff_unw} has zero file size"

        if hgt is not None:
            assert hgt.exists(), f"{hgt} does not exist"
            assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not atm_phase.exists(), f"{atm_phase} should _not_ exist!"

        if mask is not None:
            assert mask.exists(), f"{mask} does not exist"
            assert mask.stat().st_size > 0, f"{mask} has zero file size"

    def _mock_atm_mod_outputs(
        self,
        diff_unw: Path,
        hgt: Optional[Path],
        DIFF_par: Path,
        atm_phase: Path,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
    ) -> None:
        """

        Mock the program atm_mod.

        """

        if atm_phase is not None and str(atm_phase) != "-":
            atm_phase.touch()

    def atm_mod(
        self,
        diff_unw: Path,
        hgt: Optional[Path],
        DIFF_par: Path,
        atm_phase: Path,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate atmospheric phase trend with respect to height, and slant range


        input parameters:
          diff_unw  (input) unwrapped differential interferogram including atmospheric phase signal (float)
          hgt       (input) height coregistered to the interferogram (enter - for none)
          DIFF_par  (input) differential interferogram parameters
          atm_phase (output) estimated atmospheric phase (float)
          dr        range sample increment (enter - for default: 1)
          daz       azimuth sample increment (enter - for default: 1)
          mask      (input) 8-bit raster image (SUN raster, BMP, or TIFF) (enter - for default: none)
                    NOTE: regions with (R,G,B)=0 in the mask are excluded
          model     atmospheric phase model:
                      0: height (default)
                      1: slant range pixel number (GPRI mode)
          roff      reference point range sample offset
          loff      reference point line offset


        """

        if self.validate_inputs:
            self._validate_atm_mod(
                diff_unw, hgt, DIFF_par, atm_phase, dr, daz, mask, model, roff, loff
            )

        if self.mock_outputs:
            self._mock_atm_mod_outputs(
                diff_unw, hgt, DIFF_par, atm_phase, dr, daz, mask, model, roff, loff
            )

        ca = self._clean_args(locals(), inspect.signature(self.atm_mod))
        result = self._gamma_call("DIFF", "atm_mod", ca)

        assert atm_phase.exists(), f"{atm_phase} does not exist"
        assert atm_phase.stat().st_size > 0, f"{atm_phase} has zero file size"

        return result

    def _validate_ls_map_mask(
        self,
        ls_map: Path,
        width: int,
        mask: Path,
        outside_swath: Optional[int] = None,
        regular: Optional[int] = None,
        layover: Optional[int] = None,
        shadow: Optional[int] = None,
        shadow_in_layover: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ls_map_mask.

        """

        assert ls_map.exists(), f"{ls_map} does not exist"
        assert ls_map.stat().st_size > 0, f"{ls_map} has zero file size"

        assert not mask.exists(), f"{mask} should _not_ exist!"

    def _mock_ls_map_mask_outputs(
        self,
        ls_map: Path,
        width: int,
        mask: Path,
        outside_swath: Optional[int] = None,
        regular: Optional[int] = None,
        layover: Optional[int] = None,
        shadow: Optional[int] = None,
        shadow_in_layover: Optional[int] = None,
    ) -> None:
        """

        Mock the program ls_map_mask.

        """

        if mask is not None and str(mask) != "-":
            mask.touch()

    def ls_map_mask(
        self,
        ls_map: Path,
        width: int,
        mask: Path,
        outside_swath: Optional[int] = None,
        regular: Optional[int] = None,
        layover: Optional[int] = None,
        shadow: Optional[int] = None,
        shadow_in_layover: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate a mask file from a layover and shadow map


        input parameters:
          ls_map              (input) layover and shadow map (UNSIGNED CHAR)
          width               width of input data
          mask                (output) output mask in SUN raster *.ras, BMP *.bmp, or TIFF *.tif format
          outside_swath       flag for data outside of the swath (enter - for default)
                                0: do not mask areas outside of the swath
                                1: mask areas outside of the swath (default)
          regular             flag for areas within the swath and unaffected by layover or shadow (enter - for default)
                                0: do not mask areas within the swath and unaffected by layover or shadow (default)
                                1: mask areas within the swath and unaffected by layover or shadow
          layover             flag for layover areas (enter - for default)
                                0: do not mask layover areas
                                1: mask layover areas (default)
          shadow              flag for shadow areas (enter - for default)
                                0: do not mask shadow areas
                                1: mask shadow areas (default)
          shadow_in_layover   flag for "shadow in layover" areas (enter - for default)
                                0: do not mask "shadow in layover" areas
                                1: mask "shadow in layover" areas (default)


        """

        if self.validate_inputs:
            self._validate_ls_map_mask(
                ls_map,
                width,
                mask,
                outside_swath,
                regular,
                layover,
                shadow,
                shadow_in_layover,
            )

        if self.mock_outputs:
            self._mock_ls_map_mask_outputs(
                ls_map,
                width,
                mask,
                outside_swath,
                regular,
                layover,
                shadow,
                shadow_in_layover,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ls_map_mask))
        result = self._gamma_call("DIFF", "ls_map_mask", ca)

        assert mask.exists(), f"{mask} does not exist"
        assert mask.stat().st_size > 0, f"{mask} has zero file size"

        return result

    def _validate_dispmap_LOS(
        self,
        unw: Path,
        width: int,
        freq: float,
        disp_map: Path,
        sflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dispmap_LOS.

        """

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        assert not disp_map.exists(), f"{disp_map} should _not_ exist!"

    def _mock_dispmap_LOS_outputs(
        self,
        unw: Path,
        width: int,
        freq: float,
        disp_map: Path,
        sflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program dispmap_LOS.

        """

        if disp_map is not None and str(disp_map) != "-":
            disp_map.touch()

    def dispmap_LOS(
        self,
        unw: Path,
        width: int,
        freq: float,
        disp_map: Path,
        sflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Conversion of unwrapped differential phase to displacement along the LOS (m)


        input parameters:
          unw       (input) unwrapped phase (radians), (float)
          width     data samples/line
          freq      radar center frequency (GHz)
          disp_map  (output) displacement map along the Line of Sight (LOS) (float)
          sflg      displacement sign flag (enter - for default):
                      0: motion away from the radar is negative: unwrapped phase and deformation have opposite sign (default)
                      1: motion away from the radar is positive: unwrapped phase and deformation have the same sign
                         This is consistent with the look vector pointing from the radar to the target on the ground


        """

        if self.validate_inputs:
            self._validate_dispmap_LOS(unw, width, freq, disp_map, sflg)

        if self.mock_outputs:
            self._mock_dispmap_LOS_outputs(unw, width, freq, disp_map, sflg)

        ca = self._clean_args(locals(), inspect.signature(self.dispmap_LOS))
        result = self._gamma_call("DIFF", "dispmap_LOS", ca)

        assert disp_map.exists(), f"{disp_map} does not exist"
        assert disp_map.stat().st_size > 0, f"{disp_map} has zero file size"

        return result

    def _validate_sub_phase(
        self,
        d1: Path,
        d2: Path,
        DIFF_par: Path,
        diff: Path,
        dtype1: int,
        mode: Optional[int] = None,
        dtype2: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to sub_phase.

        """

        assert d1.exists(), f"{d1} does not exist"
        assert d1.stat().st_size > 0, f"{d1} has zero file size"

        assert d2.exists(), f"{d2} does not exist"
        assert d2.stat().st_size > 0, f"{d2} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not diff.exists(), f"{diff} should _not_ exist!"

    def _mock_sub_phase_outputs(
        self,
        d1: Path,
        d2: Path,
        DIFF_par: Path,
        diff: Path,
        dtype1: int,
        mode: Optional[int] = None,
        dtype2: Optional[int] = None,
    ) -> None:
        """

        Mock the program sub_phase.

        """

        if diff is not None and str(diff) != "-":
            diff.touch()

    def sub_phase(
        self,
        d1: Path,
        d2: Path,
        DIFF_par: Path,
        diff: Path,
        dtype1: int,
        mode: Optional[int] = None,
        dtype2: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Subtract or add phase from an SLC or interferogram


        input parameters:
          d1        (input) SLC, interferogram, or unwrapped phase (SCOMPLEX, FCOMPLEX, FLOAT format)
          d2        (input) SLC, interferogram, or unwrapped phase (SCOMPLEX, FCOMPLEX, FLOAT format)
          DIFF_par  (input) DIFF/GEO parameter file
          diff      (output) output data file, with the same data format as d1
          dtype1    d1 data type:
                      0: unwrapped phase (FLOAT)
                      1: interferogram or SLC (FCOMPLEX)
                      2: SLC (SCOMPLEX)
          mode      subtract or add phase of d2 (enter - for default)
                      0: subtract d2 phase from d1 data (default)
                      1: add d2 phase to d1 data
          dtype2    d2 data type (enter - for default)
                      0: unwrapped phase (FLOAT) (default)
                      1: interferogram or SLC (FCOMPLEX)
                      2: SLC (SCOMPLEX)
        NOTES:
          1. When d2 is SCOMPLEX or FCOMPLEX format, the phase of d2 is used
          2. When d1 is unwrapped phase, then d2 must also be unwrapped phase


        """

        if self.validate_inputs:
            self._validate_sub_phase(d1, d2, DIFF_par, diff, dtype1, mode, dtype2)

        if self.mock_outputs:
            self._mock_sub_phase_outputs(d1, d2, DIFF_par, diff, dtype1, mode, dtype2)

        ca = self._clean_args(locals(), inspect.signature(self.sub_phase))
        result = self._gamma_call("DIFF", "sub_phase", ca)

        assert diff.exists(), f"{diff} does not exist"
        assert diff.stat().st_size > 0, f"{diff} has zero file size"

        return result

    def _validate_phase_sim(
        self,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        ph_flag: Optional[int] = None,
        bflag: Optional[int] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        ph_mode: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to phase_sim.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert baseline.exists(), f"{baseline} does not exist"
        assert baseline.stat().st_size > 0, f"{baseline} has zero file size"

        assert hgt.exists(), f"{hgt} does not exist"
        assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        if def_ is not None:
            assert def_.exists(), f"{def_} does not exist"
            assert def_.stat().st_size > 0, f"{def_} has zero file size"

        if delta_t is not None:
            assert delta_t.exists(), f"{delta_t} does not exist"
            assert delta_t.stat().st_size > 0, f"{delta_t} has zero file size"

        if int_mode is not None:
            assert int_mode.exists(), f"{int_mode} does not exist"
            assert int_mode.stat().st_size > 0, f"{int_mode} has zero file size"

        if SLC2R_par is not None:
            assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
            assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

    def _mock_phase_sim_outputs(
        self,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        ph_flag: Optional[int] = None,
        bflag: Optional[int] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        ph_mode: Optional[int] = None,
    ) -> None:
        """

        Mock the program phase_sim.

        """
        pass

    def phase_sim(
        self,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        ph_flag: Optional[int] = None,
        bflag: Optional[int] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        ph_mode: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Simulate unwrapped interferometric phase using DEM height and deformation rate


        input parameters:
          SLC1_par  (input) parameter file of reference SLC-1
          OFF_par   (input) ISP offset/interferogram parameter file
          baseline  (input) baseline parameter file
          hgt       (input) height relative to the WGS-84 elliposid in the same geometry as the mosaic (m) (FLOAT, enter - for none)
          sim       (output) simulated interferometric phase (FLOAT, unwrapped)
          ph_flag   range phase trend selection:
                      0: unflattened interferogram (default)
                      1: flattened interferogram
          bflag     baseline selection:
                      0: initial baseline (default)
                      1: precision baseline
          def       (input) LOS deformation rate map (meters/yr, float, enter - for none)
          delta_t   (input) interferogram time interval (days, required for deformation modeling, enter - for none)
          int_mode  (input) interferometric acquisition mode  (enter - for default):
                      0: single-pass mode (Tandem-X)
                      1: repeat-pass mode (default)
          SLC2R_par (input) parameter file of resampled SLC, required if SLC-2 frequency differs from SLC-1, (enter - for none)
          ph_mode   phase offset mode:
                      0: absolute phase (default)
                      1: subtract phase at image center (height = 0.0) rounded to the nearest multiple of 2PI


        """

        if self.validate_inputs:
            self._validate_phase_sim(
                SLC1_par,
                OFF_par,
                baseline,
                hgt,
                ph_flag,
                bflag,
                def_,
                delta_t,
                int_mode,
                SLC2R_par,
                ph_mode,
            )

        if self.mock_outputs:
            self._mock_phase_sim_outputs(
                SLC1_par,
                OFF_par,
                baseline,
                hgt,
                ph_flag,
                bflag,
                def_,
                delta_t,
                int_mode,
                SLC2R_par,
                ph_mode,
            )

        ca = self._clean_args(locals(), inspect.signature(self.phase_sim))
        result = self._gamma_call("DIFF", "phase_sim", ca)
        return result

    def _validate_offset_pwr_geo(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwr_geo.

        """

        assert SLC1.exists(), f"{SLC1} does not exist"
        assert SLC1.stat().st_size > 0, f"{SLC1} has zero file size"

        assert SLC2.exists(), f"{SLC2} does not exist"
        assert SLC2.stat().st_size > 0, f"{SLC2} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not ccp.exists(), f"{ccp} should _not_ exist!"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

        if ccs is not None:
            assert not ccs.exists(), f"{ccs} should _not_ exist!"

    def _mock_offset_pwr_geo_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Mock the program offset_pwr_geo.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if ccp is not None and str(ccp) != "-":
            ccp.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_geo(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offset estimation between geocoded SLC images using intensity cross-correlation


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          DIFF_par  (input) DIFF parameter file created from DEM_par files
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          nr        number of offset estimates in range direction (enter - for default from offset parameter file)
          naz       number of offset estimates in azimuth direction (enter - for default from offset parameter file)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          format    SLC data format (enter - for default)
                      0: FCOMPLEX (default)
                      1: SCOMPLEX
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)


        """

        if self.validate_inputs:
            self._validate_offset_pwr_geo(
                SLC1,
                SLC2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                format,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        if self.mock_outputs:
            self._mock_offset_pwr_geo_outputs(
                SLC1,
                SLC2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                format,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_pwr_geo))
        result = self._gamma_call("DIFF", "offset_pwr_geo", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        if ccs is not None:
            assert ccs.exists(), f"{ccs} does not exist"
            assert ccs.stat().st_size > 0, f"{ccs} has zero file size"

        return result

    def _validate_par_RISAT_geo(
        self,
        annotation_XML: Path,
        GeoTIFF: Path,
        polarization: Path,
        DEM_par: Path,
        MLI_par: Path,
        MLI: Path,
    ) -> None:
        """

        Validate the arguments to par_RISAT_geo.

        """

        assert annotation_XML.exists(), f"{annotation_XML} does not exist"
        assert annotation_XML.stat().st_size > 0, f"{annotation_XML} has zero file size"

        assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
        assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert polarization.exists(), f"{polarization} does not exist"
        assert polarization.stat().st_size > 0, f"{polarization} has zero file size"

        assert not DEM_par.exists(), f"{DEM_par} should _not_ exist!"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        assert not MLI.exists(), f"{MLI} should _not_ exist!"

    def _mock_par_RISAT_geo_outputs(
        self,
        annotation_XML: Path,
        GeoTIFF: Path,
        polarization: Path,
        DEM_par: Path,
        MLI_par: Path,
        MLI: Path,
    ) -> None:
        """

        Mock the program par_RISAT_geo.

        """

        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

    def par_RISAT_geo(
        self,
        annotation_XML: Path,
        GeoTIFF: Path,
        polarization: Path,
        DEM_par: Path,
        MLI_par: Path,
        MLI: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate DEM parameter file, MLI image, and MLI parameter file for RISAT-1 GeoTIFF products


        input parameters:
          annotation_XML (input) RISAT-1 product annotation XML file (product.xml)
          GeoTIFF        (input) image data file in GeoTIFF format (imagery_pp.tif)
          polarization   (input) polarization RV, RH of the GeoTIFF image data
          DEM_par        (output) DIFF/GEO DEM parameter file
          MLI_par        (output) ISP image parameter file (example: yyyymmdd_pp.mli.par)
          MLI            (output) SLC data file (example: yyyymmdd_pp.mli)

        """

        if self.validate_inputs:
            self._validate_par_RISAT_geo(
                annotation_XML, GeoTIFF, polarization, DEM_par, MLI_par, MLI
            )

        if self.mock_outputs:
            self._mock_par_RISAT_geo_outputs(
                annotation_XML, GeoTIFF, polarization, DEM_par, MLI_par, MLI
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RISAT_geo))
        result = self._gamma_call("DIFF", "par_RISAT_geo", ca)

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        return result

    def _validate_MLI_interp_lt(
        self,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        lookup_table: Path,
        MLI3_par: Path,
        MLI4_par: Path,
        DIFF_par: Optional[Path],
        MLI_2R: Path,
        MLI2R_par: Path,
        order: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to MLI_interp_lt.

        """

        assert MLI_2.exists(), f"{MLI_2} does not exist"
        assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

        assert MLI1_par.exists(), f"{MLI1_par} does not exist"
        assert MLI1_par.stat().st_size > 0, f"{MLI1_par} has zero file size"

        assert MLI2_par.exists(), f"{MLI2_par} does not exist"
        assert MLI2_par.stat().st_size > 0, f"{MLI2_par} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        assert MLI3_par.exists(), f"{MLI3_par} does not exist"
        assert MLI3_par.stat().st_size > 0, f"{MLI3_par} has zero file size"

        assert MLI4_par.exists(), f"{MLI4_par} does not exist"
        assert MLI4_par.stat().st_size > 0, f"{MLI4_par} has zero file size"

        if DIFF_par is not None:
            assert DIFF_par.exists(), f"{DIFF_par} does not exist"
            assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not MLI_2R.exists(), f"{MLI_2R} should _not_ exist!"

        assert not MLI2R_par.exists(), f"{MLI2R_par} should _not_ exist!"

    def _mock_MLI_interp_lt_outputs(
        self,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        lookup_table: Path,
        MLI3_par: Path,
        MLI4_par: Path,
        DIFF_par: Optional[Path],
        MLI_2R: Path,
        MLI2R_par: Path,
        order: Optional[int] = None,
    ) -> None:
        """

        Mock the program MLI_interp_lt.

        """

        if MLI_2R is not None and str(MLI_2R) != "-":
            MLI_2R.touch()

        if MLI2R_par is not None and str(MLI2R_par) != "-":
            MLI2R_par.touch()

    def MLI_interp_lt(
        self,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        lookup_table: Path,
        MLI3_par: Path,
        MLI4_par: Path,
        DIFF_par: Optional[Path],
        MLI_2R: Path,
        MLI2R_par: Path,
        order: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        MLI image resampling via a lookup table and B-spline interpolation


        input parameters:
          MLI-2         (input) MLI-2 image to be resampled to the geometry of the MLI-1 reference image
          MLI1_par      (input) ISP image parameter file of the MLI-1 reference
          MLI2_par      (input) ISP image parameter file of MLI-2
          lookup_table  (input) lookup_table relating MLI-2 to MLI-1
          MLI3_par      (input) ISP image parameter file of reference scene MLI-3 (lookup table dimension)
          MLI4_par      (input) ISP image parameter file of MLI-4 (lookup table values)
          DIFF_par      (input) DIFF parameter file used for refinement (enter - for none)
          MLI-2R        (output) MLI-2 coregistered to MLI-1
          MLI2R_par     (output) MLI-2R ISP image parameter file for coregistered image
          order         B-Spline interpolation degree (2->9) (enter - default: 3)


        """

        if self.validate_inputs:
            self._validate_MLI_interp_lt(
                MLI_2,
                MLI1_par,
                MLI2_par,
                lookup_table,
                MLI3_par,
                MLI4_par,
                DIFF_par,
                MLI_2R,
                MLI2R_par,
                order,
            )

        if self.mock_outputs:
            self._mock_MLI_interp_lt_outputs(
                MLI_2,
                MLI1_par,
                MLI2_par,
                lookup_table,
                MLI3_par,
                MLI4_par,
                DIFF_par,
                MLI_2R,
                MLI2R_par,
                order,
            )

        ca = self._clean_args(locals(), inspect.signature(self.MLI_interp_lt))
        result = self._gamma_call("DIFF", "MLI_interp_lt", ca)

        assert MLI_2R.exists(), f"{MLI_2R} does not exist"
        assert MLI_2R.stat().st_size > 0, f"{MLI_2R} has zero file size"

        assert MLI2R_par.exists(), f"{MLI2R_par} does not exist"
        assert MLI2R_par.stat().st_size > 0, f"{MLI2R_par} has zero file size"

        return result

    def _validate_lk_vec_lt(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lt: Path,
        lv_theta: Optional[Path] = None,
        lv_phi: Optional[Path] = None,
        lv_ENU: Optional[Path] = None,
        azv_ENU: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to lk_vec_lt.

        """

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert lt.exists(), f"{lt} does not exist"
        assert lt.stat().st_size > 0, f"{lt} has zero file size"

        if lv_theta is not None:
            assert not lv_theta.exists(), f"{lv_theta} should _not_ exist!"

        if lv_phi is not None:
            assert not lv_phi.exists(), f"{lv_phi} should _not_ exist!"

        if lv_ENU is not None:
            assert not lv_ENU.exists(), f"{lv_ENU} should _not_ exist!"

        if azv_ENU is not None:
            assert not azv_ENU.exists(), f"{azv_ENU} should _not_ exist!"

    def _mock_lk_vec_lt_outputs(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lt: Path,
        lv_theta: Optional[Path] = None,
        lv_phi: Optional[Path] = None,
        lv_ENU: Optional[Path] = None,
        azv_ENU: Optional[Path] = None,
    ) -> None:
        """

        Mock the program lk_vec_lt.

        """

        if lv_theta is not None and str(lv_theta) != "-":
            lv_theta.touch()

        if lv_phi is not None and str(lv_phi) != "-":
            lv_phi.touch()

        if lv_ENU is not None and str(lv_ENU) != "-":
            lv_ENU.touch()

        if azv_ENU is not None and str(azv_ENU) != "-":
            azv_ENU.touch()

    def lk_vec_lt(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lt: Path,
        lv_theta: Optional[Path] = None,
        lv_phi: Optional[Path] = None,
        lv_ENU: Optional[Path] = None,
        azv_ENU: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate look-vector elevation and orientation angles using the geocoding lookup-table


        input parameters:
          MLI_par   (input) ISP MLI/SLC image parameter file
                    NOTE: MLI_par must have the same dimensions and number of looks as the image used to calculate the geocoding lookup table
          DEM_par   (input) DEM/MAP parameter file
          DEM       (input) DEM data file or constant height value
          lt        (input) geocoding lookup table with same dimensions as DEM
          lv_theta  (output) SAR look-vector elevation angle with respect to the topocentric horizontal plane at each map pixel (enter - for none)
                      lv_theta: PI/2 -> up  -PI/2 -> down
                      The elevation angle is measured between the local topocentric horizontal plane and the look vector pointing at the radar
          lv_phi    (output) SAR look-vector orientation angle in the topocentric horizontal plane at each map pixel (enter - for none)
                      lv_phi: 0 -> East  PI/2 -> North
          lv_ENU    (output) unit look vector (pointing from SAR sensor to ground) given in East, North, Up (ENU) topocentric coordinates at each map pixel (float) (enter - for none)
          azv_ENU   (output) unit vector in the positive azimuth direction, East, North, Up (ENU) topocentric coordinates (float) (enter - for none)


        """

        if self.validate_inputs:
            self._validate_lk_vec_lt(
                MLI_par, DEM_par, DEM, lt, lv_theta, lv_phi, lv_ENU, azv_ENU
            )

        if self.mock_outputs:
            self._mock_lk_vec_lt_outputs(
                MLI_par, DEM_par, DEM, lt, lv_theta, lv_phi, lv_ENU, azv_ENU
            )

        ca = self._clean_args(locals(), inspect.signature(self.lk_vec_lt))
        result = self._gamma_call("DIFF", "lk_vec_lt", ca)

        if lv_theta is not None:
            assert lv_theta.exists(), f"{lv_theta} does not exist"
            assert lv_theta.stat().st_size > 0, f"{lv_theta} has zero file size"

        if lv_phi is not None:
            assert lv_phi.exists(), f"{lv_phi} does not exist"
            assert lv_phi.stat().st_size > 0, f"{lv_phi} has zero file size"

        if lv_ENU is not None:
            assert lv_ENU.exists(), f"{lv_ENU} does not exist"
            assert lv_ENU.stat().st_size > 0, f"{lv_ENU} has zero file size"

        if azv_ENU is not None:
            assert azv_ENU.exists(), f"{azv_ENU} does not exist"
            assert azv_ENU.stat().st_size > 0, f"{azv_ENU} has zero file size"

        return result

    def _validate_offset_pwr_tracking_geo(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwr_tracking_geo.

        """

        assert SLC1.exists(), f"{SLC1} does not exist"
        assert SLC1.stat().st_size > 0, f"{SLC1} has zero file size"

        assert SLC2.exists(), f"{SLC2} does not exist"
        assert SLC2.stat().st_size > 0, f"{SLC2} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not ccp.exists(), f"{ccp} should _not_ exist!"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

        if ccs is not None:
            assert not ccs.exists(), f"{ccs} should _not_ exist!"

    def _mock_offset_pwr_tracking_geo_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Mock the program offset_pwr_tracking_geo.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if ccp is not None and str(ccp) != "-":
            ccp.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_tracking_geo(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offset estimation between geocoded SLC images using intensity cross-correlation***


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          DIFF_par  (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          format    SLC data format (enter - for default)
                      0: FCOMPLEX (default)
                      1: SCOMPLEX
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)


        """

        if self.validate_inputs:
            self._validate_offset_pwr_tracking_geo(
                SLC1,
                SLC2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                format,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        if self.mock_outputs:
            self._mock_offset_pwr_tracking_geo_outputs(
                SLC1,
                SLC2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                format,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_pwr_tracking_geo))
        result = self._gamma_call("DIFF", "offset_pwr_tracking_geo", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        if ccs is not None:
            assert ccs.exists(), f"{ccs} does not exist"
            assert ccs.stat().st_size > 0, f"{ccs} has zero file size"

        return result

    def _validate_coord_to_sarpix(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Optional[Path],
        lat: float,
        lon: float,
        hgt: float,
        DIFF_par: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to coord_to_sarpix.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        if DEM_par is not None:
            assert DEM_par.exists(), f"{DEM_par} does not exist"
            assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        if DIFF_par is not None:
            assert DIFF_par.exists(), f"{DIFF_par} does not exist"
            assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

    def _mock_coord_to_sarpix_outputs(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Optional[Path],
        lat: float,
        lon: float,
        hgt: float,
        DIFF_par: Optional[Path] = None,
    ) -> None:
        """

        Mock the program coord_to_sarpix.

        """
        pass

    def coord_to_sarpix(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Optional[Path],
        lat: float,
        lon: float,
        hgt: float,
        DIFF_par: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate the SAR image pixel coordinates of a point specified in map coordinates


        input parameters:
          SLC/MLI_par  (input) ISP SLC/MLI image parameter file
          OFF_par      (input) ISP offset/interferogram parameter file, enter - for SLC or MLI data
                         NOTE: it should not be necessary to enter this parameter file. The SLC/MLI parameter file should describe
                       the scene dimensions including the number of range and azimuth looks
          DEM_par      (input) DEM parameter file defining geometry of input coordinates (enter - for none)
                         NOTE: when no DEM parameter file is provided, then the input coordinates are interpreted as latitude and longitude in the WGS84 datum
          north/lat    (input) northing (m) or latitude (deg.)
          east/lon     (input) easting (m) or longitude (deg.)
          hgt          (input) height (m) of the point in the map datum
          DIFF_par     (input) DIFF/GEO parameter file containing refinement polynomial coefficients (default: none)

          NOTE: When the DIFF_par is specified, it is assumed that the simulated image was the reference for determining the geocoding correction


        """

        if self.validate_inputs:
            self._validate_coord_to_sarpix(
                SLC_par, OFF_par, DEM_par, lat, lon, hgt, DIFF_par
            )

        if self.mock_outputs:
            self._mock_coord_to_sarpix_outputs(
                SLC_par, OFF_par, DEM_par, lat, lon, hgt, DIFF_par
            )

        ca = self._clean_args(locals(), inspect.signature(self.coord_to_sarpix))
        result = self._gamma_call("DIFF", "coord_to_sarpix", ca)
        return result

    def _validate_WSS_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        m_flg: Optional[int] = None,
        boff: Optional[int] = None,
        bstep: Optional[int] = None,
        bmax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to WSS_intf.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2R.exists(), f"{SLC_2R} does not exist"
        assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        assert not OFF_par.exists(), f"{OFF_par} should _not_ exist!"

        assert not interf.exists(), f"{interf} should _not_ exist!"

    def _mock_WSS_intf_outputs(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        m_flg: Optional[int] = None,
        boff: Optional[int] = None,
        bstep: Optional[int] = None,
        bmax: Optional[int] = None,
    ) -> None:
        """

        Mock the program WSS_intf.

        """

        if OFF_par is not None and str(OFF_par) != "-":
            OFF_par.touch()

        if interf is not None and str(interf) != "-":
            interf.touch()

    def WSS_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        m_flg: Optional[int] = None,
        boff: Optional[int] = None,
        bstep: Optional[int] = None,
        bmax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate multi-look interferogram from ASAR Wide-Swath SLC images


        input parameters:
          SLC-1     (input) reference ASAR Wide-Swath SLC image
          SLC-2R    (input) resampled ASAR Wide-Swath SLC image coregistered to SLC-1
          SLC1_par  (input) ASAR Wide-Swath SLC image parameter file
          SLC2R_par (input) co-registered ASAR Wide-Swath SLC-2R image parameter file
          OFF_par   (output) ISP offset/interferogram parameter file
          interf    (output) interferogram from SLC-1 and SLC-2R
          rlks      number of range looks (enter - for default: 1)
          sps_flg   range spectral shift flag:
                      1: apply range spectral shift filter (default)
                      0: do not apply range spectral shift filter
          azf_flg   azimuth common band filter flag:
                      1: apply azimuth common band filter (default)
                      0: do not apply azimuth common band filter
          m_flg     output magnitude flag:
                      0: set output interferogram magnitude to 1.0 for non-zero samples (default)
                      1: retain multi-burst interferometric magnitude
          boff      offset to first burst to interfere (default = 0)
          bstep     burst step (default = 1)
          bmax      last burst to interfere (default = to end of SLC-1)


        """

        if self.validate_inputs:
            self._validate_WSS_intf(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                interf,
                rlks,
                sps_flg,
                azf_flg,
                m_flg,
                boff,
                bstep,
                bmax,
            )

        if self.mock_outputs:
            self._mock_WSS_intf_outputs(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                interf,
                rlks,
                sps_flg,
                azf_flg,
                m_flg,
                boff,
                bstep,
                bmax,
            )

        ca = self._clean_args(locals(), inspect.signature(self.WSS_intf))
        result = self._gamma_call("DIFF", "WSS_intf", ca)

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        return result

    def _validate_map_section(
        self,
        DEM_par: Path,
        post_north: Optional[Path],
        post_east: Optional[Path],
        DEM_par2: Path,
        lt: Optional[Path] = None,
        ISP_par1: Optional[Path] = None,
        ISP_par2: Optional[Path] = None,
        cflg: Optional[int] = None,
        lt2: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to map_section.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert not DEM_par2.exists(), f"{DEM_par2} should _not_ exist!"

        if lt is not None:
            assert lt.exists(), f"{lt} does not exist"
            assert lt.stat().st_size > 0, f"{lt} has zero file size"

        if ISP_par1 is not None:
            assert ISP_par1.exists(), f"{ISP_par1} does not exist"
            assert ISP_par1.stat().st_size > 0, f"{ISP_par1} has zero file size"

        if ISP_par2 is not None:
            assert ISP_par2.exists(), f"{ISP_par2} does not exist"
            assert ISP_par2.stat().st_size > 0, f"{ISP_par2} has zero file size"

        if lt2 is not None:
            assert not lt2.exists(), f"{lt2} should _not_ exist!"

    def _mock_map_section_outputs(
        self,
        DEM_par: Path,
        post_north: Optional[Path],
        post_east: Optional[Path],
        DEM_par2: Path,
        lt: Optional[Path] = None,
        ISP_par1: Optional[Path] = None,
        ISP_par2: Optional[Path] = None,
        cflg: Optional[int] = None,
        lt2: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program map_section.

        """

        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

        if lt2 is not None and str(lt2) != "-":
            lt2.touch()

    def map_section(
        self,
        DEM_par: Path,
        post_north: Optional[Path],
        post_east: Optional[Path],
        DEM_par2: Path,
        lt: Optional[Path] = None,
        ISP_par1: Optional[Path] = None,
        ISP_par2: Optional[Path] = None,
        cflg: Optional[int] = None,
        lt2: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate the DEM parameter file of a specfied region and extract this region from a geocoding lookup table


        input parameters:
          DEM_par     (input) DEM parameter file describing the input map geometry
          north1      northing map coordinate of the upper-left corner of the map segment (enter - to use the value in the DEM_par)
          east1       easting  map coordinate of the upper-left corner of the map segment (enter - to use the value in the DEM_par)
          north2      northing map coordinate of the lower-right corner of the map segment (enter - to use the value in the DEM_par)
          east2       easting  map coordinate of the lower-right corner of the map segment (enter - to use the value in the DEM_par)
                      NOTE: units for the corner coordinates depend on the projection specified in the DEM_par
          post_north  posting of the output lookup table for map samples in northing (enter - to keep the posting in the DEM_par)
                      NOTE: post_north must be a negative number to prevent the DEM from flipping north/south when displayed
          post_east   posting of the output lookup table in map coordinates in easting  (enter - to keep the posting in the DEM_par)
                      NOTE: post_east must be a positive number to prevent the DEM from flipping east/west when displayed
          DEM_par2    (output) DEM parameter file describing the output lookup table
          lt          (input) geocoding lookup table for the transformation from map geometry to radar Range-Doppler Coordinates (RDC) (enter - for none)
                      NOTE: The lookup table has the dimensions described by the DEM_par
          ISP_par1    (input) image parameter file (MLI_par or SLC_par) of the data used for calculation of the input lookup table values (enter - for none)
          ISP_par2    (input) image parameter file (MLI_par or SLC_par) of the data that will be terrain geocoded with the new lookup table lt2 (enter - to be the same as ISP_par1)
                      NOTE: Must be generated from the same SLC image as MLI_par but differs in the number of range and azimuth looks
          cflg        lookup table coordinate shift flag (enter - for default):
                        0: leave output lookup table values unchanged (default)
                           The output lookup table values are coordinates defined by the ISP_par1 parameters
                        1: subtract range and azimuth offsets from the output lookup table values
                           The output lookup table values are coordinates defined by the bounding box of the specified region (coords)
          lt2         (output) resampled geocoding lookup table with the specified bounds and map posting (enter - for none)
          coords      (output) rectangular region coordinates covering the region of the lt2 lookup table (text format, enter - for none)
                        ISP_par1 geometry: range_offset  range samples   azimuth_offset  azimuth_lines
                        ISP_par2 geometry: range_offset  range samples   azimuth_offset  azimuth_lines
          width       number of samples per line of lt2, (enter - for default, calculated from (east1 - east2))
          nlines      number of lines in the output lt2, (enter - for default, calculated from (north1 - north2))


        """

        if self.validate_inputs:
            self._validate_map_section(
                DEM_par,
                post_north,
                post_east,
                DEM_par2,
                lt,
                ISP_par1,
                ISP_par2,
                cflg,
                lt2,
                width,
                nlines,
            )

        if self.mock_outputs:
            self._mock_map_section_outputs(
                DEM_par,
                post_north,
                post_east,
                DEM_par2,
                lt,
                ISP_par1,
                ISP_par2,
                cflg,
                lt2,
                width,
                nlines,
            )

        ca = self._clean_args(locals(), inspect.signature(self.map_section))
        result = self._gamma_call("DIFF", "map_section", ca)

        assert DEM_par2.exists(), f"{DEM_par2} does not exist"
        assert DEM_par2.stat().st_size > 0, f"{DEM_par2} has zero file size"

        if lt2 is not None:
            assert lt2.exists(), f"{lt2} does not exist"
            assert lt2.stat().st_size > 0, f"{lt2} has zero file size"

        return result

    def _validate_offset_list_fitm(
        self,
        cp_list: Path,
        DIFF_par: Path,
        DEM_par: Optional[Path] = None,
        lookup_table: Optional[Path] = None,
        lt_type: Optional[int] = None,
        type1: Optional[int] = None,
        type2: Optional[int] = None,
        coffsets: Optional[Path] = None,
        poly_order: Optional[int] = None,
        interact_flag: Optional[int] = None,
        trans_list: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_list_fitm.

        """

        assert cp_list.exists(), f"{cp_list} does not exist"
        assert cp_list.stat().st_size > 0, f"{cp_list} has zero file size"

        if DEM_par is not None:
            assert DEM_par.exists(), f"{DEM_par} does not exist"
            assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        if lookup_table is not None:
            assert lookup_table.exists(), f"{lookup_table} does not exist"
            assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        if coffsets is not None:
            assert not coffsets.exists(), f"{coffsets} should _not_ exist!"

    def _mock_offset_list_fitm_outputs(
        self,
        cp_list: Path,
        DIFF_par: Path,
        DEM_par: Optional[Path] = None,
        lookup_table: Optional[Path] = None,
        lt_type: Optional[int] = None,
        type1: Optional[int] = None,
        type2: Optional[int] = None,
        coffsets: Optional[Path] = None,
        poly_order: Optional[int] = None,
        interact_flag: Optional[int] = None,
        trans_list: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_list_fitm.

        """

        if not DIFF_par.exists():
            DIFF_par.touch()

        if coffsets is not None and str(coffsets) != "-":
            coffsets.touch()

    def offset_list_fitm(
        self,
        cp_list: Path,
        DIFF_par: Path,
        DEM_par: Optional[Path] = None,
        lookup_table: Optional[Path] = None,
        lt_type: Optional[int] = None,
        type1: Optional[int] = None,
        type2: Optional[int] = None,
        coffsets: Optional[Path] = None,
        poly_order: Optional[int] = None,
        interact_flag: Optional[int] = None,
        trans_list: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate fine registration polynomial for geocoding from control point list


        input parameters:
          cp_list        (input) list with registration control point (CP) coordinates:
                           CP_nr  ref_col  ref_row  col2  row2
          DIFF_par       (input/output) DIFF&GEO parameter file (for output of fine registration polynomial)
          DEM_par        (input)DEM/MAP parameter file (enter - for none)
          lookup_table   (input)geocoding lookup table (required to convert between map pixel numbers and SAR pixel numbers)
          lt_type        lookup table type (enter - for default)
                           1: map_to_rdc (default)
                           2: rdc_to_map
          type1          reference coordinate type (enter - for default):
                           1: SAR (col,row) pixel numbers (default):
                           2: map (col,row) pixel numbers
                           3: map (easting, northing) coordinates)
          type2          image 2 coordinate type (enter - for default):
                           1: SAR (col,row) pixel numbers (default)
                           2: map (col,row) pixel numbers
                           3: map (easting, northing) coordinates)
          coffsets       (output) list of culled registration offsets (text file)
          poly_order     polynomial order parameter (1, 3, 4, 6, default: 4)
          interact_flag  interactive culling of input data (1=YES, 0=NO, default: NO)
          trans_list     transformed coordinate list using model


        """

        if self.validate_inputs:
            self._validate_offset_list_fitm(
                cp_list,
                DIFF_par,
                DEM_par,
                lookup_table,
                lt_type,
                type1,
                type2,
                coffsets,
                poly_order,
                interact_flag,
                trans_list,
            )

        if self.mock_outputs:
            self._mock_offset_list_fitm_outputs(
                cp_list,
                DIFF_par,
                DEM_par,
                lookup_table,
                lt_type,
                type1,
                type2,
                coffsets,
                poly_order,
                interact_flag,
                trans_list,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_list_fitm))
        result = self._gamma_call("DIFF", "offset_list_fitm", ca)

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        if coffsets is not None:
            assert coffsets.exists(), f"{coffsets} does not exist"
            assert coffsets.stat().st_size > 0, f"{coffsets} has zero file size"

        return result

    def _validate_dem_RDC_list(
        self,
        DEM_par1: Path,
        gc_map: Path,
        MLI_par: Path,
        mask: Optional[Path],
        clist_RDC: Path,
        clist_MAP: Path,
        DEM_par2: Path,
        s_north: int,
        s_east: int,
    ) -> None:
        """

        Validate the arguments to dem_RDC_list.

        """

        assert DEM_par1.exists(), f"{DEM_par1} does not exist"
        assert DEM_par1.stat().st_size > 0, f"{DEM_par1} has zero file size"

        assert gc_map.exists(), f"{gc_map} does not exist"
        assert gc_map.stat().st_size > 0, f"{gc_map} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if mask is not None:
            assert mask.exists(), f"{mask} does not exist"
            assert mask.stat().st_size > 0, f"{mask} has zero file size"

        assert not clist_RDC.exists(), f"{clist_RDC} should _not_ exist!"

        assert not clist_MAP.exists(), f"{clist_MAP} should _not_ exist!"

        assert not DEM_par2.exists(), f"{DEM_par2} should _not_ exist!"

    def _mock_dem_RDC_list_outputs(
        self,
        DEM_par1: Path,
        gc_map: Path,
        MLI_par: Path,
        mask: Optional[Path],
        clist_RDC: Path,
        clist_MAP: Path,
        DEM_par2: Path,
        s_north: int,
        s_east: int,
    ) -> None:
        """

        Mock the program dem_RDC_list.

        """

        if clist_RDC is not None and str(clist_RDC) != "-":
            clist_RDC.touch()

        if clist_MAP is not None and str(clist_MAP) != "-":
            clist_MAP.touch()

        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

    def dem_RDC_list(
        self,
        DEM_par1: Path,
        gc_map: Path,
        MLI_par: Path,
        mask: Optional[Path],
        clist_RDC: Path,
        clist_MAP: Path,
        DEM_par2: Path,
        s_north: int,
        s_east: int,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate coordinate lists in Range-Doppler Coordinates (RDC) and DEM coordinates using a lookup table


        input parameters:
          DEM_par1   (input) DEM parameter file describing region covered by the geocoding lookup table
          gc_map     (input) geocoding lookup table containing RDC coordinates defined by DEM_par1
          MLI_par    (input) ISP image parameter file of MLI image associated with the geocoding lookup table
          mask       (input) mask file in 8-bit raster mask to exclude regions in the map geometry (enter - for none)
                     NOTE: pixels with (R,G,B)=0 are excluded from the clist_RDC and clist_MAP
          clist_RDC  (output) list of x,y pixel coordinates in the reference SLC image geometry (Range-Doppler Coordinates) (text format)
          clist_MAP  (output) list of x,y pixel coordinates in the map projection geometry (text format)
          DEM_par2   (output) DEM parameter file associated with clist_MAP
          s_north    DEM latitude, S, or northing subsampling factor for patch locations (integer >= 1) (nominal: 10)
          s_east     DEM longitude, C, or easting subsampling factor (integer >= 1) (nominal: 10)

        """

        if self.validate_inputs:
            self._validate_dem_RDC_list(
                DEM_par1,
                gc_map,
                MLI_par,
                mask,
                clist_RDC,
                clist_MAP,
                DEM_par2,
                s_north,
                s_east,
            )

        if self.mock_outputs:
            self._mock_dem_RDC_list_outputs(
                DEM_par1,
                gc_map,
                MLI_par,
                mask,
                clist_RDC,
                clist_MAP,
                DEM_par2,
                s_north,
                s_east,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dem_RDC_list))
        result = self._gamma_call("DIFF", "dem_RDC_list", ca)

        assert clist_RDC.exists(), f"{clist_RDC} does not exist"
        assert clist_RDC.stat().st_size > 0, f"{clist_RDC} has zero file size"

        assert clist_MAP.exists(), f"{clist_MAP} does not exist"
        assert clist_MAP.stat().st_size > 0, f"{clist_MAP} has zero file size"

        assert DEM_par2.exists(), f"{DEM_par2} does not exist"
        assert DEM_par2.stat().st_size > 0, f"{DEM_par2} has zero file size"

        return result

    def _validate_multi_look_geo(
        self,
        DEM_par1: Path,
        MLI: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        dtype: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to multi_look_geo.

        """

        assert DEM_par1.exists(), f"{DEM_par1} does not exist"
        assert DEM_par1.stat().st_size > 0, f"{DEM_par1} has zero file size"

        assert not MLI.exists(), f"{MLI} should _not_ exist!"

        assert not DEM_par2.exists(), f"{DEM_par2} should _not_ exist!"

    def _mock_multi_look_geo_outputs(
        self,
        DEM_par1: Path,
        MLI: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        dtype: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Mock the program multi_look_geo.

        """

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

    def multi_look_geo(
        self,
        DEM_par1: Path,
        MLI: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        dtype: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate a multi-look geocoded MLI image from a geocoded SLC or MLI image


        input parameters:
          SLC/MLI      (input) geocoded SLC or MLI image (FCOMPLEX, SCOMPLEX, or FLOAT)
          DEM_par1     (input) DEM parameter file of the input image
          MLI          (output) geocoded MLI image (FLOAT)
          DEM_par2     (output) DEM parameter file of the output image
          e_lks        number of easting looks (longitude, cross-track)
          n_lks        number of northing looks (latitude, along-track)
          dtype        input data type:
                         0: FCOMPLEX (default)
                         1: SCOMPLEX
                         2: FLOAT
          scale        scale factor for output MLI (enter - for default: 1.0)
          exp          exponent for the output MLI (enter - for default: 1.0)


        """

        if self.validate_inputs:
            self._validate_multi_look_geo(
                DEM_par1, MLI, DEM_par2, e_lks, n_lks, dtype, scale, exp
            )

        if self.mock_outputs:
            self._mock_multi_look_geo_outputs(
                DEM_par1, MLI, DEM_par2, e_lks, n_lks, dtype, scale, exp
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_look_geo))
        result = self._gamma_call("DIFF", "multi_look_geo", ca)

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        assert DEM_par2.exists(), f"{DEM_par2} does not exist"
        assert DEM_par2.stat().st_size > 0, f"{DEM_par2} has zero file size"

        return result

    def _validate_atm_mod_2d(
        self,
        diff_unw: Path,
        hgt: Path,
        cc: Optional[Path],
        DIFF_par: Path,
        mask: Path,
        model: Optional[int] = None,
        a0: Optional[Path] = None,
        a1: Optional[Path] = None,
        sigma: Optional[Path] = None,
        sigma_h: Optional[Path] = None,
        s1: Optional[Path] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        h0: Optional[int] = None,
        alpha: Optional[int] = None,
        cc_min: Optional[int] = None,
        mfrac: Optional[int] = None,
        sflg: Optional[int] = None,
        svd_tol: Optional[int] = None,
        w0: Optional[int] = None,
        w1: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to atm_mod_2d.

        """

        assert diff_unw.exists(), f"{diff_unw} does not exist"
        assert diff_unw.stat().st_size > 0, f"{diff_unw} has zero file size"

        assert hgt.exists(), f"{hgt} does not exist"
        assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        if cc is not None:
            assert cc.exists(), f"{cc} does not exist"
            assert cc.stat().st_size > 0, f"{cc} has zero file size"

        assert mask.exists(), f"{mask} does not exist"
        assert mask.stat().st_size > 0, f"{mask} has zero file size"

        if a0 is not None:
            assert not a0.exists(), f"{a0} should _not_ exist!"

        if a1 is not None:
            assert not a1.exists(), f"{a1} should _not_ exist!"

        if sigma is not None:
            assert not sigma.exists(), f"{sigma} should _not_ exist!"

        if sigma_h is not None:
            assert not sigma_h.exists(), f"{sigma_h} should _not_ exist!"

        if s1 is not None:
            assert not s1.exists(), f"{s1} should _not_ exist!"

    def _mock_atm_mod_2d_outputs(
        self,
        diff_unw: Path,
        hgt: Path,
        cc: Optional[Path],
        DIFF_par: Path,
        mask: Path,
        model: Optional[int] = None,
        a0: Optional[Path] = None,
        a1: Optional[Path] = None,
        sigma: Optional[Path] = None,
        sigma_h: Optional[Path] = None,
        s1: Optional[Path] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        h0: Optional[int] = None,
        alpha: Optional[int] = None,
        cc_min: Optional[int] = None,
        mfrac: Optional[int] = None,
        sflg: Optional[int] = None,
        svd_tol: Optional[int] = None,
        w0: Optional[int] = None,
        w1: Optional[int] = None,
    ) -> None:
        """

        Mock the program atm_mod_2d.

        """

        if not DIFF_par.exists():
            DIFF_par.touch()

        if a0 is not None and str(a0) != "-":
            a0.touch()

        if a1 is not None and str(a1) != "-":
            a1.touch()

        if sigma is not None and str(sigma) != "-":
            sigma.touch()

        if sigma_h is not None and str(sigma_h) != "-":
            sigma_h.touch()

        if s1 is not None and str(s1) != "-":
            s1.touch()

    def atm_mod_2d(
        self,
        diff_unw: Path,
        hgt: Path,
        cc: Optional[Path],
        DIFF_par: Path,
        mask: Path,
        model: Optional[int] = None,
        a0: Optional[Path] = None,
        a1: Optional[Path] = None,
        sigma: Optional[Path] = None,
        sigma_h: Optional[Path] = None,
        s1: Optional[Path] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        h0: Optional[int] = None,
        alpha: Optional[int] = None,
        cc_min: Optional[int] = None,
        mfrac: Optional[int] = None,
        sflg: Optional[int] = None,
        svd_tol: Optional[int] = None,
        w0: Optional[int] = None,
        w1: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate atmospheric phase model parameters on a 2D grid


        input parameters:
          diff_unw  (input) list of unwrapped phase interferograms including the atmospheric phase (FLOAT)
          hgt       (input) height coregistered to the interferogram (FLOAT)
          cc        (input) correlation coefficient (enter - for none) (FLOAT)
          DIFF_par  (input/output) DIFF/GEO parameter file
                    NOTE: contains patch coordinates and dimensions used to used to estimate the local atmosphere phase model
          mask      (input) 8-bit raster image (SUN raster, BMP, or TIFF format)
                    regions with (R,G,B)=0 in the mask are excluded (enter - for none)
          model     atmospheric phase model (enter - for default):
                      0: linear:      atm_phase = a0 + a1*h
                      1: power-law:   atm_phase = a0 + a1*(h0 - h)**alpha
          a0        (output) constant model parameter file (enter - for none) (FLOAT)
                    NOTE: if a0 is set to -, then a0 is not included in the phase model
          a1        (output) slope model parameter file (enter - for none) (FLOAT)
                    NOTE: if a1 is set to -, then a1 is not included in the phase model
          sigma     (output) standard deviation of the atmospheric phase model (enter - for none) (FLOAT)
          sigma_h   (output) standard deviation of the DEM height (enter - for none) (FLOAT)
          s1        (output) a1 quality measure sigma/(a1*sigma_h) (enter - for none) (FLOAT)
          rwin      range (across) patch size samples (enter - for default: 512)
          azwin     azimuth (down) patch size lines (enter - for default: 512)
          rstep     range (across) step (enter - for default: 64)
          azstep    azimuth (down) step (enter - for default: 64)
          h0        power-law model scale reference height (enter - for default: 7000.0 m)
          alpha     power-law model exponent (enter - for default: 1.350)
          cc_min    minimum correlation coefficient threshold to use a point: (enter - for default: 0.150)
          mfrac     minimum fraction of points in a patch required to evaluate coefficients: (enter - for default: 0.200
          rref      reference point range (across) samples (enter - for default: none))
          azref     reference point azimuth (down) lines (enter - for default: none)
          sflg      linear regression solver flag:
                      0: use Gauss-Jorden to solve linear regression (default)
                      1: use SVD to solve linear regression
          svd_tol   SVD tolerance threshold, singular values w[i] < svd_tol * max(w[]) are set to 0.0, (enter - for default: 1.0e-12)
          w0        2D array of the singular value w[0] for each patch (FLOAT), (enter - for default: none)
          w1        2D array of the singular value w[1] for each patch (FLOAT), (enter - for default: none)


        """

        if self.validate_inputs:
            self._validate_atm_mod_2d(
                diff_unw,
                hgt,
                cc,
                DIFF_par,
                mask,
                model,
                a0,
                a1,
                sigma,
                sigma_h,
                s1,
                rwin,
                azwin,
                rstep,
                azstep,
                h0,
                alpha,
                cc_min,
                mfrac,
                sflg,
                svd_tol,
                w0,
                w1,
            )

        if self.mock_outputs:
            self._mock_atm_mod_2d_outputs(
                diff_unw,
                hgt,
                cc,
                DIFF_par,
                mask,
                model,
                a0,
                a1,
                sigma,
                sigma_h,
                s1,
                rwin,
                azwin,
                rstep,
                azstep,
                h0,
                alpha,
                cc_min,
                mfrac,
                sflg,
                svd_tol,
                w0,
                w1,
            )

        ca = self._clean_args(locals(), inspect.signature(self.atm_mod_2d))
        result = self._gamma_call("DIFF", "atm_mod_2d", ca)

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        if a0 is not None:
            assert a0.exists(), f"{a0} does not exist"
            assert a0.stat().st_size > 0, f"{a0} has zero file size"

        if a1 is not None:
            assert a1.exists(), f"{a1} does not exist"
            assert a1.stat().st_size > 0, f"{a1} has zero file size"

        if sigma is not None:
            assert sigma.exists(), f"{sigma} does not exist"
            assert sigma.stat().st_size > 0, f"{sigma} has zero file size"

        if sigma_h is not None:
            assert sigma_h.exists(), f"{sigma_h} does not exist"
            assert sigma_h.stat().st_size > 0, f"{sigma_h} has zero file size"

        if s1 is not None:
            assert s1.exists(), f"{s1} does not exist"
            assert s1.stat().st_size > 0, f"{s1} has zero file size"

        return result

    def _validate_WSS_interp_lt(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par1: Optional[Path],
        SLC_2R: Path,
        SLC2R_par: Path,
        DIFF_par2: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to WSS_interp_lt.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        assert MLI1_par.exists(), f"{MLI1_par} does not exist"
        assert MLI1_par.stat().st_size > 0, f"{MLI1_par} has zero file size"

        assert MLI2_par.exists(), f"{MLI2_par} does not exist"
        assert MLI2_par.stat().st_size > 0, f"{MLI2_par} has zero file size"

        if DIFF_par1 is not None:
            assert DIFF_par1.exists(), f"{DIFF_par1} does not exist"
            assert DIFF_par1.stat().st_size > 0, f"{DIFF_par1} has zero file size"

        assert not SLC_2R.exists(), f"{SLC_2R} should _not_ exist!"

        assert not SLC2R_par.exists(), f"{SLC2R_par} should _not_ exist!"

        if DIFF_par2 is not None:
            assert not DIFF_par2.exists(), f"{DIFF_par2} should _not_ exist!"

    def _mock_WSS_interp_lt_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par1: Optional[Path],
        SLC_2R: Path,
        SLC2R_par: Path,
        DIFF_par2: Optional[Path] = None,
    ) -> None:
        """

        Mock the program WSS_interp_lt.

        """

        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()

        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

        if DIFF_par2 is not None and str(DIFF_par2) != "-":
            DIFF_par2.touch()

    def WSS_interp_lt(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par1: Optional[Path],
        SLC_2R: Path,
        SLC2R_par: Path,
        DIFF_par2: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ASAR Wide-Swath SLC complex image resampling via a lookup table and  2-D SINC interpolation


        input parameters:
          SLC-1         (input) ASAR Wide-Swath SLC_1 reference image
          SLC-2         (input) ASAR Wide-Swath SLC-2 image to be resampled to the geometry of the WSS SLC-1 reference image
          SLC1_par      (input) ASAR Wide-Swath SLC-1 image parameter file
          SLC2_par      (input) ASAR Wide-Swath SLC-2 image parameter file
          lookup_table  (input) lookup_table relating MLI-2 to MLI-1 created from SLC-2 and SLC-1
          MLI1_par      (input) SLC/MLI ISP image parameter file of reference MLI-1 (lookup table dimension)
          MLI2_par      (input) SLC/MLI ISP image parameter file of MLI-2 (lookup table values)
          DIFF_par1     (input) DIFF/GEO offset parameter file used for lookup table refinement MLI-1, MLI-2R (enter - for none)
          SLC-2R        (output) ASAR Wide-Swath SLC-2 resampled and co-registered to SLC-1
          SLC2R_par     (output) ASAR Wide-Swath image parameter file for the co-registered resampled image
          DIFF_par2     (output) DIFF/GEO offset parameter file for MLI-1, MLI-2 (enter - for none)


        """

        if self.validate_inputs:
            self._validate_WSS_interp_lt(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                DIFF_par1,
                SLC_2R,
                SLC2R_par,
                DIFF_par2,
            )

        if self.mock_outputs:
            self._mock_WSS_interp_lt_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                DIFF_par1,
                SLC_2R,
                SLC2R_par,
                DIFF_par2,
            )

        ca = self._clean_args(locals(), inspect.signature(self.WSS_interp_lt))
        result = self._gamma_call("DIFF", "WSS_interp_lt", ca)

        assert SLC_2R.exists(), f"{SLC_2R} does not exist"
        assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        if DIFF_par2 is not None:
            assert DIFF_par2.exists(), f"{DIFF_par2} does not exist"
            assert DIFF_par2.stat().st_size > 0, f"{DIFF_par2} has zero file size"

        return result

    def _validate_dispmap_vec2(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap1: Path,
        lv1_theta: Path,
        lv1_phi: Path,
        dispmap2: Path,
        lv2_theta: Path,
        lv2_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Path] = None,
        mode: Optional[int] = None,
        ax_north: Optional[int] = None,
        ax_east: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dispmap_vec2.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert dispmap1.exists(), f"{dispmap1} does not exist"
        assert dispmap1.stat().st_size > 0, f"{dispmap1} has zero file size"

        assert lv1_theta.exists(), f"{lv1_theta} does not exist"
        assert lv1_theta.stat().st_size > 0, f"{lv1_theta} has zero file size"

        assert lv1_phi.exists(), f"{lv1_phi} does not exist"
        assert lv1_phi.stat().st_size > 0, f"{lv1_phi} has zero file size"

        assert dispmap2.exists(), f"{dispmap2} does not exist"
        assert dispmap2.stat().st_size > 0, f"{dispmap2} has zero file size"

        assert lv2_theta.exists(), f"{lv2_theta} does not exist"
        assert lv2_theta.stat().st_size > 0, f"{lv2_theta} has zero file size"

        assert lv2_phi.exists(), f"{lv2_phi} does not exist"
        assert lv2_phi.stat().st_size > 0, f"{lv2_phi} has zero file size"

        assert not dv_norm.exists(), f"{dv_norm} should _not_ exist!"

        if dv_theta is not None:
            assert not dv_theta.exists(), f"{dv_theta} should _not_ exist!"

        if dv_phi is not None:
            assert not dv_phi.exists(), f"{dv_phi} should _not_ exist!"

        if dv_x is not None:
            assert not dv_x.exists(), f"{dv_x} should _not_ exist!"

        if dv_y is not None:
            assert not dv_y.exists(), f"{dv_y} should _not_ exist!"

        if dv_z is not None:
            assert not dv_z.exists(), f"{dv_z} should _not_ exist!"

    def _mock_dispmap_vec2_outputs(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap1: Path,
        lv1_theta: Path,
        lv1_phi: Path,
        dispmap2: Path,
        lv2_theta: Path,
        lv2_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Path] = None,
        mode: Optional[int] = None,
        ax_north: Optional[int] = None,
        ax_east: Optional[int] = None,
    ) -> None:
        """

        Mock the program dispmap_vec2.

        """

        if dv_norm is not None and str(dv_norm) != "-":
            dv_norm.touch()

        if dv_theta is not None and str(dv_theta) != "-":
            dv_theta.touch()

        if dv_phi is not None and str(dv_phi) != "-":
            dv_phi.touch()

        if dv_x is not None and str(dv_x) != "-":
            dv_x.touch()

        if dv_y is not None and str(dv_y) != "-":
            dv_y.touch()

        if dv_z is not None and str(dv_z) != "-":
            dv_z.touch()

    def dispmap_vec2(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap1: Path,
        lv1_theta: Path,
        lv1_phi: Path,
        dispmap2: Path,
        lv2_theta: Path,
        lv2_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Path] = None,
        mode: Optional[int] = None,
        ax_north: Optional[int] = None,
        ax_east: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculation of displacement vector field from 2 measured components (asc./desc.)


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          DEM         (input) DEM data file (or constant height value)
          dispmap1    (input) 1. displacement observation (along look-vector 1) (float)
          lv1_theta   (input) look-vector 1 elevation angle (file or constant value in deg.)
          lv1_phi     (input) look-vector 1 orientation angle (file or constant value in deg.)
          dispmap2    (input) 2. displacement observation (along look-vector 2) (float)
          lv2_theta   (input) look-vector 2 elevation angle (file or constant value in deg.)
          lv2_phi     (input) look-vector 2 orientation angle (file or constant value in deg.)
          dv_norm     (output) norm of 3-dim displacement vector (float)
          dv_theta    (output) elevation angle of 3-dim displacement vector (float)
          dv_phi      (output) orientation angle of 3-dim displacement vector (file of float)
          dv_x        (output) easting  component of 3-dim displacement vector (float)
          dv_y        (output) northing component of 3-dim displacement vector (float)
          dv_z        (output) vertical component of 3-dim displacement vector (float)
          mask_angle  cutoff angle in degrees between the look and normal vectors to mask inaccurate results (default=2)
          mode        displacement model mode (default=0):
                        0: displacement along terrain surface
                        1: displacement towards center axis
                        2: east-west and up-down components (north-south assumed zero)
          ax_north    displacement center axis northing/latitude
          ax_east     displacement center axis easting/longitude

          NOTE: select - to avoid creation of the corresponding output file


        """

        if self.validate_inputs:
            self._validate_dispmap_vec2(
                DEM_par,
                DEM,
                dispmap1,
                lv1_theta,
                lv1_phi,
                dispmap2,
                lv2_theta,
                lv2_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
                mode,
                ax_north,
                ax_east,
            )

        if self.mock_outputs:
            self._mock_dispmap_vec2_outputs(
                DEM_par,
                DEM,
                dispmap1,
                lv1_theta,
                lv1_phi,
                dispmap2,
                lv2_theta,
                lv2_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
                mode,
                ax_north,
                ax_east,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dispmap_vec2))
        result = self._gamma_call("DIFF", "dispmap_vec2", ca)

        assert dv_norm.exists(), f"{dv_norm} does not exist"
        assert dv_norm.stat().st_size > 0, f"{dv_norm} has zero file size"

        if dv_theta is not None:
            assert dv_theta.exists(), f"{dv_theta} does not exist"
            assert dv_theta.stat().st_size > 0, f"{dv_theta} has zero file size"

        if dv_phi is not None:
            assert dv_phi.exists(), f"{dv_phi} does not exist"
            assert dv_phi.stat().st_size > 0, f"{dv_phi} has zero file size"

        if dv_x is not None:
            assert dv_x.exists(), f"{dv_x} does not exist"
            assert dv_x.stat().st_size > 0, f"{dv_x} has zero file size"

        if dv_y is not None:
            assert dv_y.exists(), f"{dv_y} does not exist"
            assert dv_y.stat().st_size > 0, f"{dv_y} has zero file size"

        if dv_z is not None:
            assert dv_z.exists(), f"{dv_z} does not exist"
            assert dv_z.stat().st_size > 0, f"{dv_z} has zero file size"

        return result

    def _validate_diff_ls_unw(
        self,
        int_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        diff_int: Path,
        int_type: Optional[int] = None,
        ph_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to diff_ls_unw.

        """

        assert int_1.exists(), f"{int_1} does not exist"
        assert int_1.stat().st_size > 0, f"{int_1} has zero file size"

        assert unw_2.exists(), f"{unw_2} does not exist"
        assert unw_2.stat().st_size > 0, f"{unw_2} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not diff_int.exists(), f"{diff_int} should _not_ exist!"

    def _mock_diff_ls_unw_outputs(
        self,
        int_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        diff_int: Path,
        int_type: Optional[int] = None,
        ph_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program diff_ls_unw.

        """

        if diff_int is not None and str(diff_int) != "-":
            diff_int.touch()

    def diff_ls_unw(
        self,
        int_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        diff_int: Path,
        int_type: Optional[int] = None,
        ph_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Three-pass differential interferometry


        input parameters:
          int-1     (input) complex or unwrapped interferogram 1 file name
          unw-2     (input) unwrapped interferogram 2 file name
          DIFF_par  (input) interferogram/offset processing parameters
          diff_int  (output)  phase difference of interferograms: (int-1 - scaled(unw-2)) file name
          int_type  int-1 type: 0: unwrapped phase, 1:complex interferogram (default: 0)
          ph_flag   phase conjugation flag: 0:normal, 1:conjugate phase (default: 0)


        """

        if self.validate_inputs:
            self._validate_diff_ls_unw(
                int_1, unw_2, DIFF_par, diff_int, int_type, ph_flag
            )

        if self.mock_outputs:
            self._mock_diff_ls_unw_outputs(
                int_1, unw_2, DIFF_par, diff_int, int_type, ph_flag
            )

        ca = self._clean_args(locals(), inspect.signature(self.diff_ls_unw))
        result = self._gamma_call("DIFF", "diff_ls_unw", ca)

        assert diff_int.exists(), f"{diff_int} does not exist"
        assert diff_int.stat().st_size > 0, f"{diff_int} has zero file size"

        return result

    def _validate_offset_pwr_list(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        clist_RDC: Path,
        clist_MAP: Path,
        offs: Path,
        ccp: Path,
        nx: Path,
        ny: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwr_list.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert clist_RDC.exists(), f"{clist_RDC} does not exist"
        assert clist_RDC.stat().st_size > 0, f"{clist_RDC} has zero file size"

        assert clist_MAP.exists(), f"{clist_MAP} does not exist"
        assert clist_MAP.stat().st_size > 0, f"{clist_MAP} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not ccp.exists(), f"{ccp} should _not_ exist!"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

        if ccs is not None:
            assert not ccs.exists(), f"{ccs} should _not_ exist!"

    def _mock_offset_pwr_list_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        clist_RDC: Path,
        clist_MAP: Path,
        offs: Path,
        ccp: Path,
        nx: Path,
        ny: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Mock the program offset_pwr_list.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if ccp is not None and str(ccp) != "-":
            ccp.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_list(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        clist_RDC: Path,
        clist_MAP: Path,
        offs: Path,
        ccp: Path,
        nx: Path,
        ny: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offsets between SLC images at positions specified by a list using intensity cross-correlation


        input parameters:
          SLC-1      (input) single-look complex image 1 (reference)
          SLC-2      (input) single-look complex image 2
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2_par   (input) SLC-2 ISP image parameter file
          OFF_par    (input) ISP offset/interferogram parameter file
          clist_RDC  (input) list of x,y pixel coordinates in the reference SLC image geometry (Range-Doppler Coordinates) (text format)
          clist_MAP  (input) list of x,y pixel coordinates in the map projection geometry (text format)
          offs       (output) offset estimate 2D map (fcomplex)
          ccp        (output) cross-correlation of each patch (0.0->1.0) in map coordinates (float)
          nx         width of 2D offset map in MAP geometry
          ny         height of 2D offset map in MAP geometry
          rwin       range patch size (range pixels, enter - for default from offset parameter file))
          azwin      azimuth patch size (azimuth lines, enter - for default from offset parameter file))
          offsets    (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr      SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          thres      cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          bw_frac    bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          deramp     deramp SLC phase flag (enter - for default)
          int_filt   intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag      print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg     plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs        (output) cross-correlation standard deviation of each patch in map coordinates (float)

        NOTE: ScanSAR and TOPS data need to be previously deramped


        """

        if self.validate_inputs:
            self._validate_offset_pwr_list(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                clist_RDC,
                clist_MAP,
                offs,
                ccp,
                nx,
                ny,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        if self.mock_outputs:
            self._mock_offset_pwr_list_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                clist_RDC,
                clist_MAP,
                offs,
                ccp,
                nx,
                ny,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_pwr_list))
        result = self._gamma_call("DIFF", "offset_pwr_list", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        if ccs is not None:
            assert ccs.exists(), f"{ccs} does not exist"
            assert ccs.stat().st_size > 0, f"{ccs} has zero file size"

        return result

    def _validate_geocode(
        self,
        lookup_table: Path,
        data_in: Path,
        width_in: int,
        data_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        rad_max: Optional[int] = None,
        nintr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to geocode.

        """

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_geocode_outputs(
        self,
        lookup_table: Path,
        data_in: Path,
        width_in: int,
        data_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        rad_max: Optional[int] = None,
        nintr: Optional[int] = None,
    ) -> None:
        """

        Mock the program geocode.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def geocode(
        self,
        lookup_table: Path,
        data_in: Path,
        width_in: int,
        data_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        rad_max: Optional[int] = None,
        nintr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Forward geocoding transformation using a lookup table


        input parameters:
          lookup_table  (input) lookup table containing pairs of real-valued output data coordinates
          data_in       (input) data file (format as specified by format_flag parameter)
          width_in      width of input data file and gc_map lookup table
          data_out      (output) output data file
          width_out     width of output data file
          nlines_out    number of lines for the output data file (enter - or 0 for default: all lines)
          interp_mode   resampling interpolation mode (enter - for default)
                          0: 1/dist (default)
                          1: nearest neighbor
                          2: SQR(1/dist)
                          3: constant
                          4: Gauss weighting
          dtype        input/output data type (enter - for default)
                          0: FLOAT (default)
                          1: FCOMPLEX
                          2: Sun/BMP/TIFF 8 or 24-bit raster image
                          3: UNSIGNED CHAR
                          4: SHORT
                          5: SCOMPLEX
                          6: DOUBLE
          lr_in         input  Sun/BMP/TIFF raster image flipped left/right (enter - for default: 1: not flipped (default), -1: flipped)
          lr_out        output Sun/BMP/TIFF raster image flipped left/right (enter - for default: 1: not flipped (default), -1: flipped)
          n_ovr         interpolation oversampling factor (enter - for default: 2)
          rad_max       maximum interpolation search radius (enter - for default 4*n_ovr: 8)
          nintr         number of points required for interpolation when not nearest neighbor (enter - for default: 4)


        """

        if self.validate_inputs:
            self._validate_geocode(
                lookup_table,
                data_in,
                width_in,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                lr_in,
                lr_out,
                n_ovr,
                rad_max,
                nintr,
            )

        if self.mock_outputs:
            self._mock_geocode_outputs(
                lookup_table,
                data_in,
                width_in,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                lr_in,
                lr_out,
                n_ovr,
                rad_max,
                nintr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.geocode))
        result = self._gamma_call("DIFF", "geocode", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_par_TX_geo(
        self,
        annotation_XML: Path,
        GeoTIFF: Path,
        MLI_par: Path,
        DEM_par: Path,
        GEO: Path,
        pol: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_TX_geo.

        """

        assert annotation_XML.exists(), f"{annotation_XML} does not exist"
        assert annotation_XML.stat().st_size > 0, f"{annotation_XML} has zero file size"

        assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
        assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        assert not DEM_par.exists(), f"{DEM_par} should _not_ exist!"

        assert not GEO.exists(), f"{GEO} should _not_ exist!"

    def _mock_par_TX_geo_outputs(
        self,
        annotation_XML: Path,
        GeoTIFF: Path,
        MLI_par: Path,
        DEM_par: Path,
        GEO: Path,
        pol: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_TX_geo.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()

        if GEO is not None and str(GEO) != "-":
            GEO.touch()

    def par_TX_geo(
        self,
        annotation_XML: Path,
        GeoTIFF: Path,
        MLI_par: Path,
        DEM_par: Path,
        GEO: Path,
        pol: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate DEM parameter and image files for Terrasar-X GEC and EEC data


        input parameters:
          annotation_XML (input) Terrasar-X product annotation XML file
          GeoTIFF        (input) image data file in GeoTIFF format
          MLI_par        (output) ISP image parameter file (example: yyyymmdd.mli.par)
          DEM_par        (output) DIFF/GEO DEM parameter file (example: yyyymmdd.dem_par)
          GEO            (output) geocoded and calibrated image data file (example: yyyymmdd.geo)
          pol            polarisation HH, HV, VH, VV (default: first polarisation found in the annotation_XML)


        """

        if self.validate_inputs:
            self._validate_par_TX_geo(annotation_XML, GeoTIFF, MLI_par, DEM_par, GEO, pol)

        if self.mock_outputs:
            self._mock_par_TX_geo_outputs(
                annotation_XML, GeoTIFF, MLI_par, DEM_par, GEO, pol
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_TX_geo))
        result = self._gamma_call("DIFF", "par_TX_geo", ca)

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert GEO.exists(), f"{GEO} does not exist"
        assert GEO.stat().st_size > 0, f"{GEO} has zero file size"

        return result

    def _validate_data2xyz(
        self, DEM_par: Path, data: Path, data_xyz: Path, dflg: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to data2xyz.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        assert not data_xyz.exists(), f"{data_xyz} should _not_ exist!"

    def _mock_data2xyz_outputs(
        self, DEM_par: Path, data: Path, data_xyz: Path, dflg: Optional[int] = None
    ) -> None:
        """

        Mock the program data2xyz.

        """

        if data_xyz is not None and str(data_xyz) != "-":
            data_xyz.touch()

    def data2xyz(
        self, DEM_par: Path, data: Path, data_xyz: Path, dflg: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Convert geocoded float data to triplets of float: (northing, easting, data_value) as binary or text format

        input parameters:
          DEM_par  (input) DEM parameter file
          data     (input) float format data with same dimensions as given in the DEM_par
          data_xyz (output) triplets (northing, easting, data_value) in 8-byte double-precision or text format
          dflg     output format:
                     0: little-endian double precision (default)
                     1: text, comma separated values (csv)

        """

        if self.validate_inputs:
            self._validate_data2xyz(DEM_par, data, data_xyz, dflg)

        if self.mock_outputs:
            self._mock_data2xyz_outputs(DEM_par, data, data_xyz, dflg)

        ca = self._clean_args(locals(), inspect.signature(self.data2xyz))
        result = self._gamma_call("DIFF", "data2xyz", ca)

        assert data_xyz.exists(), f"{data_xyz} does not exist"
        assert data_xyz.stat().st_size > 0, f"{data_xyz} has zero file size"

        return result

    def _validate_multi_cpx(
        self,
        data_in: Path,
        PAR_in: Path,
        data_out: Path,
        PAR_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to multi_cpx.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert PAR_in.exists(), f"{PAR_in} does not exist"
        assert PAR_in.stat().st_size > 0, f"{PAR_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_multi_cpx_outputs(
        self,
        data_in: Path,
        PAR_in: Path,
        data_out: Path,
        PAR_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        """

        Mock the program multi_cpx.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

        if not PAR_out.exists():
            PAR_out.touch()

    def multi_cpx(
        self,
        data_in: Path,
        PAR_in: Path,
        data_out: Path,
        PAR_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate multi-look averaged or interpolated 2D image (complex data)

        input parameters:
          data_in      (input) input complex image file (FCOMPLEX or SCOMPLEX)
          PAR_in       (input) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for input image
          data_out     (output) output multi-look or interpolated complex data file (FCOMPLEX or SCOMPLEX)
          PAR_out      (input/output) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for output, used as input if already exists
          rlks         number of range looks, values < -1 interpreted as an image oversampling factor (enter - for default: 1)
          azlks        number of azimuth looks, values < -1 interpreted as an image oversampling factor (enter - for default: 1)
          loff         line offset to starting line (enter - for default: 0)
          nlines       number of lines (enter - or 0 for default: to end of file)
          roff         offset to starting range sample (enter - for default: 0)
          nsamp        number of range samples to extract (enter - or 0 for default: to end of line)


        """

        if self.validate_inputs:
            self._validate_multi_cpx(
                data_in, PAR_in, data_out, PAR_out, rlks, azlks, loff, nlines, roff, nsamp
            )

        if self.mock_outputs:
            self._mock_multi_cpx_outputs(
                data_in, PAR_in, data_out, PAR_out, rlks, azlks, loff, nlines, roff, nsamp
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_cpx))
        result = self._gamma_call("DIFF", "multi_cpx", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        assert PAR_out.exists(), f"{PAR_out} does not exist"
        assert PAR_out.stat().st_size > 0, f"{PAR_out} has zero file size"

        return result

    def _validate_ScanSAR_burst_diff_intf(
        self,
        SLC1_tab: Path,
        SLC2R_tab: Path,
        SIM_tab: Path,
        DIFF_tab: Path,
        SLCR_tab: Optional[Path] = None,
        DIFF_dir: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ScanSAR_burst_diff_intf.

        """

        assert SLC1_tab.exists(), f"{SLC1_tab} does not exist"
        assert SLC1_tab.stat().st_size > 0, f"{SLC1_tab} has zero file size"

        self._check_tab_file(SLC1_tab, "SLC1_tab")

        assert SLC2R_tab.exists(), f"{SLC2R_tab} does not exist"
        assert SLC2R_tab.stat().st_size > 0, f"{SLC2R_tab} has zero file size"

        self._check_tab_file(SLC2R_tab, "SLC2R_tab")

        assert SIM_tab.exists(), f"{SIM_tab} does not exist"
        assert SIM_tab.stat().st_size > 0, f"{SIM_tab} has zero file size"

        self._check_tab_file(SIM_tab, "SIM_tab")

        if SLCR_tab is not None:
            assert SLCR_tab.exists(), f"{SLCR_tab} does not exist"
            assert SLCR_tab.stat().st_size > 0, f"{SLCR_tab} has zero file size"

    def _mock_ScanSAR_burst_diff_intf_outputs(
        self,
        SLC1_tab: Path,
        SLC2R_tab: Path,
        SIM_tab: Path,
        DIFF_tab: Path,
        SLCR_tab: Optional[Path] = None,
        DIFF_dir: Optional[int] = None,
    ) -> None:
        """

        Mock the program ScanSAR_burst_diff_intf.

        """

        if not DIFF_tab.exists():
            DIFF_tab.touch()

    def ScanSAR_burst_diff_intf(
        self,
        SLC1_tab: Path,
        SLC2R_tab: Path,
        SIM_tab: Path,
        DIFF_tab: Path,
        SLCR_tab: Optional[Path] = None,
        DIFF_dir: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate Differential Interferogram bursts from SLC ScanSAR data (Sentinel-1, RCM, and TSX)


        input parameters:
          SLC1_tab    (input) 3 column list of the reference ScanSAR SLC swaths listed in order from near to far range
                        SLC1_tab line entries:  SLC  SLC_par  TOPS_par
          SLC2R_tab   (input) 3 column list of ScanSAR SLC swaths listed in order from near to far range, coregistered with SLC1
                        SLC2R_tab line entries:  SLC  SLC_par  TOPS_par
          SIM_tab     (input) 3 column list of simulated multilook interferometric phase in burst format listed in order from near to far range
                        SIM_tab line entries:  SIM_UNW   MLI_par  TOPS_par
          DIFF_tab    (input/output) 3 column list of the DIFF swaths listed in order from near to far range
                        DIFF_tab line entries:  DIFF  MLI_par  TOPS_par
                      NOTES: 1. If the DIFF_tab does not yet exist, the file entries will be created with names derived from the SLC1_tab and SLC2R_tab entries
                             2. The DIFF data are FCOMPLEX format as documented in the MLI_par (Multi-Look Interferogram), and also in the TOPS_par
          SLCR_tab    (input) 3 column list of the scene used for coregistration of SLC1 and SLC2 with the swaths, listed in order from near to far range (enter - for none)
                        SLCR_tab line entries:  SLC  SLC_par  TOPS_par
                      NOTE: This is is only necessary if SLC1 is not the scene used for the coregistration of SLC2R with SLC1
          DIFF_dir    directory for output burst differential interferogram data, ignored if the DIFF_tab already exists (default: current directory)


        """

        if self.validate_inputs:
            self._validate_ScanSAR_burst_diff_intf(
                SLC1_tab, SLC2R_tab, SIM_tab, DIFF_tab, SLCR_tab, DIFF_dir
            )

        if self.mock_outputs:
            self._mock_ScanSAR_burst_diff_intf_outputs(
                SLC1_tab, SLC2R_tab, SIM_tab, DIFF_tab, SLCR_tab, DIFF_dir
            )

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_burst_diff_intf))
        result = self._gamma_call("DIFF", "ScanSAR_burst_diff_intf", ca)

        assert DIFF_tab.exists(), f"{DIFF_tab} does not exist"
        assert DIFF_tab.stat().st_size > 0, f"{DIFF_tab} has zero file size"

        return result

    def _validate_dem_xyz(self, DEM_par: Path, DEM: Path, DEM_XYZ: Path) -> None:
        """

        Validate the arguments to dem_xyz.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert not DEM_XYZ.exists(), f"{DEM_XYZ} should _not_ exist!"

    def _mock_dem_xyz_outputs(self, DEM_par: Path, DEM: Path, DEM_XYZ: Path) -> None:
        """

        Mock the program dem_xyz.

        """

        if DEM_XYZ is not None and str(DEM_XYZ) != "-":
            DEM_XYZ.touch()

    def dem_xyz(
        self, DEM_par: Path, DEM: Path, DEM_XYZ: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        DEM transformation to Cartesian XYZ coordinates

        input parameters:
          DEM_par  (input) DEM parameter file DEM
          DEM      (input) input DEM file or constant height value
          DEM_XYZ  (output) DEM samples in Cartesian XYZ coordinates (float)

        """

        if self.validate_inputs:
            self._validate_dem_xyz(DEM_par, DEM, DEM_XYZ)

        if self.mock_outputs:
            self._mock_dem_xyz_outputs(DEM_par, DEM, DEM_XYZ)

        ca = self._clean_args(locals(), inspect.signature(self.dem_xyz))
        result = self._gamma_call("DIFF", "dem_xyz", ca)

        assert DEM_XYZ.exists(), f"{DEM_XYZ} does not exist"
        assert DEM_XYZ.stat().st_size > 0, f"{DEM_XYZ} has zero file size"

        return result

    def _validate_look_vector(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Path,
        DEM: Path,
        lv_theta: Path,
        lv_phi: Path,
    ) -> None:
        """

        Validate the arguments to look_vector.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert not lv_theta.exists(), f"{lv_theta} should _not_ exist!"

        assert not lv_phi.exists(), f"{lv_phi} should _not_ exist!"

    def _mock_look_vector_outputs(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Path,
        DEM: Path,
        lv_theta: Path,
        lv_phi: Path,
    ) -> None:
        """

        Mock the program look_vector.

        """

        if lv_theta is not None and str(lv_theta) != "-":
            lv_theta.touch()

        if lv_phi is not None and str(lv_phi) != "-":
            lv_phi.touch()

    def look_vector(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Path,
        DEM: Path,
        lv_theta: Path,
        lv_phi: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate SAR look-vector orientation and elevation angles in map geometry


        input parameters:
          SLC_par   (input) ISP SLC or MLI image parameter file (slant range geometry
          OFF_par   (input) ISP offset/interferogram parameter file (enter - for SLC or MLI data)
          DEM_par   (input) DEM/MAP parameter file
          DEM       (input) DEM data file or constant height value
          lv_theta  (output) SAR look vector elevation angle at each map pixel
                      lv_theta: PI/2 -> up  -PI/2 -> down
                      The elevation angle is measured between the surface and the look vector pointing at the radar
          lv_phi    (output) SAR look vector orientation angle at each map pixel
                      lv_phi: 0 -> East  PI/2 -> North


        """

        if self.validate_inputs:
            self._validate_look_vector(SLC_par, OFF_par, DEM_par, DEM, lv_theta, lv_phi)

        if self.mock_outputs:
            self._mock_look_vector_outputs(
                SLC_par, OFF_par, DEM_par, DEM, lv_theta, lv_phi
            )

        ca = self._clean_args(locals(), inspect.signature(self.look_vector))
        result = self._gamma_call("DIFF", "look_vector", ca)

        assert lv_theta.exists(), f"{lv_theta} does not exist"
        assert lv_theta.stat().st_size > 0, f"{lv_theta} has zero file size"

        assert lv_phi.exists(), f"{lv_phi} does not exist"
        assert lv_phi.stat().st_size > 0, f"{lv_phi} has zero file size"

        return result

    def _validate_create_dem_par(
        self,
        DEM_par: Path,
        SLC_par: Optional[Path] = None,
        terra_alt: Optional[int] = None,
        delta_y: Optional[int] = None,
        delta_x: Optional[int] = None,
        EPSG: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to create_dem_par.

        """

        if SLC_par is not None:
            assert SLC_par.exists(), f"{SLC_par} does not exist"
            assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

    def _mock_create_dem_par_outputs(
        self,
        DEM_par: Path,
        SLC_par: Optional[Path] = None,
        terra_alt: Optional[int] = None,
        delta_y: Optional[int] = None,
        delta_x: Optional[int] = None,
        EPSG: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program create_dem_par.

        """

        if not DEM_par.exists():
            DEM_par.touch()

    def create_dem_par(
        self,
        DEM_par: Path,
        SLC_par: Optional[Path] = None,
        terra_alt: Optional[int] = None,
        delta_y: Optional[int] = None,
        delta_x: Optional[int] = None,
        EPSG: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DEM/MAP parameter file creation/modification


        input parameters:
          DEM_par    (input/output) DIFF/GEO DEM parameter file
          SLC_par    (input) ISP SLC or MLI image parameter file automatic calculation of DEM bounds (enter - for none)
          terra_alt  nominal terrain altitude used to calculate bounds of the radar image (enter - for default: 0.0 m)
                       ignored when no SLC_par is provided
          delta_y    DEM y line spacing for new DEM_par file (enter - for default)
                       geographical coordinates (EQA projection latitude) default: -2.777778e-04 deg.
                       all other map projections default: -25.0000 m.
          delta_x    DEM x sample spacing for new DEM_par file (enter - for default)
                       geographical coordinates (EQA projection longitude) default: 2.777778e-04 deg.
                       all other map projections default: 25.0000 m.
          EPSG       EPSG number of the geographical coordinate system or map projection (enter - for none)
                       EPSG numbers can be retrieved from the http://epsg.io database. EPSG number for WGS84 lat/lon: 4326
          iflg       interactive mode flag (enter - for default)
                       0: non-interactive (requires an existing <DEM_par> or an [EPSG] number)
                       1: interactive (default)
                       2: non-interactive, grid-aligned (pixel center) (requires an [SLC_par], and an existing <DEM_par> or an [EPSG] number)
                       3: non-interactive, grid-aligned (pixel edge) (requires an [SLC_par], and an existing <DEM_par> or an [EPSG] number)


        """

        if self.validate_inputs:
            self._validate_create_dem_par(
                DEM_par, SLC_par, terra_alt, delta_y, delta_x, EPSG, iflg
            )

        if self.mock_outputs:
            self._mock_create_dem_par_outputs(
                DEM_par, SLC_par, terra_alt, delta_y, delta_x, EPSG, iflg
            )

        ca = self._clean_args(locals(), inspect.signature(self.create_dem_par))
        result = self._gamma_call("DIFF", "create_dem_par", ca)

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        return result

    def _validate_atm_sim_2d(
        self,
        DIFF_par: Path,
        hgt: Optional[Path],
        a0: Optional[Path],
        a1: Optional[Path],
        atm_phase: Path,
        mask: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to atm_sim_2d.

        """

        if hgt is not None:
            assert hgt.exists(), f"{hgt} does not exist"
            assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        if a0 is not None:
            assert a0.exists(), f"{a0} does not exist"
            assert a0.stat().st_size > 0, f"{a0} has zero file size"

        if a1 is not None:
            assert a1.exists(), f"{a1} does not exist"
            assert a1.stat().st_size > 0, f"{a1} has zero file size"

        assert not atm_phase.exists(), f"{atm_phase} should _not_ exist!"

        if mask is not None:
            assert mask.exists(), f"{mask} does not exist"
            assert mask.stat().st_size > 0, f"{mask} has zero file size"

    def _mock_atm_sim_2d_outputs(
        self,
        DIFF_par: Path,
        hgt: Optional[Path],
        a0: Optional[Path],
        a1: Optional[Path],
        atm_phase: Path,
        mask: Optional[Path] = None,
    ) -> None:
        """

        Mock the program atm_sim_2d.

        """

        if not DIFF_par.exists():
            DIFF_par.touch()

        if atm_phase is not None and str(atm_phase) != "-":
            atm_phase.touch()

    def atm_sim_2d(
        self,
        DIFF_par: Path,
        hgt: Optional[Path],
        a0: Optional[Path],
        a1: Optional[Path],
        atm_phase: Path,
        mask: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Simulate atmospheric phase based on a 2D grid of model parameters


        input parameters:
          DIFF_par   (input/output) DIFF/GEO parameter file
          hgt        (input) height coregistered to the interferogram (enter - for none) (FLOAT)
          a0         (input) constant phase model parameter file (enter - for none) (FLOAT)
          a1         (input) slope phase model parameter file (enter - for none) (FLOAT)
          atm_phase  (output) simulated atmospheric phase (FLOAT)
          mask       (input) 8-bit raster image (SUN raster, BMP, or TIFF format)
                     regions with (R,G,B)=0 in the mask are set to 0.0 in the output phase (enter - for none)

        """

        if self.validate_inputs:
            self._validate_atm_sim_2d(DIFF_par, hgt, a0, a1, atm_phase, mask)

        if self.mock_outputs:
            self._mock_atm_sim_2d_outputs(DIFF_par, hgt, a0, a1, atm_phase, mask)

        ca = self._clean_args(locals(), inspect.signature(self.atm_sim_2d))
        result = self._gamma_call("DIFF", "atm_sim_2d", ca)

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert atm_phase.exists(), f"{atm_phase} does not exist"
        assert atm_phase.stat().st_size > 0, f"{atm_phase} has zero file size"

        return result

    def _validate_dem_x_y_z(
        self,
        DEM_par: Path,
        DEM: Path,
        DEM_X: Path,
        DEM_Y: Path,
        DEM_Z: Path,
        format_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dem_x_y_z.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert not DEM_X.exists(), f"{DEM_X} should _not_ exist!"

        assert not DEM_Y.exists(), f"{DEM_Y} should _not_ exist!"

        assert not DEM_Z.exists(), f"{DEM_Z} should _not_ exist!"

    def _mock_dem_x_y_z_outputs(
        self,
        DEM_par: Path,
        DEM: Path,
        DEM_X: Path,
        DEM_Y: Path,
        DEM_Z: Path,
        format_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program dem_x_y_z.

        """

        if DEM_X is not None and str(DEM_X) != "-":
            DEM_X.touch()

        if DEM_Y is not None and str(DEM_Y) != "-":
            DEM_Y.touch()

        if DEM_Z is not None and str(DEM_Z) != "-":
            DEM_Z.touch()

    def dem_x_y_z(
        self,
        DEM_par: Path,
        DEM: Path,
        DEM_X: Path,
        DEM_Y: Path,
        DEM_Z: Path,
        format_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DEM transformation to WGS84 Cartesian X, Y, and Z coordinates (3 files)

        input parameters:
          DEM_par      (input) DEM parameter file
          DEM          (input) DEM file or constant height value
          DEM_X        (output) X coordinates of grid points of the DEM
          DEM_Y        (output) Y coordinates of grid points of the DEM
          DEM_Z        (output) Z coordinates of grid points of the DEM
          format_flag   output data format
                          0: FLOAT (default)
                          1: DOUBLE

        """

        if self.validate_inputs:
            self._validate_dem_x_y_z(DEM_par, DEM, DEM_X, DEM_Y, DEM_Z, format_flag)

        if self.mock_outputs:
            self._mock_dem_x_y_z_outputs(DEM_par, DEM, DEM_X, DEM_Y, DEM_Z, format_flag)

        ca = self._clean_args(locals(), inspect.signature(self.dem_x_y_z))
        result = self._gamma_call("DIFF", "dem_x_y_z", ca)

        assert DEM_X.exists(), f"{DEM_X} does not exist"
        assert DEM_X.stat().st_size > 0, f"{DEM_X} has zero file size"

        assert DEM_Y.exists(), f"{DEM_Y} does not exist"
        assert DEM_Y.stat().st_size > 0, f"{DEM_Y} has zero file size"

        assert DEM_Z.exists(), f"{DEM_Z} does not exist"
        assert DEM_Z.stat().st_size > 0, f"{DEM_Z} has zero file size"

        return result

    def _validate_SLC_intf_geo2(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Optional[Path],
        MLI_1: Optional[Path],
        MLI_2: Optional[Path],
        CC: Optional[Path],
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_intf_geo2.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        if interf is not None:
            assert not interf.exists(), f"{interf} should _not_ exist!"

        if MLI_1 is not None:
            assert not MLI_1.exists(), f"{MLI_1} should _not_ exist!"

        if MLI_2 is not None:
            assert not MLI_2.exists(), f"{MLI_2} should _not_ exist!"

        if CC is not None:
            assert not CC.exists(), f"{CC} should _not_ exist!"

        assert not DEM_par2.exists(), f"{DEM_par2} should _not_ exist!"

        if sim_phase is not None:
            assert sim_phase.exists(), f"{sim_phase} does not exist"
            assert sim_phase.stat().st_size > 0, f"{sim_phase} has zero file size"

    def _mock_SLC_intf_geo2_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Optional[Path],
        MLI_1: Optional[Path],
        MLI_2: Optional[Path],
        CC: Optional[Path],
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_intf_geo2.

        """

        if interf is not None and str(interf) != "-":
            interf.touch()

        if MLI_1 is not None and str(MLI_1) != "-":
            MLI_1.touch()

        if MLI_2 is not None and str(MLI_2) != "-":
            MLI_2.touch()

        if CC is not None and str(CC) != "-":
            CC.touch()

        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

    def SLC_intf_geo2(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Optional[Path],
        MLI_1: Optional[Path],
        MLI_2: Optional[Path],
        CC: Optional[Path],
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate a geocoded differential interferogram and MLI images from geocoded SLCs with separate averaging window dimensions and decimation factors


        input parameters:
          SLC-1     (input) geocoded single-look complex image (SCOMPLEX or FCOMPLEX)
          SLC-2     (input) geocoded single-look complex image 2, coregistered to SLC-1 (same format as SLC-1)
          DEM_par   (input) SLC DEM parameter file
          interf    (output) multi-look interferogram from SLC-1 and SLC-2 (enter - for none)
          MLI-1     (output) multi-look intensity image from SLC-1 (enter - for none)
          MLI-2     (output) multi-look intensity image from SLC-2 (enter - for none)
          CC        (output) interferometric correlation magnitude of SLC-1 and SLC-2R (enter - for none)
          DEM_par2  (output) DEM parameter file for the output interferogram, correlation, and MLI files
          e_dec     easting decimation factor (int)
          n_dec     northing decimation factor (int)
          e_win     easting averaging window width (int) (enter - for default: e_dec)
          n_win     northing averaging window height (int)(enter - for default: n_dec)
          wflg      window weighting function (enter - for default):
                      0: rectangular (default)
                      1: Kaiser
                      2: circular Gaussian
          n_ovr     oversampling factor 1 -> 2 (enter - for default: 1)
          sim_phase (input) geocoded simulated interferometric phase, coregistered to SLC-1 (FLOAT, enter - for none)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 7)
          beta      Gaussian or Kaiser window parameter (enter - for default: 2.0)


        """

        if self.validate_inputs:
            self._validate_SLC_intf_geo2(
                SLC_1,
                SLC_2,
                DEM_par,
                interf,
                MLI_1,
                MLI_2,
                CC,
                DEM_par2,
                e_dec,
                n_dec,
                e_win,
                n_win,
                wflg,
                n_ovr,
                sim_phase,
                lanczos,
                beta,
            )

        if self.mock_outputs:
            self._mock_SLC_intf_geo2_outputs(
                SLC_1,
                SLC_2,
                DEM_par,
                interf,
                MLI_1,
                MLI_2,
                CC,
                DEM_par2,
                e_dec,
                n_dec,
                e_win,
                n_win,
                wflg,
                n_ovr,
                sim_phase,
                lanczos,
                beta,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_intf_geo2))
        result = self._gamma_call("DIFF", "SLC_intf_geo2", ca)

        if interf is not None:
            assert interf.exists(), f"{interf} does not exist"
            assert interf.stat().st_size > 0, f"{interf} has zero file size"

        if MLI_1 is not None:
            assert MLI_1.exists(), f"{MLI_1} does not exist"
            assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        if MLI_2 is not None:
            assert MLI_2.exists(), f"{MLI_2} does not exist"
            assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

        if CC is not None:
            assert CC.exists(), f"{CC} does not exist"
            assert CC.stat().st_size > 0, f"{CC} has zero file size"

        assert DEM_par2.exists(), f"{DEM_par2} does not exist"
        assert DEM_par2.stat().st_size > 0, f"{DEM_par2} has zero file size"

        return result

    def _validate_ras_clist(
        self,
        clist: Path,
        ras_in: Path,
        ras_out: Path,
        xsf: Optional[Path] = None,
        ysf: Optional[Path] = None,
        r: Optional[int] = None,
        g: Optional[int] = None,
        b: Optional[int] = None,
        xs: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras_clist.

        """

        assert clist.exists(), f"{clist} does not exist"
        assert clist.stat().st_size > 0, f"{clist} has zero file size"

        assert ras_in.exists(), f"{ras_in} does not exist"
        assert ras_in.stat().st_size > 0, f"{ras_in} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

    def _mock_ras_clist_outputs(
        self,
        clist: Path,
        ras_in: Path,
        ras_out: Path,
        xsf: Optional[Path] = None,
        ysf: Optional[Path] = None,
        r: Optional[int] = None,
        g: Optional[int] = None,
        b: Optional[int] = None,
        xs: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras_clist.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_clist(
        self,
        clist: Path,
        ras_in: Path,
        ras_out: Path,
        xsf: Optional[Path] = None,
        ysf: Optional[Path] = None,
        r: Optional[int] = None,
        g: Optional[int] = None,
        b: Optional[int] = None,
        xs: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DIFF Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/ras_clist.c
        Draw point list locations on a SUN/BMP raster image


        input parameters:
          clist    (input) list of x,y pixel coordinates (text format)
          ras_in   (input) raster image (SUN/BMP/TIFF format)
          ras_out  (output) raster image with crosses drawn at points (SUN/BMP/TIFF format)
          xsf      number of range looks for the raster image relative to the SLC geometry (default: 1.0)
          ysf      number azimuth looks for the raster image relative to the SLC geometry (default: 1.0)
          r        line color value red   (0 --> 255) default: 255
          g        line color value green (0 --> 255) default: 255
          b        line color value blue  (0 --> 255) default: 0
          xs       size of cross in pixels, set to 1 for single points (default: 3)
          zflg     zero image flag (default=0:retain image values  1:set all image values to 0 except crosses)

        """

        if self.validate_inputs:
            self._validate_ras_clist(clist, ras_in, ras_out, xsf, ysf, r, g, b, xs, zflg)

        if self.mock_outputs:
            self._mock_ras_clist_outputs(
                clist, ras_in, ras_out, xsf, ysf, r, g, b, xs, zflg
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras_clist))
        result = self._gamma_call("DIFF", "ras_clist", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_dispmap_sim(
        self,
        LV: Path,
        DEM_par: Path,
        disp_east: Path,
        disp_north: Path,
        disp_up: Path,
        disp_LOS: Path,
    ) -> None:
        """

        Validate the arguments to dispmap_sim.

        """

        assert LV.exists(), f"{LV} does not exist"
        assert LV.stat().st_size > 0, f"{LV} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert disp_east.exists(), f"{disp_east} does not exist"
        assert disp_east.stat().st_size > 0, f"{disp_east} has zero file size"

        assert disp_north.exists(), f"{disp_north} does not exist"
        assert disp_north.stat().st_size > 0, f"{disp_north} has zero file size"

        assert disp_up.exists(), f"{disp_up} does not exist"
        assert disp_up.stat().st_size > 0, f"{disp_up} has zero file size"

        assert not disp_LOS.exists(), f"{disp_LOS} should _not_ exist!"

    def _mock_dispmap_sim_outputs(
        self,
        LV: Path,
        DEM_par: Path,
        disp_east: Path,
        disp_north: Path,
        disp_up: Path,
        disp_LOS: Path,
    ) -> None:
        """

        Mock the program dispmap_sim.

        """

        if disp_LOS is not None and str(disp_LOS) != "-":
            disp_LOS.touch()

    def dispmap_sim(
        self,
        LV: Path,
        DEM_par: Path,
        disp_east: Path,
        disp_north: Path,
        disp_up: Path,
        disp_LOS: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DIFF Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/dispmap_sim
        Calculate radar LOS displacement given ENU displacement and the radar look vectors for each point in the DEM geometry


        input parameters:
          LV          (input) look vector in East, North, Up (ENU) coordinates for each map grid position
          DEM_par     (input) DEM parameter file describing the map geometry
          disp_east   (input) displacement in the East direction for each map grid position
          disp_north  (input) displacement in the North direction for each map grid position
          disp_up     (input) displacement in the Up direction for each map grid position
          disp_LOS    (output) displacement in the line of sight (LOS) for each map grid position

        NOTE: positive displacement in the LOS is towards the radar and negative displacement is away from the radar!


        """

        if self.validate_inputs:
            self._validate_dispmap_sim(
                LV, DEM_par, disp_east, disp_north, disp_up, disp_LOS
            )

        if self.mock_outputs:
            self._mock_dispmap_sim_outputs(
                LV, DEM_par, disp_east, disp_north, disp_up, disp_LOS
            )

        ca = self._clean_args(locals(), inspect.signature(self.dispmap_sim))
        result = self._gamma_call("DIFF", "dispmap_sim", ca)

        assert disp_LOS.exists(), f"{disp_LOS} does not exist"
        assert disp_LOS.stat().st_size > 0, f"{disp_LOS} has zero file size"

        return result

    def _validate_dem_gradient(
        self,
        DEM_par: Path,
        DEM: Path,
        theta: Path,
        phi: Path,
        mag: Path,
        type: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dem_gradient.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert not theta.exists(), f"{theta} should _not_ exist!"

        assert not phi.exists(), f"{phi} should _not_ exist!"

        assert not mag.exists(), f"{mag} should _not_ exist!"

    def _mock_dem_gradient_outputs(
        self,
        DEM_par: Path,
        DEM: Path,
        theta: Path,
        phi: Path,
        mag: Path,
        type: Optional[int] = None,
    ) -> None:
        """

        Mock the program dem_gradient.

        """

        if theta is not None and str(theta) != "-":
            theta.touch()

        if phi is not None and str(phi) != "-":
            phi.touch()

        if mag is not None and str(mag) != "-":
            mag.touch()

    def dem_gradient(
        self,
        DEM_par: Path,
        DEM: Path,
        theta: Path,
        phi: Path,
        mag: Path,
        type: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate elevation and orientation angles of the DEM normal or gradient vector magnitude


        input parameters:
          DEM_par     (input) DEM parameter file
          DEM         (input) DEM data file (or constant height value)
          theta       (output) elevation angle of DEM normal or gradient vector (float)
          phi         (output) orientation angle of DEM normal or gradient vector (float)
          mag         (output) magnitude of the gradient vector (float)
          type        vector type selection (enter - for default)
                        0: normal vector
                        1: gradient vector (default)
          sharpness   gradient sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes


        """

        if self.validate_inputs:
            self._validate_dem_gradient(DEM_par, DEM, theta, phi, mag, type)

        if self.mock_outputs:
            self._mock_dem_gradient_outputs(DEM_par, DEM, theta, phi, mag, type)

        ca = self._clean_args(locals(), inspect.signature(self.dem_gradient))
        result = self._gamma_call("DIFF", "dem_gradient", ca)

        assert theta.exists(), f"{theta} does not exist"
        assert theta.stat().st_size > 0, f"{theta} has zero file size"

        assert phi.exists(), f"{phi} does not exist"
        assert phi.stat().st_size > 0, f"{phi} has zero file size"

        assert mag.exists(), f"{mag} does not exist"
        assert mag.stat().st_size > 0, f"{mag} has zero file size"

        return result

    def _validate_offset_pwr_trackingm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwr_trackingm.

        """

        assert MLI_1.exists(), f"{MLI_1} does not exist"
        assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        assert MLI_2.exists(), f"{MLI_2} does not exist"
        assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not ccp.exists(), f"{ccp} should _not_ exist!"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

        if ccs is not None:
            assert not ccs.exists(), f"{ccs} should _not_ exist!"

    def _mock_offset_pwr_trackingm_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_pwr_trackingm.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if ccp is not None and str(ccp) != "-":
            ccp.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_trackingm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offset tracking between MLI images using intensity cross-correlation


        input parameters:
          MLI-1     (input) real valued intensity image 1 (reference)
          MLI-2     (input) real valued intensity image 2
          DIFF_par  (input) DIFF/GEO parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     MLI oversampling factor (integer 2**N (1,2,4), enter - for default: 1)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on intensity data (0.0->1.0) (enter - for default: 0.8)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)
          std_mean  patch minimum standard deviation/mean ratio (enter - for default: 0.01)


        """

        if self.validate_inputs:
            self._validate_offset_pwr_trackingm(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )

        if self.mock_outputs:
            self._mock_offset_pwr_trackingm_outputs(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_pwr_trackingm))
        result = self._gamma_call("DIFF", "offset_pwr_trackingm", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        if ccs is not None:
            assert ccs.exists(), f"{ccs} does not exist"
            assert ccs.stat().st_size > 0, f"{ccs} has zero file size"

        return result

    def _validate_init_offsetm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        offr: Optional[int] = None,
        offaz: Optional[int] = None,
        thres: Optional[float] = None,
        patch: Optional[int] = None,
        cflag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to init_offsetm.

        """

        assert MLI_1.exists(), f"{MLI_1} does not exist"
        assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        assert MLI_2.exists(), f"{MLI_2} does not exist"
        assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

    def _mock_init_offsetm_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        offr: Optional[int] = None,
        offaz: Optional[int] = None,
        thres: Optional[float] = None,
        patch: Optional[int] = None,
        cflag: Optional[int] = None,
    ) -> None:
        """

        Mock the program init_offsetm.

        """
        pass

    def init_offsetm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        offr: Optional[int] = None,
        offaz: Optional[int] = None,
        thres: Optional[float] = None,
        patch: Optional[int] = None,
        cflag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Initial offset estimation for multi-look intensity images


        input parameters:
          MLI-1     (input) intensity image 1 (float) (reference)
          MLI-2     (input) intensity image 2 (float)
          DIFF_par  DIFF/GEO parameter file
          rlks      number of range looks (enter - for default: 1)
          azlks     number of azimuth looks (enter - for default: 1)
          rpos      center of region for comparison in range (enter - for default: image center)
          azpos     center of region for comparison in azimuth (enter - for default: image center)
          offr      initial range offset (enter - for default from DIFF_par)
          offaz     initial azimuth offset (enter - for default from DIFF_par)
          thres     correlation SNR threshold (enter -  for default:  0.150)
          patch     correlation patch size (enter - for default: 512)
          cflag     copy offsets to the range and azimuth offset polynomials in DIFF_par (enter - for default)
                      0: do not copy
                      1: copy constant range and azimuth offsets (default)


        """

        if self.validate_inputs:
            self._validate_init_offsetm(
                MLI_1,
                MLI_2,
                DIFF_par,
                rlks,
                azlks,
                rpos,
                azpos,
                offr,
                offaz,
                thres,
                patch,
                cflag,
            )

        if self.mock_outputs:
            self._mock_init_offsetm_outputs(
                MLI_1,
                MLI_2,
                DIFF_par,
                rlks,
                azlks,
                rpos,
                azpos,
                offr,
                offaz,
                thres,
                patch,
                cflag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.init_offsetm))
        result = self._gamma_call("DIFF", "init_offsetm", ca)
        return result

    def _validate_gc_map_fd(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Path,
        DEM_seg: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        inc: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        ls_map: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_mode: Optional[int] = None,
        r_ovr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gc_map_fd.

        """

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert not DEM_seg.exists(), f"{DEM_seg} should _not_ exist!"

        assert not lookup_table.exists(), f"{lookup_table} should _not_ exist!"

        if sim_sar is not None:
            assert not sim_sar.exists(), f"{sim_sar} should _not_ exist!"

        if u is not None:
            assert not u.exists(), f"{u} should _not_ exist!"

        if v is not None:
            assert not v.exists(), f"{v} should _not_ exist!"

        if inc is not None:
            assert not inc.exists(), f"{inc} should _not_ exist!"

        if psi is not None:
            assert not psi.exists(), f"{psi} should _not_ exist!"

        if pix is not None:
            assert not pix.exists(), f"{pix} should _not_ exist!"

        if ls_map is not None:
            assert not ls_map.exists(), f"{ls_map} should _not_ exist!"

    def _mock_gc_map_fd_outputs(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Path,
        DEM_seg: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        inc: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        ls_map: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_mode: Optional[int] = None,
        r_ovr: Optional[int] = None,
    ) -> None:
        """

        Mock the program gc_map_fd.

        """

        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

        if DEM_seg is not None and str(DEM_seg) != "-":
            DEM_seg.touch()

        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

        if sim_sar is not None and str(sim_sar) != "-":
            sim_sar.touch()

        if u is not None and str(u) != "-":
            u.touch()

        if v is not None and str(v) != "-":
            v.touch()

        if inc is not None and str(inc) != "-":
            inc.touch()

        if psi is not None and str(psi) != "-":
            psi.touch()

        if pix is not None and str(pix) != "-":
            pix.touch()

        if ls_map is not None and str(ls_map) != "-":
            ls_map.touch()

    def gc_map_fd(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Path,
        DEM_seg: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        inc: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        ls_map: Optional[Path] = None,
        frame: Optional[int] = None,
        ls_mode: Optional[int] = None,
        r_ovr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate lookup table and DEM related products for terrain-corrected geocoding using a doppler polynomial table


        input parameters:
          MLI_par         (input) ISP MLI or SLC image parameter file (slant range geometry)
          fdtab           (input)table of doppler polynomials at uniform azimuth time steps
          DEM_par         (input) DEM/MAP parameter file
          DEM             (input) DEM data file (or constant height value)
          DEM_seg_par     (input/output) DEM/MAP segment parameter file used for output products

          NOTE: If the DEM_seg_par already exists, then the output DEM parameters will be read from this file
                otherwise they are estimated from the image data.

          DEM_seg         (output) DEM segment used for output products, interpolated if lat_ovr > 1.0  or lon_ovr > 1.0
          lookup_table    (output) geocoding lookup table (fcomplex)
          lat_ovr         latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr         longitude or easting output DEM oversampling factor (enter - for default: 1.0)
          sim_sar         (output) simulated SAR backscatter image in DEM geometry
          u               (output) zenith angle of surface normal vector n (angle between z and n)
          v               (output) orientation angle of n (between x and projection of n in xy plane)
          inc             (output) local incidence angle (between surface normal and look vector)
          psi             (output) projection angle (between surface normal and image plane normal)
          pix             (output) pixel area normalization factor
          ls_map          (output) layover and shadow map (in map projection)
          frame           number of DEM pixels to add around area covered by SAR image (enter - for default = 8)
          ls_mode         output lookup table values in regions of layover, shadow, or DEM gaps (enter - for default)
                            0: set to (0.,0.)
                            1: linear interpolation across these regions (default)
                            2: actual value
                            3: nn-thinned
          r_ovr           range over-sampling factor for nn-thinned layover/shadow mode(enter - for default: 2.0)

        NOTE: enter - as output filename to avoid creating the corresponding output file


        """

        if self.validate_inputs:
            self._validate_gc_map_fd(
                MLI_par,
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                sim_sar,
                u,
                v,
                inc,
                psi,
                pix,
                ls_map,
                frame,
                ls_mode,
                r_ovr,
            )

        if self.mock_outputs:
            self._mock_gc_map_fd_outputs(
                MLI_par,
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                sim_sar,
                u,
                v,
                inc,
                psi,
                pix,
                ls_map,
                frame,
                ls_mode,
                r_ovr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.gc_map_fd))
        result = self._gamma_call("DIFF", "gc_map_fd", ca)

        assert DEM_seg_par.exists(), f"{DEM_seg_par} does not exist"
        assert DEM_seg_par.stat().st_size > 0, f"{DEM_seg_par} has zero file size"

        assert DEM_seg.exists(), f"{DEM_seg} does not exist"
        assert DEM_seg.stat().st_size > 0, f"{DEM_seg} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        if sim_sar is not None:
            assert sim_sar.exists(), f"{sim_sar} does not exist"
            assert sim_sar.stat().st_size > 0, f"{sim_sar} has zero file size"

        if u is not None:
            assert u.exists(), f"{u} does not exist"
            assert u.stat().st_size > 0, f"{u} has zero file size"

        if v is not None:
            assert v.exists(), f"{v} does not exist"
            assert v.stat().st_size > 0, f"{v} has zero file size"

        if inc is not None:
            assert inc.exists(), f"{inc} does not exist"
            assert inc.stat().st_size > 0, f"{inc} has zero file size"

        if psi is not None:
            assert psi.exists(), f"{psi} does not exist"
            assert psi.stat().st_size > 0, f"{psi} has zero file size"

        if pix is not None:
            assert pix.exists(), f"{pix} does not exist"
            assert pix.stat().st_size > 0, f"{pix} has zero file size"

        if ls_map is not None:
            assert ls_map.exists(), f"{ls_map} does not exist"
            assert ls_map.stat().st_size > 0, f"{ls_map} has zero file size"

        return result

    def _validate_resamp_image_par(
        self,
        data_in: Path,
        PAR_1: Path,
        PAR_2: Path,
        data_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
        off_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to resamp_image_par.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert PAR_1.exists(), f"{PAR_1} does not exist"
        assert PAR_1.stat().st_size > 0, f"{PAR_1} has zero file size"

        assert PAR_2.exists(), f"{PAR_2} does not exist"
        assert PAR_2.stat().st_size > 0, f"{PAR_2} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_resamp_image_par_outputs(
        self,
        data_in: Path,
        PAR_1: Path,
        PAR_2: Path,
        data_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
        off_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> None:
        """

        Mock the program resamp_image_par.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def resamp_image_par(
        self,
        data_in: Path,
        PAR_1: Path,
        PAR_2: Path,
        data_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
        off_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Resample 2D data with geometry of the input image parameter file to the geometry of a second image parameter file of the same scene


        input parameters:
          data_in      (input) input data file (format as specified by dtype parameter)
          PAR-1        (input) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for data_in
          PAR-2        (input) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for data_out
          data_out     (output) resampled output data file
          interp_mode  interpolation mode (enter - for default)
                         0: nearest-neighbor
                         1: bicubic spline (default)
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 5)
                         5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                         6: Lanczos interpolation (default Lanczos function order: 5)
                         7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype        input and output data format (enter - for default)
                         0: FLOAT (default)
                         1: FCOMPLEX
                         2: SUN/BMP/TIFF format raster image
                         3: UNSIGNED CHAR
                         4: SHORT
                         5: DOUBLE
                         6: SCOMPLEX
          order        Lanczos function order or B-spline degree (2->9) (enter - for default: 5)
          e_flag       extrapolation flag (enter - for default)
                         0: do not extrapolate (default)
                         1: extrapolate up to 0.5 pixels beyond input edges
          off_flag     offset flag when using OFF_par or DIFF_par files (enter - for default)
                         0: image mode (resample image (e.g. interferogram / SLC / MLI) to a different multi-looking geometry) (default)
                         1: offsets mode 1 (resample input offsets to image frame)
                         2: offsets mode 2 (resample input image to offsets frame)
                         3: offsets mode 3 (resample input offsets to different offsets frame)
          lpf          low-pass filter amount when downsampling data (0.0 -> no filter, 1.0 -> ensure output is not aliased, enter - for default: 0.0)

          NOTES:
            1. The parameter files PAR-1 and PAR-2 must be from the same scene or DEM and must be the same type
            2. See documentation for information on recommended interpolation modes for different data types
            3. When resampling complex data, the data should either have been deramped, or have their spectrum centered around 0


        """

        if self.validate_inputs:
            self._validate_resamp_image_par(
                data_in,
                PAR_1,
                PAR_2,
                data_out,
                interp_mode,
                dtype,
                order,
                e_flag,
                off_flag,
                lpf,
            )

        if self.mock_outputs:
            self._mock_resamp_image_par_outputs(
                data_in,
                PAR_1,
                PAR_2,
                data_out,
                interp_mode,
                dtype,
                order,
                e_flag,
                off_flag,
                lpf,
            )

        ca = self._clean_args(locals(), inspect.signature(self.resamp_image_par))
        result = self._gamma_call("DIFF", "resamp_image_par", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_phase_sim_orb(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Optional[Path],
        sim_orb: Path,
        SLC_ref_par: Optional[Path] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[int] = None,
        ph_mode: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to phase_sim_orb.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        if hgt is not None:
            assert hgt.exists(), f"{hgt} does not exist"
            assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        assert not sim_orb.exists(), f"{sim_orb} should _not_ exist!"

        if SLC_ref_par is not None:
            assert SLC_ref_par.exists(), f"{SLC_ref_par} does not exist"
            assert SLC_ref_par.stat().st_size > 0, f"{SLC_ref_par} has zero file size"

        if def_ is not None:
            assert def_.exists(), f"{def_} does not exist"
            assert def_.stat().st_size > 0, f"{def_} has zero file size"

        if delta_t is not None:
            assert delta_t.exists(), f"{delta_t} does not exist"
            assert delta_t.stat().st_size > 0, f"{delta_t} has zero file size"

    def _mock_phase_sim_orb_outputs(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Optional[Path],
        sim_orb: Path,
        SLC_ref_par: Optional[Path] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[int] = None,
        ph_mode: Optional[int] = None,
    ) -> None:
        """

        Mock the program phase_sim_orb.

        """

        if sim_orb is not None and str(sim_orb) != "-":
            sim_orb.touch()

    def phase_sim_orb(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Optional[Path],
        sim_orb: Path,
        SLC_ref_par: Optional[Path] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[int] = None,
        ph_mode: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Simulate unwrapped interferometric phase using DEM height and deformation rate using orbit state vectors


        input parameters:
          SLC1_par    (input) SLC parameter file of reference SLC-1
          SLC2R_par   (input) SLC parameter file of resampled SLC-2
          OFF_par     (input) ISP offset/interferogram parameter file
          hgt         (input) height relative to the WGS-84 elliposid in the same geometry as the mosaic (m) (FLOAT, enter - for none)
          sim_orb     (output) simulated interferometric phase (FLOAT, unwrapped)
          SLC_ref_par (input) SLC parameter file of the image used for geometric coregistration (enter - for none)
          def         (input) LOS deformation rate map (meters/yr, float, enter - for none)
          delta_t     (input) interferogram time interval (days, required for deformation modeling, enter - for none)
          int_mode    interferometric acquisition mode (enter - for default)
                        0: single-pass mode (Tandem-X)
                        1: repeat-pass mode (default)
          ph_mode     phase offset mode (enter - for default)
                        0: absolute phase (default)
                        1: subtract phase offset that is a multiple of 2PI to improve precision


        """

        if self.validate_inputs:
            self._validate_phase_sim_orb(
                SLC1_par,
                SLC2R_par,
                OFF_par,
                hgt,
                sim_orb,
                SLC_ref_par,
                def_,
                delta_t,
                int_mode,
                ph_mode,
            )

        if self.mock_outputs:
            self._mock_phase_sim_orb_outputs(
                SLC1_par,
                SLC2R_par,
                OFF_par,
                hgt,
                sim_orb,
                SLC_ref_par,
                def_,
                delta_t,
                int_mode,
                ph_mode,
            )

        ca = self._clean_args(locals(), inspect.signature(self.phase_sim_orb))
        result = self._gamma_call("DIFF", "phase_sim_orb", ca)

        assert sim_orb.exists(), f"{sim_orb} does not exist"
        assert sim_orb.stat().st_size > 0, f"{sim_orb} has zero file size"

        return result

    def _validate_gec_map(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Path,
        href: Path,
        DEM_seg_par: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gec_map.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert href.exists(), f"{href} does not exist"
        assert href.stat().st_size > 0, f"{href} has zero file size"

        assert not lookup_table.exists(), f"{lookup_table} should _not_ exist!"

    def _mock_gec_map_outputs(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Path,
        href: Path,
        DEM_seg_par: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
    ) -> None:
        """

        Mock the program gec_map.

        """

        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

    def gec_map(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Path,
        href: Path,
        DEM_seg_par: Path,
        lookup_table: Path,
        lat_ovr: Optional[int] = None,
        lon_ovr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate geocoding lookup table for ellipsoid correction of slant-range images


        input parameters:
          SLC_par       (input) ISP SLC-1/MLI parameter file
          OFF_par       (input) ISP offset/interferogram parameter file, enter - if geocoding SLC or MLI data
          DEM_par       (input) DEM parameter file
          href          (input) elevation reference [m]
          DEM_seg_par   (input/output) DEM segment parameter file used for geocoding

          NOTE: If the DEM_seg_par already exists, then the output DEM parameters will be read from this file
                otherwise they are estimated from the image data.

          lookup_table  (output) geocoding lookup table
          lat_ovr       latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr       longitude or easting output DEM oversampling factor (enter - for default: 1.0)

        """

        if self.validate_inputs:
            self._validate_gec_map(
                SLC_par,
                OFF_par,
                DEM_par,
                href,
                DEM_seg_par,
                lookup_table,
                lat_ovr,
                lon_ovr,
            )

        if self.mock_outputs:
            self._mock_gec_map_outputs(
                SLC_par,
                OFF_par,
                DEM_par,
                href,
                DEM_seg_par,
                lookup_table,
                lat_ovr,
                lon_ovr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.gec_map))
        result = self._gamma_call("DIFF", "gec_map", ca)

        assert DEM_seg_par.exists(), f"{DEM_seg_par} does not exist"
        assert DEM_seg_par.stat().st_size > 0, f"{DEM_seg_par} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        return result

    def _validate_dh_map_orb(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Path,
        dp: Path,
        dpdh: Path,
        dh: Path,
        SLC_ref_par: Optional[Path] = None,
        int_mode: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to dh_map_orb.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert hgt.exists(), f"{hgt} does not exist"
        assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        assert dp.exists(), f"{dp} does not exist"
        assert dp.stat().st_size > 0, f"{dp} has zero file size"

        assert not dpdh.exists(), f"{dpdh} should _not_ exist!"

        assert not dh.exists(), f"{dh} should _not_ exist!"

        if SLC_ref_par is not None:
            assert SLC_ref_par.exists(), f"{SLC_ref_par} does not exist"
            assert SLC_ref_par.stat().st_size > 0, f"{SLC_ref_par} has zero file size"

        if int_mode is not None:
            assert int_mode.exists(), f"{int_mode} does not exist"
            assert int_mode.stat().st_size > 0, f"{int_mode} has zero file size"

    def _mock_dh_map_orb_outputs(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Path,
        dp: Path,
        dpdh: Path,
        dh: Path,
        SLC_ref_par: Optional[Path] = None,
        int_mode: Optional[Path] = None,
    ) -> None:
        """

        Mock the program dh_map_orb.

        """

        if dpdh is not None and str(dpdh) != "-":
            dpdh.touch()

        if dh is not None and str(dh) != "-":
            dh.touch()

    def dh_map_orb(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Path,
        dp: Path,
        dpdh: Path,
        dh: Path,
        SLC_ref_par: Optional[Path] = None,
        int_mode: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate delta height from differential interferometric phase using state vectors for baseline calculation


        input parameters:
          SLC1_par    (input) SLC parameter file of reference SLC-1
          SLC2R_par   (input) SLC parameter file of resampled SLC-2
          OFF_par     (input) ISP offset/interferogram parameter file
          hgt         (input) height map in the same geometry as the interferogram, or constant value (m) (float, enter - for none))
          dp          (input) interferogram phase - simulated phase (radians) (float, enter - for none)
          dpdh        (output) sensitivity of interf. phase with respect to height calculated using state vectors and hgt (rad/m) (float, enter - for none)
          dh          (output) height difference calculated from dp using dpdh (m) (float, enter - for none)
          SLC_ref_par (input) SLC parameter file of the image used for geometric coregistration (enter - for none)
          int_mode    (input) interferometric acquisition mode:
                        0: single-pass mode (Tandem-X)
                        1: repeat-pass mode (default)


        """

        if self.validate_inputs:
            self._validate_dh_map_orb(
                SLC1_par, SLC2R_par, OFF_par, hgt, dp, dpdh, dh, SLC_ref_par, int_mode
            )

        if self.mock_outputs:
            self._mock_dh_map_orb_outputs(
                SLC1_par, SLC2R_par, OFF_par, hgt, dp, dpdh, dh, SLC_ref_par, int_mode
            )

        ca = self._clean_args(locals(), inspect.signature(self.dh_map_orb))
        result = self._gamma_call("DIFF", "dh_map_orb", ca)

        assert dpdh.exists(), f"{dpdh} does not exist"
        assert dpdh.stat().st_size > 0, f"{dpdh} has zero file size"

        assert dh.exists(), f"{dh} does not exist"
        assert dh.stat().st_size > 0, f"{dh} has zero file size"

        return result

    def _validate_offset_subm(self, offs: Path, DIFF_par: Path, offs_sub: Path) -> None:
        """

        Validate the arguments to offset_subm.

        """

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not offs_sub.exists(), f"{offs_sub} should _not_ exist!"

    def _mock_offset_subm_outputs(
        self, offs: Path, DIFF_par: Path, offs_sub: Path
    ) -> None:
        """

        Mock the program offset_subm.

        """

        if offs_sub is not None and str(offs_sub) != "-":
            offs_sub.touch()

    def offset_subm(
        self, offs: Path, DIFF_par: Path, offs_sub: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Subtraction of polynomial from range and azimuth offset estimates


        input parameters:
          offs      (input) range and azimuth offset estimates (fcomplex)
          DIFF_par  (input) DIFF/GEO parameter file for the scene
          offs_sub  (output) range and azimuth offset estimates after polynomial subtraction (fcomplex)

        """

        if self.validate_inputs:
            self._validate_offset_subm(offs, DIFF_par, offs_sub)

        if self.mock_outputs:
            self._mock_offset_subm_outputs(offs, DIFF_par, offs_sub)

        ca = self._clean_args(locals(), inspect.signature(self.offset_subm))
        result = self._gamma_call("DIFF", "offset_subm", ca)

        assert offs_sub.exists(), f"{offs_sub} does not exist"
        assert offs_sub.stat().st_size > 0, f"{offs_sub} has zero file size"

        return result

    def _validate_offset_trackingm(
        self,
        offs: Path,
        snr: Path,
        MLI_par: Path,
        DIFF_par: Path,
        coffs_map: Path,
        coffsets: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[float] = None,
        poly_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_trackingm.

        """

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert snr.exists(), f"{snr} does not exist"
        assert snr.stat().st_size > 0, f"{snr} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not coffs_map.exists(), f"{coffs_map} should _not_ exist!"

        if coffsets is not None:
            assert not coffsets.exists(), f"{coffsets} should _not_ exist!"

    def _mock_offset_trackingm_outputs(
        self,
        offs: Path,
        snr: Path,
        MLI_par: Path,
        DIFF_par: Path,
        coffs_map: Path,
        coffsets: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[float] = None,
        poly_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_trackingm.

        """

        if coffs_map is not None and str(coffs_map) != "-":
            coffs_map.touch()

        if coffsets is not None and str(coffsets) != "-":
            coffsets.touch()

    def offset_trackingm(
        self,
        offs: Path,
        snr: Path,
        MLI_par: Path,
        DIFF_par: Path,
        coffs_map: Path,
        coffsets: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[float] = None,
        poly_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Conversion of range and azimuth offsets files to displacement map for intensity offsets


        input parameters:
          offs       (input) range and azimuth offset estimates (fcomplex)
          snr        (input) cross-correlation of the offset estimates (float)
          MLI_par    (input) MLI parameter file of reference MLI
          DIFF_par   (input) offset parameter file used in the offset tracking
          coffs_map  (output) range and azimuth displacement estimates (fcomplex)
          coffsets   (output) range and azimuth displacement estimates and cross-correlation values (enter - for none) (text)
          mode       flag indicating displacement mode:
                       0: displacement in range and azimuth pixels
                       1: displacement in meters in slant range and azimuth directions
                       2: displacement in meters in ground range and azimuth directions (default)
          thres      cross-correlation threshold to accept offset value (0.0-> 1.0, default from DIFF_par)
          poly_flag  flag indicating if trend calculated using offset polynomials from DIFF_par is subtracted:
                       0: do not subtract polynomial trend from offset data
                       1: subtract polynomial trend from offset data (default)


        """

        if self.validate_inputs:
            self._validate_offset_trackingm(
                offs, snr, MLI_par, DIFF_par, coffs_map, coffsets, mode, thres, poly_flag
            )

        if self.mock_outputs:
            self._mock_offset_trackingm_outputs(
                offs, snr, MLI_par, DIFF_par, coffs_map, coffsets, mode, thres, poly_flag
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_trackingm))
        result = self._gamma_call("DIFF", "offset_trackingm", ca)

        assert coffs_map.exists(), f"{coffs_map} does not exist"
        assert coffs_map.stat().st_size > 0, f"{coffs_map} has zero file size"

        if coffsets is not None:
            assert coffsets.exists(), f"{coffsets} does not exist"
            assert coffsets.stat().st_size > 0, f"{coffsets} has zero file size"

        return result

    def _validate_comb_interfs(
        self,
        int_1: Path,
        int_2: Path,
        base_1: Path,
        base_2: Path,
        factor_1: int,
        factor_2: int,
        width: int,
        combi_base: Path,
        sm: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to comb_interfs.

        """

        assert int_1.exists(), f"{int_1} does not exist"
        assert int_1.stat().st_size > 0, f"{int_1} has zero file size"

        assert int_2.exists(), f"{int_2} does not exist"
        assert int_2.stat().st_size > 0, f"{int_2} has zero file size"

        assert base_1.exists(), f"{base_1} does not exist"
        assert base_1.stat().st_size > 0, f"{base_1} has zero file size"

        assert base_2.exists(), f"{base_2} does not exist"
        assert base_2.stat().st_size > 0, f"{base_2} has zero file size"

        assert not combi_base.exists(), f"{combi_base} should _not_ exist!"

    def _mock_comb_interfs_outputs(
        self,
        int_1: Path,
        int_2: Path,
        base_1: Path,
        base_2: Path,
        factor_1: int,
        factor_2: int,
        width: int,
        combi_base: Path,
        sm: Optional[float] = None,
    ) -> None:
        """

        Mock the program comb_interfs.

        """

        if combi_base is not None and str(combi_base) != "-":
            combi_base.touch()

    def comb_interfs(
        self,
        int_1: Path,
        int_2: Path,
        base_1: Path,
        base_2: Path,
        factor_1: int,
        factor_2: int,
        width: int,
        combi_base: Path,
        sm: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Complex interferogram combination


        input parameters:
          int-1       complex interferogram 1
          int-2       complex interferogram 2
          base-1      baseline file 1
          base-2      baseline file 2
          factor-1    phase scaling factor 1
          factor-2    phase scaling factor 2
          width       width of interferograms (samples)
          combi_int   output combined interferogram
          combi_base  output combined interferogram baseline file
          sm          magnitude scale factor (default=1.0)

          Remarks:
          Only the use of integer phase scaling factors (positive and negative) seems reasonable
            for the scaling and summing of wrapped phase images
          The coherence of the combined interferogram is estimated from the magnitude scale factor
            and the summed phase noise.


        """

        if self.validate_inputs:
            self._validate_comb_interfs(
                int_1, int_2, base_1, base_2, factor_1, factor_2, width, combi_base, sm
            )

        if self.mock_outputs:
            self._mock_comb_interfs_outputs(
                int_1, int_2, base_1, base_2, factor_1, factor_2, width, combi_base, sm
            )

        ca = self._clean_args(locals(), inspect.signature(self.comb_interfs))
        result = self._gamma_call("DIFF", "comb_interfs", ca)

        assert combi_base.exists(), f"{combi_base} does not exist"
        assert combi_base.stat().st_size > 0, f"{combi_base} has zero file size"

        return result

    def _validate_gc_insar(
        self, SLC_par: Path, OFF_par: Path, hgt: Path, DEM_par: Path, lookup_table: Path
    ) -> None:
        """

        Validate the arguments to gc_insar.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert hgt.exists(), f"{hgt} does not exist"
        assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert not lookup_table.exists(), f"{lookup_table} should _not_ exist!"

    def _mock_gc_insar_outputs(
        self, SLC_par: Path, OFF_par: Path, hgt: Path, DEM_par: Path, lookup_table: Path
    ) -> None:
        """

        Mock the program gc_insar.

        """

        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

    def gc_insar(
        self, SLC_par: Path, OFF_par: Path, hgt: Path, DEM_par: Path, lookup_table: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Derive complex valued lookup table for terrain corrected geocoding (based on heights in SAR geometry)


        input parameters:
          SLC_par       (input) SLC parameter file of reference SLC
          OFF_par       (input) ISP offset/interferogram parameter file
          hgt           (input) height map in SAR geometry (float format)
          DEM_par       (input) DEM parameters (characterizing map projection)
          lookup_table  (output) geocoding lookup table (fcomplex format)


        """

        if self.validate_inputs:
            self._validate_gc_insar(SLC_par, OFF_par, hgt, DEM_par, lookup_table)

        if self.mock_outputs:
            self._mock_gc_insar_outputs(SLC_par, OFF_par, hgt, DEM_par, lookup_table)

        ca = self._clean_args(locals(), inspect.signature(self.gc_insar))
        result = self._gamma_call("DIFF", "gc_insar", ca)

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        return result

    def _validate_par_KS_geo(
        self,
    ) -> None:
        """

        Validate the arguments to par_KS_geo.

        """

        pass

    def _mock_par_KS_geo_outputs(
        self,
    ) -> None:
        """

        Mock the program par_KS_geo.

        """
        pass

    def par_KS_geo(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        dyld[70498]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/par_KS_geo'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)

        """

        if self.validate_inputs:
            self._validate_par_KS_geo()

        if self.mock_outputs:
            self._mock_par_KS_geo_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.par_KS_geo))
        result = self._gamma_call("DIFF", "par_KS_geo", ca)
        return result

    def _validate_offset_pwrm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwrm.

        """

        assert MLI_1.exists(), f"{MLI_1} does not exist"
        assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        assert MLI_2.exists(), f"{MLI_2} does not exist"
        assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not ccp.exists(), f"{ccp} should _not_ exist!"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

        if ccs is not None:
            assert not ccs.exists(), f"{ccs} should _not_ exist!"

    def _mock_offset_pwrm_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_pwrm.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if ccp is not None and str(ccp) != "-":
            ccp.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwrm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offset estimation between MLI images using intensity cross-correlation


        input parameters:
          MLI-1     (input) real valued intensity image 1 (reference)
          MLI-2     (input) real valued intensity image 2
          DIFF_par  (input) DIFF/GEO parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     MLI oversampling factor (integer 2**N (1,2,4), enter - for default: 1)
          nr        number of offset estimates in range direction (enter - for default from offset parameter file)
          naz       number of offset estimates in azimuth direction (enter - for default from offset parameter file)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on intensity data (0.0->1.0) (enter - for default: 0.8)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)
          std_mean  patch minimum standard deviation/mean ratio (enter - for default: 0.01)


        """

        if self.validate_inputs:
            self._validate_offset_pwrm(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )

        if self.mock_outputs:
            self._mock_offset_pwrm_outputs(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_pwrm))
        result = self._gamma_call("DIFF", "offset_pwrm", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        if ccs is not None:
            assert ccs.exists(), f"{ccs} does not exist"
            assert ccs.stat().st_size > 0, f"{ccs} has zero file size"

        return result

    def _validate_coord_to_sarpix_list(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Optional[Path],
        MAP_coord: Path,
        SAR_coord: Path,
        DIFF_par: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to coord_to_sarpix_list.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        if DEM_par is not None:
            assert DEM_par.exists(), f"{DEM_par} does not exist"
            assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert MAP_coord.exists(), f"{MAP_coord} does not exist"
        assert MAP_coord.stat().st_size > 0, f"{MAP_coord} has zero file size"

        assert not SAR_coord.exists(), f"{SAR_coord} should _not_ exist!"

        if DIFF_par is not None:
            assert DIFF_par.exists(), f"{DIFF_par} does not exist"
            assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

    def _mock_coord_to_sarpix_list_outputs(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Optional[Path],
        MAP_coord: Path,
        SAR_coord: Path,
        DIFF_par: Optional[Path] = None,
    ) -> None:
        """

        Mock the program coord_to_sarpix_list.

        """

        if SAR_coord is not None and str(SAR_coord) != "-":
            SAR_coord.touch()

    def coord_to_sarpix_list(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Optional[Path],
        MAP_coord: Path,
        SAR_coord: Path,
        DIFF_par: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate SAR pixel coordinates for each set of map coordinates in a list


        input parameters:
          SLC_par    (input) ISP SLC/MLI parameter file
          OFF_par    (input) ISP offset/interferogram parameter file, enter - for SLC or MLI data
          DEM_par    (input) DEM parameter file defining the map projection, datum, and coverage (enter - for none)
                       NOTE: if there is no DEM_par, then the coordinate data are interpreted as latitude and longitude in the WG84 datum
          MAP_coord  (input) list of map coordinates and heights with 3 columns:
                       north/lat/S   east/lon/C    height (m) in the map datum
          SAR_coord  (output) list of pixel and line coordinates in the geometry defined by the SLC_par:
                       azimuth_line  range_pixel   height (m) in the map datum
          DIFF_par   (input) DIFF/GEO parameter file containing refinement polynomial coefficients (enter - for none)

          NOTE: When the DIFF_par is specified, the refinement polynomial correction is applied to the SAR pixel and line coordinates


        """

        if self.validate_inputs:
            self._validate_coord_to_sarpix_list(
                SLC_par, OFF_par, DEM_par, MAP_coord, SAR_coord, DIFF_par
            )

        if self.mock_outputs:
            self._mock_coord_to_sarpix_list_outputs(
                SLC_par, OFF_par, DEM_par, MAP_coord, SAR_coord, DIFF_par
            )

        ca = self._clean_args(locals(), inspect.signature(self.coord_to_sarpix_list))
        result = self._gamma_call("DIFF", "coord_to_sarpix_list", ca)

        assert SAR_coord.exists(), f"{SAR_coord} does not exist"
        assert SAR_coord.stat().st_size > 0, f"{SAR_coord} has zero file size"

        return result

    def _validate_offset_fitm(
        self,
        offs: Path,
        ccp: Path,
        DIFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[float] = None,
        npoly: Optional[int] = None,
        interact_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_fitm.

        """

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        if coffs is not None:
            assert not coffs.exists(), f"{coffs} should _not_ exist!"

        if coffsets is not None:
            assert not coffsets.exists(), f"{coffsets} should _not_ exist!"

    def _mock_offset_fitm_outputs(
        self,
        offs: Path,
        ccp: Path,
        DIFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[float] = None,
        npoly: Optional[int] = None,
        interact_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_fitm.

        """

        if coffs is not None and str(coffs) != "-":
            coffs.touch()

        if coffsets is not None and str(coffsets) != "-":
            coffsets.touch()

    def offset_fitm(
        self,
        offs: Path,
        ccp: Path,
        DIFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[float] = None,
        npoly: Optional[int] = None,
        interact_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Range and azimuth offset polynomial estimation using SVD


        input parameters:
          offs          (input) range and azimuth offset estimates (fcomplex)
          ccp           (input) cross-correlation of each patch (float)
          DIFF_par      (input) DIFF/GEO parameter file for the scene
          coffs         (output) culled range and azimuth offset estimates (fcomplex, enter - for none)
          coffsets      (output) culled offset estimates and cross-correlation values (text format, enter - for none)
          thres         cross-correlation threshold (enter - for default from DIFF_par)
          npoly         number of model polynomial parameters (enter - for default, 1, 3, 4, 6, default: 4)
          interact_mode interactive culling of input data:
                          0: off (default)
                          1: on


        """

        if self.validate_inputs:
            self._validate_offset_fitm(
                offs, ccp, DIFF_par, coffs, coffsets, thres, npoly, interact_flag
            )

        if self.mock_outputs:
            self._mock_offset_fitm_outputs(
                offs, ccp, DIFF_par, coffs, coffsets, thres, npoly, interact_flag
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_fitm))
        result = self._gamma_call("DIFF", "offset_fitm", ca)

        if coffs is not None:
            assert coffs.exists(), f"{coffs} does not exist"
            assert coffs.stat().st_size > 0, f"{coffs} has zero file size"

        if coffsets is not None:
            assert coffsets.exists(), f"{coffsets} does not exist"
            assert coffsets.stat().st_size > 0, f"{coffsets} has zero file size"

        return result

    def _validate_dispmap_ENU(
        self,
        LV_tab: Path,
        DISP_tab: Path,
        SIGMA_tab: Optional[Path],
        DEM_par: Path,
        disp_east: Path,
        disp_north: Path,
        disp_up: Path,
        sigma_east: Optional[Path] = None,
        sigma_north: Optional[Path] = None,
        sigma_up: Optional[Path] = None,
        chi2: Optional[Path] = None,
        min_obs: Optional[int] = None,
        tol: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dispmap_ENU.

        """

        assert LV_tab.exists(), f"{LV_tab} does not exist"
        assert LV_tab.stat().st_size > 0, f"{LV_tab} has zero file size"

        self._check_tab_file(LV_tab, "LV_tab")

        assert DISP_tab.exists(), f"{DISP_tab} does not exist"
        assert DISP_tab.stat().st_size > 0, f"{DISP_tab} has zero file size"

        self._check_tab_file(DISP_tab, "DISP_tab")

        if SIGMA_tab is not None:
            assert SIGMA_tab.exists(), f"{SIGMA_tab} does not exist"
            assert SIGMA_tab.stat().st_size > 0, f"{SIGMA_tab} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert not disp_east.exists(), f"{disp_east} should _not_ exist!"

        assert not disp_north.exists(), f"{disp_north} should _not_ exist!"

        assert not disp_up.exists(), f"{disp_up} should _not_ exist!"

        if sigma_east is not None:
            assert not sigma_east.exists(), f"{sigma_east} should _not_ exist!"

        if sigma_north is not None:
            assert not sigma_north.exists(), f"{sigma_north} should _not_ exist!"

        if sigma_up is not None:
            assert not sigma_up.exists(), f"{sigma_up} should _not_ exist!"

        if chi2 is not None:
            assert not chi2.exists(), f"{chi2} should _not_ exist!"

    def _mock_dispmap_ENU_outputs(
        self,
        LV_tab: Path,
        DISP_tab: Path,
        SIGMA_tab: Optional[Path],
        DEM_par: Path,
        disp_east: Path,
        disp_north: Path,
        disp_up: Path,
        sigma_east: Optional[Path] = None,
        sigma_north: Optional[Path] = None,
        sigma_up: Optional[Path] = None,
        chi2: Optional[Path] = None,
        min_obs: Optional[int] = None,
        tol: Optional[int] = None,
    ) -> None:
        """

        Mock the program dispmap_ENU.

        """

        if disp_east is not None and str(disp_east) != "-":
            disp_east.touch()

        if disp_north is not None and str(disp_north) != "-":
            disp_north.touch()

        if disp_up is not None and str(disp_up) != "-":
            disp_up.touch()

        if sigma_east is not None and str(sigma_east) != "-":
            sigma_east.touch()

        if sigma_north is not None and str(sigma_north) != "-":
            sigma_north.touch()

        if sigma_up is not None and str(sigma_up) != "-":
            sigma_up.touch()

        if chi2 is not None and str(chi2) != "-":
            chi2.touch()

    def dispmap_ENU(
        self,
        LV_tab: Path,
        DISP_tab: Path,
        SIGMA_tab: Optional[Path],
        DEM_par: Path,
        disp_east: Path,
        disp_north: Path,
        disp_up: Path,
        sigma_east: Optional[Path] = None,
        sigma_north: Optional[Path] = None,
        sigma_up: Optional[Path] = None,
        chi2: Optional[Path] = None,
        min_obs: Optional[int] = None,
        tol: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DIFF Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/dispmap_ENU
        Solve for deformation in East, North, Up (ENU) given measurements of deformation along different vector directions


        input parameters:
          LV_tab       (input) list of look vector files in ENU coordinates for each map grid position
          DISP_tab     (input) list of displacement files containing LOS displacement for each map grid position (text)
                       NOTE: displacement sign must be consistent with the look vector pointing from the radar to the ground
          SIGMA_tab    (input) standard deviation of displacement for each map grid position  (enter - for all equal)
          DEM_par      (input) DEM parameter file describing the map geometry
          disp_east    (output) displacement in the East direction for each map grid position
          disp_north   (output) displacement in the North direction for each map grid position
          disp_up      (output) displacement in the Up direction for each map grid position
          sigma_east   (output) standard deviation in the East direction for each map grid position
          sigma_north  (output) standard deviation in the North direction for each map grid position
          sigma_up     (output) standard deviation in the Up direction for each map grid position
          chi2         (output) chi-square for each map grid position
          min_obs      minimum number of observations (default: 3)
          tol          threshold for accepting SVD singular values w_i, when (w_i < tol*wmax), w_i is set to 0.0: 1.0000e-05


        """

        if self.validate_inputs:
            self._validate_dispmap_ENU(
                LV_tab,
                DISP_tab,
                SIGMA_tab,
                DEM_par,
                disp_east,
                disp_north,
                disp_up,
                sigma_east,
                sigma_north,
                sigma_up,
                chi2,
                min_obs,
                tol,
            )

        if self.mock_outputs:
            self._mock_dispmap_ENU_outputs(
                LV_tab,
                DISP_tab,
                SIGMA_tab,
                DEM_par,
                disp_east,
                disp_north,
                disp_up,
                sigma_east,
                sigma_north,
                sigma_up,
                chi2,
                min_obs,
                tol,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dispmap_ENU))
        result = self._gamma_call("DIFF", "dispmap_ENU", ca)

        assert disp_east.exists(), f"{disp_east} does not exist"
        assert disp_east.stat().st_size > 0, f"{disp_east} has zero file size"

        assert disp_north.exists(), f"{disp_north} does not exist"
        assert disp_north.stat().st_size > 0, f"{disp_north} has zero file size"

        assert disp_up.exists(), f"{disp_up} does not exist"
        assert disp_up.stat().st_size > 0, f"{disp_up} has zero file size"

        if sigma_east is not None:
            assert sigma_east.exists(), f"{sigma_east} does not exist"
            assert sigma_east.stat().st_size > 0, f"{sigma_east} has zero file size"

        if sigma_north is not None:
            assert sigma_north.exists(), f"{sigma_north} does not exist"
            assert sigma_north.stat().st_size > 0, f"{sigma_north} has zero file size"

        if sigma_up is not None:
            assert sigma_up.exists(), f"{sigma_up} does not exist"
            assert sigma_up.stat().st_size > 0, f"{sigma_up} has zero file size"

        if chi2 is not None:
            assert chi2.exists(), f"{chi2} does not exist"
            assert chi2.stat().st_size > 0, f"{chi2} has zero file size"

        return result

    def _validate_dem_coord(
        self,
        DEM_par: Path,
        east: Optional[Path] = None,
        north: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dem_coord.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        if east is not None:
            assert not east.exists(), f"{east} should _not_ exist!"

        if north is not None:
            assert not north.exists(), f"{north} should _not_ exist!"

    def _mock_dem_coord_outputs(
        self,
        DEM_par: Path,
        east: Optional[Path] = None,
        north: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program dem_coord.

        """

        if east is not None and str(east) != "-":
            east.touch()

        if north is not None and str(north) != "-":
            north.touch()

    def dem_coord(
        self,
        DEM_par: Path,
        east: Optional[Path] = None,
        north: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate a 2D map of the east and north coordinates (FLOAT or DOUBLE format)


        input parameters:
          DEM_par (input) DEM parameter file
          east    (output) easting coordinate map, meters or longitude degrees (enter - for none)
          north   (output) northing coordinate map, meters or latitude degrees (enter - for none)
          dtype   data type:
                    0: FLOAT (default)
                    1: DOUBLE
        NOTE: the output maps have the dimensions of the DEM as specified in the DEM parameter file


        """

        if self.validate_inputs:
            self._validate_dem_coord(DEM_par, east, north, dtype)

        if self.mock_outputs:
            self._mock_dem_coord_outputs(DEM_par, east, north, dtype)

        ca = self._clean_args(locals(), inspect.signature(self.dem_coord))
        result = self._gamma_call("DIFF", "dem_coord", ca)

        if east is not None:
            assert east.exists(), f"{east} does not exist"
            assert east.stat().st_size > 0, f"{east} has zero file size"

        if north is not None:
            assert north.exists(), f"{north} does not exist"
            assert north.stat().st_size > 0, f"{north} has zero file size"

        return result

    def _validate_rotate_image(
        self,
        data_in: Path,
        width_in: int,
        angle: float,
        data_out: Path,
        width_out: Optional[int] = None,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rotate_image.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_rotate_image_outputs(
        self,
        data_in: Path,
        width_in: int,
        angle: float,
        data_out: Path,
        width_out: Optional[int] = None,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Mock the program rotate_image.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def rotate_image(
        self,
        data_in: Path,
        width_in: int,
        angle: float,
        data_out: Path,
        width_out: Optional[int] = None,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Rotate an image about the image center by a specifed angle


        input parameters:
          data_in      (input) input data file (format as specified by format_flag parameter)
          width_in     width of input data
          angle        rotation angle, angle > 0: counter-clockwise rotation (deg.)
          data_out     (output) output data file
          width_out    output image width, (enter - for default)
          nlines_out   number of lines in the output image, (enter - for default)
          interp_mode  interpolation mode (enter - for default):
                         0: nearest-neighbor
                         1: bicubic spline (default)
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 5)
                         5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                         6: Lanczos interpolation (default Lanczos function order: 5)
                         7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
          dtype        input and output data format (enter - for default)
                         0: FLOAT (default)
                         1: FCOMPLEX
                         2: SUN/BMP/TIFF format
                         3: UNSIGNED CHAR
                         4: SHORT
                         5: DOUBLE
          order        Lanczos function order or B-spline degree (2->9) (enter - default: 5)

          NOTE: see documentation for information on recommended interpolation modes for different data types


        """

        if self.validate_inputs:
            self._validate_rotate_image(
                data_in,
                width_in,
                angle,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                order,
            )

        if self.mock_outputs:
            self._mock_rotate_image_outputs(
                data_in,
                width_in,
                angle,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                order,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rotate_image))
        result = self._gamma_call("DIFF", "rotate_image", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_geocode_back(
        self,
        data_in: Path,
        width_in: int,
        lookup_table: Path,
        data_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to geocode_back.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_geocode_back_outputs(
        self,
        data_in: Path,
        width_in: int,
        lookup_table: Path,
        data_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program geocode_back.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def geocode_back(
        self,
        data_in: Path,
        width_in: int,
        lookup_table: Path,
        data_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Geocoding of image data using a geocoding lookup table


        input parameters:
          data_in       (input) data file (format as specified by format_flag parameter)
          width_in      width of input data file
          lookup_table  (input) lookup table containing pairs of real-valued input data coordinates
          data_out      (output) output data file
          width_out     width of gc_map lookup table, output file has the same width
          nlines_out    number of lines of output data file (enter - or 0 for default: number of lines in gc_map)
          interp_mode   interpolation mode (enter - for default)
                          0: nearest-neighbor
                          1: bicubic spline (default)
                          2: bicubic-log spline, interpolates log(data)
                          3: bicubic-sqrt spline, interpolates sqrt(data)
                          4: B-spline interpolation (default B-spline degree: 5)
                          5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                          6: Lanczos interpolation (default Lanczos function order: 5)
                          7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                        NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype         input/output data type (enter - for default)
                          0: FLOAT (default)
                          1: FCOMPLEX
                          2: SUN/BMP/TIFF 8 or 24-bit raster image
                          3: UNSIGNED CHAR
                          4: SHORT
                          5: DOUBLE
          lr_in         input  SUN/BMP/TIFF raster image flipped left/right (enter - for default: 1: not flipped (default), -1: flipped)
          lr_out        output SUN/BMP/TIFF raster image flipped left/right (enter - for default: 1: not flipped (default), -1: flipped)
          order         Lanczos function order or B-spline degree (2->9) (enter - default: 5)
          e_flag        extrapolation flag (enter - for default)
                          0: do not extrapolate (default)
                          1: extrapolate up to 0.5 pixels beyond input edges

          NOTE: see documentation for information on recommended interpolation modes for different data types


        """

        if self.validate_inputs:
            self._validate_geocode_back(
                data_in,
                width_in,
                lookup_table,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                lr_in,
                lr_out,
                order,
                e_flag,
            )

        if self.mock_outputs:
            self._mock_geocode_back_outputs(
                data_in,
                width_in,
                lookup_table,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                lr_in,
                lr_out,
                order,
                e_flag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.geocode_back))
        result = self._gamma_call("DIFF", "geocode_back", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_sarpix_coord(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path] = None,
        DEM_par: Optional[Path] = None,
        azlin: Optional[int] = None,
        rpix: Optional[int] = None,
        ref_hgt: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to sarpix_coord.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        if DEM_par is not None:
            assert DEM_par.exists(), f"{DEM_par} does not exist"
            assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

    def _mock_sarpix_coord_outputs(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path] = None,
        DEM_par: Optional[Path] = None,
        azlin: Optional[int] = None,
        rpix: Optional[int] = None,
        ref_hgt: Optional[Path] = None,
    ) -> None:
        """

        Mock the program sarpix_coord.

        """
        pass

    def sarpix_coord(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path] = None,
        DEM_par: Optional[Path] = None,
        azlin: Optional[int] = None,
        rpix: Optional[int] = None,
        ref_hgt: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Transform SAR image coordinates to map projection or geographic (lat/lon) coordinates


        input parameters:
          SLC_par  (input) ISP SLC/MLI parameter file
          OFF_par  (input) ISP offset/interferogram parameter file, enter - for SLC or MLI data
          DEM_par  (input) DEM parameter file, enter - for WGS84 lat/lon
          azlin    SAR image azimuth line
          rpix     SAR image slant range pixel number
          ref_hgt  reference height (m) in map datum


        """

        if self.validate_inputs:
            self._validate_sarpix_coord(SLC_par, OFF_par, DEM_par, azlin, rpix, ref_hgt)

        if self.mock_outputs:
            self._mock_sarpix_coord_outputs(
                SLC_par, OFF_par, DEM_par, azlin, rpix, ref_hgt
            )

        ca = self._clean_args(locals(), inspect.signature(self.sarpix_coord))
        result = self._gamma_call("DIFF", "sarpix_coord", ca)
        return result

    def _validate_resamp_image(
        self,
        data_in: Path,
        width_in: int,
        xscale: int,
        yscale: int,
        data_out: Path,
        width_out: Optional[int] = None,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        e_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to resamp_image.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_resamp_image_outputs(
        self,
        data_in: Path,
        width_in: int,
        xscale: int,
        yscale: int,
        data_out: Path,
        width_out: Optional[int] = None,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        e_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> None:
        """

        Mock the program resamp_image.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def resamp_image(
        self,
        data_in: Path,
        width_in: int,
        xscale: int,
        yscale: int,
        data_out: Path,
        width_out: Optional[int] = None,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        e_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Resample 2D data by linear scale factors and offset in x and y


        input parameters:
          data_in      (input) input data file (format as specified by dtype parameter)
          width_in     width of input data
          xscale       x coordinate (across) scaling factor (0 < xscale <= 100)
          yscale       y coordinate (down) scaling factor (0 < yscale <= 100)
          data_out     (output) output data file
          width_out    output image width, (enter - for default)
          nlines_out   number of lines in the output image, (enter - for default)
          interp_mode  interpolation mode:
                         0: nearest-neighbor
                         1: bicubic spline (default)
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 5)
                         5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                         6: Lanczos interpolation (default Lanczos function order: 5)
                         7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype        input and output data format
                         0: FLOAT (default)
                         1: FCOMPLEX
                         2: SUN/BMP/TIFF format raster image
                         3: UNSIGNED CHAR
                         4: SHORT
                         5: DOUBLE
                         6: SCOMPLEX
          order        Lanczos function order or B-spline degree (2->9) (enter - default: 5)
          xoff         x coordinate (across) offset samples (enter - for default: 0.0)
          yoff         y coordinate (down) offset lines (enter - for default: 0.0)
          e_flag       extrapolation flag (enter - for default)
                         0: do not extrapolate (default)
                         1: extrapolate up to 0.5 pixels beyond input edges
          lpf          low-pass filter amount when downsampling data (0.0 -> no filter, 1.0 -> ensure output is not aliased, enter - for default: 0.0)

          NOTES:
            1. See documentation for information on recommended interpolation modes for different data types
            2. When resampling complex data, the data should either have been deramped, or have their spectrum centered around 0


        """

        if self.validate_inputs:
            self._validate_resamp_image(
                data_in,
                width_in,
                xscale,
                yscale,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                order,
                xoff,
                yoff,
                e_flag,
                lpf,
            )

        if self.mock_outputs:
            self._mock_resamp_image_outputs(
                data_in,
                width_in,
                xscale,
                yscale,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                order,
                xoff,
                yoff,
                e_flag,
                lpf,
            )

        ca = self._clean_args(locals(), inspect.signature(self.resamp_image))
        result = self._gamma_call("DIFF", "resamp_image", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_pol2rec(
        self,
        data1: Path,
        SLC_par1: Path,
        data2: Path,
        SLC_par2: Path,
        pix_size: Path,
        dtype: int,
        imode: Optional[int] = None,
        xmin: Optional[int] = None,
        nx: Optional[int] = None,
        ymin: Optional[int] = None,
        ny: Optional[int] = None,
        rmax: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to pol2rec.

        """

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert SLC_par1.exists(), f"{SLC_par1} does not exist"
        assert SLC_par1.stat().st_size > 0, f"{SLC_par1} has zero file size"

        assert not data2.exists(), f"{data2} should _not_ exist!"

        assert not SLC_par2.exists(), f"{SLC_par2} should _not_ exist!"

        assert not pix_size.exists(), f"{pix_size} should _not_ exist!"

    def _mock_pol2rec_outputs(
        self,
        data1: Path,
        SLC_par1: Path,
        data2: Path,
        SLC_par2: Path,
        pix_size: Path,
        dtype: int,
        imode: Optional[int] = None,
        xmin: Optional[int] = None,
        nx: Optional[int] = None,
        ymin: Optional[int] = None,
        ny: Optional[int] = None,
        rmax: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Mock the program pol2rec.

        """

        if data2 is not None and str(data2) != "-":
            data2.touch()

        if SLC_par2 is not None and str(SLC_par2) != "-":
            SLC_par2.touch()

        if pix_size is not None and str(pix_size) != "-":
            pix_size.touch()

    def pol2rec(
        self,
        data1: Path,
        SLC_par1: Path,
        data2: Path,
        SLC_par2: Path,
        pix_size: Path,
        dtype: int,
        imode: Optional[int] = None,
        xmin: Optional[int] = None,
        nx: Optional[int] = None,
        ymin: Optional[int] = None,
        ny: Optional[int] = None,
        rmax: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Polar to rectangular coordinate conversion for GPRI SLC, interferogram, coherence, and MLI images


        input parameters:
          data1    (input) GPRI data in polar format
          SLC_par1 (input) SLC/MLI image parameter file describing the GPRI image geometry
          data2    (output) GPRI image in rectangular format
          SLC_par2 (output) SLC/MLI image parameter file for the output image
          pix_size (output) output pixel size (meters)
          dtype    input data type:
                     0: FLOAT
                     1: FCOMPLEX
          imode    interpolation algorithm (enter - for default)
                     0: nearest-neighbor
                     1: bicubic spline (default for FCOMPLEX data)
                     2: bicubic-log spline
                     3: bicubic-sqrt spline (default for FLOAT data)
                     4: B-spline interpolation (default B-spline degree: 5)
                     5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                     6: Lanczos interpolation (default Lanczos function order: 5)
                     7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                   NOTE: log and sqrt interpolation modes should only be used with non-negative FLOAT data!
          xmin     starting x coordinate (enter - for default: calculated from image)
          nx       number of x samples in the output image (enter - for default: calculated from image
          ymin     starting y coordinate (enter - for default: calculated from image)
          ny       number of y samples in the output image (enter - for default: calculated from image
          rmax     maximum slant range in the GPRI image to resample (enter - for default: maximum slant range of the input image)
          order    Lanczos function order or B-spline degree (2->9) (enter - for default: 5)
                   NOTE: center image line of the scan defines the direction of the X axis


        """

        if self.validate_inputs:
            self._validate_pol2rec(
                data1,
                SLC_par1,
                data2,
                SLC_par2,
                pix_size,
                dtype,
                imode,
                xmin,
                nx,
                ymin,
                ny,
                rmax,
                order,
            )

        if self.mock_outputs:
            self._mock_pol2rec_outputs(
                data1,
                SLC_par1,
                data2,
                SLC_par2,
                pix_size,
                dtype,
                imode,
                xmin,
                nx,
                ymin,
                ny,
                rmax,
                order,
            )

        ca = self._clean_args(locals(), inspect.signature(self.pol2rec))
        result = self._gamma_call("DIFF", "pol2rec", ca)

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

        assert SLC_par2.exists(), f"{SLC_par2} does not exist"
        assert SLC_par2.stat().st_size > 0, f"{SLC_par2} has zero file size"

        assert pix_size.exists(), f"{pix_size} does not exist"
        assert pix_size.stat().st_size > 0, f"{pix_size} has zero file size"

        return result

    def _validate_WSS_interp(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        DIFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
    ) -> None:
        """

        Validate the arguments to WSS_interp.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert DIFF_par.exists(), f"{DIFF_par} does not exist"
        assert DIFF_par.stat().st_size > 0, f"{DIFF_par} has zero file size"

        assert not SLC_2R.exists(), f"{SLC_2R} should _not_ exist!"

        assert not SLC2R_par.exists(), f"{SLC2R_par} should _not_ exist!"

    def _mock_WSS_interp_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        DIFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
    ) -> None:
        """

        Mock the program WSS_interp.

        """

        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()

        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def WSS_interp(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        DIFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ASAR Wide-Swath complex image resampling using 2-D SINC interpolation


        input parameters:
          SLC-1      (input) ASAR Wide-Swath SLC_1 reference image
          SLC-2      (input) ASAR Wide-Swath SLC-2 image to be resampled to the geometry of the SLC-1 reference image
          SLC1_par   (input) ASAR Wide-Swath SLC-1 image parameter file
          SLC2_par   (input) ASAR Wide-Swath SLC-2 image parameter file
          DIFF_par   (input) DIFF/GEO offset parameter file with offset model
          SLC-2R     (output) ASAR Wide-Swath SLC-2R coregistered to SLC-1
          SLC2R_par  (output) ASAR Wide-Swath SLC-2R image parameter file for coregistered image


        """

        if self.validate_inputs:
            self._validate_WSS_interp(
                SLC_1, SLC_2, SLC1_par, SLC2_par, DIFF_par, SLC_2R, SLC2R_par
            )

        if self.mock_outputs:
            self._mock_WSS_interp_outputs(
                SLC_1, SLC_2, SLC1_par, SLC2_par, DIFF_par, SLC_2R, SLC2R_par
            )

        ca = self._clean_args(locals(), inspect.signature(self.WSS_interp))
        result = self._gamma_call("DIFF", "WSS_interp", ca)

        assert SLC_2R.exists(), f"{SLC_2R} does not exist"
        assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        return result

    def _validate_dop_mlcc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        plot_data: Optional[Path] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dop_mlcc.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        if plot_data is not None:
            assert not plot_data.exists(), f"{plot_data} should _not_ exist!"

    def _mock_dop_mlcc_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        plot_data: Optional[Path] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program dop_mlcc.

        """

        if plot_data is not None and str(plot_data) != "-":
            plot_data.touch()

    def dop_mlcc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        plot_data: Optional[Path] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Doppler ambiguity estimation for IQ SAR data using the MLCC algorithm


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data (I/Q complex)
          plot_data    (output) plot file, correlation phase for MLCC (text format)
                         1: range pixel number
                         2: upper spectrum half mlcc phase (radians)
                         3: lower spectrum half mlcc phase (radians)
                         4: mlcc phase difference between uppler and lower spectrum half (radians)
          loff         number of lines offset (enter - for default=parameter file value)
          nlines       number of range lines to process (default=proc. parameters)


        """

        if self.validate_inputs:
            self._validate_dop_mlcc(
                SAR_par, PROC_par, signal_data, plot_data, loff, nlines
            )

        if self.mock_outputs:
            self._mock_dop_mlcc_outputs(
                SAR_par, PROC_par, signal_data, plot_data, loff, nlines
            )

        ca = self._clean_args(locals(), inspect.signature(self.dop_mlcc))
        result = self._gamma_call("MSP", "dop_mlcc", ca)

        if plot_data is not None:
            assert plot_data.exists(), f"{plot_data} does not exist"
            assert plot_data.stat().st_size > 0, f"{plot_data} has zero file size"

        return result

    def _validate_ERS_proc_ASF_2000(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_ASF_2000.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_ASF_2000_outputs(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> None:
        """

        Mock the program ERS_proc_ASF_2000.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ASF_2000(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing parameters from ASF Level 0 (SKY) CEOS leader after 2000


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par

        NOTE: the SAR sensor parameter files ERS1_ESA.par or ERS2_ESA.par have to be used in the next steps


        """

        if self.validate_inputs:
            self._validate_ERS_proc_ASF_2000(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_ASF_2000_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_ASF_2000))
        result = self._gamma_call("MSP", "ERS_proc_ASF_2000", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_ERS_proc_ASF(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_ASF.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_ASF_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Mock the program ERS_proc_ASF.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ASF(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing parameters (ASF PAF facility)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader
        PROC_par         (output) MSP processing parameters, example p<date>.slc.par


        """

        if self.validate_inputs:
            self._validate_ERS_proc_ASF(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_ASF_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_ASF))
        result = self._gamma_call("MSP", "ERS_proc_ASF", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_doppler_2d(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        dop2d: Path,
        loff: Optional[int] = None,
        blsz: Optional[int] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to doppler_2d.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not dop2d.exists(), f"{dop2d} should _not_ exist!"

    def _mock_doppler_2d_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        dop2d: Path,
        loff: Optional[int] = None,
        blsz: Optional[int] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> None:
        """

        Mock the program doppler_2d.

        """

        if dop2d is not None and str(dop2d) != "-":
            dop2d.touch()

    def doppler_2d(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        dop2d: Path,
        loff: Optional[int] = None,
        blsz: Optional[int] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        2-D Doppler centroid estimation for IQ SAR data


        input parameters:
          SAR_par      (input) SAR sensor parameter file
          PROC_par     (input) processing parameter file
          signal_data  (input) uncompressed IQ raw SAR data file
          dop2d        (output) Doppler centroid as a function of range for each block
          loff         number of lines offset (enter - for default=parameter file value)
          blsz         block size lines (enter - for default = 4096)
          nbl          number of blocks (enter - for default)
          a2_flg       fit a2 for second derivative of the Doppler centroid w.r.t.range (Hz/m/m) (default=0: no  1: yes)
          b0_flg       fit b0 for first derivative of the Doppler centroid w.r.t. along-track time  (Hz/sec) (0: no  default=1: yes)
          b1_flg       fit b1 for along-track rate of the change in slope of Doppler w.r.t. range (Hz/sec/m)(0: no  default=1: yes)
          c0_flg       fit c0 for second derivative of the Doppler centroid w.r.t. along-track time (Hz/sec/sec) (default=0: no 1: yes)
          ambig_flag   Doppler ambiguity resolution flag
                         0 = use unambiguous Doppler Ambiguity Resolver (DAR) estimate (default)
                         1 = command line entry for the Doppler ambiguity number
          namb         user defined number of Doppler ambiguities to add to the Doppler function


        """

        if self.validate_inputs:
            self._validate_doppler_2d(
                SAR_par,
                PROC_par,
                signal_data,
                dop2d,
                loff,
                blsz,
                nbl,
                a2_flg,
                b0_flg,
                b1_flg,
                c0_flg,
                ambig_flag,
                namb,
            )

        if self.mock_outputs:
            self._mock_doppler_2d_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                dop2d,
                loff,
                blsz,
                nbl,
                a2_flg,
                b0_flg,
                b1_flg,
                c0_flg,
                ambig_flag,
                namb,
            )

        ca = self._clean_args(locals(), inspect.signature(self.doppler_2d))
        result = self._gamma_call("MSP", "doppler_2d", ca)

        assert dop2d.exists(), f"{dop2d} does not exist"
        assert dop2d.stat().st_size > 0, f"{dop2d} has zero file size"

        return result

    def _validate_ERS_proc_ESA(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_ESA.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_ESA_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Mock the program ERS_proc_ESA.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ESA(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing parameters from ESA-ESRIN VMP and PGS CEOS format leader files


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file (VMP or PGS CEOS format)
        PROC_par         (output) MSP processing parameter file, (example: p<date>.slc.par)


        """

        if self.validate_inputs:
            self._validate_ERS_proc_ESA(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_ESA_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_ESA))
        result = self._gamma_call("MSP", "ERS_proc_ESA", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_az_proc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        SLC: Path,
        az_patch: Optional[int] = None,
        SLC_format: Optional[int] = None,
        cal_fact: Optional[int] = None,
        SLC_type: Optional[int] = None,
        kaiser: Optional[int] = None,
        npatch: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to az_proc.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert rc_data.exists(), f"{rc_data} does not exist"
        assert rc_data.stat().st_size > 0, f"{rc_data} has zero file size"

        assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_az_proc_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        SLC: Path,
        az_patch: Optional[int] = None,
        SLC_format: Optional[int] = None,
        cal_fact: Optional[int] = None,
        SLC_type: Optional[int] = None,
        kaiser: Optional[int] = None,
        npatch: Optional[int] = None,
    ) -> None:
        """

        Mock the program az_proc.

        """

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def az_proc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        SLC: Path,
        az_patch: Optional[int] = None,
        SLC_format: Optional[int] = None,
        cal_fact: Optional[int] = None,
        SLC_type: Optional[int] = None,
        kaiser: Optional[int] = None,
        npatch: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        SAR Range-Doppler azimuth compression of range-compressed data


        input parameters:
          SAR_par     (input) MSP SAR sensor parameter file
          PROC_par    (input) MSP processing parameter file
          rc_data     (input) input range compressed data file
          SLC         (output) single look complex image file
          az_patch    along-track azimuth patch size (range lines): (N*1024)
          SLC_format  SLC output format (enter - for default, from PROC_par):
                        0: FCOMPLEX, pairs of 4-byte float values
                        1: SCOMPLEX, pairs of 2-byte short integers
          cal_fact    processor radiometric calibration factor (dB), (enter - for default, from PROC_par)
                      NOTE: absolute calibration factors (dB) are listed in sensor_cal_MSP.dat
                            add 60.0 dB to the value from sensor_cal_MSP.dat if SLC_format is SCOMPLEX
          SLC_type    output SLC data type:
                        0: sigma0 = (SQR(re) + SQR(im) (default)
                        1: gamma0 = (SQR(re) + SQR(im)/cos(inc)
          kaiser      Kaiser window parameter for azimuth reference function weighting (enter - for default: 2.120)
          npatch      number of along-track patches to process (default: sufficient for entire file)


        """

        if self.validate_inputs:
            self._validate_az_proc(
                SAR_par,
                PROC_par,
                rc_data,
                SLC,
                az_patch,
                SLC_format,
                cal_fact,
                SLC_type,
                kaiser,
                npatch,
            )

        if self.mock_outputs:
            self._mock_az_proc_outputs(
                SAR_par,
                PROC_par,
                rc_data,
                SLC,
                az_patch,
                SLC_format,
                cal_fact,
                SLC_type,
                kaiser,
                npatch,
            )

        ca = self._clean_args(locals(), inspect.signature(self.az_proc))
        result = self._gamma_call("MSP", "az_proc", ca)

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_dop_interf(
        self, PROC_par1_out: Path, PROC_par2_out: Path, dop: Path
    ) -> None:
        """

        Validate the arguments to dop_interf.

        """

        assert not PROC_par1_out.exists(), f"{PROC_par1_out} should _not_ exist!"

        assert not PROC_par2_out.exists(), f"{PROC_par2_out} should _not_ exist!"

        assert not dop.exists(), f"{dop} should _not_ exist!"

        pass

    def _mock_dop_interf_outputs(
        self, PROC_par1_out: Path, PROC_par2_out: Path, dop: Path
    ) -> None:
        """

        Mock the program dop_interf.

        """

        if PROC_par1_out is not None and str(PROC_par1_out) != "-":
            PROC_par1_out.touch()

        if PROC_par2_out is not None and str(PROC_par2_out) != "-":
            PROC_par2_out.touch()

        if dop is not None and str(dop) != "-":
            dop.touch()

    def dop_interf(
        self, PROC_par1_out: Path, PROC_par2_out: Path, dop: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Doppler parameter optimization for Repeat Track Interferometry v2.2 26-Nov-2003 clw


        input parameters:
          SAR_par1_in      (input) SAR sensor/raw data parameter file for scene 1
          PROC_par1_in     (input) MSP processing parameter file for scene 1
          PROC_par2_in     (input) MSP processing parameter file for scene 2
          PROC_par1_out    (output) MSP processing parameter file for scene 1
          PROC_par2_out    (output) MSP processing parameter file for scene 2
          dop              (output) doppler function as a function of range sample number (plot file)


        """

        if self.validate_inputs:
            self._validate_dop_interf(PROC_par1_out, PROC_par2_out, dop)

        if self.mock_outputs:
            self._mock_dop_interf_outputs(PROC_par1_out, PROC_par2_out, dop)

        ca = self._clean_args(locals(), inspect.signature(self.dop_interf))
        result = self._gamma_call("MSP", "dop_interf", ca)

        assert PROC_par1_out.exists(), f"{PROC_par1_out} does not exist"
        assert PROC_par1_out.stat().st_size > 0, f"{PROC_par1_out} has zero file size"

        assert PROC_par2_out.exists(), f"{PROC_par2_out} does not exist"
        assert PROC_par2_out.stat().st_size > 0, f"{PROC_par2_out} has zero file size"

        assert dop.exists(), f"{dop} does not exist"
        assert dop.stat().st_size > 0, f"{dop} has zero file size"

        return result

    def _validate_CS_proc(
        self,
    ) -> None:
        """

        Validate the arguments to CS_proc.

        """

        pass

    def _mock_CS_proc_outputs(
        self,
    ) -> None:
        """

        Mock the program CS_proc.

        """
        pass

    def CS_proc(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        dyld[71217]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/MSP/bin/CS_proc'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)

        """

        if self.validate_inputs:
            self._validate_CS_proc()

        if self.mock_outputs:
            self._mock_CS_proc_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.CS_proc))
        result = self._gamma_call("MSP", "CS_proc", ca)
        return result

    def _validate_azsp_SLC(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SAR_data: Path,
        spectrum: int,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        data_format: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to azsp_SLC.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert SAR_data.exists(), f"{SAR_data} does not exist"
        assert SAR_data.stat().st_size > 0, f"{SAR_data} has zero file size"

    def _mock_azsp_SLC_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SAR_data: Path,
        spectrum: int,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        data_format: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program azsp_SLC.

        """
        pass

    def azsp_SLC(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SAR_data: Path,
        spectrum: int,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        data_format: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        SAR azimuth spectrum from range compressed or SLC data***


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          SAR_data     (input) input SLC or range compressed data file
          spectrum     output azimuth spectrum
          loff         number of lines offset to start of estimation window (enter - for default:0)
          roff         range samples offset to center of estimation window (enter - for default: center_swath)
          nsub         number of sub-apertures to sum (default: 8)
          data_format  input data format flag (enter - for default: from MSP processing parameter file)
                         0: FCOMPLEX (pairs of 4-byte float)
                         1: SCOMPLEX (pairs of 2-byte short integer)
          pltflg       azimuth spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format


        """

        if self.validate_inputs:
            self._validate_azsp_SLC(
                SAR_par,
                PROC_par,
                SAR_data,
                spectrum,
                loff,
                roff,
                nsub,
                data_format,
                pltflg,
            )

        if self.mock_outputs:
            self._mock_azsp_SLC_outputs(
                SAR_par,
                PROC_par,
                SAR_data,
                spectrum,
                loff,
                roff,
                nsub,
                data_format,
                pltflg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.azsp_SLC))
        result = self._gamma_call("MSP", "azsp_SLC", ca)
        return result

    def _validate_pre_rc_JERS(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rspec: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[int] = None,
        kaiser: Optional[int] = None,
        filt_lm: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to pre_rc_JERS.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert rspec.exists(), f"{rspec} does not exist"
        assert rspec.stat().st_size > 0, f"{rspec} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not rc_data.exists(), f"{rc_data} should _not_ exist!"

    def _mock_pre_rc_JERS_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rspec: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[int] = None,
        kaiser: Optional[int] = None,
        filt_lm: Optional[int] = None,
    ) -> None:
        """

        Mock the program pre_rc_JERS.

        """

        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def pre_rc_JERS(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rspec: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[int] = None,
        kaiser: Optional[int] = None,
        filt_lm: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Prefilter/SAR range compression for JERS-1/PALSAR complex IQ SAR data (swath extension)


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          rspec        (input) range spectra data file for RFI suppression
          signal_data  (input) uncompressed raw SAR signal data filename
          rc_data      (output) range compressed data filename
          prefilt_dec  prefilter decimation factor (enter - for default from PROC_par)
          kaiser       range chirp Kaiser window parameter beta (enter - for default: 2.120, -30 dB sidelobes)
          filt_lm      filter length multiplier, FIR length = FIR_lm * prefilt_dec + 1 (enter - for default: 8)

          NOTE: Updates for the number of range samples, number of offset lines, number of lines to process,
                and the swath extension parameter values must occur when running program rspec_JERS.


        """

        if self.validate_inputs:
            self._validate_pre_rc_JERS(
                SAR_par,
                PROC_par,
                rspec,
                signal_data,
                rc_data,
                prefilt_dec,
                kaiser,
                filt_lm,
            )

        if self.mock_outputs:
            self._mock_pre_rc_JERS_outputs(
                SAR_par,
                PROC_par,
                rspec,
                signal_data,
                rc_data,
                prefilt_dec,
                kaiser,
                filt_lm,
            )

        ca = self._clean_args(locals(), inspect.signature(self.pre_rc_JERS))
        result = self._gamma_call("MSP", "pre_rc_JERS", ca)

        assert rc_data.exists(), f"{rc_data} does not exist"
        assert rc_data.stat().st_size > 0, f"{rc_data} has zero file size"

        return result

    def _validate_ERS_proc_NASDA(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_NASDA.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_NASDA_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Mock the program ERS_proc_NASDA.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_NASDA(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        SAR processing parameters (Japan NASDA PAF)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par


        """

        if self.validate_inputs:
            self._validate_ERS_proc_NASDA(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_NASDA_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_NASDA))
        result = self._gamma_call("MSP", "ERS_proc_NASDA", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_ERS_proc_ARG(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_ARG.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_ARG_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Mock the program ERS_proc_ARG.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ARG(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing parameters from CEOS leader produced by the Argentina PAF ACS processor


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file Argentina PAF
        PROC_par         (output) MSP processing parameter file, (example p<date>.slc.par)


        """

        if self.validate_inputs:
            self._validate_ERS_proc_ARG(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_ARG_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_ARG))
        result = self._gamma_call("MSP", "ERS_proc_ARG", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_PALSAR_proc(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        raw_out: Optional[Path] = None,
        TX_POL: Optional[int] = None,
        RX_POL: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to PALSAR_proc.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not SAR_par.exists(), f"{SAR_par} should _not_ exist!"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

        assert CEOS_raw_data.exists(), f"{CEOS_raw_data} does not exist"
        assert CEOS_raw_data.stat().st_size > 0, f"{CEOS_raw_data} has zero file size"

        if raw_out is not None:
            assert not raw_out.exists(), f"{raw_out} should _not_ exist!"

    def _mock_PALSAR_proc_outputs(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        raw_out: Optional[Path] = None,
        TX_POL: Optional[int] = None,
        RX_POL: Optional[int] = None,
    ) -> None:
        """

        Mock the program PALSAR_proc.

        """

        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

        if raw_out is not None and str(raw_out) != "-":
            raw_out.touch()

    def PALSAR_proc(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        raw_out: Optional[Path] = None,
        TX_POL: Optional[int] = None,
        RX_POL: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        PALSAR raw data pre-processing and generation of the MSP processing parameter file


        input parameters:
          CEOS_SAR_leader  (input) CEOS SAR leader file for PALSAR (LED...)
          SAR_par          (output) MSP sensor parameter file
          PROC_par         (output) MSP processing parameter file
          CEOS_raw_data    (input)  PALSAR CEOS format raw data file (IMG...)
          raw_out          (output) PALSAR range aligned raw data output (enter - for none)
          TX_POL           extracted channel transmit polarization:
                             0: H (default)
                             1: V
          RX_POL           extracted channel receive polarization:
                             0: H (default)
                             1: V

        NOTE: For EORC data, TX_POL and RX_POL are used to document the polarization in the MSP PROC_par file.
              For ERSDAC data, these parameters are used to extract the specified raw data channel. In dual-pol
              mode, the value of TX_POL is derived from the SAR metadata and the command line value is ignored.
              In single-pol mode, the TX_POL and RX_POL values are derived from the SAR metadata alone and
              the command line values are ignored.


        """

        if self.validate_inputs:
            self._validate_PALSAR_proc(
                CEOS_SAR_leader, SAR_par, PROC_par, CEOS_raw_data, raw_out, TX_POL, RX_POL
            )

        if self.mock_outputs:
            self._mock_PALSAR_proc_outputs(
                CEOS_SAR_leader, SAR_par, PROC_par, CEOS_raw_data, raw_out, TX_POL, RX_POL
            )

        ca = self._clean_args(locals(), inspect.signature(self.PALSAR_proc))
        result = self._gamma_call("MSP", "PALSAR_proc", ca)

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        if raw_out is not None:
            assert raw_out.exists(), f"{raw_out} does not exist"
            assert raw_out.stat().st_size > 0, f"{raw_out} has zero file size"

        return result

    def _validate_rspec_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[int] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rspec_real.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not range_spec.exists(), f"{range_spec} should _not_ exist!"

    def _mock_rspec_real_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[int] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program rspec_real.

        """

        if range_spec is not None and str(range_spec) != "-":
            range_spec.touch()

    def rspec_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[int] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Range spectrum estimation for offset video raw data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          range_spec   (output) range spectrum
          loff         offset echoes from start of raw data file (enter - for default from PROC_par file)
          nlspec       number of lines to estimate spectrum (enter - for default: 1024)
          nrfft        range FFT size (enter - for default: 4096)
          pltflg       range spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format

        """

        if self.validate_inputs:
            self._validate_rspec_real(
                SAR_par, PROC_par, signal_data, range_spec, loff, nlspec, nrfft, pltflg
            )

        if self.mock_outputs:
            self._mock_rspec_real_outputs(
                SAR_par, PROC_par, signal_data, range_spec, loff, nlspec, nrfft, pltflg
            )

        ca = self._clean_args(locals(), inspect.signature(self.rspec_real))
        result = self._gamma_call("MSP", "rspec_real", ca)

        assert range_spec.exists(), f"{range_spec} does not exist"
        assert range_spec.stat().st_size > 0, f"{range_spec} has zero file size"

        return result

    def _validate_rspec_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[int] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[int] = None,
        roff: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rspec_IQ.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not range_spec.exists(), f"{range_spec} should _not_ exist!"

    def _mock_rspec_IQ_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[int] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[int] = None,
        roff: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program rspec_IQ.

        """

        if range_spec is not None and str(range_spec) != "-":
            range_spec.touch()

    def rspec_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[int] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[int] = None,
        roff: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Range spectrum estimation for IQ raw SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data
          range_spec   (output) range spectrum plot file (text)
          loff         offset echoes from start of raw data file (enter - for default: PROC_par)
          nlspec       number of lines to estimate spectrum (enter - for default: 4096)
          nrfft        range FFT size (enter - for default: 4096)
          roff         range offset in samples (enter - for default: PROC_par)
          pltflg       range spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format

        """

        if self.validate_inputs:
            self._validate_rspec_IQ(
                SAR_par,
                PROC_par,
                signal_data,
                range_spec,
                loff,
                nlspec,
                nrfft,
                roff,
                pltflg,
            )

        if self.mock_outputs:
            self._mock_rspec_IQ_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                range_spec,
                loff,
                nlspec,
                nrfft,
                roff,
                pltflg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rspec_IQ))
        result = self._gamma_call("MSP", "rspec_IQ", ca)

        assert range_spec.exists(), f"{range_spec} does not exist"
        assert range_spec.stat().st_size > 0, f"{range_spec} has zero file size"

        return result

    def _validate_af(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SLC: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        thres: Optional[float] = None,
        update_flg: Optional[int] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        dac_flg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to af.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

    def _mock_af_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SLC: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        thres: Optional[float] = None,
        update_flg: Optional[int] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        dac_flg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
    ) -> None:
        """

        Mock the program af.

        """

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

    def af(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SLC: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        thres: Optional[float] = None,
        update_flg: Optional[int] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        dac_flg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Autofocus estimation of effective velocity for SAR processing


        input parameters:
          SAR_par    (input) MSP SAR sensor parameter file
          PROC_par   (input) MSP processing parameter file
          SLC        (input) single-look complex image
          rwin       range window size (enter - for default: 1024)
          azwin      azimuth window size (enter - for default: 4096)
          dr         range sample increment (enter - for default: 1024,  enter 0 for single patch)
          daz        azimuth line increment (enter - for default: 8192,  enter 0 for single patch)
          thres      offset estimation SNR threshold (enter - for default:   10.000)
          update_flg update effective velocity flag (enter - for default: 1)
                       0: no update of effective velocity in PROC_par file
                       1: update effective velocity in PROC_par (default)
          a1_flg     fit a1 for first derivative of the effective velocity w.r.t.range
                       0: no (default)
                       1: yes
          b0_flg     fit b0 for first derivative of the effective velocity w.r.t. along-track time
                       0: no (default)
                       1: yes
          offsets    (output) range and azimuth offsets and SNR data in text format, enter - for no output
          dac_flg    Doppler ambiguity correction flag
                       0: Doppler centroid remains unchanged: exit if Doppler ambiguity error detected
                       1: Doppler centroid ambiguity corrected (default)
          n_ovr      SLC oversampling factor (1,2,4: enter - for default: 1)
          roff       range offset for single patch center
          azoff      azimuth offset for single patch center

        """

        if self.validate_inputs:
            self._validate_af(
                SAR_par,
                PROC_par,
                SLC,
                rwin,
                azwin,
                dr,
                daz,
                thres,
                update_flg,
                a1_flg,
                b0_flg,
                offsets,
                dac_flg,
                n_ovr,
                roff,
                azoff,
            )

        if self.mock_outputs:
            self._mock_af_outputs(
                SAR_par,
                PROC_par,
                SLC,
                rwin,
                azwin,
                dr,
                daz,
                thres,
                update_flg,
                a1_flg,
                b0_flg,
                offsets,
                dac_flg,
                n_ovr,
                roff,
                azoff,
            )

        ca = self._clean_args(locals(), inspect.signature(self.af))
        result = self._gamma_call("MSP", "af", ca)

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        return result

    def _validate_hist_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to hist_IQ.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

    def _mock_hist_IQ_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Mock the program hist_IQ.

        """
        pass

    def hist_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        IQ histogram estimation of raw SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          histogram    (output) histogram (text format)
          loff         number of lines offset (default = parameter file value)
          nl           number of lines to estimate historgram (default=1024)


        """

        if self.validate_inputs:
            self._validate_hist_IQ(SAR_par, PROC_par, signal_data, loff, nl)

        if self.mock_outputs:
            self._mock_hist_IQ_outputs(SAR_par, PROC_par, signal_data, loff, nl)

        ca = self._clean_args(locals(), inspect.signature(self.hist_IQ))
        result = self._gamma_call("MSP", "hist_IQ", ca)
        return result

    def _validate_PALSAR_burst_sync(
        self,
        SAR_par1: Path,
        PROC_par1: Path,
        raw1: Path,
        SAR_par2: Path,
        PROC_par2: Path,
        raw2: Path,
        PROC_par1_out: Path,
        raw1_out: Path,
        PROC_par2_out: Path,
        raw2_out: Path,
    ) -> None:
        """

        Validate the arguments to PALSAR_burst_sync.

        """

        assert SAR_par1.exists(), f"{SAR_par1} does not exist"
        assert SAR_par1.stat().st_size > 0, f"{SAR_par1} has zero file size"

        assert PROC_par1.exists(), f"{PROC_par1} does not exist"
        assert PROC_par1.stat().st_size > 0, f"{PROC_par1} has zero file size"

        assert raw1.exists(), f"{raw1} does not exist"
        assert raw1.stat().st_size > 0, f"{raw1} has zero file size"

        assert SAR_par2.exists(), f"{SAR_par2} does not exist"
        assert SAR_par2.stat().st_size > 0, f"{SAR_par2} has zero file size"

        assert PROC_par2.exists(), f"{PROC_par2} does not exist"
        assert PROC_par2.stat().st_size > 0, f"{PROC_par2} has zero file size"

        assert raw2.exists(), f"{raw2} does not exist"
        assert raw2.stat().st_size > 0, f"{raw2} has zero file size"

        assert not PROC_par1_out.exists(), f"{PROC_par1_out} should _not_ exist!"

        assert not raw1_out.exists(), f"{raw1_out} should _not_ exist!"

        assert not PROC_par2_out.exists(), f"{PROC_par2_out} should _not_ exist!"

        assert not raw2_out.exists(), f"{raw2_out} should _not_ exist!"

    def _mock_PALSAR_burst_sync_outputs(
        self,
        SAR_par1: Path,
        PROC_par1: Path,
        raw1: Path,
        SAR_par2: Path,
        PROC_par2: Path,
        raw2: Path,
        PROC_par1_out: Path,
        raw1_out: Path,
        PROC_par2_out: Path,
        raw2_out: Path,
    ) -> None:
        """

        Mock the program PALSAR_burst_sync.

        """

        if PROC_par1_out is not None and str(PROC_par1_out) != "-":
            PROC_par1_out.touch()

        if raw1_out is not None and str(raw1_out) != "-":
            raw1_out.touch()

        if PROC_par2_out is not None and str(PROC_par2_out) != "-":
            PROC_par2_out.touch()

        if raw2_out is not None and str(raw2_out) != "-":
            raw2_out.touch()

    def PALSAR_burst_sync(
        self,
        SAR_par1: Path,
        PROC_par1: Path,
        raw1: Path,
        SAR_par2: Path,
        PROC_par2: Path,
        raw2: Path,
        PROC_par1_out: Path,
        raw1_out: Path,
        PROC_par2_out: Path,
        raw2_out: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        PALSAR ScanSAR azimuth burst synchronization


        input parameters:
          SAR_par1      (input) MSP sensor parameter file for track-1 (reference)
          PROC_par1     (input) MSP processing parameter file for track-1 (reference)
          raw1         (input) WB ScanSAR data track-1
          SAR_par2      (input) MSP sensor parameter file for track-2
          PROC_par2     (input) MSP processing parameter file for track-2
          raw2         (input) WB ScanSAR or FBS raw data track-2
          PROC_par1_out (output) MSP processing parameter file for burst sync. track-1
          raw1_out      (output) WB ScanSAR data for burst sync. track-1
          PROC_par2_out (output) MSP processing parameter file for burst sync. track-2
          raw2_out      (output) WB ScanSAR data for burst sync. track-2

        """

        if self.validate_inputs:
            self._validate_PALSAR_burst_sync(
                SAR_par1,
                PROC_par1,
                raw1,
                SAR_par2,
                PROC_par2,
                raw2,
                PROC_par1_out,
                raw1_out,
                PROC_par2_out,
                raw2_out,
            )

        if self.mock_outputs:
            self._mock_PALSAR_burst_sync_outputs(
                SAR_par1,
                PROC_par1,
                raw1,
                SAR_par2,
                PROC_par2,
                raw2,
                PROC_par1_out,
                raw1_out,
                PROC_par2_out,
                raw2_out,
            )

        ca = self._clean_args(locals(), inspect.signature(self.PALSAR_burst_sync))
        result = self._gamma_call("MSP", "PALSAR_burst_sync", ca)

        assert PROC_par1_out.exists(), f"{PROC_par1_out} does not exist"
        assert PROC_par1_out.stat().st_size > 0, f"{PROC_par1_out} has zero file size"

        assert raw1_out.exists(), f"{raw1_out} does not exist"
        assert raw1_out.stat().st_size > 0, f"{raw1_out} has zero file size"

        assert PROC_par2_out.exists(), f"{PROC_par2_out} does not exist"
        assert PROC_par2_out.stat().st_size > 0, f"{PROC_par2_out} has zero file size"

        assert raw2_out.exists(), f"{raw2_out} does not exist"
        assert raw2_out.stat().st_size > 0, f"{raw2_out} has zero file size"

        return result

    def _validate_swap_IQ(self, SAR_par: Path, raw_IQ: Path, raw_IQ_swap: Path) -> None:
        """

        Validate the arguments to swap_IQ.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert raw_IQ.exists(), f"{raw_IQ} does not exist"
        assert raw_IQ.stat().st_size > 0, f"{raw_IQ} has zero file size"

        assert not raw_IQ_swap.exists(), f"{raw_IQ_swap} should _not_ exist!"

    def _mock_swap_IQ_outputs(
        self, SAR_par: Path, raw_IQ: Path, raw_IQ_swap: Path
    ) -> None:
        """

        Mock the program swap_IQ.

        """

        if raw_IQ_swap is not None and str(raw_IQ_swap) != "-":
            raw_IQ_swap.touch()

    def swap_IQ(
        self, SAR_par: Path, raw_IQ: Path, raw_IQ_swap: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Swap IQ of complex raw SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          raw_IQ       (input) input uncompressed SAR data
          raw_IQ_swap  (output) output raw data with IQ swapped


        """

        if self.validate_inputs:
            self._validate_swap_IQ(SAR_par, raw_IQ, raw_IQ_swap)

        if self.mock_outputs:
            self._mock_swap_IQ_outputs(SAR_par, raw_IQ, raw_IQ_swap)

        ca = self._clean_args(locals(), inspect.signature(self.swap_IQ))
        result = self._gamma_call("MSP", "swap_IQ", ca)

        assert raw_IQ_swap.exists(), f"{raw_IQ_swap} does not exist"
        assert raw_IQ_swap.stat().st_size > 0, f"{raw_IQ_swap} has zero file size"

        return result

    def _validate_dop_ambig(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        algorithm: Optional[int] = None,
        loff: Optional[int] = None,
        output_plot: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to dop_ambig.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        if output_plot is not None:
            assert not output_plot.exists(), f"{output_plot} should _not_ exist!"

    def _mock_dop_ambig_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        algorithm: Optional[int] = None,
        loff: Optional[int] = None,
        output_plot: Optional[Path] = None,
    ) -> None:
        """

        Mock the program dop_ambig.

        """

        if output_plot is not None and str(output_plot) != "-":
            output_plot.touch()

    def dop_ambig(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        algorithm: Optional[int] = None,
        loff: Optional[int] = None,
        output_plot: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Doppler ambiguity estimation for IQ SAR raw data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data (I/Q complex)
          algorithm    algorithm selection:
                         1: Multi-Look Cross Correlation (MLCC)
                         2: Multi-Look Beat Frequency (MLBF) (default)
          loff         number of lines offset (enter - for default: parameter file value)
          output_plot  (output) plot file: correlation phase for MLCC, azimuth spectrum for MLBF

        """

        if self.validate_inputs:
            self._validate_dop_ambig(
                SAR_par, PROC_par, signal_data, algorithm, loff, output_plot
            )

        if self.mock_outputs:
            self._mock_dop_ambig_outputs(
                SAR_par, PROC_par, signal_data, algorithm, loff, output_plot
            )

        ca = self._clean_args(locals(), inspect.signature(self.dop_ambig))
        result = self._gamma_call("MSP", "dop_ambig", ca)

        if output_plot is not None:
            assert output_plot.exists(), f"{output_plot} does not exist"
            assert output_plot.stat().st_size > 0, f"{output_plot} has zero file size"

        return result

    def _validate_PRC_proc(
        self, PROC_par: Path, PRC: int, nstate: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to PRC_proc.

        """

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

    def _mock_PRC_proc_outputs(
        self, PROC_par: Path, PRC: int, nstate: Optional[int] = None
    ) -> None:
        """

        Mock the program PRC_proc.

        """
        pass

    def PRC_proc(
        self, PROC_par: Path, PRC: int, nstate: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        State vectors  from ERS PRC orbit data for MSP processing


        input parameters:
          PROC_par  (input) MSP processing parameter file
          PRC       PRC state vector file
          nstate    number of state vectors (default=5, maximum=64)


        """

        if self.validate_inputs:
            self._validate_PRC_proc(PROC_par, PRC, nstate)

        if self.mock_outputs:
            self._mock_PRC_proc_outputs(PROC_par, PRC, nstate)

        ca = self._clean_args(locals(), inspect.signature(self.PRC_proc))
        result = self._gamma_call("MSP", "PRC_proc", ca)
        return result

    def _validate_rc_fmcw(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        nrc_off: int,
        nrc_samp: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rc_fmcw.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not rc_data.exists(), f"{rc_data} should _not_ exist!"

    def _mock_rc_fmcw_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        nrc_off: int,
        nrc_samp: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[int] = None,
    ) -> None:
        """

        Mock the program rc_fmcw.

        """

        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def rc_fmcw(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        nrc_off: int,
        nrc_samp: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        SAR range compression for offset-video FMCW radar data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          rc_data      (output) output range compressed data filename
          nrc_off      offset to the first sample of the output range-compressed data (samples)
          nrc_samp     number of samples in the output range-compressed data (enter - for default)
          loff         number of lines offset (enter - for default)
          nl           number of lines to range compress (enter - for default)
          kaiser       range chirp Kaiser window parameter beta (enter - for default)

        """

        if self.validate_inputs:
            self._validate_rc_fmcw(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                nrc_off,
                nrc_samp,
                loff,
                nl,
                kaiser,
            )

        if self.mock_outputs:
            self._mock_rc_fmcw_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                nrc_off,
                nrc_samp,
                loff,
                nl,
                kaiser,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rc_fmcw))
        result = self._gamma_call("MSP", "rc_fmcw", ca)

        assert rc_data.exists(), f"{rc_data} does not exist"
        assert rc_data.stat().st_size > 0, f"{rc_data} has zero file size"

        return result

    def _validate_RSAT_lks(
        self,
        SLC_PROC_par: Path,
        MLI_PROC_par: Path,
        SLC_image: Path,
        kaiser: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to RSAT_lks.

        """

        assert SLC_PROC_par.exists(), f"{SLC_PROC_par} does not exist"
        assert SLC_PROC_par.stat().st_size > 0, f"{SLC_PROC_par} has zero file size"

        assert not MLI_PROC_par.exists(), f"{MLI_PROC_par} should _not_ exist!"

        assert SLC_image.exists(), f"{SLC_image} does not exist"
        assert SLC_image.stat().st_size > 0, f"{SLC_image} has zero file size"

    def _mock_RSAT_lks_outputs(
        self,
        SLC_PROC_par: Path,
        MLI_PROC_par: Path,
        SLC_image: Path,
        kaiser: Optional[int] = None,
    ) -> None:
        """

        Mock the program RSAT_lks.

        """

        if MLI_PROC_par is not None and str(MLI_PROC_par) != "-":
            MLI_PROC_par.touch()

    def RSAT_lks(
        self,
        SLC_PROC_par: Path,
        MLI_PROC_par: Path,
        SLC_image: Path,
        kaiser: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        RADARSAT SLC --> RADARSAT multilook image calculation


        input parameters:
          SLC_PROC_par  (input) MSP SLC processing parameter file
          MLI_PROC_par  (output) MLI processing parameter file
          SLC_image     (input) SLC image file
          MLI_image     (output) MLI image
          kaiser        Kaiser window parameter (default=2.9)


        """

        if self.validate_inputs:
            self._validate_RSAT_lks(SLC_PROC_par, MLI_PROC_par, SLC_image, kaiser)

        if self.mock_outputs:
            self._mock_RSAT_lks_outputs(SLC_PROC_par, MLI_PROC_par, SLC_image, kaiser)

        ca = self._clean_args(locals(), inspect.signature(self.RSAT_lks))
        result = self._gamma_call("MSP", "RSAT_lks", ca)

        assert MLI_PROC_par.exists(), f"{MLI_PROC_par} does not exist"
        assert MLI_PROC_par.stat().st_size > 0, f"{MLI_PROC_par} has zero file size"

        return result

    def _validate_extract_psd(self, num: int) -> None:
        """

        Validate the arguments to extract_psd.

        """

        pass

    def _mock_extract_psd_outputs(self, num: int) -> None:
        """

        Mock the program extract_psd.

        """
        pass

    def extract_psd(self, num: int) -> Tuple[int, List[str], List[str]]:
        """

        Extract single spectrum from binary format range spectra file


        input parameters:
          range_spec    range spectra data file (binary format from rspec_JERS.c)
          num           spectrum number (1 --> rsp.nspec)
          output        output spectrum (text format for plotting)


        """

        if self.validate_inputs:
            self._validate_extract_psd(num)

        if self.mock_outputs:
            self._mock_extract_psd_outputs(num)

        ca = self._clean_args(locals(), inspect.signature(self.extract_psd))
        result = self._gamma_call("MSP", "extract_psd", ca)
        return result

    def _validate_doppler_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to doppler_real.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not doppler.exists(), f"{doppler} should _not_ exist!"

    def _mock_doppler_real_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> None:
        """

        Mock the program doppler_real.

        """

        if doppler is not None and str(doppler) != "-":
            doppler.touch()

    def doppler_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Doppler centroid estimation (offset_video real valued data)


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed IQ raw SAR data file
          doppler      (output) Doppler as a function of slant range (text format)
          loff         number of lines offset (enter - for default=parameter file value)
          nsub         number of azimuth subapertures (default = 12)
          ambig_flag   Doppler ambiguity resolution flag
                         0 = use unambiguous Doppler Ambiguity Resolver (DAR) estimate (default)
                         1 = estimate Doppler ambiguity number from the Doppler slope
                         2 = command line entry for the Doppler ambiguity number
          namb         User defined number of Doppler ambiguities to add to the Doppler function


        """

        if self.validate_inputs:
            self._validate_doppler_real(
                SAR_par, PROC_par, signal_data, doppler, loff, nsub, ambig_flag, namb
            )

        if self.mock_outputs:
            self._mock_doppler_real_outputs(
                SAR_par, PROC_par, signal_data, doppler, loff, nsub, ambig_flag, namb
            )

        ca = self._clean_args(locals(), inspect.signature(self.doppler_real))
        result = self._gamma_call("MSP", "doppler_real", ca)

        assert doppler.exists(), f"{doppler} does not exist"
        assert doppler.stat().st_size > 0, f"{doppler} has zero file size"

        return result

    def _validate_pre_rc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[int] = None,
        filt_lm: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
        pre_ext: Optional[int] = None,
        post_ext: Optional[int] = None,
        RFI_filt: Optional[int] = None,
        RFI_thres: Optional[int] = None,
        fc_offset: Optional[int] = None,
        win_bw: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to pre_rc.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not rc_data.exists(), f"{rc_data} should _not_ exist!"

    def _mock_pre_rc_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[int] = None,
        filt_lm: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
        pre_ext: Optional[int] = None,
        post_ext: Optional[int] = None,
        RFI_filt: Optional[int] = None,
        RFI_thres: Optional[int] = None,
        fc_offset: Optional[int] = None,
        win_bw: Optional[int] = None,
    ) -> None:
        """

        Mock the program pre_rc.

        """

        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def pre_rc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[int] = None,
        filt_lm: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
        pre_ext: Optional[int] = None,
        post_ext: Optional[int] = None,
        RFI_filt: Optional[int] = None,
        RFI_thres: Optional[int] = None,
        fc_offset: Optional[int] = None,
        win_bw: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        SAR data prefilter and range compression for complex IQ data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw IQ SAR signal data
          rc_data      (output) range compressed data filename
          prefilt_dec  prefilter decimation factor (enter - for default from PROC_par)
          loff         number of lines offset from start of file (enter - for default from PROC_par)
          nl           number of lines to range compress (enter - for default from PROC_par)
          nr_samp      number of range samples (enter - for default from PROC_par)
          kaiser       range chirp Kaiser window parameter beta (enter - for default: 2.120)
          filt_lm      filter length multiplier, FIR length = FIR_lm * prefilt_dec + 1 (enter - for default: 8)
          nr_ext       near-range swath extension in samples (enter - for default from PROC_par)
          fr_ext       far-range swath extension in samples  (enter - for default from PROC_par)
          pre_ext      pre-azimuth data extension in echoes  (enter - for default from PROC_par)
          post_ext     post-azimuth data extension in echoes (enter - for default from PROC_par)
          RFI_filt     RFI suppression filtering (enter - for default):
                         0:OFF (default)
                         1:ON
          RFI_thres    RFI detection threshold, nominal range 1.1-->1.6 (enter - for default= 1.500)
          fc_offset    offset of the center of the chirp window as a fraction of the chirp bandwidth, range -0.5 to 0.5 (enter - for default: 0.0)
          win_bw       chirp window bandwidth as a fraction of chirp bandwidth, range: 0.0 to 1.0 (enter - for default: 1.0)


        """

        if self.validate_inputs:
            self._validate_pre_rc(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                prefilt_dec,
                loff,
                nl,
                nr_samp,
                kaiser,
                filt_lm,
                nr_ext,
                fr_ext,
                pre_ext,
                post_ext,
                RFI_filt,
                RFI_thres,
                fc_offset,
                win_bw,
            )

        if self.mock_outputs:
            self._mock_pre_rc_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                prefilt_dec,
                loff,
                nl,
                nr_samp,
                kaiser,
                filt_lm,
                nr_ext,
                fr_ext,
                pre_ext,
                post_ext,
                RFI_filt,
                RFI_thres,
                fc_offset,
                win_bw,
            )

        ca = self._clean_args(locals(), inspect.signature(self.pre_rc))
        result = self._gamma_call("MSP", "pre_rc", ca)

        assert rc_data.exists(), f"{rc_data} does not exist"
        assert rc_data.stat().st_size > 0, f"{rc_data} has zero file size"

        return result

    def _validate_PALSAR_proc_WB(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        beam: Path,
        raw_out: Optional[Path] = None,
        prf: Optional[Path] = None,
        wflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to PALSAR_proc_WB.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not SAR_par.exists(), f"{SAR_par} should _not_ exist!"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

        assert CEOS_raw_data.exists(), f"{CEOS_raw_data} does not exist"
        assert CEOS_raw_data.stat().st_size > 0, f"{CEOS_raw_data} has zero file size"

        assert beam.exists(), f"{beam} does not exist"
        assert beam.stat().st_size > 0, f"{beam} has zero file size"

        if raw_out is not None:
            assert not raw_out.exists(), f"{raw_out} should _not_ exist!"

        if prf is not None:
            assert prf.exists(), f"{prf} does not exist"
            assert prf.stat().st_size > 0, f"{prf} has zero file size"

    def _mock_PALSAR_proc_WB_outputs(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        beam: Path,
        raw_out: Optional[Path] = None,
        prf: Optional[Path] = None,
        wflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program PALSAR_proc_WB.

        """

        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

        if raw_out is not None and str(raw_out) != "-":
            raw_out.touch()

    def PALSAR_proc_WB(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        beam: Path,
        raw_out: Optional[Path] = None,
        prf: Optional[Path] = None,
        wflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        PALSAR ScanSAR raw data pre-processing and generation of the MSP processing parameters


        input parameters:
          CEOS_SAR_leader  (input) CEOS SAR leader file for PALSAR (LED...)
          SAR_par          (output) MSP sensor parameter file
          PROC_par         (output) MSP processing parameter file
          CEOS_raw_data    (input)  PALSAR CEOS format raw data file (IMG...)
          beam             (input)  beam number (1 --> 5)
          raw_out          (output) PALSAR range aligned raw data output (enter - for none)
          prf              (input)  PRF of the resampled data, (enter - for default: beam 4 PRF)
          wflg             (input) burst window weighting flag (enter - for default):
                             0: no window applied to bursts (default)
                             1: apply Kaiser window to each burst

        """

        if self.validate_inputs:
            self._validate_PALSAR_proc_WB(
                CEOS_SAR_leader,
                SAR_par,
                PROC_par,
                CEOS_raw_data,
                beam,
                raw_out,
                prf,
                wflg,
            )

        if self.mock_outputs:
            self._mock_PALSAR_proc_WB_outputs(
                CEOS_SAR_leader,
                SAR_par,
                PROC_par,
                CEOS_raw_data,
                beam,
                raw_out,
                prf,
                wflg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.PALSAR_proc_WB))
        result = self._gamma_call("MSP", "PALSAR_proc_WB", ca)

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        if raw_out is not None:
            assert raw_out.exists(), f"{raw_out} does not exist"
            assert raw_out.stat().st_size > 0, f"{raw_out} has zero file size"

        return result

    def _validate_ORRM_proc(
        self, PROC_par: Path, ORRM: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to ORRM_proc.

        """

        assert ORRM.exists(), f"{ORRM} does not exist"
        assert ORRM.stat().st_size > 0, f"{ORRM} has zero file size"

    def _mock_ORRM_proc_outputs(
        self, PROC_par: Path, ORRM: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Mock the program ORRM_proc.

        """

        if not PROC_par.exists():
            PROC_par.touch()

    def ORRM_proc(
        self, PROC_par: Path, ORRM: Path, nstate: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract state vectors from ORRM file for processing parameter file


        input parameters:
          PROC_par  (input/output) MSP processing parameter file
          ORRM      (input) ORRM state vector file
          nstate    number of state vectors (default=5, maximum=64)


        """

        if self.validate_inputs:
            self._validate_ORRM_proc(PROC_par, ORRM, nstate)

        if self.mock_outputs:
            self._mock_ORRM_proc_outputs(PROC_par, ORRM, nstate)

        ca = self._clean_args(locals(), inspect.signature(self.ORRM_proc))
        result = self._gamma_call("MSP", "ORRM_proc", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_ERS_proc_UK(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_UK.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_UK_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Mock the program ERS_proc_UK.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_UK(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing parameters (UK-PAF, QinetiQ)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par)


        """

        if self.validate_inputs:
            self._validate_ERS_proc_UK(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_UK_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_UK))
        result = self._gamma_call("MSP", "ERS_proc_UK", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_RSAT_raw(
        self, SAR_par: Path, PROC_par: Path, raw_data_files: Path, raw_out: Path
    ) -> None:
        """

        Validate the arguments to RSAT_raw.

        """

        assert not SAR_par.exists(), f"{SAR_par} should _not_ exist!"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

        assert raw_data_files.exists(), f"{raw_data_files} does not exist"
        assert raw_data_files.stat().st_size > 0, f"{raw_data_files} has zero file size"

        assert not raw_out.exists(), f"{raw_out} should _not_ exist!"

    def _mock_RSAT_raw_outputs(
        self, SAR_par: Path, PROC_par: Path, raw_data_files: Path, raw_out: Path
    ) -> None:
        """

        Mock the program RSAT_raw.

        """

        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

        if raw_out is not None and str(raw_out) != "-":
            raw_out.touch()

    def RSAT_raw(
        self, SAR_par: Path, PROC_par: Path, raw_data_files: Path, raw_out: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        RADARSAT raw data reformatting + generation of MSP processing parameter files


        input parameters:
          CEOS_ldr        (input) CEOS leader file
          SAR_par         (output) MSP SAR sensor parameter file
          PROC_par        (output) MSP processing parameter file
          raw_data_files  (input) Radarsat raw data file(s) to condition and concatenate
          raw_out         (output) Radarsat conditioned raw output data file


        """

        if self.validate_inputs:
            self._validate_RSAT_raw(SAR_par, PROC_par, raw_data_files, raw_out)

        if self.mock_outputs:
            self._mock_RSAT_raw_outputs(SAR_par, PROC_par, raw_data_files, raw_out)

        ca = self._clean_args(locals(), inspect.signature(self.RSAT_raw))
        result = self._gamma_call("MSP", "RSAT_raw", ca)

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert raw_out.exists(), f"{raw_out} does not exist"
        assert raw_out.stat().st_size > 0, f"{raw_out} has zero file size"

        return result

    def _validate_ERS_ENVISAT_proc(
        self,
        L0: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swst_flg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ERS_ENVISAT_proc.

        """

        assert L0.exists(), f"{L0} does not exist"
        assert L0.stat().st_size > 0, f"{L0} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

        assert not raw.exists(), f"{raw} should _not_ exist!"

    def _mock_ERS_ENVISAT_proc_outputs(
        self,
        L0: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swst_flg: Optional[int] = None,
    ) -> None:
        """

        Mock the program ERS_ENVISAT_proc.

        """

        if not SAR_par.exists():
            SAR_par.touch()

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

        if raw is not None and str(raw) != "-":
            raw.touch()

    def ERS_ENVISAT_proc(
        self,
        L0: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swst_flg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        MSP preprocessing for ERS raw data in ENVISAT format


        input parameters:
          L0       (input) Level 0 Image Mode ERS data file in Envisat format (SAR_IM__0P*.E*)
          SAR_par  (input/output) MSP SAR sensor parameter file (ERS*_ESA.par)
          PROC_par (output) MSP processing parameter file, (example p<orbit>.slc.par)
          raw      (output) byte aligned 8-bit I/Q raw data
          loff     number of lines offset from start of raw data file (enter - for default: 0)
          nl       number of lines to extract (enter - for default: to end of input raw data
          swst_flg SWST data window position processing flag:
                     0: ignore changes in the data window position (only for corrupted data)
                     1: track changes in the data window position (default)


        """

        if self.validate_inputs:
            self._validate_ERS_ENVISAT_proc(
                L0, SAR_par, PROC_par, raw, loff, nl, swst_flg
            )

        if self.mock_outputs:
            self._mock_ERS_ENVISAT_proc_outputs(
                L0, SAR_par, PROC_par, raw, loff, nl, swst_flg
            )

        ca = self._clean_args(locals(), inspect.signature(self.ERS_ENVISAT_proc))
        result = self._gamma_call("MSP", "ERS_ENVISAT_proc", ca)

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert raw.exists(), f"{raw} does not exist"
        assert raw.stat().st_size > 0, f"{raw} has zero file size"

        return result

    def _validate_multi_SLC(
        self,
        SLC_PROC_par: Path,
        MLI_PROC_par: Path,
        SLC: Path,
        MLI: Path,
        rlks: int,
        azlks: int,
        slc_format: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to multi_SLC.

        """

        assert SLC_PROC_par.exists(), f"{SLC_PROC_par} does not exist"
        assert SLC_PROC_par.stat().st_size > 0, f"{SLC_PROC_par} has zero file size"

        assert not MLI_PROC_par.exists(), f"{MLI_PROC_par} should _not_ exist!"

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert not MLI.exists(), f"{MLI} should _not_ exist!"

    def _mock_multi_SLC_outputs(
        self,
        SLC_PROC_par: Path,
        MLI_PROC_par: Path,
        SLC: Path,
        MLI: Path,
        rlks: int,
        azlks: int,
        slc_format: Optional[int] = None,
    ) -> None:
        """

        Mock the program multi_SLC.

        """

        if MLI_PROC_par is not None and str(MLI_PROC_par) != "-":
            MLI_PROC_par.touch()

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

    def multi_SLC(
        self,
        SLC_PROC_par: Path,
        MLI_PROC_par: Path,
        SLC: Path,
        MLI: Path,
        rlks: int,
        azlks: int,
        slc_format: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate a multilook intensity image (MLI) from an SLC


        input parameters:
          SLC_PROC_par  (input) SLC MSP processing parameter file
          MLI_PROC_par  (output) MLI MSP processing parameter file
          SLC           (input) single look complex image
          MLI           (output) multilook intensity image derived from SLC
          rlks          number of range looks
          azlks         number of azimuth looks
          slc_format    input SLC format flag (default: from SLC_PROC_par)
                        0: FCOMPLEX (pairs of 4-byte float)
                        1: SCOMPLEX (pairs of 2-byte short integer)


        """

        if self.validate_inputs:
            self._validate_multi_SLC(
                SLC_PROC_par, MLI_PROC_par, SLC, MLI, rlks, azlks, slc_format
            )

        if self.mock_outputs:
            self._mock_multi_SLC_outputs(
                SLC_PROC_par, MLI_PROC_par, SLC, MLI, rlks, azlks, slc_format
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_SLC))
        result = self._gamma_call("MSP", "multi_SLC", ca)

        assert MLI_PROC_par.exists(), f"{MLI_PROC_par} does not exist"
        assert MLI_PROC_par.stat().st_size > 0, f"{MLI_PROC_par} has zero file size"

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        return result

    def _validate_JERS_acs(
        self,
        USER_HEADER: Path,
        SEG_DESCR: Path,
        ORBIT_DATA: Path,
        SENSOR_DATA: Path,
        track: Optional[Path],
        SAR_par: Path,
        PROC_par: Path,
        raw_out: Path,
        loff: int,
        nl: Optional[int] = None,
        nsx: Optional[int] = None,
        fsx: Optional[int] = None,
        terra_alt: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to JERS_acs.

        """

        assert USER_HEADER.exists(), f"{USER_HEADER} does not exist"
        assert USER_HEADER.stat().st_size > 0, f"{USER_HEADER} has zero file size"

        assert SEG_DESCR.exists(), f"{SEG_DESCR} does not exist"
        assert SEG_DESCR.stat().st_size > 0, f"{SEG_DESCR} has zero file size"

        assert ORBIT_DATA.exists(), f"{ORBIT_DATA} does not exist"
        assert ORBIT_DATA.stat().st_size > 0, f"{ORBIT_DATA} has zero file size"

        assert SENSOR_DATA.exists(), f"{SENSOR_DATA} does not exist"
        assert SENSOR_DATA.stat().st_size > 0, f"{SENSOR_DATA} has zero file size"

        if track is not None:
            assert not track.exists(), f"{track} should _not_ exist!"

        assert not SAR_par.exists(), f"{SAR_par} should _not_ exist!"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

        assert not raw_out.exists(), f"{raw_out} should _not_ exist!"

    def _mock_JERS_acs_outputs(
        self,
        USER_HEADER: Path,
        SEG_DESCR: Path,
        ORBIT_DATA: Path,
        SENSOR_DATA: Path,
        track: Optional[Path],
        SAR_par: Path,
        PROC_par: Path,
        raw_out: Path,
        loff: int,
        nl: Optional[int] = None,
        nsx: Optional[int] = None,
        fsx: Optional[int] = None,
        terra_alt: Optional[int] = None,
    ) -> None:
        """

        Mock the program JERS_acs.

        """

        if track is not None and str(track) != "-":
            track.touch()

        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

        if raw_out is not None and str(raw_out) != "-":
            raw_out.touch()

    def JERS_acs(
        self,
        USER_HEADER: Path,
        SEG_DESCR: Path,
        ORBIT_DATA: Path,
        SENSOR_DATA: Path,
        track: Optional[Path],
        SAR_par: Path,
        PROC_par: Path,
        raw_out: Path,
        loff: int,
        nl: Optional[int] = None,
        nsx: Optional[int] = None,
        fsx: Optional[int] = None,
        terra_alt: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Read JERS raw data recorded by the ACS ground system


        input parameters:
        USER_HEADER  (input) ACS user header file
        SEG_DESCR    (input) ACS segment descriptor file
        ORBIT_DATA   (input) ACS orbit data file
        SENSOR_DATA  (input) ACS JERS sensor data
        track        (output) track file containing near, center, far lat/lon vs. time (enter - for none, text format)
        SAR_par      (output) JERS SAR Sensor parameter file
        PROC_par     (output) MSP processing parameter file
        raw_out      (output) reformatted raw data file
        loff         offset to first line to reformat (lines)
        nl           number of lines to reformat (enter - for all)
        nsx          near swath extension (samples default: 0)
        fsx          far swath extension  (samples default: 0)
        terra_alt    nominal terrain altitude (m default = 0.0)
        deskew       deskew flag (default:ON  OFF)

        """

        if self.validate_inputs:
            self._validate_JERS_acs(
                USER_HEADER,
                SEG_DESCR,
                ORBIT_DATA,
                SENSOR_DATA,
                track,
                SAR_par,
                PROC_par,
                raw_out,
                loff,
                nl,
                nsx,
                fsx,
                terra_alt,
            )

        if self.mock_outputs:
            self._mock_JERS_acs_outputs(
                USER_HEADER,
                SEG_DESCR,
                ORBIT_DATA,
                SENSOR_DATA,
                track,
                SAR_par,
                PROC_par,
                raw_out,
                loff,
                nl,
                nsx,
                fsx,
                terra_alt,
            )

        ca = self._clean_args(locals(), inspect.signature(self.JERS_acs))
        result = self._gamma_call("MSP", "JERS_acs", ca)

        if track is not None:
            assert track.exists(), f"{track} does not exist"
            assert track.stat().st_size > 0, f"{track} has zero file size"

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert raw_out.exists(), f"{raw_out} does not exist"
        assert raw_out.stat().st_size > 0, f"{raw_out} has zero file size"

        return result

    def _validate_DORIS_proc(
        self, PROC_par: Path, DOR: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to DORIS_proc.

        """

        assert DOR.exists(), f"{DOR} does not exist"
        assert DOR.stat().st_size > 0, f"{DOR} has zero file size"

    def _mock_DORIS_proc_outputs(
        self, PROC_par: Path, DOR: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Mock the program DORIS_proc.

        """

        if not PROC_par.exists():
            PROC_par.touch()

    def DORIS_proc(
        self, PROC_par: Path, DOR: Path, nstate: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        extract ENVISAT DORIS state vectors and write to an MSP processing parameter file


        input parameters:
          PROC_par (input/output) MSP processing parameter file, (example p<orbit>.slc.par)
          DOR      (input) ASAR DORIS data file (DOR_VOR_AXVF)
          nstate   number of state vectors to extract (enter - for default: 11)

        """

        if self.validate_inputs:
            self._validate_DORIS_proc(PROC_par, DOR, nstate)

        if self.mock_outputs:
            self._mock_DORIS_proc_outputs(PROC_par, DOR, nstate)

        ca = self._clean_args(locals(), inspect.signature(self.DORIS_proc))
        result = self._gamma_call("MSP", "DORIS_proc", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_ASAR_AP_proc(
        self,
        L0: Path,
        INS: Path,
        SAR_par1: Path,
        SAR_par2: Path,
        PROC_par1: Path,
        PROC_par2: Path,
        raw1: Path,
        raw2: Path,
        ant_gain1: Path,
        ant_gain2: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ASAR_AP_proc.

        """

        assert L0.exists(), f"{L0} does not exist"
        assert L0.stat().st_size > 0, f"{L0} has zero file size"

        assert INS.exists(), f"{INS} does not exist"
        assert INS.stat().st_size > 0, f"{INS} has zero file size"

        assert not SAR_par1.exists(), f"{SAR_par1} should _not_ exist!"

        assert not SAR_par2.exists(), f"{SAR_par2} should _not_ exist!"

        assert not PROC_par1.exists(), f"{PROC_par1} should _not_ exist!"

        assert not PROC_par2.exists(), f"{PROC_par2} should _not_ exist!"

        assert not raw1.exists(), f"{raw1} should _not_ exist!"

        assert not raw2.exists(), f"{raw2} should _not_ exist!"

        assert ant_gain1.exists(), f"{ant_gain1} does not exist"
        assert ant_gain1.stat().st_size > 0, f"{ant_gain1} has zero file size"

        assert ant_gain2.exists(), f"{ant_gain2} does not exist"
        assert ant_gain2.stat().st_size > 0, f"{ant_gain2} has zero file size"

    def _mock_ASAR_AP_proc_outputs(
        self,
        L0: Path,
        INS: Path,
        SAR_par1: Path,
        SAR_par2: Path,
        PROC_par1: Path,
        PROC_par2: Path,
        raw1: Path,
        raw2: Path,
        ant_gain1: Path,
        ant_gain2: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
    ) -> None:
        """

        Mock the program ASAR_AP_proc.

        """

        if SAR_par1 is not None and str(SAR_par1) != "-":
            SAR_par1.touch()

        if SAR_par2 is not None and str(SAR_par2) != "-":
            SAR_par2.touch()

        if PROC_par1 is not None and str(PROC_par1) != "-":
            PROC_par1.touch()

        if PROC_par2 is not None and str(PROC_par2) != "-":
            PROC_par2.touch()

        if raw1 is not None and str(raw1) != "-":
            raw1.touch()

        if raw2 is not None and str(raw2) != "-":
            raw2.touch()

    def ASAR_AP_proc(
        self,
        L0: Path,
        INS: Path,
        SAR_par1: Path,
        SAR_par2: Path,
        PROC_par1: Path,
        PROC_par2: Path,
        raw1: Path,
        raw2: Path,
        ant_gain1: Path,
        ant_gain2: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        MSP preprocessing for ASAR L0 Alternating Polarization mode data


        input parameters:
          L0         (input) Level 0 Image Mode ASAR data file (ASA_IM_0P)
          INS        (input) ASAR instrument characterization file (ASA_INS_AX)
          SAR_par1   (output) MSP SAR sensor parameter file
          SAR_par2   (output) MSP SAR sensor parameter file
          PROC_par1  (output) MSP processing parameter file, (example p<orbit>.slc.par)
          PROC_par2  (output) MSP processing parameter file, (example p<orbit>.slc.par)
          raw1       (output) byte aligned 8-bit I/Q raw data
          raw2       (output) byte aligned 8-bit I/Q raw data
          ant_gain1  (input) antenna pattern file 1 (derived using program ASAR_XCA)
          ant_gain2  (input) antenna pattern file 2 (derived using program ASAR_XCA)
          loff       offset to first line to process (default = 0, enter - for default)
          nl         number of lines to process(default = to end of input, enter - for default)
          roff       offset to first range sample to process (default = 0, enter - for default)
          nr         number of range samples to process (default = to end of line, enter - for default)

         NOTE:  Possible AP modes are the following pairs  (HH/VV), (HH/HV), (VV/VH). Indices in the file names
         refer to the first and second polarization pairs (1/2). Filenames should be chosen chosen for consistency


        """

        if self.validate_inputs:
            self._validate_ASAR_AP_proc(
                L0,
                INS,
                SAR_par1,
                SAR_par2,
                PROC_par1,
                PROC_par2,
                raw1,
                raw2,
                ant_gain1,
                ant_gain2,
                loff,
                nl,
                roff,
                nr,
            )

        if self.mock_outputs:
            self._mock_ASAR_AP_proc_outputs(
                L0,
                INS,
                SAR_par1,
                SAR_par2,
                PROC_par1,
                PROC_par2,
                raw1,
                raw2,
                ant_gain1,
                ant_gain2,
                loff,
                nl,
                roff,
                nr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ASAR_AP_proc))
        result = self._gamma_call("MSP", "ASAR_AP_proc", ca)

        assert SAR_par1.exists(), f"{SAR_par1} does not exist"
        assert SAR_par1.stat().st_size > 0, f"{SAR_par1} has zero file size"

        assert SAR_par2.exists(), f"{SAR_par2} does not exist"
        assert SAR_par2.stat().st_size > 0, f"{SAR_par2} has zero file size"

        assert PROC_par1.exists(), f"{PROC_par1} does not exist"
        assert PROC_par1.stat().st_size > 0, f"{PROC_par1} has zero file size"

        assert PROC_par2.exists(), f"{PROC_par2} does not exist"
        assert PROC_par2.stat().st_size > 0, f"{PROC_par2} has zero file size"

        assert raw1.exists(), f"{raw1} does not exist"
        assert raw1.stat().st_size > 0, f"{raw1} has zero file size"

        assert raw2.exists(), f"{raw2} does not exist"
        assert raw2.stat().st_size > 0, f"{raw2} has zero file size"

        return result

    def _validate_JERS_proc_ASF(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to JERS_proc_ASF.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_JERS_proc_ASF_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Mock the program JERS_proc_ASF.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def JERS_proc_ASF(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        JERS SAR processing parameters from ASF Level 0 (SKY) CEOS leader (2000)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR leader file (ASF Level 0 leader)
        PROC_par         (output) MSP processing parameter file, (example p<orbit>.slc.par)


        """

        if self.validate_inputs:
            self._validate_JERS_proc_ASF(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_JERS_proc_ASF_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.JERS_proc_ASF))
        result = self._gamma_call("MSP", "JERS_proc_ASF", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_rc_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
        r_chirp: Optional[Path] = None,
        rfi_filt: Optional[int] = None,
        rfi_thres: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rc_real.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not rc_data.exists(), f"{rc_data} should _not_ exist!"

        if r_chirp is not None:
            assert r_chirp.exists(), f"{r_chirp} does not exist"
            assert r_chirp.stat().st_size > 0, f"{r_chirp} has zero file size"

    def _mock_rc_real_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
        r_chirp: Optional[Path] = None,
        rfi_filt: Optional[int] = None,
        rfi_thres: Optional[int] = None,
    ) -> None:
        """

        Mock the program rc_real.

        """

        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def rc_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
        r_chirp: Optional[Path] = None,
        rfi_filt: Optional[int] = None,
        rfi_thres: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        SAR range compression for offset-video (SIR-C) raw data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          rc_data      (output) output range compressed data filename
          loff         number of lines offset (enter - for default)
          nl           number of lines to range compress (enter - for default)
          kaiser       range chirp Kaiser window parameter beta (enter - for default)
          nr_ext       near range swath extension in raw data samples (enter - for default)
          fr_ext       far range swath extension in raw data samples (enter - for default)
          r_chirp      (input) file containing user supplied range chirp samples (enter - for none)
          rfi_filt     RFI suppression filtering (0:OFF (default)  1:ON)
          rfi_thres    RFI detection threshold, nominal range 1.0 --> 1.5 (default= 1.100)


        """

        if self.validate_inputs:
            self._validate_rc_real(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                loff,
                nl,
                kaiser,
                nr_ext,
                fr_ext,
                r_chirp,
                rfi_filt,
                rfi_thres,
            )

        if self.mock_outputs:
            self._mock_rc_real_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                loff,
                nl,
                kaiser,
                nr_ext,
                fr_ext,
                r_chirp,
                rfi_filt,
                rfi_thres,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rc_real))
        result = self._gamma_call("MSP", "rc_real", ca)

        assert rc_data.exists(), f"{rc_data} does not exist"
        assert rc_data.stat().st_size > 0, f"{rc_data} has zero file size"

        return result

    def _validate_ERS_proc_CRISP(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_CRISP.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_CRISP_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Mock the program ERS_proc_CRISP.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_CRISP(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing  parameters, (CRISP, Singapore PAF)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par


        """

        if self.validate_inputs:
            self._validate_ERS_proc_CRISP(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_CRISP_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_CRISP))
        result = self._gamma_call("MSP", "ERS_proc_CRISP", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_prefilt(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        prefilt_out: Path,
        prefilt_dec: Optional[int] = None,
        filt_lm: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to prefilt.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert rc_data.exists(), f"{rc_data} does not exist"
        assert rc_data.stat().st_size > 0, f"{rc_data} has zero file size"

        assert not prefilt_out.exists(), f"{prefilt_out} should _not_ exist!"

    def _mock_prefilt_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        prefilt_out: Path,
        prefilt_dec: Optional[int] = None,
        filt_lm: Optional[int] = None,
    ) -> None:
        """

        Mock the program prefilt.

        """

        if prefilt_out is not None and str(prefilt_out) != "-":
            prefilt_out.touch()

    def prefilt(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        prefilt_out: Path,
        prefilt_dec: Optional[int] = None,
        filt_lm: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Prefilter for range-compressed SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          rc_data      (input) range compressed SAR data
          prefilt_out  (output) output prefiltered data filename
          prefilt_dec  prefilter decimation factor (enter - for default from PROC_par)
          filt_lm      filter length multiplier, FIR length = FIR_lm * prefilt_dec + 1 (enter - for default: 8)


        """

        if self.validate_inputs:
            self._validate_prefilt(
                SAR_par, PROC_par, rc_data, prefilt_out, prefilt_dec, filt_lm
            )

        if self.mock_outputs:
            self._mock_prefilt_outputs(
                SAR_par, PROC_par, rc_data, prefilt_out, prefilt_dec, filt_lm
            )

        ca = self._clean_args(locals(), inspect.signature(self.prefilt))
        result = self._gamma_call("MSP", "prefilt", ca)

        assert prefilt_out.exists(), f"{prefilt_out} does not exist"
        assert prefilt_out.stat().st_size > 0, f"{prefilt_out} has zero file size"

        return result

    def _validate_doppler(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
        order: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to doppler.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not doppler.exists(), f"{doppler} should _not_ exist!"

    def _mock_doppler_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
        order: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program doppler.

        """

        if doppler is not None and str(doppler) != "-":
            doppler.touch()

    def doppler(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
        order: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Doppler centroid estimation across track for IQ SAR data


        input parameters:
          SAR_par      (input) SAR sensor parameter file
          PROC_par     (input) processing parameter file
          signal_data  (input) input uncompressed IQ raw SAR data file
          doppler      (output) Doppler as a function of slant range
          loff         number of lines offset (enter - for default: PROC_par loff value)
          nsub         number of azimuth subapertures (enter - for default: 12)
          ambig_flag   Doppler ambiguity resolution flag
                         0: use unambiguous Doppler Ambiguity Resolver (DAR) estimate (default)
                         1: estimate Doppler ambiguity number from the Doppler slope
                         2: command line entry for the Doppler ambiguity number
          namb         user defined number of Doppler ambiguities to add to the Doppler function (enter - for default: 0)
          order        order of polynomial used to fit the range Doppler function 0-->3: (enter - for default: 1)
          pltflg       azimuth spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format


        """

        if self.validate_inputs:
            self._validate_doppler(
                SAR_par,
                PROC_par,
                signal_data,
                doppler,
                loff,
                nsub,
                ambig_flag,
                namb,
                order,
                pltflg,
            )

        if self.mock_outputs:
            self._mock_doppler_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                doppler,
                loff,
                nsub,
                ambig_flag,
                namb,
                order,
                pltflg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.doppler))
        result = self._gamma_call("MSP", "doppler", ca)

        assert doppler.exists(), f"{doppler} does not exist"
        assert doppler.stat().st_size > 0, f"{doppler} has zero file size"

        return result

    def _validate_DELFT_proc2(
        self,
        PROC_par: Path,
        DELFT_dir: int,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        ODR: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to DELFT_proc2.

        """

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

    def _mock_DELFT_proc2_outputs(
        self,
        PROC_par: Path,
        DELFT_dir: int,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        ODR: Optional[int] = None,
    ) -> None:
        """

        Mock the program DELFT_proc2.

        """
        pass

    def DELFT_proc2(
        self,
        PROC_par: Path,
        DELFT_dir: int,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        ODR: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract and interpolate Delft ERS-1, ERS-2, and ENVISAT state vectors for the MSP


        input parameters:
          PROC_par   (input) MSP processing parameter file
          DELFT_dir  directory containing Delft orbit arclist and ODR files for ERS-1, ERS-2 or ENVISAT
                       NOTE: enter . for current directory
          nstate     number of state vectors to generate (enter - for default (>= 11)
          interval   time interval between state vectors in the ISP image parameter file (s) (default: 10.0)
          ODR        ODR file to use (include path) rather than ODR file determined from the Delft orbit arclist


        """

        if self.validate_inputs:
            self._validate_DELFT_proc2(PROC_par, DELFT_dir, nstate, interval, ODR)

        if self.mock_outputs:
            self._mock_DELFT_proc2_outputs(PROC_par, DELFT_dir, nstate, interval, ODR)

        ca = self._clean_args(locals(), inspect.signature(self.DELFT_proc2))
        result = self._gamma_call("MSP", "DELFT_proc2", ca)
        return result

    def _validate_ERS_proc_ESRIN_ACS(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_ESRIN_ACS.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_ESRIN_ACS_outputs(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> None:
        """

        Mock the program ERS_proc_ESRIN_ACS.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ESRIN_ACS(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        SAR processing parameter input (ESRIN ACS processor)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par


        """

        if self.validate_inputs:
            self._validate_ERS_proc_ESRIN_ACS(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_ESRIN_ACS_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_ESRIN_ACS))
        result = self._gamma_call("MSP", "ERS_proc_ESRIN_ACS", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_ERS_proc_ASF_91(
        self, CEOS_SAR_leader: Path, CEOS_trailer: Path, PROC_par: Path
    ) -> None:
        """

        Validate the arguments to ERS_proc_ASF_91.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert CEOS_trailer.exists(), f"{CEOS_trailer} does not exist"
        assert CEOS_trailer.stat().st_size > 0, f"{CEOS_trailer} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_ASF_91_outputs(
        self, CEOS_SAR_leader: Path, CEOS_trailer: Path, PROC_par: Path
    ) -> None:
        """

        Mock the program ERS_proc_ASF_91.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ASF_91(
        self, CEOS_SAR_leader: Path, CEOS_trailer: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing parameters from ASF CEOS format leader files (1991-1996)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR leader file (*.ldr)
        CEOS_trailer     (input) CEOS trailer file(*.tlr)
        PROC_par         (output) MSP processing parameter file, example pdate>.slc.par


        """

        if self.validate_inputs:
            self._validate_ERS_proc_ASF_91(CEOS_SAR_leader, CEOS_trailer, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_ASF_91_outputs(CEOS_SAR_leader, CEOS_trailer, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_ASF_91))
        result = self._gamma_call("MSP", "ERS_proc_ASF_91", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_ORB_prop(
        self,
        PROC_par: Path,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        extra: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ORB_prop.

        """

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

    def _mock_ORB_prop_outputs(
        self,
        PROC_par: Path,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        extra: Optional[int] = None,
    ) -> None:
        """

        Mock the program ORB_prop.

        """
        pass

    def ORB_prop(
        self,
        PROC_par: Path,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        extra: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate state vectors using orbit propagation and interpolation


        input parameters:
          PROC_par  (input) MSP processing parameter file
          nstate    number of state vectors to calculate for the MSP image parameter file,
                    (enter - for the default value determined from the duration of the state vectors)
          interval  time interval between state vectors (default: input state vector time interval)
          extra     extra time for state vector coverage at start and end of image (default= 30.0 s.)


        """

        if self.validate_inputs:
            self._validate_ORB_prop(PROC_par, nstate, interval, extra)

        if self.mock_outputs:
            self._mock_ORB_prop_outputs(PROC_par, nstate, interval, extra)

        ca = self._clean_args(locals(), inspect.signature(self.ORB_prop))
        result = self._gamma_call("MSP", "ORB_prop", ca)
        return result

    def _validate_ERS_fix(
        self, ERS_PAF: int, SAR_par: Path, PROC_par: Path, cc_flag: int, output_file: Path
    ) -> None:
        """

        Validate the arguments to ERS_fix.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert not output_file.exists(), f"{output_file} should _not_ exist!"

    def _mock_ERS_fix_outputs(
        self, ERS_PAF: int, SAR_par: Path, PROC_par: Path, cc_flag: int, output_file: Path
    ) -> None:
        """

        Mock the program ERS_fix.

        """

        if output_file is not None and str(output_file) != "-":
            output_file.touch()

    def ERS_fix(
        self, ERS_PAF: int, SAR_par: Path, PROC_par: Path, cc_flag: int, output_file: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS raw data missing line detection and range gate alignment


        input parameters:
          ERS_PAF        ERS Processing and Archive Facility (PAF), valid inputs:

             ENVISAT ACRES CCRS COLUMBIA DPAF ESA/ESRIN NASDA EIC CRISP UK/QinetiQ

          SAR_par        (input) MSP SAR sensor parameter file
          PROC_par       (input) MSP processing parameter file
          cc_flag        cross correlation detection of missing lines (default=0=OFF, 1=ON)
          raw data files (input) list of raw data file name(s) to check and concatenate
                         IMPORTANT: for ERS_PAF=ENVISAT use cat_raw to concatenate!
          output_file    (output) fixed raw data


        """

        if self.validate_inputs:
            self._validate_ERS_fix(ERS_PAF, SAR_par, PROC_par, cc_flag, output_file)

        if self.mock_outputs:
            self._mock_ERS_fix_outputs(ERS_PAF, SAR_par, PROC_par, cc_flag, output_file)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_fix))
        result = self._gamma_call("MSP", "ERS_fix", ca)

        assert output_file.exists(), f"{output_file} does not exist"
        assert output_file.stat().st_size > 0, f"{output_file} has zero file size"

        return result

    def _validate_ERS_proc_CCRS(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_CCRS.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_CCRS_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Mock the program ERS_proc_CCRS.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_CCRS(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing processing parameters from CCRS PAF format CEOS leader


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file (contains no VMP header information)
        PROC_par         (output) MSP processing parameter file, (example p<date>.slc.par)


        """

        if self.validate_inputs:
            self._validate_ERS_proc_CCRS(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_CCRS_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_CCRS))
        result = self._gamma_call("MSP", "ERS_proc_CCRS", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_ptarg(
        self,
        SLC: Path,
        width: int,
        r_samp: Path,
        az_samp: Path,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        data_format: int,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ptarg.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert r_samp.exists(), f"{r_samp} does not exist"
        assert r_samp.stat().st_size > 0, f"{r_samp} has zero file size"

        assert az_samp.exists(), f"{az_samp} does not exist"
        assert az_samp.stat().st_size > 0, f"{az_samp} has zero file size"

        assert not ptr_image.exists(), f"{ptr_image} should _not_ exist!"

        assert not r_plot.exists(), f"{r_plot} should _not_ exist!"

        assert not az_plot.exists(), f"{az_plot} should _not_ exist!"

    def _mock_ptarg_outputs(
        self,
        SLC: Path,
        width: int,
        r_samp: Path,
        az_samp: Path,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        data_format: int,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program ptarg.

        """

        if ptr_image is not None and str(ptr_image) != "-":
            ptr_image.touch()

        if r_plot is not None and str(r_plot) != "-":
            r_plot.touch()

        if az_plot is not None and str(az_plot) != "-":
            az_plot.touch()

    def ptarg(
        self,
        SLC: Path,
        width: int,
        r_samp: Path,
        az_samp: Path,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        data_format: int,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Point target response analysis and interpolation


        input parameters:
          SLC          (input) SLC in fcomplex or scomplex format
          width        (input) SLC complex samples per line
          r_samp       (input) point target range sample number
          az_samp      (input) point target azimuth line number
          ptr_image    (output) oversampled point target image (fcomplex, 1024x1024 samples), with and without phase gradient
          r_plot       (output) range point target response plot data (text format)
          az_plot      (output) azimuth point target response plot data (text format)
          data_format  input data format flag (default:from MSP processing parameter file)
                         0: FCOMPLEX (pairs of 4-byte float)
                         1: SCOMPLEX (pairs of 2-byte short integer)
          win          maximum search window offset (samples) (integer, default: 1)
          pltflg       azimuth spectrum plotting flag:
                         0: none (default)
                         1: output plots in PNG format
                         2: screen output and PNG format plots


        """

        if self.validate_inputs:
            self._validate_ptarg(
                SLC,
                width,
                r_samp,
                az_samp,
                ptr_image,
                r_plot,
                az_plot,
                data_format,
                win,
                pltflg,
            )

        if self.mock_outputs:
            self._mock_ptarg_outputs(
                SLC,
                width,
                r_samp,
                az_samp,
                ptr_image,
                r_plot,
                az_plot,
                data_format,
                win,
                pltflg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ptarg))
        result = self._gamma_call("MSP", "ptarg", ca)

        assert ptr_image.exists(), f"{ptr_image} does not exist"
        assert ptr_image.stat().st_size > 0, f"{ptr_image} has zero file size"

        assert r_plot.exists(), f"{r_plot} does not exist"
        assert r_plot.stat().st_size > 0, f"{r_plot} has zero file size"

        assert az_plot.exists(), f"{az_plot} does not exist"
        assert az_plot.stat().st_size > 0, f"{az_plot} has zero file size"

        return result

    def _validate_multi_GRD_SLC(
        self,
        SLC_PROC_par: Path,
        GRD_PROC_par: Path,
        SLC_image: Path,
        GRD_image: Path,
        rlks: int,
        azlks: int,
        interp_mode: Optional[int] = None,
        sample_spacing: Optional[int] = None,
        gr_start: Optional[int] = None,
        t_start: Optional[int] = None,
        t_end: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to multi_GRD_SLC.

        """

        assert SLC_PROC_par.exists(), f"{SLC_PROC_par} does not exist"
        assert SLC_PROC_par.stat().st_size > 0, f"{SLC_PROC_par} has zero file size"

        assert not GRD_PROC_par.exists(), f"{GRD_PROC_par} should _not_ exist!"

        assert SLC_image.exists(), f"{SLC_image} does not exist"
        assert SLC_image.stat().st_size > 0, f"{SLC_image} has zero file size"

        assert not GRD_image.exists(), f"{GRD_image} should _not_ exist!"

    def _mock_multi_GRD_SLC_outputs(
        self,
        SLC_PROC_par: Path,
        GRD_PROC_par: Path,
        SLC_image: Path,
        GRD_image: Path,
        rlks: int,
        azlks: int,
        interp_mode: Optional[int] = None,
        sample_spacing: Optional[int] = None,
        gr_start: Optional[int] = None,
        t_start: Optional[int] = None,
        t_end: Optional[int] = None,
    ) -> None:
        """

        Mock the program multi_GRD_SLC.

        """

        if GRD_PROC_par is not None and str(GRD_PROC_par) != "-":
            GRD_PROC_par.touch()

        if GRD_image is not None and str(GRD_image) != "-":
            GRD_image.touch()

    def multi_GRD_SLC(
        self,
        SLC_PROC_par: Path,
        GRD_PROC_par: Path,
        SLC_image: Path,
        GRD_image: Path,
        rlks: int,
        azlks: int,
        interp_mode: Optional[int] = None,
        sample_spacing: Optional[int] = None,
        gr_start: Optional[int] = None,
        t_start: Optional[int] = None,
        t_end: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Multi-look ground range (GRD) images from MSP SLC data


        input parameters:
          SLC_PROC_par    (input) MSP SLC processing parameter file
          GRD_PROC_par    (output) MSP ground range (GRD) multi-look image parameter file
          SLC_image       (input) SLC image file
          GRD_image       (output) ground-range projected image file (float)
          rlks            number of range looks (default: 1)
          azlks           number of azimuth looks (default: 1)
          interp_mode     interpolation mode:
                            0: nearest-neighbor
                            1: SINC interpolator (default)
          sample_spacing  multilook image sample spacing (m) (enter - for default: azimuth SLC spacing * azlks)
          gr_start        starting ground-range (meters), (enter - for default: start of data)
          t_start         starting time (s) for output, (enter - for default: start of data)
          t_end           ending time (s) for output, (enter -  for default: end of data)


        """

        if self.validate_inputs:
            self._validate_multi_GRD_SLC(
                SLC_PROC_par,
                GRD_PROC_par,
                SLC_image,
                GRD_image,
                rlks,
                azlks,
                interp_mode,
                sample_spacing,
                gr_start,
                t_start,
                t_end,
            )

        if self.mock_outputs:
            self._mock_multi_GRD_SLC_outputs(
                SLC_PROC_par,
                GRD_PROC_par,
                SLC_image,
                GRD_image,
                rlks,
                azlks,
                interp_mode,
                sample_spacing,
                gr_start,
                t_start,
                t_end,
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_GRD_SLC))
        result = self._gamma_call("MSP", "multi_GRD_SLC", ca)

        assert GRD_PROC_par.exists(), f"{GRD_PROC_par} does not exist"
        assert GRD_PROC_par.stat().st_size > 0, f"{GRD_PROC_par} has zero file size"

        assert GRD_image.exists(), f"{GRD_image} does not exist"
        assert GRD_image.stat().st_size > 0, f"{GRD_image} has zero file size"

        return result

    def _validate_create_sar_par(self, SAR_par: Path) -> None:
        """

        Validate the arguments to create_sar_par.

        """

        pass

    def _mock_create_sar_par_outputs(self, SAR_par: Path) -> None:
        """

        Mock the program create_sar_par.

        """

        if not SAR_par.exists():
            SAR_par.touch()

    def create_sar_par(self, SAR_par: Path) -> Tuple[int, List[str], List[str]]:
        """

        Create SAR Sensor Parameter File


        input parameters:
          SAR_par  (input/output) MSP SAR sensor parameter file


        """

        if self.validate_inputs:
            self._validate_create_sar_par(SAR_par)

        if self.mock_outputs:
            self._mock_create_sar_par_outputs(SAR_par)

        ca = self._clean_args(locals(), inspect.signature(self.create_sar_par))
        result = self._gamma_call("MSP", "create_sar_par", ca)

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        return result

    def _validate_rspec_JERS(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        nr_samp: Optional[int] = None,
        nl_spec: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rspec_JERS.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not range_spec.exists(), f"{range_spec} should _not_ exist!"

    def _mock_rspec_JERS_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        nr_samp: Optional[int] = None,
        nl_spec: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
    ) -> None:
        """

        Mock the program rspec_JERS.

        """

        if range_spec is not None and str(range_spec) != "-":
            range_spec.touch()

    def rspec_JERS(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        nr_samp: Optional[int] = None,
        nl_spec: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        JERS-1/PALSAR range spectrum estimation for RFI suppression


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          range_spec   (output) range spectra data file for RFI suppression
          nr_samp      number of range samples to process (enter - for default from PROC_par)
          nl_spec      number of lines to use to estimate spectrum (enter - for default=1024)
          loff         offset echoes for first line to process (enter - default from PROC_par)
          nlines       number of lines to process (enter - for default from PROC_par)
          nr_ext       near range swath extension in samples (default from PROC_par)
          fr_ext       far range swath extension in samples (default from PROC_par)


        """

        if self.validate_inputs:
            self._validate_rspec_JERS(
                SAR_par,
                PROC_par,
                signal_data,
                range_spec,
                nr_samp,
                nl_spec,
                loff,
                nlines,
                nr_ext,
                fr_ext,
            )

        if self.mock_outputs:
            self._mock_rspec_JERS_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                range_spec,
                nr_samp,
                nl_spec,
                loff,
                nlines,
                nr_ext,
                fr_ext,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rspec_JERS))
        result = self._gamma_call("MSP", "rspec_JERS", ca)

        assert range_spec.exists(), f"{range_spec} does not exist"
        assert range_spec.stat().st_size > 0, f"{range_spec} has zero file size"

        return result

    def _validate_azsp_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        spectrum: Path,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flg: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to azsp_IQ.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not spectrum.exists(), f"{spectrum} should _not_ exist!"

    def _mock_azsp_IQ_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        spectrum: Path,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flg: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program azsp_IQ.

        """

        if spectrum is not None and str(spectrum) != "-":
            spectrum.touch()

    def azsp_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        spectrum: Path,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flg: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Azimuth spectrum and Doppler centroid for IQ raw SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) input raw I/Q format SAR data
          spectrum     (output) azimuth spectrum (text format)
          loff         number of lines offset to start of estimation window (default: 0)
          roff         range samples offset to center of estimation window (enter - for default: center_swath)
          nsub         number of azimuth subapertures for spectrum estimation (enter - for default: 24)
          ambig_flg    Doppler ambiguity resolution mode
                         0 = add multiples of PRF specified by the namb command line parameter
                         1 = use unambiguous Doppler centroid estimate from the PROC_par file (default)
          namb         number of multiples of the PRF to add to the ambiguous Doppler estimate (enter - for default: 0)
          pltflg       azimuth spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format


        """

        if self.validate_inputs:
            self._validate_azsp_IQ(
                SAR_par,
                PROC_par,
                signal_data,
                spectrum,
                loff,
                roff,
                nsub,
                ambig_flg,
                namb,
                pltflg,
            )

        if self.mock_outputs:
            self._mock_azsp_IQ_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                spectrum,
                loff,
                roff,
                nsub,
                ambig_flg,
                namb,
                pltflg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.azsp_IQ))
        result = self._gamma_call("MSP", "azsp_IQ", ca)

        assert spectrum.exists(), f"{spectrum} does not exist"
        assert spectrum.stat().st_size > 0, f"{spectrum} has zero file size"

        return result

    def _validate_ERS_proc_ACRES(
        self, CEOS_SAR_leader: Path, PROC_par: Path, type: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to ERS_proc_ACRES.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_ACRES_outputs(
        self, CEOS_SAR_leader: Path, PROC_par: Path, type: Optional[int] = None
    ) -> None:
        """

        Mock the program ERS_proc_ACRES.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ACRES(
        self, CEOS_SAR_leader: Path, PROC_par: Path, type: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing parameters (Australian ACRS PAF facility)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par
        type             raw data type:
                           0: CEOS leader format before 1998 (default)
                           1: CEOS leader format after 1998


        """

        if self.validate_inputs:
            self._validate_ERS_proc_ACRES(CEOS_SAR_leader, PROC_par, type)

        if self.mock_outputs:
            self._mock_ERS_proc_ACRES_outputs(CEOS_SAR_leader, PROC_par, type)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_ACRES))
        result = self._gamma_call("MSP", "ERS_proc_ACRES", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_pre_rc_RSAT(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[int] = None,
        filt_lm: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to pre_rc_RSAT.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert signal_data.exists(), f"{signal_data} does not exist"
        assert signal_data.stat().st_size > 0, f"{signal_data} has zero file size"

        assert not rc_data.exists(), f"{rc_data} should _not_ exist!"

    def _mock_pre_rc_RSAT_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[int] = None,
        filt_lm: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
    ) -> None:
        """

        Mock the program pre_rc_RSAT.

        """

        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def pre_rc_RSAT(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[int] = None,
        filt_lm: Optional[int] = None,
        nr_ext: Optional[int] = None,
        fr_ext: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Prefilter/SAR range compression for Radarsat-1 raw data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          rc_data      (output) range compressed data filename
          prefilt_dec  prefilter decimation factor (default from PROC_par)
          loff         number of lines offset (enter - for default=parameter file value)
          nl           number of lines filter/range compress (enter - for default=parameter file value)
          nr_samp      number of range samples (enter - for default from PROC_par)
          kaiser       range chirp Kaiser window parameter beta (default=2.120, -30 dB sidelobes)
          filt_lm      filter length multiplier, FIR length = FIR_lm * prefilt_dec + 1 (default=8)
          nr_ext       near range swath extension in samples (default from PROC_par)pixels
          fr_ext       far range swath extension in samples (default from PROC_par)


        """

        if self.validate_inputs:
            self._validate_pre_rc_RSAT(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                prefilt_dec,
                loff,
                nl,
                nr_samp,
                kaiser,
                filt_lm,
                nr_ext,
                fr_ext,
            )

        if self.mock_outputs:
            self._mock_pre_rc_RSAT_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                prefilt_dec,
                loff,
                nl,
                nr_samp,
                kaiser,
                filt_lm,
                nr_ext,
                fr_ext,
            )

        ca = self._clean_args(locals(), inspect.signature(self.pre_rc_RSAT))
        result = self._gamma_call("MSP", "pre_rc_RSAT", ca)

        assert rc_data.exists(), f"{rc_data} does not exist"
        assert rc_data.stat().st_size > 0, f"{rc_data} has zero file size"

        return result

    def _validate_autof(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        autofocus: Path,
        SNR_min: Optional[int] = None,
        prefilter: Optional[int] = None,
        auto_az: Optional[int] = None,
        az_offset: Optional[int] = None,
        auto_bins: Optional[int] = None,
        dop_ambig: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to autof.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert rc_data.exists(), f"{rc_data} does not exist"
        assert rc_data.stat().st_size > 0, f"{rc_data} has zero file size"

        assert not autofocus.exists(), f"{autofocus} should _not_ exist!"

    def _mock_autof_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        autofocus: Path,
        SNR_min: Optional[int] = None,
        prefilter: Optional[int] = None,
        auto_az: Optional[int] = None,
        az_offset: Optional[int] = None,
        auto_bins: Optional[int] = None,
        dop_ambig: Optional[int] = None,
    ) -> None:
        """

        Mock the program autof.

        """

        if autofocus is not None and str(autofocus) != "-":
            autofocus.touch()

    def autof(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        autofocus: Path,
        SNR_min: Optional[int] = None,
        prefilter: Optional[int] = None,
        auto_az: Optional[int] = None,
        az_offset: Optional[int] = None,
        auto_bins: Optional[int] = None,
        dop_ambig: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Autofocus for range/Doppler processing


        input parameters:
          SAR_par    (input) MSP SAR sensor parameter file
          PROC_par   (input) MSP processing parameter file
          rc_data    (input) range compressed data file
          autofocus  (output) autofocus correlation function file (text format)
          SNR_min    minimum autofocus SNR to accept velocity estimate (default=5.0)
          prefilter  prefilter decimation factor (default from PROC_par)
          auto_az    autofocus azimuth correlation patch size (2**N, default = 2048)
          az_offset  offset in prefiltered lines from start of file (default=0)
          auto_bins  number of range bins to use for autofocus (2**N, default=1024)
          dop_ambig  Doppler ambiguity correction flag
                       0: Doppler centroid remains unchanged
                       1: Doppler centroid ambiguity corrected (default)


        """

        if self.validate_inputs:
            self._validate_autof(
                SAR_par,
                PROC_par,
                rc_data,
                autofocus,
                SNR_min,
                prefilter,
                auto_az,
                az_offset,
                auto_bins,
                dop_ambig,
            )

        if self.mock_outputs:
            self._mock_autof_outputs(
                SAR_par,
                PROC_par,
                rc_data,
                autofocus,
                SNR_min,
                prefilter,
                auto_az,
                az_offset,
                auto_bins,
                dop_ambig,
            )

        ca = self._clean_args(locals(), inspect.signature(self.autof))
        result = self._gamma_call("MSP", "autof", ca)

        assert autofocus.exists(), f"{autofocus} does not exist"
        assert autofocus.stat().st_size > 0, f"{autofocus} has zero file size"

        return result

    def _validate_cat_raw(
        self,
        RAW_list: Path,
        SAR_par: Path,
        PROC_par: Path,
        RAW_out: Path,
        fill: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to cat_raw.

        """

        assert RAW_list.exists(), f"{RAW_list} does not exist"
        assert RAW_list.stat().st_size > 0, f"{RAW_list} has zero file size"

        assert not SAR_par.exists(), f"{SAR_par} should _not_ exist!"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

        assert not RAW_out.exists(), f"{RAW_out} should _not_ exist!"

    def _mock_cat_raw_outputs(
        self,
        RAW_list: Path,
        SAR_par: Path,
        PROC_par: Path,
        RAW_out: Path,
        fill: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Mock the program cat_raw.

        """

        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

        if RAW_out is not None and str(RAW_out) != "-":
            RAW_out.touch()

    def cat_raw(
        self,
        RAW_list: Path,
        SAR_par: Path,
        PROC_par: Path,
        RAW_out: Path,
        fill: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Concatenate a set of raw data files in MSP compatible format

        input parameters:
          RAW_list  (input) 3 column list of raw data and MSP sensor and processing parameter files:
                      1. SAR raw data file
                      2. MSP SAR sensor parameter file
                      3. MSP processing parameter file
          SAR_par   (output) MSP sensor parameter file for concatenated raw data set
          PROC_par  (output) MSP processing parameter file for concatenated raw data set
          RAW_out   (output) output concatenated raw data file
          fill      fill gaps between raw data files flag:
                      0: no
                      1: yes (default)
          loff      number of lines offset from start of file (enter - for default: 0)
          nl        number of lines to output (enter - for default: to end of data)

          NOTE: files must be in sequential order with the earliest file at the start of the RAW_list


        """

        if self.validate_inputs:
            self._validate_cat_raw(RAW_list, SAR_par, PROC_par, RAW_out, fill, loff, nl)

        if self.mock_outputs:
            self._mock_cat_raw_outputs(
                RAW_list, SAR_par, PROC_par, RAW_out, fill, loff, nl
            )

        ca = self._clean_args(locals(), inspect.signature(self.cat_raw))
        result = self._gamma_call("MSP", "cat_raw", ca)

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert RAW_out.exists(), f"{RAW_out} does not exist"
        assert RAW_out.stat().st_size > 0, f"{RAW_out} has zero file size"

        return result

    def _validate_ERS_proc_ASI(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to ERS_proc_ASI.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_ERS_proc_ASI_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        """

        Mock the program ERS_proc_ASI.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ASI(
        self, CEOS_SAR_leader: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ERS SAR processing parameters (ASI PAF)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par)


        """

        if self.validate_inputs:
            self._validate_ERS_proc_ASI(CEOS_SAR_leader, PROC_par)

        if self.mock_outputs:
            self._mock_ERS_proc_ASI_outputs(CEOS_SAR_leader, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.ERS_proc_ASI))
        result = self._gamma_call("MSP", "ERS_proc_ASI", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_JERS_proc(self, CEOS_SAR_ldr: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to JERS_proc.

        """

        assert CEOS_SAR_ldr.exists(), f"{CEOS_SAR_ldr} does not exist"
        assert CEOS_SAR_ldr.stat().st_size > 0, f"{CEOS_SAR_ldr} has zero file size"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_JERS_proc_outputs(self, CEOS_SAR_ldr: Path, PROC_par: Path) -> None:
        """

        Mock the program JERS_proc.

        """

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def JERS_proc(
        self, CEOS_SAR_ldr: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        SAR processing  parameter input for JERS-1 data from NASDA


        input parameters:
          CEOS_SAR_ldr  (input) CEOS SAR leader file for JERS-1
          PROC_par      (output) MSP processing parameter file


        """

        if self.validate_inputs:
            self._validate_JERS_proc(CEOS_SAR_ldr, PROC_par)

        if self.mock_outputs:
            self._mock_JERS_proc_outputs(CEOS_SAR_ldr, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.JERS_proc))
        result = self._gamma_call("MSP", "JERS_proc", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_PALSAR_antpat(
        self,
        SAR_par: Optional[Path],
        PROC_par: Optional[Path],
        ant_file: Path,
        Beam_ID: Optional[Path] = None,
        TX_POL: Optional[int] = None,
        RX_POL: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to PALSAR_antpat.

        """

        if SAR_par is not None:
            assert SAR_par.exists(), f"{SAR_par} does not exist"
            assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        if PROC_par is not None:
            assert PROC_par.exists(), f"{PROC_par} does not exist"
            assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert not ant_file.exists(), f"{ant_file} should _not_ exist!"

        if Beam_ID is not None:
            assert Beam_ID.exists(), f"{Beam_ID} does not exist"
            assert Beam_ID.stat().st_size > 0, f"{Beam_ID} has zero file size"

    def _mock_PALSAR_antpat_outputs(
        self,
        SAR_par: Optional[Path],
        PROC_par: Optional[Path],
        ant_file: Path,
        Beam_ID: Optional[Path] = None,
        TX_POL: Optional[int] = None,
        RX_POL: Optional[int] = None,
    ) -> None:
        """

        Mock the program PALSAR_antpat.

        """

        if ant_file is not None and str(ant_file) != "-":
            ant_file.touch()

    def PALSAR_antpat(
        self,
        SAR_par: Optional[Path],
        PROC_par: Optional[Path],
        ant_file: Path,
        Beam_ID: Optional[Path] = None,
        TX_POL: Optional[int] = None,
        RX_POL: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract specified antenna pattern from a PALSAR JAXA antenna pattern file


        input parameters:
          SAR_par     (input) MSP SAR sensor parameter file (enter - for none)
          PROC_par    (input) MSP processing parameter file (enter - for none)
          PALSAR_ANT  (input) PALSAR antenna pattern file provided by JAXA (e.g. palsar_ant_20061024.dat)
          ant_file    (output) MSP format antenna pattern file (text format)
          Beam_ID     (input) PALSAR mode beam ID, if not provided the program will determine the beam from the SAR_par look angle parameter
          TX_POL      transmit polarization: (required if PROC_par not specified)
                        0: H (default)
                        1: V
          RX_POL      receive polarization: (required if PROC_par not specified)
                        0: H (default)
                        1: V

        Beam IDs for different center-beam look angles and PALSAR modes:

        Beam ID    look angle (deg.)   Mode
        =======================================
           0              9.9          FBS
           1             14.1          FBS
           2             17.9          FBS
           3             21.2          FBS
           4             25.8          FBS
           5             28.7          FBS
           6             30.8          FBS
           7             34.0          FBS
           8             36.7          FBS
           9             38.5          FBS
           10            41.3          FBS
           11            43.4          FBS
           12            45.1          FBS
           13            46.6          FBS
           14            47.7          FBS
           15            49.0          FBS
           16            50.0          FBS
           17            50.6          FBS
           18            19.9          WB1, WB2 Beam 1
           19            25.8          WB1, WB2 Beam 2
           20            30.3          WB1, WB2 Beam 3
           21            33.6          WB1, WB2 Beam 4
           22            36.0          WB1, WB2 Beam 5

        """

        if self.validate_inputs:
            self._validate_PALSAR_antpat(
                SAR_par, PROC_par, ant_file, Beam_ID, TX_POL, RX_POL
            )

        if self.mock_outputs:
            self._mock_PALSAR_antpat_outputs(
                SAR_par, PROC_par, ant_file, Beam_ID, TX_POL, RX_POL
            )

        ca = self._clean_args(locals(), inspect.signature(self.PALSAR_antpat))
        result = self._gamma_call("MSP", "PALSAR_antpat", ca)

        assert ant_file.exists(), f"{ant_file} does not exist"
        assert ant_file.stat().st_size > 0, f"{ant_file} has zero file size"

        return result

    def _validate_create_proc_par(self, SAR_par: Path, PROC_par: Path) -> None:
        """

        Validate the arguments to create_proc_par.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

    def _mock_create_proc_par_outputs(self, SAR_par: Path, PROC_par: Path) -> None:
        """

        Mock the program create_proc_par.

        """

        if not PROC_par.exists():
            PROC_par.touch()

    def create_proc_par(
        self, SAR_par: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Create MSP processing parameter file


        input parameters:
          SAR_par   (input) MSP SAR sensor parameter file
          PROC_par  (input/output) MSP processing parameter file


        """

        if self.validate_inputs:
            self._validate_create_proc_par(SAR_par, PROC_par)

        if self.mock_outputs:
            self._mock_create_proc_par_outputs(SAR_par, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.create_proc_par))
        result = self._gamma_call("MSP", "create_proc_par", ca)

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_SIRC_proc(
        self, CEOS_SAR_leader: Path, SAR_par: Path, PROC_par: Path
    ) -> None:
        """

        Validate the arguments to SIRC_proc.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not SAR_par.exists(), f"{SAR_par} should _not_ exist!"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

    def _mock_SIRC_proc_outputs(
        self, CEOS_SAR_leader: Path, SAR_par: Path, PROC_par: Path
    ) -> None:
        """

        Mock the program SIRC_proc.

        """

        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def SIRC_proc(
        self, CEOS_SAR_leader: Path, SAR_par: Path, PROC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        SIR-C MSP processing parameter extraction from CEOS leader


        input parameters:
          CEOS_SAR_leader  (input) CEOS SAR raw data leader file
          SAR_par          (output) MSP sensor parameter file, (example SIRC.par)
          PROC_par         (output) MSP processing parameter file, (example p<orbit>.slc.par)
          UTC/MET          raw data time reference: 0=UTC, 1=Mission Elapsed Time, default=UTC


        """

        if self.validate_inputs:
            self._validate_SIRC_proc(CEOS_SAR_leader, SAR_par, PROC_par)

        if self.mock_outputs:
            self._mock_SIRC_proc_outputs(CEOS_SAR_leader, SAR_par, PROC_par)

        ca = self._clean_args(locals(), inspect.signature(self.SIRC_proc))
        result = self._gamma_call("MSP", "SIRC_proc", ca)

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        return result

    def _validate_ASAR_IM_proc(
        self,
        L0: Path,
        INS: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        ant_gain: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ASAR_IM_proc.

        """

        assert L0.exists(), f"{L0} does not exist"
        assert L0.stat().st_size > 0, f"{L0} has zero file size"

        assert INS.exists(), f"{INS} does not exist"
        assert INS.stat().st_size > 0, f"{INS} has zero file size"

        assert not SAR_par.exists(), f"{SAR_par} should _not_ exist!"

        assert not PROC_par.exists(), f"{PROC_par} should _not_ exist!"

        assert not raw.exists(), f"{raw} should _not_ exist!"

        assert ant_gain.exists(), f"{ant_gain} does not exist"
        assert ant_gain.stat().st_size > 0, f"{ant_gain} has zero file size"

    def _mock_ASAR_IM_proc_outputs(
        self,
        L0: Path,
        INS: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        ant_gain: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Mock the program ASAR_IM_proc.

        """

        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()

        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

        if raw is not None and str(raw) != "-":
            raw.touch()

    def ASAR_IM_proc(
        self,
        L0: Path,
        INS: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        ant_gain: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        MSP preprocessing for ASAR L0 Image mode data


        input parameters:
          L0       (input) Level 0 Image Mode ASAR data file (ASA_IM_0P)
          INS      (input) ASAR instrument characterization file (ASA_INS_AX)
          SAR_par  (output) MSP SAR sensor parameter file
          PROC_par (output) MSP processing parameter file, (example p<orbit>.slc.par)
          raw      (output) byte aligned 8-bit I/Q raw data
          ant_gain (input) antenna pattern file name (derived using program ASAR_XCA)
          loff     number of lines offset from start of raw data file (enter - for default: 0)
          nl       number of lines to extract (enter - for default: to end of input raw data


        """

        if self.validate_inputs:
            self._validate_ASAR_IM_proc(
                L0, INS, SAR_par, PROC_par, raw, ant_gain, loff, nl
            )

        if self.mock_outputs:
            self._mock_ASAR_IM_proc_outputs(
                L0, INS, SAR_par, PROC_par, raw, ant_gain, loff, nl
            )

        ca = self._clean_args(locals(), inspect.signature(self.ASAR_IM_proc))
        result = self._gamma_call("MSP", "ASAR_IM_proc", ca)

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert raw.exists(), f"{raw} does not exist"
        assert raw.stat().st_size > 0, f"{raw} has zero file size"

        return result

    def _validate_rasdt_pwr(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rasdt_pwr.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if pwr is not None:
            assert pwr.exists(), f"{pwr} does not exist"
            assert pwr.stat().st_size > 0, f"{pwr} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_rasdt_pwr_outputs(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> None:
        """

        Mock the program rasdt_pwr.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rasdt_pwr(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasdt_pwr
        Calculate a raster image of data (FLOAT) with linear scaling using a specified colormap combined with power-law scaled intensity (8 or 24-bits/pixel)


        input parameters:
          data    (input) data in FLOAT format (deformation, height, unwrapped phase, correlation...)
          pwr     (input) intensity image coregistered with data (enter - for none, FLOAT or raster image)
          width   number of samples/row of data and pwr
          start   starting line of data and pwr (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          min     minimum data value (enter - for default:  0.0000e+00)
          max     maximum data value (enter - for default:  1.0000e+00)
          cflg    cyclic data display flag:
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max - min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          scale   intensity display scale factor (enter - for default: 1.0)
          exp     intensity display exponent (enter - for default: 0.35)
          bits    bits/pixel:
                    8:  8-bit indexed color map (default)
                    24: RGB 8-bits/color

        """

        if self.validate_inputs:
            self._validate_rasdt_pwr(
                data,
                pwr,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                min,
                max,
                cflg,
                cmap,
                rasf,
                scale,
                exp,
                bits,
            )

        if self.mock_outputs:
            self._mock_rasdt_pwr_outputs(
                data,
                pwr,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                min,
                max,
                cflg,
                cmap,
                rasf,
                scale,
                exp,
                bits,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rasdt_pwr))
        result = self._gamma_call("DISP", "rasdt_pwr", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_rascpx(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rascpx.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_rascpx_outputs(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Mock the program rascpx.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rascpx(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rascpx
        Calculate a raster image of data (FCOMPLEX, SCOMPLEX) using linear, logarithmic, or power-law scaling using a specified colormap


        input parameters:
          data   (input) input data (FCOMPLEX, SCOMPLEX)
          width  number of samples/row of data
          mode   display mode (enter - for default: power-law scaling)
                   0: intensity with power-law scaling (scale and exp), default colormap: gray.cm, (default)
                   1: intensity with logarithmic scaling min -> max (dB), default colormap: gray.cm
                   2: real component, scaling min -> max, default colormap: hls.cm
                   3: imaginary component, scaling min -> max, default colormap: hls.cm
                   4: phase, scaling min -> max, default colormap: default colormap rmg.cm
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          min     data display minimum (enter - for default mode 0: not used, mode 1: -10 dB, modes 2,3: -1.0, mode 4: -PI)
          max     data display maximum (enter - for default mode 0: not used, mode 1: +16 dB, modes 2,3: +1.0, mode 4: +PI)
          cmap    colormap file (enter - for default)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          scale   power-law scale factor, (enter - for default: 1.0) (mode 0 only)
          exp     power-law exponent (enter - for default: 0.35) (mode 0 only)
          dtype   input data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
          sc_ave  intensity to use to calculate image scaling (modes 0 and 1)
                  (enter- for default: determined from the input data file)


        """

        if self.validate_inputs:
            self._validate_rascpx(
                data,
                width,
                mode,
                start,
                nlines,
                pixavx,
                pixavy,
                min,
                max,
                cmap,
                rasf,
                scale,
                exp,
                dtype,
                sc_ave,
            )

        if self.mock_outputs:
            self._mock_rascpx_outputs(
                data,
                width,
                mode,
                start,
                nlines,
                pixavx,
                pixavy,
                min,
                max,
                cmap,
                rasf,
                scale,
                exp,
                dtype,
                sc_ave,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rascpx))
        result = self._gamma_call("DISP", "rascpx", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_gcp_ras(
        self,
        ras: Path,
        GCP: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gcp_ras.

        """

        assert ras.exists(), f"{ras} does not exist"
        assert ras.stat().st_size > 0, f"{ras} has zero file size"

        assert not GCP.exists(), f"{GCP} should _not_ exist!"

    def _mock_gcp_ras_outputs(
        self,
        ras: Path,
        GCP: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Mock the program gcp_ras.

        """

        if GCP is not None and str(GCP) != "-":
            GCP.touch()

    def gcp_ras(
        self,
        ras: Path,
        GCP: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP gcp_ras: select GCPs using a raster format reference image


        input parameters:
          ras     (input) image, SUN raster: *.ras, BMP: *.bmp, TIFF: *.tif
          GCP     (output) GCP data file (text format)
          mag     zoom magnification factor (enter - for default: 3)
          win_sz  zoom window size before magnification (enter - for default: 132)


        """

        if self.validate_inputs:
            self._validate_gcp_ras(ras, GCP, mag, win_sz)

        if self.mock_outputs:
            self._mock_gcp_ras_outputs(ras, GCP, mag, win_sz)

        ca = self._clean_args(locals(), inspect.signature(self.gcp_ras))
        result = self._gamma_call("DISP", "gcp_ras", ca)

        assert GCP.exists(), f"{GCP} does not exist"
        assert GCP.stat().st_size > 0, f"{GCP} has zero file size"

        return result

    def _validate_cpx_math(
        self,
        d1: Path,
        d2: Optional[Path],
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c_re: Optional[int] = None,
        c_im: Optional[int] = None,
        zflg: Optional[int] = None,
        rflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to cpx_math.

        """

        assert d1.exists(), f"{d1} does not exist"
        assert d1.stat().st_size > 0, f"{d1} has zero file size"

        if d2 is not None:
            assert d2.exists(), f"{d2} does not exist"
            assert d2.stat().st_size > 0, f"{d2} has zero file size"

        assert not d_out.exists(), f"{d_out} should _not_ exist!"

    def _mock_cpx_math_outputs(
        self,
        d1: Path,
        d2: Optional[Path],
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c_re: Optional[int] = None,
        c_im: Optional[int] = None,
        zflg: Optional[int] = None,
        rflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program cpx_math.

        """

        if d_out is not None and str(d_out) != "-":
            d_out.touch()

    def cpx_math(
        self,
        d1: Path,
        d2: Optional[Path],
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c_re: Optional[int] = None,
        c_im: Optional[int] = None,
        zflg: Optional[int] = None,
        rflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/cpx_math
        Perform complex arithmetic operations on data files (FCOMPLEX format)


        input parameters:
          d1     (input) data file 1 (FCOMPLEX)
          d2     (input) data file 2 (FCOMPLEX) (enter - for none)
                 NOTE: if no input file is provided, d2 values are given by the c_re and c_im parameters
          d_out  (output) output of math operation on d1 and d2 (FCOMPLEX)
          width  number of samples/line
          mode   math operation to perform on data:
                   0:  addition, d1 + d2
                   1:  subtraction, d1 - d2
                   2:  multiplication, d1 * d2
                   3:  division, d1/d2
                   4:  conjugate, conj(d1)
                   5:  conjugate multiplication, d1*conj(d2)
          roff   range pixel offset to center of the reference region (enter - for default: no reference correction)
          loff   line offset to center of the reference region (enter - for default: no reference correction)
          nr     number of range pixels to average in the reference region (enter - for default: 13)
          nl     number of lines average in the reference region (enter - for default: 13)
          c_re   constant real value (enter - for default: 1.18e-38 for addition and subtraction, 1.0 for multiplication and division)
          c_im   constant imaginary value (enter - for default: 0.0)
          zflg   zero data flag (enter - for default: 0)
                   0: values of 0.0 in d1 or d2 are considered as no-data and the output is set to 0.0 (default)
                   1: values of 0.0 are considered as valid data
          rflg   reference region normalization flag (enter - for default: 0)
                   av1: average of d1 reference region
                   av2: average of d2 reference region

                   rflg = 0:
                      addition        (d1 - av1) + (d2 - av2)
                      subtraction     (d1 - av1) - (d2 - av2)
                      multiplication  (d1/av1) * (d2/av2)
                      conjugat mult.  (d1/av1) * conj(d2/av2)
                      division        (d1/av1) / (d2/av2)

                   rflg = 1:
                      addition        d1/exp(j*arg(av1)) + d2/exp(j*arg(av2))
                      subtraction     d1/exp(j*arg(av1)) - d2/exp(j*arg(av2))
                      multiplication  d1/exp(j*arg(av1)) * d2/exp(j*arg(av2))
                      conjugate mult. d1/exp(j*arg(av1)) * conj(d2/exp(j*arg(av2)))
                      division        d1/exp(j*arg(av1)) / d2/exp(j*arg(av2))


        """

        if self.validate_inputs:
            self._validate_cpx_math(
                d1, d2, d_out, width, mode, roff, loff, nr, nl, c_re, c_im, zflg, rflg
            )

        if self.mock_outputs:
            self._mock_cpx_math_outputs(
                d1, d2, d_out, width, mode, roff, loff, nr, nl, c_re, c_im, zflg, rflg
            )

        ca = self._clean_args(locals(), inspect.signature(self.cpx_math))
        result = self._gamma_call("DISP", "cpx_math", ca)

        assert d_out.exists(), f"{d_out} does not exist"
        assert d_out.stat().st_size > 0, f"{d_out} has zero file size"

        return result

    def _validate_disflag(
        self,
        flag: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to disflag.

        """

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

    def _mock_disflag_outputs(
        self,
        flag: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program disflag.

        """
        pass

    def disflag(
        self,
        flag: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP disflag: display phase unwrapping flag file


        input parameters:
          flag    (input) phase unwrapping flag file (unsigned char)
          width   samples per row of flag file
          start   starting line of flag file (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)


        """

        if self.validate_inputs:
            self._validate_disflag(flag, width, start, nlines)

        if self.mock_outputs:
            self._mock_disflag_outputs(flag, width, start, nlines)

        ca = self._clean_args(locals(), inspect.signature(self.disflag))
        result = self._gamma_call("DISP", "disflag", ca)
        return result

    def _validate_set_value(
        self,
        PAR_in: Path,
        PAR_out: Path,
        keyword: str,
        value: str,
        new_key: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to set_value.

        """

        pass

    def _mock_set_value_outputs(
        self,
        PAR_in: Path,
        PAR_out: Path,
        keyword: str,
        value: str,
        new_key: Optional[int] = None,
    ) -> None:
        """

        Mock the program set_value.

        """

        if PAR_out is not None and str(PAR_out) != "-":
            PAR_out.touch()

    def set_value(
        self,
        PAR_in: Path,
        PAR_out: Path,
        keyword: str,
        value: str,
        new_key: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Update keyword:value in text parameter files


        input parameters:
          PAR_in   (input) keyword:value based parameter file
          PAR_out  (output) keyword:value based parameter file (can be the same file as PAR_in)
          keyword  search keyword of keyword:value pair
          value    new value (note: delimit value with double quotes if it contains spaces or punctuation)
          new_key  options for new keyword_value pair
                     0: update value of existing keyword:value pair (default)
                     1: append new keyword:value pair to PAR_out


        """

        if self.validate_inputs:
            self._validate_set_value(PAR_in, PAR_out, keyword, value, new_key)

        if self.mock_outputs:
            self._mock_set_value_outputs(PAR_in, PAR_out, keyword, value, new_key)

        ca = self._clean_args(locals(), inspect.signature(self.set_value))
        result = self._gamma_call("DISP", "set_value", ca)

        assert PAR_out.exists(), f"{PAR_out} does not exist"
        assert PAR_out.stat().st_size > 0, f"{PAR_out} has zero file size"

        return result

    def _validate_cpx_to_real(self, cpx: Path, real: Path, width: int, mode: int) -> None:
        """

        Validate the arguments to cpx_to_real.

        """

        assert cpx.exists(), f"{cpx} does not exist"
        assert cpx.stat().st_size > 0, f"{cpx} has zero file size"

        assert not real.exists(), f"{real} should _not_ exist!"

    def _mock_cpx_to_real_outputs(
        self, cpx: Path, real: Path, width: int, mode: int
    ) -> None:
        """

        Mock the program cpx_to_real.

        """

        if real is not None and str(real) != "-":
            real.touch()

    def cpx_to_real(
        self, cpx: Path, real: Path, width: int, mode: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        Display Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/cpx_to_real.c
        Calculate real part, imaginary part, intensity, magnitude, or phase of FCOMPLEX data

        input parameters:
          cpx    (input) complex-valued data (FCOMPLEX)
          real   (output) real-valued data (FLOAT)
          width  samples per line of input data
          mode   math operation to perform on data:
                   0: real part
                   1: imaginary part
                   2: intensity (re*re + im*im)
                   3: magnitude (sqrt(re*re + im*im))
                   4: phase (atan2(im, re))


        """

        if self.validate_inputs:
            self._validate_cpx_to_real(cpx, real, width, mode)

        if self.mock_outputs:
            self._mock_cpx_to_real_outputs(cpx, real, width, mode)

        ca = self._clean_args(locals(), inspect.signature(self.cpx_to_real))
        result = self._gamma_call("DISP", "cpx_to_real", ca)

        assert real.exists(), f"{real} does not exist"
        assert real.stat().st_size > 0, f"{real} has zero file size"

        return result

    def _validate_dis2_dB(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min_dB: Optional[int] = None,
        max_dB: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dis2_dB.

        """

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

    def _mock_dis2_dB_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min_dB: Optional[int] = None,
        max_dB: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        """

        Mock the program dis2_dB.

        """
        pass

    def dis2_dB(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min_dB: Optional[int] = None,
        max_dB: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2_dB
        Display of 2 intensity images (FLOAT or UNSIGNED SHORT) with logarithmic scaling using a specified colormap


        input parameters:
          data1    (input) data1 (FLOAT, UNSIGNED SHORT)
          data2    (input) data2 (FLOAT, UNSIGNED SHORT, same data type as data1
          width1   number of samples/row of data1
          width2   number of samples/row of data2
          start    starting line of data (enter - for default: 1)
          nlines   number of lines to display (enter - or 0 for default: to end of file)
          xoff     x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff     y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          min_dB   minimum data value (enter - for default: -1.0000e+01)
          max_dB   maximum data value (enter - for default:  1.0000e+01)
          cmap     colormap file (enter - for default: gray.cm)
                   NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                         colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype    data type (enter - for default)
                     0: FLOAT (default)
                     1: UNSIGNED SHORT
          sc_abs   absolute scaling flag (enter - for default)
                     0: scaling relative to average (min_dB + av_dB) -> (max_dB + av_dB) (default)
                        NOTE: av_dB is the average image intensity dB
                     1: absolute scaling range: min_dB -> max_dB


        """

        if self.validate_inputs:
            self._validate_dis2_dB(
                data1,
                data2,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                min_dB,
                max_dB,
                cmap,
                dtype,
                sc_abs,
            )

        if self.mock_outputs:
            self._mock_dis2_dB_outputs(
                data1,
                data2,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                min_dB,
                max_dB,
                cmap,
                dtype,
                sc_abs,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis2_dB))
        result = self._gamma_call("DISP", "dis2_dB", ca)
        return result

    def _validate_disgbyte(
        self,
        image: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        cmap: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to disgbyte.

        """

        assert image.exists(), f"{image} does not exist"
        assert image.stat().st_size > 0, f"{image} has zero file size"

    def _mock_disgbyte_outputs(
        self,
        image: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        cmap: Optional[Path] = None,
    ) -> None:
        """

        Mock the program disgbyte.

        """
        pass

    def disgbyte(
        self,
        image: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        cmap: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP disgbyte: display data in GBYTE logarithmic scaled format


        input parameters:
          image   (input) GBYTE format data (1 byte/sample)
          width   samples per row of image
          start   starting line of image1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          scale   display scale factor (enter - for default: 1.0)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png


        """

        if self.validate_inputs:
            self._validate_disgbyte(image, width, start, nlines, scale, cmap)

        if self.mock_outputs:
            self._mock_disgbyte_outputs(image, width, start, nlines, scale, cmap)

        ca = self._clean_args(locals(), inspect.signature(self.disgbyte))
        result = self._gamma_call("DISP", "disgbyte", ca)
        return result

    def _validate_dis_dB(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min_dB: Optional[int] = None,
        max_dB: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dis_dB.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

    def _mock_dis_dB_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min_dB: Optional[int] = None,
        max_dB: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        """

        Mock the program dis_dB.

        """
        pass

    def dis_dB(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min_dB: Optional[int] = None,
        max_dB: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis_dB
        Display of intensity data (FLOAT or UNSIGNED SHORT) using logarithmic scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT or UNSIGNED SHORT)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          min_dB  data display minimum (enter - for default: -10.00 dB)
          max_dB  data display maximum (enter - for default: 10.00 dB)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT
          sc_abs  absolute scaling flag (enter - for default)
                    0: scaling relative to average (min_dB + av_dB) -> (max_dB + av_dB) (default)
                       NOTE: av_dB is the average image intensity dB
                    1: absolute scaling range: min_dB -> max_dB


        """

        if self.validate_inputs:
            self._validate_dis_dB(
                data, width, start, nlines, min_dB, max_dB, cmap, dtype, sc_abs
            )

        if self.mock_outputs:
            self._mock_dis_dB_outputs(
                data, width, start, nlines, min_dB, max_dB, cmap, dtype, sc_abs
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis_dB))
        result = self._gamma_call("DISP", "dis_dB", ca)
        return result

    def _validate_svg_map(
        self,
        image: Path,
        dem_par: Path,
        svg: Path,
        font: Optional[int] = None,
        fsize: Optional[int] = None,
        color: Optional[int] = None,
        gcolor: Optional[int] = None,
        majorx: Optional[int] = None,
        majory: Optional[int] = None,
        minorx: Optional[int] = None,
        minory: Optional[int] = None,
        thick: Optional[int] = None,
        grid: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to svg_map.

        """

        assert image.exists(), f"{image} does not exist"
        assert image.stat().st_size > 0, f"{image} has zero file size"

        assert dem_par.exists(), f"{dem_par} does not exist"
        assert dem_par.stat().st_size > 0, f"{dem_par} has zero file size"

        assert not svg.exists(), f"{svg} should _not_ exist!"

    def _mock_svg_map_outputs(
        self,
        image: Path,
        dem_par: Path,
        svg: Path,
        font: Optional[int] = None,
        fsize: Optional[int] = None,
        color: Optional[int] = None,
        gcolor: Optional[int] = None,
        majorx: Optional[int] = None,
        majory: Optional[int] = None,
        minorx: Optional[int] = None,
        minory: Optional[int] = None,
        thick: Optional[int] = None,
        grid: Optional[int] = None,
    ) -> None:
        """

        Mock the program svg_map.

        """

        if svg is not None and str(svg) != "-":
            svg.touch()

    def svg_map(
        self,
        image: Path,
        dem_par: Path,
        svg: Path,
        font: Optional[int] = None,
        fsize: Optional[int] = None,
        color: Optional[int] = None,
        gcolor: Optional[int] = None,
        majorx: Optional[int] = None,
        majory: Optional[int] = None,
        minorx: Optional[int] = None,
        minory: Optional[int] = None,
        thick: Optional[int] = None,
        grid: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP svg_map: SVG map generator


        input parameters:
          image   (input) URL of background image in png or jpg format (- for no background image)
          dem_par (input) corresponding dem_par file
          svg     (output) SVG output file
          font    name of labelling font (default = sans-serif)
          fsize   font size (default = 14)
          color   color of ticks and labels (default = black)
          gcolor  color of grid (default = black)
          majorx  major x-ticks in dem_par coordinates (default = 1)
          majory  major y-ticks in dem_par coordinates (default = 1)
          minorx  minor x-ticks in dem_par coordinates (default = 0.1)
          minory  minor y-ticks in dem_par coordinates (default = 0.1)
          thick   tick and gridline thickness in pixels (default = 1)
          grid    1 = draw grid, 0 = no grid (default = 0)
          gopac   grid opacity, 0.0 (fully transparent) to 1.0 (fully opaque), default=1.0
          gdash   grid dash size in px (default = 0 = no dashes)


        """

        if self.validate_inputs:
            self._validate_svg_map(
                image,
                dem_par,
                svg,
                font,
                fsize,
                color,
                gcolor,
                majorx,
                majory,
                minorx,
                minory,
                thick,
                grid,
            )

        if self.mock_outputs:
            self._mock_svg_map_outputs(
                image,
                dem_par,
                svg,
                font,
                fsize,
                color,
                gcolor,
                majorx,
                majory,
                minorx,
                minory,
                thick,
                grid,
            )

        ca = self._clean_args(locals(), inspect.signature(self.svg_map))
        result = self._gamma_call("DISP", "svg_map", ca)

        assert svg.exists(), f"{svg} does not exist"
        assert svg.stat().st_size > 0, f"{svg} has zero file size"

        return result

    def _validate_gbyte2float(self, infile: Path, outfile: Path) -> None:
        """

        Validate the arguments to gbyte2float.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_gbyte2float_outputs(self, infile: Path, outfile: Path) -> None:
        """

        Mock the program gbyte2float.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def gbyte2float(
        self, infile: Path, outfile: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Convert GBYTE logarithmic scaled format data (1 byte/value) to FLOAT format (4 bytes/value)***


        input parameters:
          infile   (input) GBYTE logarithmic scaled format data (1 byte/sample)
          outfile  (output) FLOAT format data (4 bytes/sample)

        """

        if self.validate_inputs:
            self._validate_gbyte2float(infile, outfile)

        if self.mock_outputs:
            self._mock_gbyte2float_outputs(infile, outfile)

        ca = self._clean_args(locals(), inspect.signature(self.gbyte2float))
        result = self._gamma_call("DISP", "gbyte2float", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_real_to_cpx(
        self, data1: Optional[Path], cpx: Path, width: int, type: int
    ) -> None:
        """

        Validate the arguments to real_to_cpx.

        """

        if data1 is not None:
            assert data1.exists(), f"{data1} does not exist"
            assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert not cpx.exists(), f"{cpx} should _not_ exist!"

    def _mock_real_to_cpx_outputs(
        self, data1: Optional[Path], cpx: Path, width: int, type: int
    ) -> None:
        """

        Mock the program real_to_cpx.

        """

        if cpx is not None and str(cpx) != "-":
            cpx.touch()

    def real_to_cpx(
        self, data1: Optional[Path], cpx: Path, width: int, type: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISPLAY Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/real_to_cpx
        Generate FCOMPLEX data from real and imaginary or magnitude and phase components

        input parameters:
          data1  (input) input data file data1 (enter - for none, FLOAT)
          data2  (input) input data file data2 (enter - for none, FLOAT)
          cpx    (output) output data file (FCOMPLEX)
          width  samples per line of data files
          type   input data type:
                   0: data1: real, set to 0.0 if not specified
                      data2: imaginary, set to 0.0 if not specified
                   1: data1: magnitude, set to 1.0 if not specified
                      data2: phase (radians), set to 0.0 if not specified


        """

        if self.validate_inputs:
            self._validate_real_to_cpx(data1, cpx, width, type)

        if self.mock_outputs:
            self._mock_real_to_cpx_outputs(data1, cpx, width, type)

        ca = self._clean_args(locals(), inspect.signature(self.real_to_cpx))
        result = self._gamma_call("DISP", "real_to_cpx", ca)

        assert cpx.exists(), f"{cpx} does not exist"
        assert cpx.stat().st_size > 0, f"{cpx} has zero file size"

        return result

    def _validate_rasmph_pwr(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rasmph_pwr.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if pwr is not None:
            assert pwr.exists(), f"{pwr} does not exist"
            assert pwr.stat().st_size > 0, f"{pwr} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_rasmph_pwr_outputs(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> None:
        """

        Mock the program rasmph_pwr.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rasmph_pwr(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasmph_pwr
        Calculate a raster image of FCOMPLEX data phase using a specified colormap combined with power-law scaled intensity (8 or 24-bits/pixel)


        input parameters:
          data    (input) input data FCOMPLEX format
          pwr     (input) intensity image coregistered with data (enter - for none, FLOAT or raster image)
          width   number of samples/row of data and pwr
          start   starting line of data and pwr (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          scale   intensity display scale factor (enter - for default: 1.0)
          exp     intensity display exponent (enter - for default: 0.35)
          bits    bits/pixel:
                    8:  8-bit indexed color map (default)
                    24: RGB 8-bits/color


        """

        if self.validate_inputs:
            self._validate_rasmph_pwr(
                data,
                pwr,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                cmap,
                rasf,
                scale,
                exp,
                bits,
            )

        if self.mock_outputs:
            self._mock_rasmph_pwr_outputs(
                data,
                pwr,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                cmap,
                rasf,
                scale,
                exp,
                bits,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rasmph_pwr))
        result = self._gamma_call("DISP", "rasmph_pwr", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_data2geotiff(
        self,
        DEM_par: Path,
        data: Path,
        type: int,
        GeoTIFF: Path,
        no_data: Optional[float] = None,
        COGflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to data2geotiff.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        assert not GeoTIFF.exists(), f"{GeoTIFF} should _not_ exist!"

    def _mock_data2geotiff_outputs(
        self,
        DEM_par: Path,
        data: Path,
        type: int,
        GeoTIFF: Path,
        no_data: Optional[float] = None,
        COGflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program data2geotiff.

        """

        if GeoTIFF is not None and str(GeoTIFF) != "-":
            GeoTIFF.touch()

    def data2geotiff(
        self,
        DEM_par: Path,
        data: Path,
        type: int,
        GeoTIFF: Path,
        no_data: Optional[float] = None,
        COGflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP data2geotiff: convert geocoded data with DEM parameter file to GeoTIFF format


        input parameters:
          DEM_par  (input) DIFF/GEO DEM parameter file
          data     (input) data file
          type     data type:
                     0: RASTER 8 or 24 bit uncompressed raster image, SUN (*.ras), BMP:(*.bmp), or TIFF: (*.tif)
                     1: SHORT integer (2 bytes/value)
                     2: FLOAT (4 bytes/value)
                     3: SCOMPLEX (short complex, 4 bytes/value)
                     4: FCOMPLEX (float complex, 8 bytes/value)
                     5: BYTE
                     6: UNSIGNED SHORT integer (2 bytes/value)
          GeoTIFF  (output) GeoTIFF file (.tif is the recommended extension)
          no_data  no_data value (enter -  for default: 0.0)
          COGflg   generate Cloud Optimized GeoTIFF (COG):
                      0: no COG tiling of output GeoTIFF (default)
                      1: generate tiled COG GeoTIFF


        """

        if self.validate_inputs:
            self._validate_data2geotiff(DEM_par, data, type, GeoTIFF, no_data, COGflg)

        if self.mock_outputs:
            self._mock_data2geotiff_outputs(DEM_par, data, type, GeoTIFF, no_data, COGflg)

        ca = self._clean_args(locals(), inspect.signature(self.data2geotiff))
        result = self._gamma_call("DISP", "data2geotiff", ca)

        assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
        assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        return result

    def _validate_disras(
        self, ras: Path, mag: Optional[int] = None, win_sz: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to disras.

        """

        assert ras.exists(), f"{ras} does not exist"
        assert ras.stat().st_size > 0, f"{ras} has zero file size"

    def _mock_disras_outputs(
        self, ras: Path, mag: Optional[int] = None, win_sz: Optional[int] = None
    ) -> None:
        """

        Mock the program disras.

        """
        pass

    def disras(
        self, ras: Path, mag: Optional[int] = None, win_sz: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP disras: Display raster format images, Sun Raster, BMP, or TIFF format


        input parameters:
          ras     (input) raster image
          mag     zoom magnification factor (enter - for default: 3)
          win_sz  zoom window size before magnification (enter - for default: 132)

          NOTE:   raster format file extensions: SUN: *.ras, BMP: *.bmp, TIFF: *.tif


        """

        if self.validate_inputs:
            self._validate_disras(ras, mag, win_sz)

        if self.mock_outputs:
            self._mock_disras_outputs(ras, mag, win_sz)

        ca = self._clean_args(locals(), inspect.signature(self.disras))
        result = self._gamma_call("DISP", "disras", ca)
        return result

    def _validate_dis2ras(
        self,
        ras1: Path,
        ras2: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dis2ras.

        """

        assert ras1.exists(), f"{ras1} does not exist"
        assert ras1.stat().st_size > 0, f"{ras1} has zero file size"

        assert ras2.exists(), f"{ras2} does not exist"
        assert ras2.stat().st_size > 0, f"{ras2} has zero file size"

    def _mock_dis2ras_outputs(
        self,
        ras1: Path,
        ras2: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Mock the program dis2ras.

        """
        pass

    def dis2ras(
        self,
        ras1: Path,
        ras2: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP dis2ras: alternating display of two raster (SUN/BMP/TIFF) format images


        input parameters:
          ras1    (input) SUN/BMP/TIFF image (8 or 24 bits/pixel) 1
          ras2    (input) SUN/BMP/TIFF image (8 or 24 bits/pixel) 2
          mag     zoom magnification factor (enter - for default: 3)
          win_sz  zoom window size before magnification (enter - for default: 132)

          NOTE:   raster format file extensions: SUN: *.ras, BMP: *.bmp, TIFF: *.tif


        """

        if self.validate_inputs:
            self._validate_dis2ras(ras1, ras2, mag, win_sz)

        if self.mock_outputs:
            self._mock_dis2ras_outputs(ras1, ras2, mag, win_sz)

        ca = self._clean_args(locals(), inspect.signature(self.dis2ras))
        result = self._gamma_call("DISP", "dis2ras", ca)
        return result

    def _validate_kml2poly(self, DEM_par: Path, kml: Path, poly: Path) -> None:
        """

        Validate the arguments to kml2poly.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert kml.exists(), f"{kml} does not exist"
        assert kml.stat().st_size > 0, f"{kml} has zero file size"

        assert not poly.exists(), f"{poly} should _not_ exist!"

    def _mock_kml2poly_outputs(self, DEM_par: Path, kml: Path, poly: Path) -> None:
        """

        Mock the program kml2poly.

        """

        if poly is not None and str(poly) != "-":
            poly.touch()

    def kml2poly(
        self, DEM_par: Path, kml: Path, poly: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate a polygon file from a KML file and a DEM/MAP parameter file


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          kml         (input) KML file containing georeferenced polygon corner coordinates
          poly        (output) file containing polygon corner coordinates


        """

        if self.validate_inputs:
            self._validate_kml2poly(DEM_par, kml, poly)

        if self.mock_outputs:
            self._mock_kml2poly_outputs(DEM_par, kml, poly)

        ca = self._clean_args(locals(), inspect.signature(self.kml2poly))
        result = self._gamma_call("DISP", "kml2poly", ca)

        assert poly.exists(), f"{poly} does not exist"
        assert poly.stat().st_size > 0, f"{poly} has zero file size"

        return result

    def _validate_dismph_pwr(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dismph_pwr.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if pwr is not None:
            assert pwr.exists(), f"{pwr} does not exist"
            assert pwr.stat().st_size > 0, f"{pwr} has zero file size"

    def _mock_dismph_pwr_outputs(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> None:
        """

        Mock the program dismph_pwr.

        """
        pass

    def dismph_pwr(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dismph_pwr
        Display FCOMPLEX data phase using a specified colormap combined with power-law scaled intensity (8 or 24-bits/pixel)


        input parameters:
          data    (input) data (FCOMPLEX)
          pwr     (input) intensity image coregistered with data (enter - for none, FLOAT or raster image)
          width   number of samples/row of data and pwr
          start   starting line of data and pwr (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   intensity display scale factor (enter - for default: 1.0)
          exp     intensity display exponent (enter - for default: 0.35)
          bits    bits/pixel (enter - for default)
                     8: 8-bit indexed color map (default)
                    24: RGB 8-bits/color


        """

        if self.validate_inputs:
            self._validate_dismph_pwr(
                data, pwr, width, start, nlines, cmap, scale, exp, bits
            )

        if self.mock_outputs:
            self._mock_dismph_pwr_outputs(
                data, pwr, width, start, nlines, cmap, scale, exp, bits
            )

        ca = self._clean_args(locals(), inspect.signature(self.dismph_pwr))
        result = self._gamma_call("DISP", "dismph_pwr", ca)
        return result

    def _validate_vec_math(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        c1: Optional[int] = None,
        c2: Optional[int] = None,
        c3: Optional[int] = None,
        nflg: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to vec_math.

        """

        assert d1.exists(), f"{d1} does not exist"
        assert d1.stat().st_size > 0, f"{d1} has zero file size"

        assert d2.exists(), f"{d2} does not exist"
        assert d2.stat().st_size > 0, f"{d2} has zero file size"

        assert not d_out.exists(), f"{d_out} should _not_ exist!"

    def _mock_vec_math_outputs(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        c1: Optional[int] = None,
        c2: Optional[int] = None,
        c3: Optional[int] = None,
        nflg: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Mock the program vec_math.

        """

        if d_out is not None and str(d_out) != "-":
            d_out.touch()

    def vec_math(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        c1: Optional[int] = None,
        c2: Optional[int] = None,
        c3: Optional[int] = None,
        nflg: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/vec_math
        Perform vector and arithmetic operations on 3D float vector data


        input parameters:
          d1     (input) vector float data 1 (XYZ, ENU..., enter - for none)
                 NOTE: if no input file is provided, then d1 values are set to (0,0,0)
          d2     (input) vector float data 2 (XYZ, ENU..., enter - for none)
                 NOTE: if no input file is provided for modes 0->3, d2 values are set to (c1, c2, c3)
          d_out  (output) vector or scalar result (XYZ, ENU..., or scalar for modes 2,4: dot product and norm(d1))
          width  number of 3D vectors/line
          mode   math operations:
                   0: vector addition: d1 + d2
                   1: vector subtraction: d1 - d2
                   2: dot product: d1 . d2, scalar float output
                   3: cross product: d1 x d2
                   4: norm(d1), scalar float output
                   5: scalar multiply d1 * d2, where d2 is a scalar array
                   6: scalar divide d1/d2 where d2 is a scalar array
          c1     constant value for first vector component, when d2 set to - (float)
          c2     constant value for second vector component, when d2 set to - (float)
          c3     constant value for third vector component, when d2 set to - (float)
          nflg   normalize vector flag (enter - for default: 0):
                   0: do not normalize output vector data (default)
                   1: normalize output vector data, dividing by |d_out| for modes 0,1,3
                 NOTE: if the vector is (0,0,0) then the normalized output is set to (0,0,0)
          nl     number of lines, required only if d1 is set to -
          NOTE: The input data arrays d1 and d2 must all have the same number of samples/line

        """

        if self.validate_inputs:
            self._validate_vec_math(d1, d2, d_out, width, mode, c1, c2, c3, nflg, nl)

        if self.mock_outputs:
            self._mock_vec_math_outputs(d1, d2, d_out, width, mode, c1, c2, c3, nflg, nl)

        ca = self._clean_args(locals(), inspect.signature(self.vec_math))
        result = self._gamma_call("DISP", "vec_math", ca)

        assert d_out.exists(), f"{d_out} does not exist"
        assert d_out.stat().st_size > 0, f"{d_out} has zero file size"

        return result

    def _validate_dismph_fft(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        nfft: Optional[int] = None,
        mag: Optional[int] = None,
        data_type: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dismph_fft.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

    def _mock_dismph_fft_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        nfft: Optional[int] = None,
        mag: Optional[int] = None,
        data_type: Optional[int] = None,
    ) -> None:
        """

        Mock the program dismph_fft.

        """
        pass

    def dismph_fft(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        nfft: Optional[int] = None,
        mag: Optional[int] = None,
        data_type: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP dismph_fft: Display of magnitude/phase and 2D FFT of complex data


        input parameters:
          data       (input) data (SCOMPLEX or FCOMPLEX)
          width      complex samples per row
          start      starting line to display (enter - for default: 1)
          nlines     number of lines to display (enter - or 0 for default: to end of file)
          scale      display scale factor (enter - for default: 1.0)
          exp        display exponent (enter - for default: 0.35)
          nfft       2D FFT size, nfft x nfft (enter - for default: 128)
          mag        zoom and FFT window magnification factor (enter - for default: 3)
          data_type  input data type (enter - for default)
                       0: FCOMPLEX (default)
                       1: SCOMPLEX


        """

        if self.validate_inputs:
            self._validate_dismph_fft(
                data, width, start, nlines, scale, exp, nfft, mag, data_type
            )

        if self.mock_outputs:
            self._mock_dismph_fft_outputs(
                data, width, start, nlines, scale, exp, nfft, mag, data_type
            )

        ca = self._clean_args(locals(), inspect.signature(self.dismph_fft))
        result = self._gamma_call("DISP", "dismph_fft", ca)
        return result

    def _validate_svg_arrow(
        self,
        dv_norm: Path,
        dv_phi: Path,
        width: int,
        svg: Path,
        image: Optional[int] = None,
        norm: Optional[int] = None,
        gridx: Optional[int] = None,
        gridy: Optional[int] = None,
        color: Optional[int] = None,
        thick: Optional[int] = None,
        head: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to svg_arrow.

        """

        assert dv_norm.exists(), f"{dv_norm} does not exist"
        assert dv_norm.stat().st_size > 0, f"{dv_norm} has zero file size"

        assert dv_phi.exists(), f"{dv_phi} does not exist"
        assert dv_phi.stat().st_size > 0, f"{dv_phi} has zero file size"

        assert not svg.exists(), f"{svg} should _not_ exist!"

    def _mock_svg_arrow_outputs(
        self,
        dv_norm: Path,
        dv_phi: Path,
        width: int,
        svg: Path,
        image: Optional[int] = None,
        norm: Optional[int] = None,
        gridx: Optional[int] = None,
        gridy: Optional[int] = None,
        color: Optional[int] = None,
        thick: Optional[int] = None,
        head: Optional[int] = None,
    ) -> None:
        """

        Mock the program svg_arrow.

        """

        if svg is not None and str(svg) != "-":
            svg.touch()

    def svg_arrow(
        self,
        dv_norm: Path,
        dv_phi: Path,
        width: int,
        svg: Path,
        image: Optional[int] = None,
        norm: Optional[int] = None,
        gridx: Optional[int] = None,
        gridy: Optional[int] = None,
        color: Optional[int] = None,
        thick: Optional[int] = None,
        head: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP svg_arrow: Draw arrow files on an image and store as SVG


        input parameters:
          dv_norm (input) arrow length file (float)
          dv_phi  (input) arrow direction file (float)
          width   number of samples/row
          svg     (output) arrow file in SVG format
          image   URL of background image in png or jpg format (- for no background image)
          norm    arrow length normalisation factor (default = 1.0)
          gridx   step size for arrow grid in x direction (default = 10)
          gridy   step size for arrow grid in y direction (default = gridx)
          color   black, white, blue etc (default = black)
          thick   line thickness in pixels (default = 1)
          head    arrow head size (default = 3)


        """

        if self.validate_inputs:
            self._validate_svg_arrow(
                dv_norm, dv_phi, width, svg, image, norm, gridx, gridy, color, thick, head
            )

        if self.mock_outputs:
            self._mock_svg_arrow_outputs(
                dv_norm, dv_phi, width, svg, image, norm, gridx, gridy, color, thick, head
            )

        ca = self._clean_args(locals(), inspect.signature(self.svg_arrow))
        result = self._gamma_call("DISP", "svg_arrow", ca)

        assert svg.exists(), f"{svg} does not exist"
        assert svg.stat().st_size > 0, f"{svg} has zero file size"

        return result

    def _validate_ras3pwr(
        self,
        d1: Path,
        d2: Path,
        d3: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale1: Optional[int] = None,
        scale2: Optional[int] = None,
        scale3: Optional[int] = None,
        exp: Optional[float] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to ras3pwr.

        """

        assert d1.exists(), f"{d1} does not exist"
        assert d1.stat().st_size > 0, f"{d1} has zero file size"

        assert d2.exists(), f"{d2} does not exist"
        assert d2.stat().st_size > 0, f"{d2} has zero file size"

        assert d3.exists(), f"{d3} does not exist"
        assert d3.stat().st_size > 0, f"{d3} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_ras3pwr_outputs(
        self,
        d1: Path,
        d2: Path,
        d3: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale1: Optional[int] = None,
        scale2: Optional[int] = None,
        scale3: Optional[int] = None,
        exp: Optional[float] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Mock the program ras3pwr.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras3pwr(
        self,
        d1: Path,
        d2: Path,
        d3: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale1: Optional[int] = None,
        scale2: Optional[int] = None,
        scale3: Optional[int] = None,
        exp: Optional[float] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras3pwr
        Generate 24-bit RGB raster graphics image of 3 intensity files


        input parameters:
          d1       (input) data channel 1 (used for image scaling) (float) (red)
          d2       (input) data channel 2 (float)(green)
          d3       (input) data channel 3 (float)(blue)
          width    number of samples/row in the input data files
          start    starting line (enter - for default: 1)
          nlines   number of lines (enter - or 0 for default: to end of file)
          pixavx   number of pixels to average across (enter - for default: 1)
          pixavy   number of pixels to average down (enter - for default: 1)
          scale1   relative display scale factor for channel 1 red   (enter - for default: 1.0)
          scale2   relative display scale factor for channel 2 green (enter - for default: 1.0)
          scale3   relative display scale factor for channel 3 blue  (enter - for default: 1.0)
          exp      display exponent (enter - for default: 0.35)
          rasf     (output) image filename, extension determines the format, enter - for default: *.bmp
                     *.bmp BMP format
                     *.ras Sun raster format
                     *.tif TIFF format


        """

        if self.validate_inputs:
            self._validate_ras3pwr(
                d1,
                d2,
                d3,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                scale1,
                scale2,
                scale3,
                exp,
                rasf,
            )

        if self.mock_outputs:
            self._mock_ras3pwr_outputs(
                d1,
                d2,
                d3,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                scale1,
                scale2,
                scale3,
                exp,
                rasf,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras3pwr))
        result = self._gamma_call("DISP", "ras3pwr", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_disdt_pwr(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to disdt_pwr.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if pwr is not None:
            assert pwr.exists(), f"{pwr} does not exist"
            assert pwr.stat().st_size > 0, f"{pwr} has zero file size"

    def _mock_disdt_pwr_outputs(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> None:
        """

        Mock the program disdt_pwr.

        """
        pass

    def disdt_pwr(
        self,
        data: Path,
        pwr: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        bits: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/disdt_pwr
        Display data (FLOAT) with linear scaling using a specified colormap combined with power-law scaled intensity (8 or 24-bits/pixel)


        input parameters:
          data    (input) data in FLOAT format (deformation, height, unwrapped phase, correlation...)
          pwr     (input) intensity image coregistered with data (enter - for none, FLOAT or raster image)
          width   number of samples/row of data and pwr
          start   starting line of data and pwr file (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          min     minimum data value (enter - for default:  0.0000e+00)
          max     maximum data value (enter - for default:  1.0000e+00)
          cflg    cyclic data display flag:
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max - min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   intensity display scale factor (enter - for default: 1.0)
          exp     intensity display exponent (enter - for default: 0.35)
          bits    bits/pixel (enter - for default)
                     8: 8-bit indexed color map (default)
                    24: RGB 8-bits/color

        """

        if self.validate_inputs:
            self._validate_disdt_pwr(
                data, pwr, width, start, nlines, min, max, cflg, cmap, scale, exp, bits
            )

        if self.mock_outputs:
            self._mock_disdt_pwr_outputs(
                data, pwr, width, start, nlines, min, max, cflg, cmap, scale, exp, bits
            )

        ca = self._clean_args(locals(), inspect.signature(self.disdt_pwr))
        result = self._gamma_call("DISP", "disdt_pwr", ca)
        return result

    def _validate_real_to_vec(
        self, cmp1: Path, cmp2: Path, cmp3: Path, width: int, vec: Path
    ) -> None:
        """

        Validate the arguments to real_to_vec.

        """

        assert cmp1.exists(), f"{cmp1} does not exist"
        assert cmp1.stat().st_size > 0, f"{cmp1} has zero file size"

        assert cmp2.exists(), f"{cmp2} does not exist"
        assert cmp2.stat().st_size > 0, f"{cmp2} has zero file size"

        assert cmp3.exists(), f"{cmp3} does not exist"
        assert cmp3.stat().st_size > 0, f"{cmp3} has zero file size"

        assert not vec.exists(), f"{vec} should _not_ exist!"

    def _mock_real_to_vec_outputs(
        self, cmp1: Path, cmp2: Path, cmp3: Path, width: int, vec: Path
    ) -> None:
        """

        Mock the program real_to_vec.

        """

        if vec is not None and str(vec) != "-":
            vec.touch()

    def real_to_vec(
        self, cmp1: Path, cmp2: Path, cmp3: Path, width: int, vec: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Display Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/real_to_vec.c
        Combine 3 individual float vector components into a float vector format output file

        input parameters:
          cmp1   (input) vector component 1 (float, enter - for none)
                 NOTE: if the input is specified as -, then the component data value is set to 0.0
          cmp2   (input) vector component 2 (float, enter - for none)
          cmp3   (input) vector component 3 (float, enter - for none)
          width  number of vectors per line of the input data
          vec    (output) vector data (float)
                 NOTE: vector data are triplets of 4-byte single-precision floating point numbers (cmp1, cmp2, cmp3)


        """

        if self.validate_inputs:
            self._validate_real_to_vec(cmp1, cmp2, cmp3, width, vec)

        if self.mock_outputs:
            self._mock_real_to_vec_outputs(cmp1, cmp2, cmp3, width, vec)

        ca = self._clean_args(locals(), inspect.signature(self.real_to_vec))
        result = self._gamma_call("DISP", "real_to_vec", ca)

        assert vec.exists(), f"{vec} does not exist"
        assert vec.stat().st_size > 0, f"{vec} has zero file size"

        return result

    def _validate_float2short(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        neg: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to float2short.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_float2short_outputs(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        neg: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program float2short.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def float2short(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        neg: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP float2short: Convert floating point data to short integer format


        input parameters:
          infile   (input) input data file (FLOAT, 4 bytes/sample)
          outfile  (output) output file (SHORT integers, 2 bytes/sample)
          scale    scale factor (enter - for default: 1.0)
          exp      exponent (enter - for default: 1.0)
          neg      behavior for negative output values (enter - for default)
                     0: replace by minimum positive value (default)
                     1: keep negative values
          dtype    output data type (enter - for default)
                     0: SHORT (int16, default)
                     1: UNSIGNED SHORT (uint16)

        output = scale*input^exp  (for SAR backscatter use scale=1000.0, exp=0.5)


        """

        if self.validate_inputs:
            self._validate_float2short(infile, outfile, scale, exp, neg, dtype)

        if self.mock_outputs:
            self._mock_float2short_outputs(infile, outfile, scale, exp, neg, dtype)

        ca = self._clean_args(locals(), inspect.signature(self.float2short))
        result = self._gamma_call("DISP", "float2short", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_dis2mph_pwr(
        self,
        data1: Path,
        data2: Path,
        pwr: Optional[Path],
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to dis2mph_pwr.

        """

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

        if pwr is not None:
            assert pwr.exists(), f"{pwr} does not exist"
            assert pwr.stat().st_size > 0, f"{pwr} has zero file size"

    def _mock_dis2mph_pwr_outputs(
        self,
        data1: Path,
        data2: Path,
        pwr: Optional[Path],
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Mock the program dis2mph_pwr.

        """
        pass

    def dis2mph_pwr(
        self,
        data1: Path,
        data2: Path,
        pwr: Optional[Path],
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2mph_pwr
        Display the phase of 2 complex images (FCOMPLEX type) combined with power-law scaled intensity


        input parameters:
          data1   (input) complex data1 (FCOMPLEX)
          data2   (input) complex data2 (FCOMPLEX)
          pwr     (input) intensity image coregistered with data1 (enter - for none, FLOAT or raster image)
          width1  data samples per row of data1
          width2  data samples per row of data2
          start   starting line of cpx1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   display scale factor (enter - for default: 1.0)
          exp     display exponent (enter - for default: 0.35)


        """

        if self.validate_inputs:
            self._validate_dis2mph_pwr(
                data1, data2, pwr, width2, start, nlines, xoff, yoff, cmap, scale, exp
            )

        if self.mock_outputs:
            self._mock_dis2mph_pwr_outputs(
                data1, data2, pwr, width2, start, nlines, xoff, yoff, cmap, scale, exp
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis2mph_pwr))
        result = self._gamma_call("DISP", "dis2mph_pwr", ca)
        return result

    def _validate_ras2ras(
        self,
        ras_in: Path,
        ras_out: Path,
        cmap: Optional[Path] = None,
        force24: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras2ras.

        """

        assert ras_in.exists(), f"{ras_in} does not exist"
        assert ras_in.stat().st_size > 0, f"{ras_in} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

    def _mock_ras2ras_outputs(
        self,
        ras_in: Path,
        ras_out: Path,
        cmap: Optional[Path] = None,
        force24: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras2ras.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras2ras(
        self,
        ras_in: Path,
        ras_out: Path,
        cmap: Optional[Path] = None,
        force24: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Format and colormap conversion of raster images


        input parameters:
          ras_in   (input) SUN/BMP/TIFF format raster image (8 or 24 bits/sample)
          ras_out  (output) SUN/BMP/TIFF format raster image
          cmap     new colormap for 8-bit input image (enter - for default, retain original colormap)
                   NOTE: colormaps are located by default in $DISP_HOME/cmaps, examples: gray.cm, hls.cm, rmg.cm...
          force24  convert 8 to 24 bits: (enter - for default)
                     0: bits/sample remains unchanged (default)
                     1: output is 24 bits/sample


        """

        if self.validate_inputs:
            self._validate_ras2ras(ras_in, ras_out, cmap, force24)

        if self.mock_outputs:
            self._mock_ras2ras_outputs(ras_in, ras_out, cmap, force24)

        ca = self._clean_args(locals(), inspect.signature(self.ras2ras))
        result = self._gamma_call("DISP", "ras2ras", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_ras24_float(
        self,
        f1: Path,
        f2: Path,
        f3: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        imin: Optional[int] = None,
        imax: Optional[int] = None,
        sat_min: Optional[int] = None,
        sat_max: Optional[int] = None,
        sc1: Optional[int] = None,
        A1: Optional[int] = None,
        B1: Optional[int] = None,
        cyclic1: Optional[int] = None,
        sc2: Optional[int] = None,
        A2: Optional[int] = None,
        B2: Optional[int] = None,
        start_f1: Optional[int] = None,
        start_f2: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras24_float.

        """

        assert f1.exists(), f"{f1} does not exist"
        assert f1.stat().st_size > 0, f"{f1} has zero file size"

        assert f2.exists(), f"{f2} does not exist"
        assert f2.stat().st_size > 0, f"{f2} has zero file size"

        assert f3.exists(), f"{f3} does not exist"
        assert f3.stat().st_size > 0, f"{f3} has zero file size"

        assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_ras24_float_outputs(
        self,
        f1: Path,
        f2: Path,
        f3: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        imin: Optional[int] = None,
        imax: Optional[int] = None,
        sat_min: Optional[int] = None,
        sat_max: Optional[int] = None,
        sc1: Optional[int] = None,
        A1: Optional[int] = None,
        B1: Optional[int] = None,
        cyclic1: Optional[int] = None,
        sc2: Optional[int] = None,
        A2: Optional[int] = None,
        B2: Optional[int] = None,
        start_f1: Optional[int] = None,
        start_f2: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras24_float.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras24_float(
        self,
        f1: Path,
        f2: Path,
        f3: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        imin: Optional[int] = None,
        imax: Optional[int] = None,
        sat_min: Optional[int] = None,
        sat_max: Optional[int] = None,
        sc1: Optional[int] = None,
        A1: Optional[int] = None,
        B1: Optional[int] = None,
        cyclic1: Optional[int] = None,
        sc2: Optional[int] = None,
        A2: Optional[int] = None,
        B2: Optional[int] = None,
        start_f1: Optional[int] = None,
        start_f2: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras24_float
        Generate 24-bit raster graphics image of 1, 2, or 3 float data files


        input parameters:
          f1           (input) file 1 (float, red/hue           enter - if not available)
          f2           (input) file 2 (float, green/brightness, enter - if not available)
          f3           (input) file 3 (float, blue/saturation,  enter - if not available)
          width        samples per row of f1, f2, and f3
          rasf         (output) image filename, extension determines format:
                         *.bmp BMP format
                         *.ras Sun raster format
                         *.tif TIFF format
          color_model  color model selection flag: (enter - for default)
                         0: RGB color model (default)
                         1: HLS (double hexagon color model)
                         2: HSV (single hexagon color model)
          h0           starting hue (color for starting value, enter - for default: 0.0)
          hrange       range of hue values in degrees (-360. ... 360., enter - for default: 360.0)
          imin         minimum brightness value (0.0 ... 1.0, enter - for default: 0.15)
          imax         maximum brightness value (0.0 ... 1.0, enter - for default: 0.85)
          sat_min      minimum color saturation value (0.0 ... 1.0, enter - for default: 0.0)
          sat_max      maximum color saturation value (0.0 ... 1.0, enter - for default: 1.0)

        Input image f1 scaling parameters:
          sc1          Scaling model flag (enter - for default: 0; 0: lin, 1: log, 2: power-law)
          A1           Scaling parameter A (minimum or scale; enter - for default: 0.0)
          B1           Scaling parameter B (maximum or exponent; enter - for default: 6.2832)
          cyclic1      Cyclic scaling model (enter - for default: 1; 0: no 1: yes)

        Input image f2 scaling parameters:
          sc2          Scaling model flag (enter - for default: 2; 0: lin, 1: log, 2: power-law)
          A2           Scaling parameter A (minimum or scale; enter - for default: 1.0)
          B2           Scaling parameter B (maximum or exponent; enter - for default: 0.35)

        Input image f3 scaling parameters:
          sc3          Scaling model flag (enter - for default: 0; 0: lin, 1: log, 2: power-law)
          A3           Scaling parameter A (minimum or scale; enter - for default: 0.0)
          B3           Scaling parameter B (maximum or exponent; enter - for default: 1.0)

        General parameters:
          start_f1     starting line of f1 (enter - for default: 1)
          start_f2     starting line of f2 (enter - for default: 1)
          start_f3     starting line of f3 (enter - for default: 1)
          nlines       number of lines to process (enter - or 0 for default: to end of file)
          pixavr       number of pixels to average in range (enter - for default: 1)
          pixavaz      number of pixels to average in azimuth (enter - for default: 1)


        """

        if self.validate_inputs:
            self._validate_ras24_float(
                f1,
                f2,
                f3,
                width,
                rasf,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat_min,
                sat_max,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                nlines,
                pixavr,
                pixavaz,
            )

        if self.mock_outputs:
            self._mock_ras24_float_outputs(
                f1,
                f2,
                f3,
                width,
                rasf,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat_min,
                sat_max,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                nlines,
                pixavr,
                pixavaz,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras24_float))
        result = self._gamma_call("DISP", "ras24_float", ca)

        assert rasf.exists(), f"{rasf} does not exist"
        assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_double2float(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to double2float.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_double2float_outputs(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Mock the program double2float.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def double2float(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/double2float.c
        Convert double precision floating point data to single precision floating point data


        input parameters:
          infile   (input) input data file (double)
          outfile  (output) output data file (float)
          scale    scale factor (default: 1.0)
          exp      exponent (default: 1.0)

        NOTE: output = scale*input^exp


        """

        if self.validate_inputs:
            self._validate_double2float(infile, outfile, scale, exp)

        if self.mock_outputs:
            self._mock_double2float_outputs(infile, outfile, scale, exp)

        ca = self._clean_args(locals(), inspect.signature(self.double2float))
        result = self._gamma_call("DISP", "double2float", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_float2uchar(
        self, infile: int, outfile: int, scale: float, exp: float
    ) -> None:
        """

        Validate the arguments to float2uchar.

        """

        pass

    def _mock_float2uchar_outputs(
        self, infile: int, outfile: int, scale: float, exp: float
    ) -> None:
        """

        Mock the program float2uchar.

        """
        pass

    def float2uchar(
        self, infile: int, outfile: int, scale: float, exp: float
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP float2uchar: Format transformation from float (4-byte) to unsigned char (1-byte)
        outfile = scale*infile^exp (for coherence use scale=255.0, exp=1.0)


        input parameters:
          infile   input file (float, 4 bytes/sample)
          outfile  output file (unsigned char, 1 byte/sample)
          scale    scale factor (default=1.0)
          exp      exponent (default=1.0)


        """

        if self.validate_inputs:
            self._validate_float2uchar(infile, outfile, scale, exp)

        if self.mock_outputs:
            self._mock_float2uchar_outputs(infile, outfile, scale, exp)

        ca = self._clean_args(locals(), inspect.signature(self.float2uchar))
        result = self._gamma_call("DISP", "float2uchar", ca)
        return result

    def _validate_float_math(
        self,
        d1: Path,
        d2: Optional[Path],
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c0: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to float_math.

        """

        assert d1.exists(), f"{d1} does not exist"
        assert d1.stat().st_size > 0, f"{d1} has zero file size"

        if d2 is not None:
            assert d2.exists(), f"{d2} does not exist"
            assert d2.stat().st_size > 0, f"{d2} has zero file size"

        assert not d_out.exists(), f"{d_out} should _not_ exist!"

    def _mock_float_math_outputs(
        self,
        d1: Path,
        d2: Optional[Path],
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c0: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program float_math.

        """

        if d_out is not None and str(d_out) != "-":
            d_out.touch()

    def float_math(
        self,
        d1: Path,
        d2: Optional[Path],
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c0: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/float_math
        Perform mathematical operations on data files (float)


        input parameters:
          d1     (input) data file 1 (float)
          d2     (input) data file 2 (float) (enter - for none)
                  NOTE: if no input file is provided, d2 values are set to value specified by c0 parameter
          d_out  (output) output of math operation on the input data, must differ from d1 and d2! (float)
          width  number of samples/line
          mode   math operation to perform on data:
                   0:  addition, d1 + d2
                   1:  subtraction, d1 - d2
                   2:  multiplication, d1 * d2
                   3:  division, d1/d2
                   4:  10 * log10(d1), evaluate dB value
                   5:  d1*d1
                   6:  sqrt(d1)
                   7:  sin(d1)
                   8:  cos(d1)
                   9:  tan(d1)
                   10: asin(d1)
                   11: acos(d1)
                   12: atan2(d2,d1)
                   13: d1**d2
                   14: abs(d1)
          roff   range pixel offset to center of the reference region (enter - for default: no reference correction)
          loff   line offset to center of the reference region (enter - for default: no reference correction)
          nr     number of range pixels to average in the reference region (enter - for default: 13)
          nl     number of lines average in the reference region (enter - for default: 13)
          c0     constant value (enter - for default: 1.18e-38 for addition and subtraction, 1.0 for multiplication and division)
          zflg   zero data flag (enter - for default:0):
                   0: values of 0.0 in d1 or d2 are considered as no-data and the output is set to 0.0 (default)
                   1: values of 0.0 are considered as valid data

          NOTE: when specifying a reference region with roff, loff, nr, nl parameters:
                modes 0, 1:  reference region average value is subtracted from d1 and d2 data respectively
                modes 2, 3:  d1 and d2 data are divided by the average in the reference region
                mode  4:     data values in d1 are divided by the average in the reference region
                modes 7->14: reference correction not applicable to these modes

        """

        if self.validate_inputs:
            self._validate_float_math(
                d1, d2, d_out, width, mode, roff, loff, nr, nl, c0, zflg
            )

        if self.mock_outputs:
            self._mock_float_math_outputs(
                d1, d2, d_out, width, mode, roff, loff, nr, nl, c0, zflg
            )

        ca = self._clean_args(locals(), inspect.signature(self.float_math))
        result = self._gamma_call("DISP", "float_math", ca)

        assert d_out.exists(), f"{d_out} does not exist"
        assert d_out.stat().st_size > 0, f"{d_out} has zero file size"

        return result

    def _validate_cpd(
        self,
        din: Path,
        dout: Path,
        width: int,
        dtype: int,
        xoff: Optional[int] = None,
        nx: Optional[int] = None,
        yoff: Optional[int] = None,
        ny: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to cpd.

        """

        assert din.exists(), f"{din} does not exist"
        assert din.stat().st_size > 0, f"{din} has zero file size"

        assert not dout.exists(), f"{dout} should _not_ exist!"

    def _mock_cpd_outputs(
        self,
        din: Path,
        dout: Path,
        width: int,
        dtype: int,
        xoff: Optional[int] = None,
        nx: Optional[int] = None,
        yoff: Optional[int] = None,
        ny: Optional[int] = None,
    ) -> None:
        """

        Mock the program cpd.

        """

        if dout is not None and str(dout) != "-":
            dout.touch()

    def cpd(
        self,
        din: Path,
        dout: Path,
        width: int,
        dtype: int,
        xoff: Optional[int] = None,
        nx: Optional[int] = None,
        yoff: Optional[int] = None,
        ny: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP cpd: Copy segments of FLOAT, FCOMPLEX and SCOMPLEX data files


        input parameters:
          din       (input) input data file
          dout      (output) output data file
          width     number of data values/line in the input data file
          dtype     input data type:
                      0: FLOAT (4 bytes/value)
                      1: FCOMPLEX (4 bytes real, 4 bytes imaginary)
                      2: SCOMPLEX (2 bytes real, 2 bytes imaginary)
          xoff      offset to starting sample (samples) (enter - for default: 0)
          nx        number of output samples/line (enter - for default: to end of line)
          yoff      offset to starting line (lines) (enter - for default: 0)
          ny        number of output lines (enter - for default: to end of file)

        """

        if self.validate_inputs:
            self._validate_cpd(din, dout, width, dtype, xoff, nx, yoff, ny)

        if self.mock_outputs:
            self._mock_cpd_outputs(din, dout, width, dtype, xoff, nx, yoff, ny)

        ca = self._clean_args(locals(), inspect.signature(self.cpd))
        result = self._gamma_call("DISP", "cpd", ca)

        assert dout.exists(), f"{dout} does not exist"
        assert dout.stat().st_size > 0, f"{dout} has zero file size"

        return result

    def _validate_disras_dem_par(
        self,
        ras: Path,
        DEM_par: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to disras_dem_par.

        """

        assert ras.exists(), f"{ras} does not exist"
        assert ras.stat().st_size > 0, f"{ras} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

    def _mock_disras_dem_par_outputs(
        self,
        ras: Path,
        DEM_par: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Mock the program disras_dem_par.

        """
        pass

    def disras_dem_par(
        self,
        ras: Path,
        DEM_par: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP disras_dem_par: display raster image with DEM/MAP parameter file


        input parameters:
          ras      (input) raster image with same dimensions as in DEM_par (SUN *.ras, or BMP *.bmp format)
          DEM_par  (input) DIFF DEM/MAP parameter file
          mag      zoom magnification factor (enter - for default: 3)
          win_sz   zoom window size before magnification (enter - for default: 132)


        """

        if self.validate_inputs:
            self._validate_disras_dem_par(ras, DEM_par, mag, win_sz)

        if self.mock_outputs:
            self._mock_disras_dem_par_outputs(ras, DEM_par, mag, win_sz)

        ca = self._clean_args(locals(), inspect.signature(self.disras_dem_par))
        result = self._gamma_call("DISP", "disras_dem_par", ca)
        return result

    def _validate_ras2float(
        self,
        ras: Path,
        chan: Optional[int],
        mode: Optional[int],
        min: Optional[float],
        max: Optional[float],
        dout: Path,
    ) -> None:
        """

        Validate the arguments to ras2float.

        """

        assert ras.exists(), f"{ras} does not exist"
        assert ras.stat().st_size > 0, f"{ras} has zero file size"

        assert not dout.exists(), f"{dout} should _not_ exist!"

    def _mock_ras2float_outputs(
        self,
        ras: Path,
        chan: Optional[int],
        mode: Optional[int],
        min: Optional[float],
        max: Optional[float],
        dout: Path,
    ) -> None:
        """

        Mock the program ras2float.

        """

        if dout is not None and str(dout) != "-":
            dout.touch()

    def ras2float(
        self,
        ras: Path,
        chan: Optional[int],
        mode: Optional[int],
        min: Optional[float],
        max: Optional[float],
        dout: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras2float
        Convert selected color channel (RGB) of a raster image to 32-bit FLOAT


        input parameters:
          ras   (input) 8 or 24-bit raster image
                  *.bmp BMP format
                  *.ras Sun raster format
                  *.tif TIFF format
          chan  RGB channel to convert to FLOAT (enter - for default)
                  1: red (default)
                  2: green
                  3: blue
          mode  data scaling (enter - for default: linear scaling)
                  0: linear scaling: min -> max, (default)
                  1: logarithmic scaling: min_dB -> max_dB
          min   minimum value to rescale raster data (enter - for default)
                  linear:        0.0
                  logarithmic: -40.0 dB
          max   maximum value to rescale raster data (enter - for default)
                  linear:        2.0
                  logarithmic:  10.0 dB
          dout   (output) data file (FLOAT format)

        NOTES
          1. Data values are the selected R, G, or B channel of the colomap for 8-bit images
          2. min and max are interpreted as dB for mode 1: logarithmic scaling
          3. Data are converted to intensity from the rescaled dB values in mode 1: logarithmic scaling


        """

        if self.validate_inputs:
            self._validate_ras2float(ras, chan, mode, min, max, dout)

        if self.mock_outputs:
            self._mock_ras2float_outputs(ras, chan, mode, min, max, dout)

        ca = self._clean_args(locals(), inspect.signature(self.ras2float))
        result = self._gamma_call("DISP", "ras2float", ca)

        assert dout.exists(), f"{dout} does not exist"
        assert dout.stat().st_size > 0, f"{dout} has zero file size"

        return result

    def _validate_dismph(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dismph.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

    def _mock_dismph_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Mock the program dismph.

        """
        pass

    def dismph(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dismph
        Display data (FCOMPLEX, SCOMPLEX, BCOMPLEX) using a specified colormap and power-law scaled intensity


        input parameters:
          data    (input) data (FCOMPLEX, SCOMPLEX, BCOMPLEX)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          scale   power-law scale factor, (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
                    2: BCOMPLEX
          bits    bits/pixel (enter - for default)
                     8: 8-bit indexed color map (default)
                    24: RGB 8-bits/color
          sc_ave  average intensity used to scale image (enter - for default: determined from data)


        """

        if self.validate_inputs:
            self._validate_dismph(
                data, width, start, nlines, scale, exp, cmap, dtype, bits, sc_ave
            )

        if self.mock_outputs:
            self._mock_dismph_outputs(
                data, width, start, nlines, scale, exp, cmap, dtype, bits, sc_ave
            )

        ca = self._clean_args(locals(), inspect.signature(self.dismph))
        result = self._gamma_call("DISP", "dismph", ca)
        return result

    def _validate_rasshd(
        self,
        DEM: Path,
        width: int,
        col_post: int,
        row_post: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        theta0: Optional[int] = None,
        phi0: Optional[int] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
        shade: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to rasshd.

        """

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

        if shade is not None:
            assert not shade.exists(), f"{shade} should _not_ exist!"

    def _mock_rasshd_outputs(
        self,
        DEM: Path,
        width: int,
        col_post: int,
        row_post: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        theta0: Optional[int] = None,
        phi0: Optional[int] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
        shade: Optional[Path] = None,
    ) -> None:
        """

        Mock the program rasshd.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

        if shade is not None and str(shade) != "-":
            shade.touch()

    def rasshd(
        self,
        DEM: Path,
        width: int,
        col_post: int,
        row_post: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        theta0: Optional[int] = None,
        phi0: Optional[int] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
        shade: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasshd
        Generate 8-bit raster graphics image of DEM data as shaded relief


        input parameters:
          DEM         (input) digital elevation model (FLOAT or SHORT integer)
          width       samples per row of DEM
          col_post    posting between cols (in meters)
          row_post    posting between rows (in meters, enter - for default: col_post)
          start       starting line of DEM (enter - for default: 1)
          nlines      number of lines to display (enter - or 0 for default: to end of file)
          pixavx      number of pixels to average (and decimate) in horizontal direction (enter - for default: 1)
          pixavy      number of pixels to average (and decimate) in vertical direction (enter - for default: 1)
          theta0      illumination elevation angle in deg. (enter - for default: 45.0)
          phi0        illumination orientation angle in deg. (enter - default: 135.0)
                      (0.: right, 90: top, 180: left, 270: bottom)
          rasf        (output) image filename, extension determines the format, enter - for default: *.bmp
                        *.bmp BMP format
                        *.ras SUN raster format
                        *.tif TIFF format
          dtype       DEM data type (enter - for default):
                        0: FLOAT (default)
                        1: SHORT integer
          zflg        zero data handling (enter - for default):
                        0: 0.0 interpreted at missing value (default)
                        1: 0.0 interpreted as valid data
          scale       power-law display scale factor (enter - for default: 1.0)
          exp         power-law display exponent (enter - for default: 1.00)
          illum_mode  illumination mode (enter - for default)
                        0: single angle (default)
                        1: multiple angle
          sharpness   shaded relief sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes
          shade       (output) shaded relief intensity image (FLOAT) (enter - for none)


        """

        if self.validate_inputs:
            self._validate_rasshd(
                DEM,
                width,
                col_post,
                row_post,
                start,
                nlines,
                pixavx,
                pixavy,
                theta0,
                phi0,
                rasf,
                dtype,
                zflg,
                scale,
                exp,
                illum_mode,
                sharpness,
                edge,
                shade,
            )

        if self.mock_outputs:
            self._mock_rasshd_outputs(
                DEM,
                width,
                col_post,
                row_post,
                start,
                nlines,
                pixavx,
                pixavy,
                theta0,
                phi0,
                rasf,
                dtype,
                zflg,
                scale,
                exp,
                illum_mode,
                sharpness,
                edge,
                shade,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rasshd))
        result = self._gamma_call("DISP", "rasshd", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        if shade is not None:
            assert shade.exists(), f"{shade} does not exist"
            assert shade.stat().st_size > 0, f"{shade} has zero file size"

        return result

    def _validate_dis2mph(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dis2mph.

        """

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

    def _mock_dis2mph_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Mock the program dis2mph.

        """
        pass

    def dis2mph(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2mph
        Display the scaled intensity and phase of 2 complex images (FCOMPLEX, SCOMPLEX, BCOMPLEX)


        input parameters:
          data1   (input) complex data1 (FCOMPLEX, SCOMPLEX)
          data2   (input) complex data2 (same data type as data1)
          width1  data samples per row of data1
          width2  data samples per row of data2
          start   starting line of cpx1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          scale   display scale factor (enter - for default: 1.0)
          exp     display exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   input data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
                    2: BCOMPLEX
          sc_ave  average intensity used to scale images (enter - for default: determined from data)


        """

        if self.validate_inputs:
            self._validate_dis2mph(
                data1,
                data2,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                scale,
                exp,
                cmap,
                dtype,
                sc_ave,
            )

        if self.mock_outputs:
            self._mock_dis2mph_outputs(
                data1,
                data2,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                scale,
                exp,
                cmap,
                dtype,
                sc_ave,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis2mph))
        result = self._gamma_call("DISP", "dis2mph", ca)
        return result

    def _validate_poly2kml(
        self,
        DEM_par: Path,
        ras: Path,
        poly_in: Optional[Path],
        kml: Path,
        poly_out: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to poly2kml.

        """

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert ras.exists(), f"{ras} does not exist"
        assert ras.stat().st_size > 0, f"{ras} has zero file size"

        if poly_in is not None:
            assert poly_in.exists(), f"{poly_in} does not exist"
            assert poly_in.stat().st_size > 0, f"{poly_in} has zero file size"

        assert not kml.exists(), f"{kml} should _not_ exist!"

        if poly_out is not None:
            assert not poly_out.exists(), f"{poly_out} should _not_ exist!"

    def _mock_poly2kml_outputs(
        self,
        DEM_par: Path,
        ras: Path,
        poly_in: Optional[Path],
        kml: Path,
        poly_out: Optional[Path] = None,
    ) -> None:
        """

        Mock the program poly2kml.

        """

        if kml is not None and str(kml) != "-":
            kml.touch()

        if poly_out is not None and str(poly_out) != "-":
            poly_out.touch()

    def poly2kml(
        self,
        DEM_par: Path,
        ras: Path,
        poly_in: Optional[Path],
        kml: Path,
        poly_out: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate a KML file from a polygon drawn on a georeferenced image


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          ras         (input) raster image (SUN/BMP/TIFF format, enter - for none)
          poly_in     (input) file containing polygon corner coordinates (enter - for none)
          kml         (output) KML file containing georeferenced polygon corner coordinates
          poly_out    (output) file containing polygon corner coordinates (enter - for none)

          NOTE: the KML file can be created in two ways:
          1. An existing polygon file <poly_in> is used as input to directly generate the KML file using the information
             in the <DEM_par> file. No raster image is used in that case (<ras> is ignored if specified in the command).
          2. A graphical interface permits drawing the polygon(s) over the background raster image using the mouse.
             A raster image <ras> corresponding to the <DEM_par> must be specified and - must be entered for <poly_in>.


        """

        if self.validate_inputs:
            self._validate_poly2kml(DEM_par, ras, poly_in, kml, poly_out)

        if self.mock_outputs:
            self._mock_poly2kml_outputs(DEM_par, ras, poly_in, kml, poly_out)

        ca = self._clean_args(locals(), inspect.signature(self.poly2kml))
        result = self._gamma_call("DISP", "poly2kml", ca)

        assert kml.exists(), f"{kml} does not exist"
        assert kml.stat().st_size > 0, f"{kml} has zero file size"

        if poly_out is not None:
            assert poly_out.exists(), f"{poly_out} does not exist"
            assert poly_out.stat().st_size > 0, f"{poly_out} has zero file size"

        return result

    def _validate_dis2SLC(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dis2SLC.

        """

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

    def _mock_dis2SLC_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program dis2SLC.

        """
        pass

    def dis2SLC(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2SLC
        Display the intensity of 2 complex images (FCOMPLEX, SCOMPLEX) using power-law scaling


        input parameters:
          data1   (input) complex data1 (FCOMPLEX, SCOMPLEX)
          data2   (input) complex data2 (FCOMPLEX. SCOMPLEX, same type as data1)
          width1  data samples per row of data1
          width2  data samples per row of data2
          start   starting line of cpx1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          scale   display scale factor (enter - for default: 1.0)
          exp     display exponent (enter - for default: 0.35)
          dtype   input data type (enter - for default)
                    0: FCOMPLEX
                    1: SCOMPLEX (default)


        """

        if self.validate_inputs:
            self._validate_dis2SLC(
                data1, data2, width1, width2, start, nlines, xoff, yoff, scale, exp, dtype
            )

        if self.mock_outputs:
            self._mock_dis2SLC_outputs(
                data1, data2, width1, width2, start, nlines, xoff, yoff, scale, exp, dtype
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis2SLC))
        result = self._gamma_call("DISP", "dis2SLC", ca)
        return result

    def _validate_raspwr(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to raspwr.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_raspwr_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Mock the program raspwr.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def raspwr(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/raspwr
        Calculate a raster image from data (FLOAT or UNSIGNED SHORT) with power-law scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT, UNSIGNED SHORT)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          scale   power-law display scale factor (enter - for default: 1.0)
          exp     power-law display exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   input data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT
          sc_ave  average intensity used to scale image
                  (enter - for default: determined from the data file)


        """

        if self.validate_inputs:
            self._validate_raspwr(
                data,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                scale,
                exp,
                cmap,
                rasf,
                dtype,
                sc_ave,
            )

        if self.mock_outputs:
            self._mock_raspwr_outputs(
                data,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                scale,
                exp,
                cmap,
                rasf,
                dtype,
                sc_ave,
            )

        ca = self._clean_args(locals(), inspect.signature(self.raspwr))
        result = self._gamma_call("DISP", "raspwr", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_disSLC(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to disSLC.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

    def _mock_disSLC_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program disSLC.

        """
        pass

    def disSLC(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/disSLC
        Display complex data (FCOMPLEX, SCOMPLEX) intensity using power-law scaling


        input parameters:
          data    (input) input data (FCOMPLEX, SCOMPLEX SLC)
          width   number of samples/row of the data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          scale   power-law scale factor, (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          dtype   data type (enter - for default)
                    0: FCOMPLEX
                    1: SCOMPLEX (default)

        """

        if self.validate_inputs:
            self._validate_disSLC(data, width, start, nlines, scale, exp, dtype)

        if self.mock_outputs:
            self._mock_disSLC_outputs(data, width, start, nlines, scale, exp, dtype)

        ca = self._clean_args(locals(), inspect.signature(self.disSLC))
        result = self._gamma_call("DISP", "disSLC", ca)
        return result

    def _validate_ras8_colormap(
        self,
        model: int,
        h0: int,
        hrange: int,
        ival: int,
        sat: int,
        cm: Path,
        cm_ras: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to ras8_colormap.

        """

        assert not cm.exists(), f"{cm} should _not_ exist!"

        if cm_ras is not None:
            assert not cm_ras.exists(), f"{cm_ras} should _not_ exist!"

        pass

    def _mock_ras8_colormap_outputs(
        self,
        model: int,
        h0: int,
        hrange: int,
        ival: int,
        sat: int,
        cm: Path,
        cm_ras: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[Path] = None,
    ) -> None:
        """

        Mock the program ras8_colormap.

        """

        if cm is not None and str(cm) != "-":
            cm.touch()

        if cm_ras is not None and str(cm_ras) != "-":
            cm_ras.touch()

    def ras8_colormap(
        self,
        model: int,
        h0: int,
        hrange: int,
        ival: int,
        sat: int,
        cm: Path,
        cm_ras: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras8_colormap
        Generate 8-bit raster color map with 256 levels


        input parameters:
          model   color model selection flag:
                    0: CMY color model used in Gamma Software (default)
                    1: HLS (double hexagon color model)
                    2: HSV (single hexagon color model)
                    3: SIN (sinusoidal color model)
          h0      starting hue (color for starting value)
          hrange  range of hue values in degrees (-360. ... 360)
          ival    relative brightness value (0.0 ... 1.0)
          sat     color saturation value (0.0 ... 1.0)
          cm      (output) text format colormap with 256 entries, triplets of R,G,B 0->255
          cm_ras  (output) raster image of the colormap, 512 samples wide x 32 lines (enter - for none, extension determines the format)
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          width   colorbar raster image width in pixels (enter - for default: 512)
          nlines  colorbar raster image height in lines (enter - for default: 32)


        """

        if self.validate_inputs:
            self._validate_ras8_colormap(
                model, h0, hrange, ival, sat, cm, cm_ras, width, nlines
            )

        if self.mock_outputs:
            self._mock_ras8_colormap_outputs(
                model, h0, hrange, ival, sat, cm, cm_ras, width, nlines
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras8_colormap))
        result = self._gamma_call("DISP", "ras8_colormap", ca)

        assert cm.exists(), f"{cm} does not exist"
        assert cm.stat().st_size > 0, f"{cm} has zero file size"

        if cm_ras is not None:
            assert cm_ras.exists(), f"{cm_ras} does not exist"
            assert cm_ras.stat().st_size > 0, f"{cm_ras} has zero file size"

        return result

    def _validate_cp_data(
        self,
        infile: Path,
        outfile: Path,
        lbytes: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        offset: Optional[int] = None,
        file_ldr: Optional[int] = None,
        offb: Optional[int] = None,
        nbyte: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to cp_data.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_cp_data_outputs(
        self,
        infile: Path,
        outfile: Path,
        lbytes: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        offset: Optional[int] = None,
        file_ldr: Optional[int] = None,
        offb: Optional[int] = None,
        nbyte: Optional[int] = None,
    ) -> None:
        """

        Mock the program cp_data.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def cp_data(
        self,
        infile: Path,
        outfile: Path,
        lbytes: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        offset: Optional[int] = None,
        file_ldr: Optional[int] = None,
        offb: Optional[int] = None,
        nbyte: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP cp_data: File copy utility


        input parameters:
          infile    (input) input data file
          outfile   (output) output data file
          lbytes    number of bytes per row of input file
          start     starting line (enter - for default: 1)
          nlines    number of lines to copy (enter - or 0 for default: to end of file)
          offset    offset in bytes from the start of the file to skip (enter - for default: 0)
          file_ldr  size of file leader (bytes) to copy after a skipping [offset] (enter - for default: 0)
          offb      offset in bytes for each line to start copy (enter - for default: 0)
          nbyte     number of bytes to copy from each line (enter - for default: (lbytes - offb))


        """

        if self.validate_inputs:
            self._validate_cp_data(
                infile, outfile, lbytes, start, nlines, offset, file_ldr, offb, nbyte
            )

        if self.mock_outputs:
            self._mock_cp_data_outputs(
                infile, outfile, lbytes, start, nlines, offset, file_ldr, offb, nbyte
            )

        ca = self._clean_args(locals(), inspect.signature(self.cp_data))
        result = self._gamma_call("DISP", "cp_data", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_uchar2float(self, scale: float, exp: float) -> None:
        """

        Validate the arguments to uchar2float.

        """

        pass

    def _mock_uchar2float_outputs(self, scale: float, exp: float) -> None:
        """

        Mock the program uchar2float.

        """
        pass

    def uchar2float(self, scale: float, exp: float) -> Tuple[int, List[str], List[str]]:
        """

        DISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/uchar2float.c
        Format transformation from unsigned char (1-byte) to float (4-byte)
        output = scale * (data + offset)^exp (for coherence use scale=0.00392, exp=1.0)


        input parameters:
          data_in   (input) input data file (unsigned char, 1 byte/sample)
          data_out  (output output file (float)
          scale     scale factor (default: 1.0)
          exp       exponent (default: 1.0)
          offset    offset (default: 0.0)


        """

        if self.validate_inputs:
            self._validate_uchar2float(scale, exp)

        if self.mock_outputs:
            self._mock_uchar2float_outputs(scale, exp)

        ca = self._clean_args(locals(), inspect.signature(self.uchar2float))
        result = self._gamma_call("DISP", "uchar2float", ca)
        return result

    def _validate_float2gbyte(self, infile: Path, outfile: Path) -> None:
        """

        Validate the arguments to float2gbyte.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_float2gbyte_outputs(self, infile: Path, outfile: Path) -> None:
        """

        Mock the program float2gbyte.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def float2gbyte(
        self, infile: Path, outfile: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Convert FLOAT format data to GBYTE logarithmic scaled format (1 byte/value)


        input parameters:
          infile   (input) FLOAT format data (4 bytes/sample)
          outfile  (output) GBYTE logarithmic scaled format data (1 byte/sample)

        """

        if self.validate_inputs:
            self._validate_float2gbyte(infile, outfile)

        if self.mock_outputs:
            self._mock_float2gbyte_outputs(infile, outfile)

        ca = self._clean_args(locals(), inspect.signature(self.float2gbyte))
        result = self._gamma_call("DISP", "float2gbyte", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_kml_plan(
        self,
        MLI_par: Path,
        DEM_par: Path,
        lookup_table: Path,
        kml: Path,
        geoid: Optional[Path] = None,
        geoid_par: Optional[Path] = None,
        extension: Optional[int] = None,
        flight_path: Optional[int] = None,
        t_event: Optional[int] = None,
        pt_list: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to kml_plan.

        """

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

        assert lookup_table.exists(), f"{lookup_table} does not exist"
        assert lookup_table.stat().st_size > 0, f"{lookup_table} has zero file size"

        assert not kml.exists(), f"{kml} should _not_ exist!"

        if geoid is not None:
            assert geoid.exists(), f"{geoid} does not exist"
            assert geoid.stat().st_size > 0, f"{geoid} has zero file size"

        if geoid_par is not None:
            assert geoid_par.exists(), f"{geoid_par} does not exist"
            assert geoid_par.stat().st_size > 0, f"{geoid_par} has zero file size"

        if pt_list is not None:
            assert pt_list.exists(), f"{pt_list} does not exist"
            assert pt_list.stat().st_size > 0, f"{pt_list} has zero file size"

    def _mock_kml_plan_outputs(
        self,
        MLI_par: Path,
        DEM_par: Path,
        lookup_table: Path,
        kml: Path,
        geoid: Optional[Path] = None,
        geoid_par: Optional[Path] = None,
        extension: Optional[int] = None,
        flight_path: Optional[int] = None,
        t_event: Optional[int] = None,
        pt_list: Optional[Path] = None,
    ) -> None:
        """

        Mock the program kml_plan.

        """

        if kml is not None and str(kml) != "-":
            kml.touch()

    def kml_plan(
        self,
        MLI_par: Path,
        DEM_par: Path,
        lookup_table: Path,
        kml: Path,
        geoid: Optional[Path] = None,
        geoid_par: Optional[Path] = None,
        extension: Optional[int] = None,
        flight_path: Optional[int] = None,
        t_event: Optional[int] = None,
        pt_list: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate a KML file containing a polygon corresponding to the scene area and a line corresponding to the platform path during the acquisition


        input parameters:
          MLI_par         (input) MLI or SLC image parameter file (slant range geometry)
          DEM_par         (input) DEM/MAP parameter file
          lookup_table    (input) geocoding lookup table (fcomplex, original DEM geometry)
          kml             (output) kml output file
          geoid           (input) global geoid (float, egm96 or egm2008) or constant geoid height value (enter - for none)
          geoid_par       (input) global geoid DEM_par file (enter - for none)
          extension       extension length before and after acquisition for waypoint calculation (enter - for default: 1852.0 m)
          flight_path     flight path visualization option: (enter - for default)
                            0: show flight path and flight path clamped to the ground (default)
                            1: do not show the flight path clamped to the ground
                            2: do not show the flight path
          t_event         additional event markers are added "t_event" seconds ahead of the actual event markers (enter - for default: 0.0 seconds)
          pt_list         (input) list of points triggering event markers (three columns, csv format: pt_name; east/lon/c; north/lat/s) (enter - for none)

        """

        if self.validate_inputs:
            self._validate_kml_plan(
                MLI_par,
                DEM_par,
                lookup_table,
                kml,
                geoid,
                geoid_par,
                extension,
                flight_path,
                t_event,
                pt_list,
            )

        if self.mock_outputs:
            self._mock_kml_plan_outputs(
                MLI_par,
                DEM_par,
                lookup_table,
                kml,
                geoid,
                geoid_par,
                extension,
                flight_path,
                t_event,
                pt_list,
            )

        ca = self._clean_args(locals(), inspect.signature(self.kml_plan))
        result = self._gamma_call("DISP", "kml_plan", ca)

        assert kml.exists(), f"{kml} does not exist"
        assert kml.stat().st_size > 0, f"{kml} has zero file size"

        return result

    def _validate_kml_map(self, image: Path, dem_par: Path, kml: Path) -> None:
        """

        Validate the arguments to kml_map.

        """

        assert image.exists(), f"{image} does not exist"
        assert image.stat().st_size > 0, f"{image} has zero file size"

        assert dem_par.exists(), f"{dem_par} does not exist"
        assert dem_par.stat().st_size > 0, f"{dem_par} has zero file size"

        assert not kml.exists(), f"{kml} should _not_ exist!"

    def _mock_kml_map_outputs(self, image: Path, dem_par: Path, kml: Path) -> None:
        """

        Mock the program kml_map.

        """

        if kml is not None and str(kml) != "-":
            kml.touch()

    def kml_map(
        self, image: Path, dem_par: Path, kml: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP kml_map: Create KML file with link to image


        input parameters:
          image   (input) URL of background image in bmp, png or jpg format,
                  needs to be in EQA projection with WGS84 for Google Earth
          dem_par (input) corresponding dem_par file
          kml     (output) kml output file (default = *.kml)


        """

        if self.validate_inputs:
            self._validate_kml_map(image, dem_par, kml)

        if self.mock_outputs:
            self._mock_kml_map_outputs(image, dem_par, kml)

        ca = self._clean_args(locals(), inspect.signature(self.kml_map))
        result = self._gamma_call("DISP", "kml_map", ca)

        assert kml.exists(), f"{kml} does not exist"
        assert kml.stat().st_size > 0, f"{kml} has zero file size"

        return result

    def _validate_ras_dB(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras_dB.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_ras_dB_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras_dB.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras_dB(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras_dB
        Calculate a raster image from data (FLOAT or UNSIGNED SHORT) using logarithmic scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT or UNSIGNED SHORT)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          min     minimum data value (enter - for default: -10.00 dB)
          max     maximum data value (enter - for default: 10.00 dB)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   input data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT
          sc_abs  absolute scaling flag:
                    0: scaling relative to average (min_dB + av_dB) -> (max_dB + av_dB) (default)
                       NOTE: av_dB is the average image intensity dB
                    1: absolute image scaling range: min_dB -> max_dB


        """

        if self.validate_inputs:
            self._validate_ras_dB(
                data,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                min,
                max,
                cmap,
                rasf,
                dtype,
                sc_abs,
            )

        if self.mock_outputs:
            self._mock_ras_dB_outputs(
                data,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                min,
                max,
                cmap,
                rasf,
                dtype,
                sc_abs,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras_dB))
        result = self._gamma_call("DISP", "ras_dB", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_thres_data(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        t_data: Path,
        t_min: int,
        t_max: int,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to thres_data.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

        assert t_data.exists(), f"{t_data} does not exist"
        assert t_data.stat().st_size > 0, f"{t_data} has zero file size"

    def _mock_thres_data_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        t_data: Path,
        t_min: int,
        t_max: int,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program thres_data.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def thres_data(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        t_data: Path,
        t_min: int,
        t_max: int,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Data are set to 0 where t_data < t_min or t_data > t_max  (FLOAT, FCOMPLEX, or SUN/BMP/TIFF raster format)***


        input parameters:
          data_in     (input) data file (FLOAT, FCOMPLEX, or SUN/BMP/TIFF raster format)
          width       width of input data file and threshold data file
          data_out    (output) data file, same data format as input data
                      all points in data_in are set to 0.0 where thres_data < tmin or thres_data > t_max
          t_data      (input) data used for threshold test (FLOAT format)
          t_min       minimum threshold data value (FLOAT)
          t_max       maximum threshold data value (FLOAT)
          dtype       data type (enter - for default)
                        0: FLOAT (default)
                        1: FCOMPLEX
                        2: SUN/BMP/TIFF raster image


        """

        if self.validate_inputs:
            self._validate_thres_data(
                data_in, width, data_out, t_data, t_min, t_max, dtype
            )

        if self.mock_outputs:
            self._mock_thres_data_outputs(
                data_in, width, data_out, t_data, t_min, t_max, dtype
            )

        ca = self._clean_args(locals(), inspect.signature(self.thres_data))
        result = self._gamma_call("DISP", "thres_data", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_distree(
        self,
        flag: Path,
        unw: Optional[Path],
        int: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to distree.

        """

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

        if unw is not None:
            assert unw.exists(), f"{unw} does not exist"
            assert unw.stat().st_size > 0, f"{unw} has zero file size"

        if int is not None:
            assert int.exists(), f"{int} does not exist"
            assert int.stat().st_size > 0, f"{int} has zero file size"

    def _mock_distree_outputs(
        self,
        flag: Path,
        unw: Optional[Path],
        int: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[int] = None,
    ) -> None:
        """

        Mock the program distree.

        """
        pass

    def distree(
        self,
        flag: Path,
        unw: Optional[Path],
        int: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP distree: display of unwrapped phase + wrapped phase + flags


        input parameters:
          flag      (input) phase unwrapping flag file (unsigned char)
          unw       (input) unwrapped phase image (enter - for None) (FLOAT)
          int       (input) complex interferogram (wrapped) (enter - for None) (FCOMPLEX)
          width     samples per row of flag, unw, and int
          start     starting line of flag, unw, and int (enter - for default: 1)
          nlines    number of lines to display (enter - or 0 for default: to end of file)
          ph_scale  unwrapped phase display scale factor (enter - for default: 0.33333)


        """

        if self.validate_inputs:
            self._validate_distree(flag, unw, int, width, start, nlines, ph_scale)

        if self.mock_outputs:
            self._mock_distree_outputs(flag, unw, int, width, start, nlines, ph_scale)

        ca = self._clean_args(locals(), inspect.signature(self.distree))
        result = self._gamma_call("DISP", "distree", ca)
        return result

    def _validate_dis_linear(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dis_linear.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

    def _mock_dis_linear_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program dis_linear.

        """
        pass

    def dis_linear(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis_linear
        Display of data (FLOAT, UNSIGNED SHORT, SIGNED SHORT, or UNSIGNED BYTE) with linear scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT, UNSIGNED SHORT, or UNSIGNED BYTE)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          min     data display minimum (enter - for default: 0.000)
          max     data display maximum (enter - for default: 1.000)
          cflg    cyclic data display flag (enter - for default)
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max-min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT (2-byte integer)
                    2: SIGNED SHORT (2-byte integer)
                    3: UNSIGNED BYTE


        """

        if self.validate_inputs:
            self._validate_dis_linear(
                data, width, start, nlines, min, max, cflg, cmap, dtype
            )

        if self.mock_outputs:
            self._mock_dis_linear_outputs(
                data, width, start, nlines, min, max, cflg, cmap, dtype
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis_linear))
        result = self._gamma_call("DISP", "dis_linear", ca)
        return result

    def _validate_disdem_par(
        self,
        DEM: Path,
        DEM_par: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        exaggerate: Optional[int] = None,
        theta0: Optional[int] = None,
        phi0: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to disdem_par.

        """

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert DEM_par.exists(), f"{DEM_par} does not exist"
        assert DEM_par.stat().st_size > 0, f"{DEM_par} has zero file size"

    def _mock_disdem_par_outputs(
        self,
        DEM: Path,
        DEM_par: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        exaggerate: Optional[int] = None,
        theta0: Optional[int] = None,
        phi0: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
    ) -> None:
        """

        Mock the program disdem_par.

        """
        pass

    def disdem_par(
        self,
        DEM: Path,
        DEM_par: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        exaggerate: Optional[int] = None,
        theta0: Optional[int] = None,
        phi0: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP disdem_par: Display DEM with DEM/MAP parameter file as shaded relief


        input parameters:
          DEM         (input) Digital elevation model (FLOAT or SHORT as specified in DEM_par)
          DEM_par     (input) DIFF/GEO DEM parameter file
          start       starting line of DEM (enter - for default: 1)
          nlines      number of lines to display (enter - or 0 for default: to end of file)
          exaggerate  relief exaggeration factor to increase contrast of display (enter - for default: 1.0)
          theta0      illumination elevation angle in deg. (enter - for default: 45.0)
          phi0        illumination orientation angle in deg. (enter - for default: 135.0)
                      (0.: right, 90: top, 180: left, 270: bottom)
          illum_mode  illumination mode (enter - for default)
                        0: single angle (default)
                        1: multiple angle
          sharpness   shaded relief sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes


        """

        if self.validate_inputs:
            self._validate_disdem_par(
                DEM,
                DEM_par,
                start,
                nlines,
                exaggerate,
                theta0,
                phi0,
                illum_mode,
                sharpness,
                edge,
            )

        if self.mock_outputs:
            self._mock_disdem_par_outputs(
                DEM,
                DEM_par,
                start,
                nlines,
                exaggerate,
                theta0,
                phi0,
                illum_mode,
                sharpness,
                edge,
            )

        ca = self._clean_args(locals(), inspect.signature(self.disdem_par))
        result = self._gamma_call("DISP", "disdem_par", ca)
        return result

    def _validate_gcp_2ras(
        self,
        ras1: Path,
        ras2: Path,
        gcp: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gcp_2ras.

        """

        assert ras1.exists(), f"{ras1} does not exist"
        assert ras1.stat().st_size > 0, f"{ras1} has zero file size"

        assert ras2.exists(), f"{ras2} does not exist"
        assert ras2.stat().st_size > 0, f"{ras2} has zero file size"

        assert not gcp.exists(), f"{gcp} should _not_ exist!"

    def _mock_gcp_2ras_outputs(
        self,
        ras1: Path,
        ras2: Path,
        gcp: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Mock the program gcp_2ras.

        """

        if gcp is not None and str(gcp) != "-":
            gcp.touch()

    def gcp_2ras(
        self,
        ras1: Path,
        ras2: Path,
        gcp: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP gcp_2ras: Display 2 SUN raster, BMP, or TIFF format images and select corresponding pairs of points for ground control


        input parameters:
          ras1    (input) image 1, SUN raster: *.ras, BMP: *.bmp, TIFF: *.tif
          ras2    (input) image 2, SUN raster: *.ras, BMP: *.bmp, TIFF: *.tif
                  NOTE: the image depth (bits/pixel) of ras1 and ras2 must be the same
          gcp     (output) ground control point file (text format)
          mag     zoom magnification factor (enter - for default: 3)
          win_sz  zoom window size before magnification (enter - for default: 132)


        """

        if self.validate_inputs:
            self._validate_gcp_2ras(ras1, ras2, gcp, mag, win_sz)

        if self.mock_outputs:
            self._mock_gcp_2ras_outputs(ras1, ras2, gcp, mag, win_sz)

        ca = self._clean_args(locals(), inspect.signature(self.gcp_2ras))
        result = self._gamma_call("DISP", "gcp_2ras", ca)

        assert gcp.exists(), f"{gcp} does not exist"
        assert gcp.stat().st_size > 0, f"{gcp} has zero file size"

        return result

    def _validate_ras_linear(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras_linear.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_ras_linear_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras_linear.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras_linear(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras_linear
        Calculate a raster image (FLOAT, UNSIGNED SHORT, SIGNED SHORT, or UNSIGNED BYTE) with linear scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT, UNSIGNED SHORT, or UNSIGNED BYTE)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          min     minimum data value (enter - for default: 0.000)
          max     maximum data value (enter - for default: 1.000)
          cflg    cyclic data display flag:
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max - min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   input data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT (2-byte integer)
                    2: SIGNED SHORT (2-byte integer)
                    3: UNSIGNED BYTE


        """

        if self.validate_inputs:
            self._validate_ras_linear(
                data,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                min,
                max,
                cflg,
                cmap,
                rasf,
                dtype,
            )

        if self.mock_outputs:
            self._mock_ras_linear_outputs(
                data,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                min,
                max,
                cflg,
                cmap,
                rasf,
                dtype,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras_linear))
        result = self._gamma_call("DISP", "ras_linear", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_tree_edit(
        self,
        flag: Path,
        ras: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to tree_edit.

        """

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

        assert ras.exists(), f"{ras} does not exist"
        assert ras.stat().st_size > 0, f"{ras} has zero file size"

    def _mock_tree_edit_outputs(
        self,
        flag: Path,
        ras: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Mock the program tree_edit.

        """
        pass

    def tree_edit(
        self,
        flag: Path,
        ras: Path,
        mag: Optional[int] = None,
        win_sz: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP tree_edit: edit phase unwrapping flag file


        input parameters:
          flag    (input) phase unwrapping flag file with same dimensions as the raster overlay image
          ras     (input) 8-bit raster overlay image (Sun raster: *.ras, BMP: *.bmp, or TIFF: *.tif)
          mag     magnification factor (enter - for default: 5)
          win_sz  size of input data region to be magnified (enter - for default: 80)


        """

        if self.validate_inputs:
            self._validate_tree_edit(flag, ras, mag, win_sz)

        if self.mock_outputs:
            self._mock_tree_edit_outputs(flag, ras, mag, win_sz)

        ca = self._clean_args(locals(), inspect.signature(self.tree_edit))
        result = self._gamma_call("DISP", "tree_edit", ca)
        return result

    def _validate_discpx(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to discpx.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

    def _mock_discpx_outputs(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Mock the program discpx.

        """
        pass

    def discpx(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/discpx
        Display of data (FCOMPLEX, SCOMPLEX) using linear, logarithmic, or power-law scaling using a specified colormap


        input parameters:
          data   (input) data (FCOMPLEX, SCOMPLEX)
          width  number of samples/row of data
          mode   display mode (enter - for default: power-law scaling)
                   0: intensity with power-law scaling (scale and exp), default colormap: gray.cm, (default)
                   1: intensity with logarithmic scaling min -> max (dB), default colormap: gray.cm
                   2: real component, scaling min -> max, default colormap: hls.cm
                   3: imaginary component, scaling min -> max, default colormap: hls.cm
                   4: phase, scaling min -> max, default colormap: default colormap rmg.cm
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          min     data display minimum (enter - for default mode 0: not used, mode 1: -10 dB, modes 2,3: -1.0, mode 4: -PI)
          max     data display maximum (enter - for default mode 0: not used, mode 1: +16 dB, modes 2,3: +1.0, mode 4: +PI)
          cmap    colormap file (enter - for default)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   power-law scale factor, (enter - for default: 1.0) (mode 0 only)
          exp     power-law exponent (enter - for default: 0.35) (mode 0 only)
          dtype   data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
          sc_ave  average intensity used to calculate image scaling (modes 0 and 1)
                  (enter - for default: determined from the input data file)


        """

        if self.validate_inputs:
            self._validate_discpx(
                data,
                width,
                mode,
                start,
                nlines,
                min,
                max,
                cmap,
                scale,
                exp,
                dtype,
                sc_ave,
            )

        if self.mock_outputs:
            self._mock_discpx_outputs(
                data,
                width,
                mode,
                start,
                nlines,
                min,
                max,
                cmap,
                scale,
                exp,
                dtype,
                sc_ave,
            )

        ca = self._clean_args(locals(), inspect.signature(self.discpx))
        result = self._gamma_call("DISP", "discpx", ca)
        return result

    def _validate_fill(self, d1: Path, d2: Path, dout: Path, width: int) -> None:
        """

        Validate the arguments to fill.

        """

        assert d1.exists(), f"{d1} does not exist"
        assert d1.stat().st_size > 0, f"{d1} has zero file size"

        assert d2.exists(), f"{d2} does not exist"
        assert d2.stat().st_size > 0, f"{d2} has zero file size"

        assert not dout.exists(), f"{dout} should _not_ exist!"

    def _mock_fill_outputs(self, d1: Path, d2: Path, dout: Path, width: int) -> None:
        """

        Mock the program fill.

        """

        if dout is not None and str(dout) != "-":
            dout.touch()

    def fill(
        self, d1: Path, d2: Path, dout: Path, width: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/fill
        Fill gaps in data file 1 with values from data file 2 or a constant value (float format)


        input parameters:
          d1     (input) data file 1 (float)
          d2     (input) data file 2 used to fill gaps in d1, or a constant value (float)
          dout   (output) d1 with gaps filled (float)
          width  number of samples/line


        """

        if self.validate_inputs:
            self._validate_fill(d1, d2, dout, width)

        if self.mock_outputs:
            self._mock_fill_outputs(d1, d2, dout, width)

        ca = self._clean_args(locals(), inspect.signature(self.fill))
        result = self._gamma_call("DISP", "fill", ca)

        assert dout.exists(), f"{dout} does not exist"
        assert dout.stat().st_size > 0, f"{dout} has zero file size"

        return result

    def _validate_dis2pwr(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dis2pwr.

        """

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

    def _mock_dis2pwr_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Mock the program dis2pwr.

        """
        pass

    def dis2pwr(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2pwr
        Display 2 intensity images (FLOAT, UNSIGNED SHORT) with power-law scaling using a specified colormap


        input parameters:
          data1    (input) data1 (FLOAT, UNSIGNED SHORT)
          data2    (input) data2 (same data type as data1)
          width1   number of samples/row of data1
          width2   number of samples/row of data2
          start    starting line of data (enter - for default: 1)
          nlines   number of lines to display (enter - or 0 for default: to end of file)
          xoff     x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff     y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          scale    power-law scale factor (enter - for default: 1.0)
          exp      power-law exponent (enter - for default: 0.35)
          cmap     colormap file (enter - for default: gray.cm)
                   NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                         colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype    data type (enter - for default)
                     0: FLOAT (default)
                     1: UNSIGNED SHORT
          sc_ave   average intensity used to scale images (enter - for default: determined from data)


        """

        if self.validate_inputs:
            self._validate_dis2pwr(
                data1,
                data2,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                scale,
                exp,
                cmap,
                dtype,
                sc_ave,
            )

        if self.mock_outputs:
            self._mock_dis2pwr_outputs(
                data1,
                data2,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                scale,
                exp,
                cmap,
                dtype,
                sc_ave,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis2pwr))
        result = self._gamma_call("DISP", "dis2pwr", ca)
        return result

    def _validate_dispwr(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dispwr.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

    def _mock_dispwr_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Mock the program dispwr.

        """
        pass

    def dispwr(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dispwr
        Display intensity data (FLOAT or UNSIGNED SHORT) with power-law scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT, UNSIGNED SHORT)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          scale   power-law scale factor (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT
          sc_ave  average intensity used to scale image (enter - for default: determined from data)


        """

        if self.validate_inputs:
            self._validate_dispwr(
                data, width, start, nlines, scale, exp, cmap, dtype, sc_ave
            )

        if self.mock_outputs:
            self._mock_dispwr_outputs(
                data, width, start, nlines, scale, exp, cmap, dtype, sc_ave
            )

        ca = self._clean_args(locals(), inspect.signature(self.dispwr))
        result = self._gamma_call("DISP", "dispwr", ca)
        return result

    def _validate_rasSLC(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rasSLC.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_rasSLC_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program rasSLC.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rasSLC(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasSLC
        Calculate a multilook intensity raster image from complex data (FCOMPLEX, SCOMPLEX) using power-law scaling


        input parameters:
          data    (input) input data (FCOMPLEX, SCOMPLEX SLC)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          scale   power-law scale factor, (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   data type (enter - for default)
                    0: FCOMPLEX
                    1: SCOMPLEX (default)

        """

        if self.validate_inputs:
            self._validate_rasSLC(
                data, width, start, nlines, pixavx, pixavy, scale, exp, rasf, dtype
            )

        if self.mock_outputs:
            self._mock_rasSLC_outputs(
                data, width, start, nlines, pixavx, pixavy, scale, exp, rasf, dtype
            )

        ca = self._clean_args(locals(), inspect.signature(self.rasSLC))
        result = self._gamma_call("DISP", "rasSLC", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_short2float(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to short2float.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_short2float_outputs(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program short2float.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def short2float(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP short2float: Convert short 2-byte integers to floating point format


        input parameters:
          infile   (input) input data file (SHORT integers, 2 bytes/sample)
          outfile  (output) output data file (FLOAT, 4 bytes/sample)
          scale    scale factor (enter - for default: 1.0)
          exp      exponent (enter - for default: 1.0)
          dtype    input data type (enter - for default)
                     0: SHORT (int16, default)
                     1: UNSIGNED SHORT (uint16)

        NOTE: output = scale*input^exp  (for SAR backscatter use scale=0.000001, exp=2.0)


        """

        if self.validate_inputs:
            self._validate_short2float(infile, outfile, scale, exp, dtype)

        if self.mock_outputs:
            self._mock_short2float_outputs(infile, outfile, scale, exp, dtype)

        ca = self._clean_args(locals(), inspect.signature(self.short2float))
        result = self._gamma_call("DISP", "short2float", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_ras8_color_scale(
        self,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        ival: Optional[int] = None,
        sat: Optional[int] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        chip_height: Optional[int] = None,
        nval: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras8_color_scale.

        """

        assert not rasf.exists(), f"{rasf} should _not_ exist!"

        pass

    def _mock_ras8_color_scale_outputs(
        self,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        ival: Optional[int] = None,
        sat: Optional[int] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        chip_height: Optional[int] = None,
        nval: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras8_color_scale.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras8_color_scale(
        self,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        ival: Optional[int] = None,
        sat: Optional[int] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        chip_height: Optional[int] = None,
        nval: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras8_color_scale
        Generate 8-bit raster graphics image of the selected color scale


        input parameters:
          rasf         (output) image filename, extension determines the format
                         *.bmp BMP format
                         *.ras Sun raster format
                         *.tif TIFF format
          color_model  color model selection flag: (enter - for default)
                         0: CMY color model used in Gamma Software (default)
                         1: HLS (double hexagon color model)
                         2: HSV (single hexagon color model)
                         3: SIN (sinusoidal color model)
          h0           starting hue (color for starting value, enter - for default: 0.0)
          hrange       range of hue values in degrees (-360. ... 360., enter - for default: 360.0)
          ival         relative brightness value (0.0 ... 1.0, enter - for default: 0.80)
          sat          color saturation value (0.0 ... 1.0, enter - for default: 0.75)
          chip_width   width of color chips (enter - for default: 8)
          gap          number of pixels between color chips (enter - for default: 1)
          chip_height  height of color chips (enter - for default: chip_width)
          nval         number of color chips (enter - for default: 16)


        """

        if self.validate_inputs:
            self._validate_ras8_color_scale(
                rasf,
                color_model,
                h0,
                hrange,
                ival,
                sat,
                chip_width,
                gap,
                chip_height,
                nval,
            )

        if self.mock_outputs:
            self._mock_ras8_color_scale_outputs(
                rasf,
                color_model,
                h0,
                hrange,
                ival,
                sat,
                chip_width,
                gap,
                chip_height,
                nval,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras8_color_scale))
        result = self._gamma_call("DISP", "ras8_color_scale", ca)

        assert rasf.exists(), f"{rasf} does not exist"
        assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_rasmph(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to rasmph.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_rasmph_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> None:
        """

        Mock the program rasmph.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rasmph(
        self,
        data: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasmph
        Calculate a raster image of data (FCOMPLEX, SCOMPLEX, BCOMPLEX) using a specified colormap and power-law scaled intensity


        input parameters:
          data    (input) data (FCOMPLEX, SCOMPLEX, BCOMPLEX)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          scale   power-law scale factor, (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   input data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
                    2: BCOMPLEX
          bits    bits/pixel:
                    8:  8-bit indexed color map (default)
                    24: RGB 8-bits/color
          sc_ave  average intensity used to scale image
                  (enter - for default: determined from data)


        """

        if self.validate_inputs:
            self._validate_rasmph(
                data,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                scale,
                exp,
                cmap,
                rasf,
                dtype,
                bits,
                sc_ave,
            )

        if self.mock_outputs:
            self._mock_rasmph_outputs(
                data,
                width,
                start,
                nlines,
                pixavx,
                pixavy,
                scale,
                exp,
                cmap,
                rasf,
                dtype,
                bits,
                sc_ave,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rasmph))
        result = self._gamma_call("DISP", "rasmph", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_get_value(self, PAR_in: int, keyword: int) -> None:
        """

        Validate the arguments to get_value.

        """

        pass

    def _mock_get_value_outputs(self, PAR_in: int, keyword: int) -> None:
        """

        Mock the program get_value.

        """
        pass

    def get_value(self, PAR_in: int, keyword: int) -> Tuple[int, List[str], List[str]]:
        """

        Search a keyword based parameter using a key and copy the value to stdout


        input parameters:
          PAR_in       input  keyword:value based parameter file
          keyword      search keyword of keyword:value pair


        """

        if self.validate_inputs:
            self._validate_get_value(PAR_in, keyword)

        if self.mock_outputs:
            self._mock_get_value_outputs(PAR_in, keyword)

        ca = self._clean_args(locals(), inspect.signature(self.get_value))
        result = self._gamma_call("DISP", "get_value", ca)
        return result

    def _validate_polyras(
        self, ras: Path, mag: Optional[int] = None, win_sz: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to polyras.

        """

        assert ras.exists(), f"{ras} does not exist"
        assert ras.stat().st_size > 0, f"{ras} has zero file size"

    def _mock_polyras_outputs(
        self, ras: Path, mag: Optional[int] = None, win_sz: Optional[int] = None
    ) -> None:
        """

        Mock the program polyras.

        """
        pass

    def polyras(
        self, ras: Path, mag: Optional[int] = None, win_sz: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP polyras: polygon selection using a raster image as reference


        input parameters:
          ras        (input) raster image, SUN raster: *.ras, BMP: *.bmp, TIFF: *.tif
          mag        zoom magnification factor (enter - for default: 2)
          win_sz     zoom window size before magnification (enter - for default: 160)
          poly_file  (output) file containing polygon corner coordinates

          NOTE: 1. Use I/O redirection of STDOUT to write to the poly_file:
                        polyras my_image.bmp > poly_file
                2. Do not use raster images with left/right flipped geometry!


        """

        if self.validate_inputs:
            self._validate_polyras(ras, mag, win_sz)

        if self.mock_outputs:
            self._mock_polyras_outputs(ras, mag, win_sz)

        ca = self._clean_args(locals(), inspect.signature(self.polyras))
        result = self._gamma_call("DISP", "polyras", ca)
        return result

    def _validate_rastree(
        self,
        flag: Path,
        unw: Optional[Path],
        int: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[int] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to rastree.

        """

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

        if unw is not None:
            assert unw.exists(), f"{unw} does not exist"
            assert unw.stat().st_size > 0, f"{unw} has zero file size"

        if int is not None:
            assert int.exists(), f"{int} does not exist"
            assert int.stat().st_size > 0, f"{int} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_rastree_outputs(
        self,
        flag: Path,
        unw: Optional[Path],
        int: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[int] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Mock the program rastree.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rastree(
        self,
        flag: Path,
        unw: Optional[Path],
        int: Optional[Path],
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[int] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rastree
        Generate 8-bit raster graphics image of unwrapped phase, wrapped phase, and unwrapping flags


        input parameters:
          flag      (input) phase unwrapping flag file (unsigned char)
          unw       (input) unwrapped phase image (enter - for None) (FLOAT)
          int       (input) complex interferogram (wrapped) (enter - for None) (FCOMPLEX)
          width     samples per row of flag, unw, and int
          start     starting line of flag, unw, and int (enter - for default: 1)
          nlines    number of lines to display (enter - or 0 for default: to end of file)
          ph_scale  unwrapped phase display scale factor (enter - for default: 0.33333)
          rasf      (output) image filename, extension determines the format, enter - for default: *.bmp
                      *.bmp BMP format
                      *.ras Sun raster format
                      *.tif TIFF format
          NOTE: ph_scale < 1. permits detection of phase unwrapping errors


        """

        if self.validate_inputs:
            self._validate_rastree(flag, unw, int, width, start, nlines, ph_scale, rasf)

        if self.mock_outputs:
            self._mock_rastree_outputs(
                flag, unw, int, width, start, nlines, ph_scale, rasf
            )

        ca = self._clean_args(locals(), inspect.signature(self.rastree))
        result = self._gamma_call("DISP", "rastree", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_disshd(
        self,
        DEM: Path,
        width: int,
        col_post: int,
        row_post: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        theta0: Optional[int] = None,
        phi0: Optional[int] = None,
        dtype: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to disshd.

        """

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

    def _mock_disshd_outputs(
        self,
        DEM: Path,
        width: int,
        col_post: int,
        row_post: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        theta0: Optional[int] = None,
        phi0: Optional[int] = None,
        dtype: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
    ) -> None:
        """

        Mock the program disshd.

        """
        pass

    def disshd(
        self,
        DEM: Path,
        width: int,
        col_post: int,
        row_post: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        theta0: Optional[int] = None,
        phi0: Optional[int] = None,
        dtype: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP disshd: Display DEM as shaded relief


        input parameters:
          DEM         (input) digital elevation model (FLOAT or SHORT)
          width       samples per row of DEM
          col_post    posting between cols (same unit as DEM values)
          row_post    posting between rows (same unit as DEM, enter - for default: col_post)
          start       starting line of DEM (enter - for default: 1)
          nlines      number of lines to display (enter - or 0 for default: to end of file)
          theta0      illumination elevation angle in deg. (enter - for default: 45.0)
          phi0        illumination orientation angle in deg. (enter - for default: 135.0)
                      (0.: right, 90: top, 180: left, 270: bottom)
          dtype       data type (enter - for default)
                        0: FLOAT (default)
                        1: SHORT INTEGER
          illum_mode  illumination mode (enter - for default)
                        0: single angle (default)
                        1: multiple angle
          sharpness   shaded relief sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes


        """

        if self.validate_inputs:
            self._validate_disshd(
                DEM,
                width,
                col_post,
                row_post,
                start,
                nlines,
                theta0,
                phi0,
                dtype,
                illum_mode,
                sharpness,
                edge,
            )

        if self.mock_outputs:
            self._mock_disshd_outputs(
                DEM,
                width,
                col_post,
                row_post,
                start,
                nlines,
                theta0,
                phi0,
                dtype,
                illum_mode,
                sharpness,
                edge,
            )

        ca = self._clean_args(locals(), inspect.signature(self.disshd))
        result = self._gamma_call("DISP", "disshd", ca)
        return result

    def _validate_dis2gbyte(
        self,
        image1: Path,
        image2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        cmap: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to dis2gbyte.

        """

        assert image1.exists(), f"{image1} does not exist"
        assert image1.stat().st_size > 0, f"{image1} has zero file size"

        assert image2.exists(), f"{image2} does not exist"
        assert image2.stat().st_size > 0, f"{image2} has zero file size"

    def _mock_dis2gbyte_outputs(
        self,
        image1: Path,
        image2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        cmap: Optional[Path] = None,
    ) -> None:
        """

        Mock the program dis2gbyte.

        """
        pass

    def dis2gbyte(
        self,
        image1: Path,
        image2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[float] = None,
        cmap: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP dis2gbyte: alternating display of two GBYTE format images


        input parameters:
          image1  (input) GBYTE format image 1
          image2  (input) GBYTE format image 2
          width1  samples per row of image1
          width2  samples per row of image2
          start   starting line of image1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          scale   display scale factor (enter - for default: 1.0)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png


        """

        if self.validate_inputs:
            self._validate_dis2gbyte(
                image1, image2, width1, width2, start, nlines, xoff, yoff, scale, cmap
            )

        if self.mock_outputs:
            self._mock_dis2gbyte_outputs(
                image1, image2, width1, width2, start, nlines, xoff, yoff, scale, cmap
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis2gbyte))
        result = self._gamma_call("DISP", "dis2gbyte", ca)
        return result

    def _validate_ras8_float(
        self,
        f1: Path,
        f2: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        imin: Optional[int] = None,
        imax: Optional[int] = None,
        sat: Optional[int] = None,
        sc1: Optional[int] = None,
        A1: Optional[int] = None,
        B1: Optional[int] = None,
        cyclic1: Optional[int] = None,
        sc2: Optional[int] = None,
        A2: Optional[int] = None,
        B2: Optional[int] = None,
        start_f1: Optional[int] = None,
        start_f2: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras8_float.

        """

        assert f1.exists(), f"{f1} does not exist"
        assert f1.stat().st_size > 0, f"{f1} has zero file size"

        assert f2.exists(), f"{f2} does not exist"
        assert f2.stat().st_size > 0, f"{f2} has zero file size"

        assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_ras8_float_outputs(
        self,
        f1: Path,
        f2: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        imin: Optional[int] = None,
        imax: Optional[int] = None,
        sat: Optional[int] = None,
        sc1: Optional[int] = None,
        A1: Optional[int] = None,
        B1: Optional[int] = None,
        cyclic1: Optional[int] = None,
        sc2: Optional[int] = None,
        A2: Optional[int] = None,
        B2: Optional[int] = None,
        start_f1: Optional[int] = None,
        start_f2: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras8_float.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras8_float(
        self,
        f1: Path,
        f2: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        imin: Optional[int] = None,
        imax: Optional[int] = None,
        sat: Optional[int] = None,
        sc1: Optional[int] = None,
        A1: Optional[int] = None,
        B1: Optional[int] = None,
        cyclic1: Optional[int] = None,
        sc2: Optional[int] = None,
        A2: Optional[int] = None,
        B2: Optional[int] = None,
        start_f1: Optional[int] = None,
        start_f2: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras8_float
        Generate 8-bit raster graphics image of 1 or 2 float data files


        input parameters:
          f1           (input) file 1 (float, enter - if not available --> greyscale image for f2)
          f2           (input) file 2 (float, enter - if not available --> 8-bit color image for f1)
          width        samples per row of f1 and f2
          rasf         (output) image filename, extension determines format:
                         *.bmp BMP format
                         *.ras Sun raster format
                         *.tif TIFF format
          color_model  color model selection flag: (enter - for default)
                         0: CMY color model used in Gamma Software (default)
                         1: HLS (double hexagon color model)
                         2: HSV (single hexagon color model)
                         3: SIN (sinus color model)
                         4: GREY (greyscale model for f1)
          h0           starting hue (color for starting value, enter - for default: 0.0)
          hrange       range of hue values in degrees (-360. ... 360., enter - for default: 360.0)
          imin         minimum brightness value (0.0 ... 1.0, enter - for default: 0.15)
          imax         maximum brightness value (0.0 ... 1.0, enter - for default: 0.85)
          sat          color saturation value (0.0 ... 1.0, enter - for default: 0.75)

        Image f1 scaling parameters:
          sc1          Scaling model flag (enter - for default: 0; 0: lin, 1: log, 2: power-law)
          A1           Scaling parameter A (minimum or scale; enter - for default: 0.0)
          B1           Scaling parameter B (maximum or exponent; enter - for default: 6.2832)
          cyclic1      Cyclic scaling model (enter - for default: 1; 0: no 1: yes)

        Image f2 scaling parameters:
          sc2          Scaling model flag (enter - for default: 2; 0: lin, 1: log, 2: power-law)
          A2           Scaling parameter A (minimum or scale; enter - for default: 1.0)
          B2           Scaling parameter B (maximum or exponent; enter - for default: 0.35)

        General parameters:
          start_f1     starting line of f1 (enter - for default: 1)
          start_f2     starting line of f2 (enter - for default: 1)
          nlines       number of lines to process (enter - or 0 for default: to end of file)
          pixavr       number of pixels to average in range (enter - for default: 1)
          pixavaz      number of pixels to average in azimuth (enter - for default: 1)


        """

        if self.validate_inputs:
            self._validate_ras8_float(
                f1,
                f2,
                width,
                rasf,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                nlines,
                pixavr,
                pixavaz,
            )

        if self.mock_outputs:
            self._mock_ras8_float_outputs(
                f1,
                f2,
                width,
                rasf,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                nlines,
                pixavr,
                pixavaz,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras8_float))
        result = self._gamma_call("DISP", "ras8_float", ca)

        assert rasf.exists(), f"{rasf} does not exist"
        assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_flip(
        self,
        infile: Path,
        outfile: Path,
        width: int,
        dtype: Optional[int] = None,
        direction: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to flip.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_flip_outputs(
        self,
        infile: Path,
        outfile: Path,
        width: int,
        dtype: Optional[int] = None,
        direction: Optional[int] = None,
    ) -> None:
        """

        Mock the program flip.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def flip(
        self,
        infile: Path,
        outfile: Path,
        width: int,
        dtype: Optional[int] = None,
        direction: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/flip
        Flip data right/left, top/bottom or both (multiple formats)


        input parameters:
          infile      (input) input data file
          outfile     (output) output data file (flipped)
          width       number of data values/line
          dtype       data type (enter - for default)
                        0: FLOAT (default)
                        1: FCOMPLEX
                        2: SCOMPLEX
                        3: UNSIGNED CHAR
                        4: SHORT
                        5: INTEGER
                        6: DOUBLE
                        7: SUN/BMP/TIFF format raster image
          direction   flip direction (enter - for default)
                        1: right/left
                        2: top/bottom
                        3: right/left and top/bottom


        """

        if self.validate_inputs:
            self._validate_flip(infile, outfile, width, dtype, direction)

        if self.mock_outputs:
            self._mock_flip_outputs(infile, outfile, width, dtype, direction)

        ca = self._clean_args(locals(), inspect.signature(self.flip))
        result = self._gamma_call("DISP", "flip", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_dis2dt_pwr(
        self,
        data1: Path,
        data2: Path,
        pwr: Optional[Path],
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to dis2dt_pwr.

        """

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

        if pwr is not None:
            assert pwr.exists(), f"{pwr} does not exist"
            assert pwr.stat().st_size > 0, f"{pwr} has zero file size"

    def _mock_dis2dt_pwr_outputs(
        self,
        data1: Path,
        data2: Path,
        pwr: Optional[Path],
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Mock the program dis2dt_pwr.

        """
        pass

    def dis2dt_pwr(
        self,
        data1: Path,
        data2: Path,
        pwr: Optional[Path],
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2dt_pwr
        Display 2 data files (FLOAT, UNSIGNED SHORT, UNSIGNED BYTE) combined with power-law scaled intensity of a background image


        input parameters:
          data1   (input) data1 (FLOAT, UNSIGNED SHORT, or UNSIGNED BYTE)
          data2   (input) data2 (same data type as data1)
          pwr     (input) intensity image coregistered with data1 (enter - for none, FLOAT or raster image)
          width1  number of samples/row of data1
          width2  number of samples/row of data2
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          min     minimum data value (enter - for default:  0.0000e+00)
          max     maximum data value (enter - for default:  1.0000e+00)
          cflg    cyclic data display flag (enter - for default)
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max - min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   display scale factor (enter - for default: 1.0)
          exp     display exponent (enter - for default: 0.35)


        """

        if self.validate_inputs:
            self._validate_dis2dt_pwr(
                data1,
                data2,
                pwr,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                min,
                max,
                cflg,
                cmap,
                scale,
                exp,
            )

        if self.mock_outputs:
            self._mock_dis2dt_pwr_outputs(
                data1,
                data2,
                pwr,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                min,
                max,
                cflg,
                cmap,
                scale,
                exp,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis2dt_pwr))
        result = self._gamma_call("DISP", "dis2dt_pwr", ca)
        return result

    def _validate_create_array(
        self,
        output: Path,
        width: int,
        nlines: int,
        dtype: Optional[int] = None,
        val: Optional[int] = None,
        val_im: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to create_array.

        """

        assert not output.exists(), f"{output} should _not_ exist!"

        pass

    def _mock_create_array_outputs(
        self,
        output: Path,
        width: int,
        nlines: int,
        dtype: Optional[int] = None,
        val: Optional[int] = None,
        val_im: Optional[int] = None,
    ) -> None:
        """

        Mock the program create_array.

        """

        if output is not None and str(output) != "-":
            output.touch()

    def create_array(
        self,
        output: Path,
        width: int,
        nlines: int,
        dtype: Optional[int] = None,
        val: Optional[int] = None,
        val_im: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Create an array and store it as a binary file


        input parameters:
          output      (output) binary file
          width       width of output file
          nlines      number of lines of output file
          dtype       output data type (enter - for default)
                        0: FLOAT (default)
                        1: DOUBLE
                        2: INT
                        3: SHORT
                        4: SCOMPLEX
                        5: FCOMPLEX
                        6: UNSIGNED CHAR
                        7: SUN/BMP/TIFF 8-bit grayscale raster image
          val         constant value filling the array (real part for complex data) (enter - for default: 0)
          val_im      imaginary part of the constant value filling a complex array (enter - for default: 0)


        """

        if self.validate_inputs:
            self._validate_create_array(output, width, nlines, dtype, val, val_im)

        if self.mock_outputs:
            self._mock_create_array_outputs(output, width, nlines, dtype, val, val_im)

        ca = self._clean_args(locals(), inspect.signature(self.create_array))
        result = self._gamma_call("DISP", "create_array", ca)

        assert output.exists(), f"{output} does not exist"
        assert output.stat().st_size > 0, f"{output} has zero file size"

        return result

    def _validate_ascii2float(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        coff: Optional[int] = None,
        nv: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ascii2float.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_ascii2float_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        coff: Optional[int] = None,
        nv: Optional[int] = None,
    ) -> None:
        """

        Mock the program ascii2float.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def ascii2float(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        coff: Optional[int] = None,
        nv: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP program: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ascii2float.c
        Convert text format data to float format


        input parameters:
          data_in   (input) input text format data file with , or whitespace between columns
          width     number of data values (columns) in each line of text
          data_out  (output) output data file (float)
          loff      offset lines to start of data (enter - for default: 0)
          nl        number of lines (enter - for default: all)
          coff      offset columns to begin reading data values (enter - for default: 0)
          nv        number of values to read (enter - for default: to end of line)

        """

        if self.validate_inputs:
            self._validate_ascii2float(data_in, width, data_out, loff, nl, coff, nv)

        if self.mock_outputs:
            self._mock_ascii2float_outputs(data_in, width, data_out, loff, nl, coff, nv)

        ca = self._clean_args(locals(), inspect.signature(self.ascii2float))
        result = self._gamma_call("DISP", "ascii2float", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_data2tiff(
        self,
        data: Path,
        width: int,
        type: int,
        TIFF: Path,
        nodata: Optional[int] = None,
        xspacing: Optional[int] = None,
        yspacing: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to data2tiff.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        assert not TIFF.exists(), f"{TIFF} should _not_ exist!"

    def _mock_data2tiff_outputs(
        self,
        data: Path,
        width: int,
        type: int,
        TIFF: Path,
        nodata: Optional[int] = None,
        xspacing: Optional[int] = None,
        yspacing: Optional[int] = None,
    ) -> None:
        """

        Mock the program data2tiff.

        """

        if TIFF is not None and str(TIFF) != "-":
            TIFF.touch()

    def data2tiff(
        self,
        data: Path,
        width: int,
        type: int,
        TIFF: Path,
        nodata: Optional[int] = None,
        xspacing: Optional[int] = None,
        yspacing: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP data2tiff: convert image data to TIFF format


        input parameters:
          data     (input) data file
          width    input data file width
          type     input data type:
                     0: RASTER, 8 or 24 bit uncompressed raster image, SUN (*.ras), BMP:(*.bmp), TIFF (*.tif)
                     1: SHORT integer
                     2: FLOAT (4 bytes/value)
                     3: SCOMPLEX (short complex)
                     4: FCOMPLEX (float complex)
                     5: BYTE
          TIFF     (output) TIFF file (.tif extension)
          nodata   nodata value (default=0.0)
          xspacing (ignored if omitted)
          yspacing (ignored if omitted, default=xspacing)


        """

        if self.validate_inputs:
            self._validate_data2tiff(data, width, type, TIFF, nodata, xspacing, yspacing)

        if self.mock_outputs:
            self._mock_data2tiff_outputs(
                data, width, type, TIFF, nodata, xspacing, yspacing
            )

        ca = self._clean_args(locals(), inspect.signature(self.data2tiff))
        result = self._gamma_call("DISP", "data2tiff", ca)

        assert TIFF.exists(), f"{TIFF} does not exist"
        assert TIFF.stat().st_size > 0, f"{TIFF} has zero file size"

        return result

    def _validate_dis2_linear(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dis2_linear.

        """

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

    def _mock_dis2_linear_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program dis2_linear.

        """
        pass

    def dis2_linear(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[float] = None,
        max: Optional[float] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2_linear
        Display 2 data sets (FLOAT, UNSIGNED SHORT, SIGNED SHORT, or UNSIGNED BYTE) with linear scaling using a specified colormap


        input parameters:
          data1    (input) data1 (FLOAT, UNSIGNED SHORT, or UNSIGNED BYTE)
          data2    (input) data2 (same data type as data1)
          width1   number of samples/row of data1
          width2   number of samples/row of data2
          start    starting line of data (enter - for default: 1)
          nlines   number of lines to display (enter - or 0 for default: to end of file)
          xoff     x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff     y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          min      minimum data value (enter - for default:  0.0000e+00)
          max      maximum data value (enter - for default:  1.0000e+00)
          cflg     cyclic data display flag (enter - for default: hls.cm)
                     0: display min <= data < max (default)
                     1: display (data - min) modulo (max - min)
                     2: autoscale between min and max value found in data
          cmap     colormap file (enter - for default: hls.cm)
                   NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                         colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT (2-byte integer)
                    2: SIGNED SHORT (2-byte integer)
                    3: UNSIGNED BYTE


        """

        if self.validate_inputs:
            self._validate_dis2_linear(
                data1,
                data2,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                min,
                max,
                cflg,
                cmap,
                dtype,
            )

        if self.mock_outputs:
            self._mock_dis2_linear_outputs(
                data1,
                data2,
                width1,
                width2,
                start,
                nlines,
                xoff,
                yoff,
                min,
                max,
                cflg,
                cmap,
                dtype,
            )

        ca = self._clean_args(locals(), inspect.signature(self.dis2_linear))
        result = self._gamma_call("DISP", "dis2_linear", ca)
        return result

    def _validate_mapshd(
        self,
        DEM: Path,
        width: int,
        col_post: int,
        row_post: Optional[int],
        theta0: Optional[int],
        phi0: Optional[int],
        shade: Path,
        dtype: Optional[int] = None,
        zero_flag: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to mapshd.

        """

        assert DEM.exists(), f"{DEM} does not exist"
        assert DEM.stat().st_size > 0, f"{DEM} has zero file size"

        assert not shade.exists(), f"{shade} should _not_ exist!"

    def _mock_mapshd_outputs(
        self,
        DEM: Path,
        width: int,
        col_post: int,
        row_post: Optional[int],
        theta0: Optional[int],
        phi0: Optional[int],
        shade: Path,
        dtype: Optional[int] = None,
        zero_flag: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
    ) -> None:
        """

        Mock the program mapshd.

        """

        if shade is not None and str(shade) != "-":
            shade.touch()

    def mapshd(
        self,
        DEM: Path,
        width: int,
        col_post: int,
        row_post: Optional[int],
        theta0: Optional[int],
        phi0: Optional[int],
        shade: Path,
        dtype: Optional[int] = None,
        zero_flag: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[int] = None,
        edge: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/mapshd
        Generate shaded relief intensity image from DEM


        input parameters:
          DEM         (input) digital elevation model (FLOAT)
          width       samples per row of DEM
          col_post    posting between cols (same unit as DEM values)
          row_post    posting between rows (enter - for default: col_post)
          theta0      illumination elevation angle in deg. (enter - for default: 45.)
          phi0        illumination orientation angle in deg. (enter - default: 135)
                      (0.: right, 90: top, 180: left, 270: bottom)
          shade       (output) shaded relief intensity image (FLOAT)
          dtype       DEM data type (enter - for default):
                        0: FLOAT (default)
                        1: SHORT integer
          zero_flag   zero data handling (enter - for default):
                        0: 0.0 interpreted at missing value (default)
                        1: 0.0 interpreted as valid data
          illum_mode  illumination mode (enter - for default)
                        0: single angle (default)
                        1: multiple angle
          sharpness   shaded relief sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes


        """

        if self.validate_inputs:
            self._validate_mapshd(
                DEM,
                width,
                col_post,
                row_post,
                theta0,
                phi0,
                shade,
                dtype,
                zero_flag,
                illum_mode,
                sharpness,
                edge,
            )

        if self.mock_outputs:
            self._mock_mapshd_outputs(
                DEM,
                width,
                col_post,
                row_post,
                theta0,
                phi0,
                shade,
                dtype,
                zero_flag,
                illum_mode,
                sharpness,
                edge,
            )

        ca = self._clean_args(locals(), inspect.signature(self.mapshd))
        result = self._gamma_call("DISP", "mapshd", ca)

        assert shade.exists(), f"{shade} does not exist"
        assert shade.stat().st_size > 0, f"{shade} has zero file size"

        return result

    def _validate_update_par(self, PAR_1: Path, PAR_2: Path) -> None:
        """

        Validate the arguments to update_par.

        """

        assert PAR_1.exists(), f"{PAR_1} does not exist"
        assert PAR_1.stat().st_size > 0, f"{PAR_1} has zero file size"

        assert not PAR_2.exists(), f"{PAR_2} should _not_ exist!"

    def _mock_update_par_outputs(self, PAR_1: Path, PAR_2: Path) -> None:
        """

        Mock the program update_par.

        """

        if PAR_2 is not None and str(PAR_2) != "-":
            PAR_2.touch()

    def update_par(self, PAR_1: Path, PAR_2: Path) -> Tuple[int, List[str], List[str]]:
        """

        Update parameter file to the format of the latest version


        input parameters:
          PAR-1    (input) input SLC/MLI, TOPS, DEM, DIFF/GEO, ISP offset/interferogram or GPRI parameter file
          PAR-2    (output) updated SLC/MLI, TOPS, DEM, DIFF/GEO, ISP offset/interferogram or GPRI parameter file

          NOTE: The output parameter file can be the same as the input parameter file


        """

        if self.validate_inputs:
            self._validate_update_par(PAR_1, PAR_2)

        if self.mock_outputs:
            self._mock_update_par_outputs(PAR_1, PAR_2)

        ca = self._clean_args(locals(), inspect.signature(self.update_par))
        result = self._gamma_call("DISP", "update_par", ca)

        assert PAR_2.exists(), f"{PAR_2} does not exist"
        assert PAR_2.stat().st_size > 0, f"{PAR_2} has zero file size"

        return result

    def _validate_kml_pt(
        self,
        table: Path,
        lat_col: int,
        lon_col: int,
        val1_col: Optional[int],
        val1_label: Optional[int],
        val2_col: Optional[int],
        val2_label: Optional[int],
        val3_col: Optional[int],
        val3_label: Optional[int],
        id_col: Optional[int],
        kml: Path,
        icon_URL: Optional[int] = None,
        logo_URL: Optional[int] = None,
        legend_URL: Optional[int] = None,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        imin: Optional[int] = None,
        imax: Optional[int] = None,
        sat_min: Optional[int] = None,
        sat_max: Optional[int] = None,
        sc1: Optional[int] = None,
        A1: Optional[int] = None,
        B1: Optional[int] = None,
        cyclic1: Optional[int] = None,
        sc2: Optional[int] = None,
        A2: Optional[int] = None,
        B2: Optional[int] = None,
        icon_sz: Optional[int] = None,
        dir_name: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to kml_pt.

        """

        assert table.exists(), f"{table} does not exist"
        assert table.stat().st_size > 0, f"{table} has zero file size"

        assert not kml.exists(), f"{kml} should _not_ exist!"

    def _mock_kml_pt_outputs(
        self,
        table: Path,
        lat_col: int,
        lon_col: int,
        val1_col: Optional[int],
        val1_label: Optional[int],
        val2_col: Optional[int],
        val2_label: Optional[int],
        val3_col: Optional[int],
        val3_label: Optional[int],
        id_col: Optional[int],
        kml: Path,
        icon_URL: Optional[int] = None,
        logo_URL: Optional[int] = None,
        legend_URL: Optional[int] = None,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        imin: Optional[int] = None,
        imax: Optional[int] = None,
        sat_min: Optional[int] = None,
        sat_max: Optional[int] = None,
        sc1: Optional[int] = None,
        A1: Optional[int] = None,
        B1: Optional[int] = None,
        cyclic1: Optional[int] = None,
        sc2: Optional[int] = None,
        A2: Optional[int] = None,
        B2: Optional[int] = None,
        icon_sz: Optional[int] = None,
        dir_name: Optional[int] = None,
    ) -> None:
        """

        Mock the program kml_pt.

        """

        if kml is not None and str(kml) != "-":
            kml.touch()

    def kml_pt(
        self,
        table: Path,
        lat_col: int,
        lon_col: int,
        val1_col: Optional[int],
        val1_label: Optional[int],
        val2_col: Optional[int],
        val2_label: Optional[int],
        val3_col: Optional[int],
        val3_label: Optional[int],
        id_col: Optional[int],
        kml: Path,
        icon_URL: Optional[int] = None,
        logo_URL: Optional[int] = None,
        legend_URL: Optional[int] = None,
        color_model: Optional[int] = None,
        h0: Optional[int] = None,
        hrange: Optional[int] = None,
        imin: Optional[int] = None,
        imax: Optional[int] = None,
        sat_min: Optional[int] = None,
        sat_max: Optional[int] = None,
        sc1: Optional[int] = None,
        A1: Optional[int] = None,
        B1: Optional[int] = None,
        cyclic1: Optional[int] = None,
        sc2: Optional[int] = None,
        A2: Optional[int] = None,
        B2: Optional[int] = None,
        icon_sz: Optional[int] = None,
        dir_name: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP kml_pt: Create KML file with icons indicating values from ascii table


        input parameters:
          table       (input) ASCII file with columns of latitude, longitude and value
          lat_col     column number containing latitude information (WGS84, decimal)
          lon_col     column number containing longitude information (WGS84, decimal)
          val1_col    column number containing the value for red/hue (enter - if not available)
          val1_label  label of val1_col (enter - if values shall be omitted in the pop-up window)
          val2_col    column number containing the value for green/brightness (enter - if not available)
          val2_label  label of val2_col (enter - if values shall be omitted in the pop-up window)
          val3_col    column number containing the value for blue/saturation (enter - if not available)
          val3_label  label of val3_col (enter - if values shall be omitted in the pop-up window)
          id_col      column number containing the id values (enter - if no ID values shall be displayed)
          kml         (output) kml output file
          icon_URL    Uniform Resource Locator to the master icon (enter - for default: https://www.gamma-rs.ch/images/media/kml/images/button_master.png)
          logo_URL    Uniform Resource Locator to the logo image (enter - for none, enter "gamma" for gamma logo: https://www.gamma-rs.ch/images/media/kml/images/gamma_logo.png)
          legend_URL  Uniform Resource Locator to the legend image (use a vertical legend, enter - for none)
          color_model color model selection flag: (enter - for default)
                        0: RGB color model (default)
                        1: HLS (double hexagon color model)
                        2: HSV (single hexagon color model)
          h0          starting hue (color for starting value, enter - for default: 0.0)
          hrange      range of hue values in degrees (-360. ... 360., enter - for default: 360.)
          imin        minimum brightness value (0.0 ... 1.0, enter - for default: 0.15)
          imax        maximum brightness value (0.0 ... 1.0, enter - for default: 0.85)
          sat_min     minimum color saturation value (0.0 ... 1.0, enter - for default: 0.0)
          sat_max     maximum color saturation value (0.0 ... 1.0, enter - for default: 1.0)
                      Scaling parameters for val1:
          sc1         scaling model flag (enter - for default)
                        0: linear (default)
                        1: log
                        2: power-law
          A1          scaling parameter A (minimum or scale; enter - for default: 0.0)
          B1          scaling parameter B (maximum or exponent; enter - for default: 6.2832)
          cyclic1     cyclic scaling model (enter - for default)
                        0: no
                        1: yes (default)
                      Scaling parameters for val2:
          sc2         scaling model flag (enter - for default)
                        0: linear
                        1: log
                        2: power-law (default)
          A2          scaling parameter A (minimum or scale; enter - for default: 1.0)
          B2          scaling parameter B (maximum or exponent; enter - for default: 0.35)
                      Scaling parameters for val3:
          sc3         scaling model flag (enter - for default)
                        0: linear (default)
                        1: log
                        2: power-law
          A3          scaling parameter A (minimum or scale; enter - for default: 0.0)
          B3          scaling parameter B (maximum or exponent; enter - for default: 1.0)
          icon_sz     icon size (enter - for default: 0.3)
          dir_name    directory name for the KML tiles (enter - for default: kml)


        """

        if self.validate_inputs:
            self._validate_kml_pt(
                table,
                lat_col,
                lon_col,
                val1_col,
                val1_label,
                val2_col,
                val2_label,
                val3_col,
                val3_label,
                id_col,
                kml,
                icon_URL,
                logo_URL,
                legend_URL,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat_min,
                sat_max,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                icon_sz,
                dir_name,
            )

        if self.mock_outputs:
            self._mock_kml_pt_outputs(
                table,
                lat_col,
                lon_col,
                val1_col,
                val1_label,
                val2_col,
                val2_label,
                val3_col,
                val3_label,
                id_col,
                kml,
                icon_URL,
                logo_URL,
                legend_URL,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat_min,
                sat_max,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                icon_sz,
                dir_name,
            )

        ca = self._clean_args(locals(), inspect.signature(self.kml_pt))
        result = self._gamma_call("DISP", "kml_pt", ca)

        assert kml.exists(), f"{kml} does not exist"
        assert kml.stat().st_size > 0, f"{kml} has zero file size"

        return result

    def _validate_vec_to_real(self, vec: Path, width: int, index: int, cmp: Path) -> None:
        """

        Validate the arguments to vec_to_real.

        """

        assert vec.exists(), f"{vec} does not exist"
        assert vec.stat().st_size > 0, f"{vec} has zero file size"

        assert not cmp.exists(), f"{cmp} should _not_ exist!"

    def _mock_vec_to_real_outputs(
        self, vec: Path, width: int, index: int, cmp: Path
    ) -> None:
        """

        Mock the program vec_to_real.

        """

        if cmp is not None and str(cmp) != "-":
            cmp.touch()

    def vec_to_real(
        self, vec: Path, width: int, index: int, cmp: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Display Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/vec_to_real.c
        Extract individual components from float vector data and store as float

        input parameters:
          vec    (input) vector input data (float)
                 NOTE: vector data are triplets of 4-byte single-precision floating point numbers
          width  number of vectors per line of the input data
          index  index of vector component to extract:
                   1: component 1
                   2: component 2
                   3: component 3
          cmp    (output) selected vector component (float)

        """

        if self.validate_inputs:
            self._validate_vec_to_real(vec, width, index, cmp)

        if self.mock_outputs:
            self._mock_vec_to_real_outputs(vec, width, index, cmp)

        ca = self._clean_args(locals(), inspect.signature(self.vec_to_real))
        result = self._gamma_call("DISP", "vec_to_real", ca)

        assert cmp.exists(), f"{cmp} does not exist"
        assert cmp.stat().st_size > 0, f"{cmp} has zero file size"

        return result

    def _validate_ras_ras(
        self,
        ras_in: Path,
        ras_out: Path,
        col_looks: Optional[int] = None,
        row_looks: Optional[int] = None,
        LR: Optional[int] = None,
        force24: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras_ras.

        """

        assert ras_in.exists(), f"{ras_in} does not exist"
        assert ras_in.stat().st_size > 0, f"{ras_in} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

    def _mock_ras_ras_outputs(
        self,
        ras_in: Path,
        ras_out: Path,
        col_looks: Optional[int] = None,
        row_looks: Optional[int] = None,
        LR: Optional[int] = None,
        force24: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras_ras.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_ras(
        self,
        ras_in: Path,
        ras_out: Path,
        col_looks: Optional[int] = None,
        row_looks: Optional[int] = None,
        LR: Optional[int] = None,
        force24: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras_ras
        Multi-looking, left/right flip, and format conversion of SUN, BMP, or TIFF format raster images


        input parameters:
          ras_in     (input)  SUN/BMP/TIFF format raster image (8 or 24 bits/sample)
          ras_out    (output) SUN/BMP/TIFF format raster image
          col_looks  number of column looks (across) (enter - for default: 1)
          row_looks  number of row looks (down) (enter - for default: 1)
          LR         flip image left/right (1: normal (default), -1: mirror image) (enter - for default)
          force24    convert to 24 bits (enter - for default)
                       0: bits/sample remains unchanged (default)
                       1: output is 24 bits/sample

        """

        if self.validate_inputs:
            self._validate_ras_ras(ras_in, ras_out, col_looks, row_looks, LR, force24)

        if self.mock_outputs:
            self._mock_ras_ras_outputs(ras_in, ras_out, col_looks, row_looks, LR, force24)

        ca = self._clean_args(locals(), inspect.signature(self.ras_ras))
        result = self._gamma_call("DISP", "ras_ras", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_swap_bytes(self, infile: Path, outfile: Path, swap_type: int) -> None:
        """

        Validate the arguments to swap_bytes.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_swap_bytes_outputs(
        self, infile: Path, outfile: Path, swap_type: int
    ) -> None:
        """

        Mock the program swap_bytes.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def swap_bytes(
        self, infile: Path, outfile: Path, swap_type: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP swap_bytes: swap bytes for binary format data


        input parameters:
          infile     (input) input data file
          outfile    (output) output data file
          swap_type  data type (bytes/value)
                       2: (1,2,3,4,5,6,7,8...) --> (2,1,4,3,6,5,8,7...) (SHORT, SCOMPLEX)
                       4: (1,2,3,4,5,6,7,8...) --> (4,3,2,1,8,7,6,5...) (INT, FLOAT, FCOMPLEX)
                       8: (1,2,3,4,5,6,7,8...) --> (8,7,6,5,4,3,2,1...) (DOUBLE)


        """

        if self.validate_inputs:
            self._validate_swap_bytes(infile, outfile, swap_type)

        if self.mock_outputs:
            self._mock_swap_bytes_outputs(infile, outfile, swap_type)

        ca = self._clean_args(locals(), inspect.signature(self.swap_bytes))
        result = self._gamma_call("DISP", "swap_bytes", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_float2double(
        self, infile: Path, outfile: Path, scale: float, exp: float
    ) -> None:
        """

        Validate the arguments to float2double.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_float2double_outputs(
        self, infile: Path, outfile: Path, scale: float, exp: float
    ) -> None:
        """

        Mock the program float2double.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def float2double(
        self, infile: Path, outfile: Path, scale: float, exp: float
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP float2double: Convert single precision floating point data to double precision floating point data


        input parameters:
          infile   (input) input data file (float, 4 bytes/sample)
          outfile  (output) output data file (double, 8 bytes/sample)
          scale    scale factor (default: 1.0)
          exp      exponent (default: 1.0)
        NOTE: output = scale*input^exp


        """

        if self.validate_inputs:
            self._validate_float2double(infile, outfile, scale, exp)

        if self.mock_outputs:
            self._mock_float2double_outputs(infile, outfile, scale, exp)

        ca = self._clean_args(locals(), inspect.signature(self.float2double))
        result = self._gamma_call("DISP", "float2double", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_svg_poly(
        self,
        image: Path,
        dem_par: Path,
        poly: Path,
        svg: Path,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
        thick: Optional[int] = None,
        lcolor: Optional[int] = None,
        lopac: Optional[int] = None,
        pcolor: Optional[int] = None,
        popac: Optional[int] = None,
        tcolor: Optional[int] = None,
        font: Optional[int] = None,
        fsize: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to svg_poly.

        """

        assert image.exists(), f"{image} does not exist"
        assert image.stat().st_size > 0, f"{image} has zero file size"

        assert dem_par.exists(), f"{dem_par} does not exist"
        assert dem_par.stat().st_size > 0, f"{dem_par} has zero file size"

        assert poly.exists(), f"{poly} does not exist"
        assert poly.stat().st_size > 0, f"{poly} has zero file size"

        assert not svg.exists(), f"{svg} should _not_ exist!"

    def _mock_svg_poly_outputs(
        self,
        image: Path,
        dem_par: Path,
        poly: Path,
        svg: Path,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
        thick: Optional[int] = None,
        lcolor: Optional[int] = None,
        lopac: Optional[int] = None,
        pcolor: Optional[int] = None,
        popac: Optional[int] = None,
        tcolor: Optional[int] = None,
        font: Optional[int] = None,
        fsize: Optional[int] = None,
    ) -> None:
        """

        Mock the program svg_poly.

        """

        if svg is not None and str(svg) != "-":
            svg.touch()

    def svg_poly(
        self,
        image: Path,
        dem_par: Path,
        poly: Path,
        svg: Path,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
        thick: Optional[int] = None,
        lcolor: Optional[int] = None,
        lopac: Optional[int] = None,
        pcolor: Optional[int] = None,
        popac: Optional[int] = None,
        tcolor: Optional[int] = None,
        font: Optional[int] = None,
        fsize: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP svg_poly: Draw polygon on an image and store as SVG


        input parameters:
          image   (input) URL of background image in png or jpg format (- for no background image)
          dem_par (input) corresponding dem_par file (- for no dem_par file)
          poly    (input) polygon point file, format: x-coord y-coord index text
          svg     (output) SVG output file
          width   image width (overruled by dem_par width if applicable)
          nlines  number of image lines (overruled by dem_par nlines if applicable)
          mode    drawing mode (default = 0)
                   0: draw a solid polygon connecting points
                   1: draw a solid arc connecting points
                   2: draw a dashed polygon connecting points
                   3: draw a dashed arc connecting points
                   4: draw a solid polygon that respects insideness specified by the points
                   5: draw a dashed polygon that respects insideness specified by the points
                   6: draw crosses
                   7: draw triangles
                   8: draw circles
                   9: draw boxes
                  10: only text
          thick   line thickness in pixels (default = 1.0)
          lcolor  line/symbol color (default = black), use none for no stroke lines
          lopac   line/text opacity 0.0 (fully transparent) to 1.0 (fully opaque), default=1.0
          pcolor  polygon fill color (default = black), use none for no fill
          popac   polygon fill opacity 0.0 (fully transparent) to 1.0 (fully opaque), default=1.0
          tcolor  text color (default = black), use none for no text
          font    name of labelling font (default = sans-serif)
          fsize   font size (default = 14)


        """

        if self.validate_inputs:
            self._validate_svg_poly(
                image,
                dem_par,
                poly,
                svg,
                width,
                nlines,
                thick,
                lcolor,
                lopac,
                pcolor,
                popac,
                tcolor,
                font,
                fsize,
            )

        if self.mock_outputs:
            self._mock_svg_poly_outputs(
                image,
                dem_par,
                poly,
                svg,
                width,
                nlines,
                thick,
                lcolor,
                lopac,
                pcolor,
                popac,
                tcolor,
                font,
                fsize,
            )

        ca = self._clean_args(locals(), inspect.signature(self.svg_poly))
        result = self._gamma_call("DISP", "svg_poly", ca)

        assert svg.exists(), f"{svg} does not exist"
        assert svg.stat().st_size > 0, f"{svg} has zero file size"

        return result

    def _validate_get_data_values(
        self,
        data: Path,
        positions: Path,
        report: Path,
        mode: Optional[int] = None,
        dtype: Optional[int] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
        zero_flag: Optional[int] = None,
        print_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to get_data_values.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        assert positions.exists(), f"{positions} does not exist"
        assert positions.stat().st_size > 0, f"{positions} has zero file size"

        assert not report.exists(), f"{report} should _not_ exist!"

    def _mock_get_data_values_outputs(
        self,
        data: Path,
        positions: Path,
        report: Path,
        mode: Optional[int] = None,
        dtype: Optional[int] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
        zero_flag: Optional[int] = None,
        print_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program get_data_values.

        """

        if report is not None and str(report) != "-":
            report.touch()

    def get_data_values(
        self,
        data: Path,
        positions: Path,
        report: Path,
        mode: Optional[int] = None,
        dtype: Optional[int] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
        zero_flag: Optional[int] = None,
        print_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extraction of data values along profiles, in polygon regions, or from indicated positions


        input parameters:
          data        (input) input data file
          par/width   (input) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for input data, or width of input data
          positions   (input) text file containing list of positions:
                        no DEM parameter file provided: column number, row number (can be integer or real values)
                        DEM parameter file provided: longitude, latitude (EQA) or easting, northing (map coordinates, e.g. UTM)
          report      (output) text file containing extracted values
          mode        data extraction mode (enter - for default)
                        0 : extract values along the profile connecting the indicated positions (default)
                        1 : extract values in the polygon region specified by the indicated positions
                        2 : extract values at the indicated positions
          dtype       data type (enter - for default)
                        0: FLOAT (default)
                        1: DOUBLE
                        2: INT
                        3: SHORT
                        4: SCOMPLEX
                        5: FCOMPLEX
                        6: UNSIGNED CHAR
                        7: SUN/BMP/TIFF raster image
          interp_mode interpolation mode (enter - for default)
                        0: nearest-neighbor
                        1: bicubic spline (default)
                        2: bicubic-log spline, interpolates log(data)
                        3: bicubic-sqrt spline, interpolates sqrt(data)
                        4: B-spline interpolation (default B-spline degree: 5)
                        5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                        6: Lanczos interpolation (default Lanczos function order: 5)
                        7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                      NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          order       Lanczos function order or B-spline degree (2->9) (enter - default: 5)
          zero_flag   interpretation of 0.0 values (enter - for default)
                        0: 0.0 indicates missing value (default)
                        1: 0.0 is a valid value
          print_flag  print flag (enter - for default)
                        0: print values at all positions (default)
                        1: print only positions with valid data


        """

        if self.validate_inputs:
            self._validate_get_data_values(
                data,
                positions,
                report,
                mode,
                dtype,
                interp_mode,
                order,
                zero_flag,
                print_flag,
            )

        if self.mock_outputs:
            self._mock_get_data_values_outputs(
                data,
                positions,
                report,
                mode,
                dtype,
                interp_mode,
                order,
                zero_flag,
                print_flag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.get_data_values))
        result = self._gamma_call("DISP", "get_data_values", ca)

        assert report.exists(), f"{report} does not exist"
        assert report.stat().st_size > 0, f"{report} has zero file size"

        return result

    def _validate_float2ascii(
        self,
        din: Path,
        width: int,
        data_out: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to float2ascii.

        """

        assert din.exists(), f"{din} does not exist"
        assert din.stat().st_size > 0, f"{din} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_float2ascii_outputs(
        self,
        din: Path,
        width: int,
        data_out: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Mock the program float2ascii.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def float2ascii(
        self,
        din: Path,
        width: int,
        data_out: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP program: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/float2ascii.c
        Convert float format data to text format


        input parameters:
          din       (input) input data file (float)
          width     number of data values per line
          data_out  (output) input text format data file with whitespace between columns
          loff      offset lines to start of data (default: 0)
          nl        number of lines (enter - for default: to end of file)

        """

        if self.validate_inputs:
            self._validate_float2ascii(din, width, data_out, loff, nl)

        if self.mock_outputs:
            self._mock_float2ascii_outputs(din, width, data_out, loff, nl)

        ca = self._clean_args(locals(), inspect.signature(self.float2ascii))
        result = self._gamma_call("DISP", "float2ascii", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_replace_values(
        self,
        data_in: Path,
        value: float,
        new_value: int,
        data_out: Path,
        width: int,
        rpl_flg: Optional[int] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to replace_values.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_replace_values_outputs(
        self,
        data_in: Path,
        value: float,
        new_value: int,
        data_out: Path,
        width: int,
        rpl_flg: Optional[int] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program replace_values.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def replace_values(
        self,
        data_in: Path,
        value: float,
        new_value: int,
        data_out: Path,
        width: int,
        rpl_flg: Optional[int] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/replace_values

        Replace value(s) of input data file with specified value or values extracted from a second input data file

        input parameters:
          data_in    (input) input data file
          value      threshold value or nan
          new_value  new value to use or a second input data file that is used to replace values in the output
                     NOTE: if this is a second input data file, it must be the same data type as data_in
          data_out   (output) output data file
                     NOTE: data_in and data_out can be the same file
          width      number of samples/row
          rpl_flg    replacement option flag (enter - for default)
                       0: replace all points == value with new_value (default)
                       1: replace all points >= value with new_value
                       2: replace all points <= value with new_value
          dtype      data type (enter - for default)
                       2: FLOAT (default)
                       4: SHORT integer
          zflg       interpretation of 0.0 values (enter - for default)
                       0: zero is interpreted as NO_DATA and is not changed (default)
                       1: zero is a valid data value


        """

        if self.validate_inputs:
            self._validate_replace_values(
                data_in, value, new_value, data_out, width, rpl_flg, dtype, zflg
            )

        if self.mock_outputs:
            self._mock_replace_values_outputs(
                data_in, value, new_value, data_out, width, rpl_flg, dtype, zflg
            )

        ca = self._clean_args(locals(), inspect.signature(self.replace_values))
        result = self._gamma_call("DISP", "replace_values", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_SLC_deskew(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC_2: Path,
        SLC2_par: Path,
        mode: Optional[int] = None,
        interp: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
        ph_corr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_deskew.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert not SLC_2.exists(), f"{SLC_2} should _not_ exist!"

        assert not SLC2_par.exists(), f"{SLC2_par} should _not_ exist!"

    def _mock_SLC_deskew_outputs(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC_2: Path,
        SLC2_par: Path,
        mode: Optional[int] = None,
        interp: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
        ph_corr: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_deskew.

        """

        if SLC_2 is not None and str(SLC_2) != "-":
            SLC_2.touch()

        if SLC2_par is not None and str(SLC2_par) != "-":
            SLC2_par.touch()

    def SLC_deskew(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC_2: Path,
        SLC2_par: Path,
        mode: Optional[int] = None,
        interp: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
        ph_corr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Change geometry from Doppler centroid to zero-Doppler (deskew) or vice-versa


        input parameters:
          SLC-1     (input) SLC image file (FCOMPLEX or SCOMPLEX format)
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC-2     (output) SLC image file in new geometry
          SLC2_par  (output) SLC-2 ISP image parameter file
          mode      mode of operation (enter - for default)
                      0: change geometry from Doppler centroid to zero-Doppler (deskew, default)
                      1: change geometry from zero-Doppler to Doppler centroid (reskew)
          interp    interpolation method (enter - for default)
                      0: Lanczos interpolation (default)
                      1: B-spline interpolation
          order     Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)
          deramp    deramp flag (enter - for default)
                      0: do not deramp and reramp data
                      1: deramp data before interpolation and reramp afterwards (default)
          ph_corr   range shift phase correction flag (enter - for default)
                      0: do not correct phase related to range shift
                      1: correct phase related to range shift (default)


        """

        if self.validate_inputs:
            self._validate_SLC_deskew(
                SLC_1, SLC1_par, SLC_2, SLC2_par, mode, interp, order, deramp, ph_corr
            )

        if self.mock_outputs:
            self._mock_SLC_deskew_outputs(
                SLC_1, SLC1_par, SLC_2, SLC2_par, mode, interp, order, deramp, ph_corr
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_deskew))
        result = self._gamma_call("ISP", "SLC_deskew", ca)

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        return result

    def _validate_sbi_offset(
        self,
        sbi_unw: Path,
        SLCf_par: Path,
        SLCb_par: Path,
        OFF_par: Path,
        az_offset: Path,
    ) -> None:
        """

        Validate the arguments to sbi_offset.

        """

        assert sbi_unw.exists(), f"{sbi_unw} does not exist"
        assert sbi_unw.stat().st_size > 0, f"{sbi_unw} has zero file size"

        assert SLCf_par.exists(), f"{SLCf_par} does not exist"
        assert SLCf_par.stat().st_size > 0, f"{SLCf_par} has zero file size"

        assert SLCb_par.exists(), f"{SLCb_par} does not exist"
        assert SLCb_par.stat().st_size > 0, f"{SLCb_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not az_offset.exists(), f"{az_offset} should _not_ exist!"

    def _mock_sbi_offset_outputs(
        self,
        sbi_unw: Path,
        SLCf_par: Path,
        SLCb_par: Path,
        OFF_par: Path,
        az_offset: Path,
    ) -> None:
        """

        Mock the program sbi_offset.

        """

        if az_offset is not None and str(az_offset) != "-":
            az_offset.touch()

    def sbi_offset(
        self,
        sbi_unw: Path,
        SLCf_par: Path,
        SLCb_par: Path,
        OFF_par: Path,
        az_offset: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate azimuth offsets from unwrapped split-beam interferogram


        input parameters:
          sbi_unw   (input) unwrapped phase of split-beam interferogram (float)
          SLCf_par  (input) reference SLC parameter file (forward-looking)
          SLCb_par  (input) reference SLC parameter file (backward-looking)
          OFF_par   (input) offset parameter file
          az_offset (output) azimuth offsets (m)

        """

        if self.validate_inputs:
            self._validate_sbi_offset(sbi_unw, SLCf_par, SLCb_par, OFF_par, az_offset)

        if self.mock_outputs:
            self._mock_sbi_offset_outputs(sbi_unw, SLCf_par, SLCb_par, OFF_par, az_offset)

        ca = self._clean_args(locals(), inspect.signature(self.sbi_offset))
        result = self._gamma_call("ISP", "sbi_offset", ca)

        assert az_offset.exists(), f"{az_offset} does not exist"
        assert az_offset.stat().st_size > 0, f"{az_offset} has zero file size"

        return result

    def _validate_par_ASF_RSAT_SS(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_ASF_RSAT_SS.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_ASF_RSAT_SS_outputs(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_ASF_RSAT_SS.

        """

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_ASF_RSAT_SS(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file for ASF Radarsat-1 SCANSAR images


        input parameters:
          CEOS_leader  (input) CEOS leader file (Radarsat-1 SCANSAR)
          CEOS_data    (input) CEOS data file (Radarsat-1 SCANSAR)
          GRD_par      (output) ISP image parameter file (example <orbit>.mli.par)
          GRD          (output) ISP image (example <orbit>.mli) (enter -  for none, short integer)

        """

        if self.validate_inputs:
            self._validate_par_ASF_RSAT_SS(CEOS_leader, CEOS_data, GRD_par, GRD)

        if self.mock_outputs:
            self._mock_par_ASF_RSAT_SS_outputs(CEOS_leader, CEOS_data, GRD_par, GRD)

        ca = self._clean_args(locals(), inspect.signature(self.par_ASF_RSAT_SS))
        result = self._gamma_call("ISP", "par_ASF_RSAT_SS", ca)

        assert GRD_par.exists(), f"{GRD_par} does not exist"
        assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_par_ASF_SLC(
        self, SLC_par: Path, CEOS_data: Optional[Path] = None, SLC: Optional[Path] = None
    ) -> None:
        """

        Validate the arguments to par_ASF_SLC.

        """

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if CEOS_data is not None:
            assert CEOS_data.exists(), f"{CEOS_data} does not exist"
            assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_ASF_SLC_outputs(
        self, SLC_par: Path, CEOS_data: Optional[Path] = None, SLC: Optional[Path] = None
    ) -> None:
        """

        Mock the program par_ASF_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_ASF_SLC(
        self, SLC_par: Path, CEOS_data: Optional[Path] = None, SLC: Optional[Path] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC image parameter file and reformat data


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file
          SLC_par      (output) ISP SLC parameter file (example <date>.slc.par)
          CEOS_data    (input) CEOS data file (example: dat_01.001)
          SLC          (output) SLC data with file and line headers removed (example: <date>.slc)

        """

        if self.validate_inputs:
            self._validate_par_ASF_SLC(SLC_par, CEOS_data, SLC)

        if self.mock_outputs:
            self._mock_par_ASF_SLC_outputs(SLC_par, CEOS_data, SLC)

        ca = self._clean_args(locals(), inspect.signature(self.par_ASF_SLC))
        result = self._gamma_call("ISP", "par_ASF_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_S1_BURST_tab(
        self, SLC1_tab: Path, SLC2_tab: Path, BURST_tab: Path
    ) -> None:
        """

        Validate the arguments to S1_BURST_tab.

        """

        assert SLC1_tab.exists(), f"{SLC1_tab} does not exist"
        assert SLC1_tab.stat().st_size > 0, f"{SLC1_tab} has zero file size"

        self._check_tab_file(SLC1_tab, "SLC1_tab")

        assert SLC2_tab.exists(), f"{SLC2_tab} does not exist"
        assert SLC2_tab.stat().st_size > 0, f"{SLC2_tab} has zero file size"

        self._check_tab_file(SLC2_tab, "SLC2_tab")

        assert not BURST_tab.exists(), f"{BURST_tab} should _not_ exist!"

    def _mock_S1_BURST_tab_outputs(
        self, SLC1_tab: Path, SLC2_tab: Path, BURST_tab: Path
    ) -> None:
        """

        Mock the program S1_BURST_tab.

        """

        if BURST_tab is not None and str(BURST_tab) != "-":
            BURST_tab.touch()

    def S1_BURST_tab(
        self, SLC1_tab: Path, SLC2_tab: Path, BURST_tab: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/S1_BURST_tab
        Calculate Sentinel BURST_tab based on parameters extracted from SLC parameter files listed in SLC1_tab and SLC2_tab
        Running SLC_copy_ScanSAR using BURST_tab will generate SLC-2 data with matching bursts for each swath of SLC-1 and SLC-2


        input parameters:
          SLC1_tab   (input) 3 column list of the reference TOPS SLC swaths in row order IW1, IW2, IW3
          SLC2_tab   (input) 3 column list of TOPS SLC-2 swaths to be resampled to the geometry of the reference SLC1 in row order IW1, IW2, IW3.
          BURST_tab  (output) 2 column list of the first and last bursts to copy from each swath, one line for each swath
                     BURST_tab line entries: first_burst  last_burst    Note: first burst is 1

        """

        if self.validate_inputs:
            self._validate_S1_BURST_tab(SLC1_tab, SLC2_tab, BURST_tab)

        if self.mock_outputs:
            self._mock_S1_BURST_tab_outputs(SLC1_tab, SLC2_tab, BURST_tab)

        ca = self._clean_args(locals(), inspect.signature(self.S1_BURST_tab))
        result = self._gamma_call("ISP", "S1_BURST_tab", ca)

        assert BURST_tab.exists(), f"{BURST_tab} does not exist"
        assert BURST_tab.stat().st_size > 0, f"{BURST_tab} has zero file size"

        return result

    def _validate_par_KS_SLC(
        self,
    ) -> None:
        """

        Validate the arguments to par_KS_SLC.

        """

        pass

    def _mock_par_KS_SLC_outputs(
        self,
    ) -> None:
        """

        Mock the program par_KS_SLC.

        """
        pass

    def par_KS_SLC(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        dyld[70969]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_KS_SLC'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)

        """

        if self.validate_inputs:
            self._validate_par_KS_SLC()

        if self.mock_outputs:
            self._mock_par_KS_SLC_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.par_KS_SLC))
        result = self._gamma_call("ISP", "par_KS_SLC", ca)
        return result

    def _validate_ScanSAR_full_aperture_SLC(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        SLCR_tab: Optional[Path] = None,
        vmode: Optional[int] = None,
        wflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
        n_ovr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ScanSAR_full_aperture_SLC.

        """

        assert SLC1_tab.exists(), f"{SLC1_tab} does not exist"
        assert SLC1_tab.stat().st_size > 0, f"{SLC1_tab} has zero file size"

        self._check_tab_file(SLC1_tab, "SLC1_tab")

        if SLCR_tab is not None:
            assert SLCR_tab.exists(), f"{SLCR_tab} does not exist"
            assert SLCR_tab.stat().st_size > 0, f"{SLCR_tab} has zero file size"

    def _mock_ScanSAR_full_aperture_SLC_outputs(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        SLCR_tab: Optional[Path] = None,
        vmode: Optional[int] = None,
        wflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
        n_ovr: Optional[int] = None,
    ) -> None:
        """

        Mock the program ScanSAR_full_aperture_SLC.

        """

        if not SLC2_tab.exists():
            SLC2_tab.touch()

    def ScanSAR_full_aperture_SLC(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        SLCR_tab: Optional[Path] = None,
        vmode: Optional[int] = None,
        wflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
        n_ovr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate continuous SLC data from ScanSAR burst data (Sentinel-1, RCM, and TSX)


        input parameters:
          SLC1_tab  (input) 3 column list of ScanSAR SLC swaths listed in order from near to far range
                      SLC1_tab line entries:   SLC   SLC_par  TOPS_par
          SLC2_tab  (input/output) 3 column list of oversampled continuous SLC swaths listed in order from near to far range
                      SLC2_tab line entries:   SLC   SLC_par
                    NOTE: if the SLC2_tab does not yet exist, the file entries will be created with names derived from the SLC1_tab entries
          SLCR_tab  (input) 3 column list of the reference scene with swaths, listed in order from near to far range (enter - for none)
                      SLCR_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_dir  directory for output oversampled continuous SLC, ignored if the SLC2_tab already exists (enter . for the current directory)
          vmode     sample validity mode (enter - for default):
                      0: all data in the burst are considered valid (default)
                      1: interpolate samples between the valid data bounds of the burst
          wflg      burst window calculation flag (enter - for default):
                      0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                      1: calculate burst window parameters from burst parameters and the number of range and azimuth looks
          imode     interpolation mode (enter - for default):
                      0: Lanczos (default)
                      1: B-spline
          order     Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 5)
          dtype     output data type, (enter - for default: same as input data):
                      0: FCOMPLEX
                      1: SCOMPLEX
          n_ovr     SLC oversampling factor, must be in the range 2 --> 32 (enter - for default: automatically calculated)


        """

        if self.validate_inputs:
            self._validate_ScanSAR_full_aperture_SLC(
                SLC1_tab, SLC2_tab, SLCR_tab, vmode, wflg, imode, order, n_ovr
            )

        if self.mock_outputs:
            self._mock_ScanSAR_full_aperture_SLC_outputs(
                SLC1_tab, SLC2_tab, SLCR_tab, vmode, wflg, imode, order, n_ovr
            )

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_full_aperture_SLC))
        result = self._gamma_call("ISP", "ScanSAR_full_aperture_SLC", ca)

        assert SLC2_tab.exists(), f"{SLC2_tab} does not exist"
        assert SLC2_tab.stat().st_size > 0, f"{SLC2_tab} has zero file size"

        return result

    def _validate_init_offset(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        offr: Optional[int] = None,
        offaz: Optional[int] = None,
        thres: Optional[float] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        cflag: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to init_offset.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

    def _mock_init_offset_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        offr: Optional[int] = None,
        offaz: Optional[int] = None,
        thres: Optional[float] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        cflag: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> None:
        """

        Mock the program init_offset.

        """
        pass

    def init_offset(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        offr: Optional[int] = None,
        offaz: Optional[int] = None,
        thres: Optional[float] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        cflag: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Determine initial offset between SLC images using correlation of image intensity


        input parameters:
          SLC-1     (input) single-look complex image 1 (reference)
          SLC-2     (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          rlks      number of range looks (default: 1)
          azlks     number of azimuth looks (default: 1)
          rpos      center of patch in range (samples) (enter - for default: image center)
          azpos     center of patch in azimuth (lines) (enter - for default: image center)
          offr      initial range offset (samples) (enter - for default: 0)
          offaz     initial azimuth offset (lines) (enter - for default: 0)
          thres     cross-correlation threshold (enter - for default: 0.150)
          rwin      range window size (default: 512)
          azwin     azimuth window size (default: 512)
          cflag     copy offsets to the range and azimuth offset polynomials in the OFF_par (enter - for default)
                      0: do not copy
                      1: copy constant range and azimuth offset (default)
          deramp    deramp SLC phase flag (enter - for default)
                      0: no deramp (Doppler centroid close to 0) (default)
                      1: deramp SLC phase

        """

        if self.validate_inputs:
            self._validate_init_offset(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                rlks,
                azlks,
                rpos,
                azpos,
                offr,
                offaz,
                thres,
                rwin,
                azwin,
                cflag,
                deramp,
            )

        if self.mock_outputs:
            self._mock_init_offset_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                rlks,
                azlks,
                rpos,
                azpos,
                offr,
                offaz,
                thres,
                rwin,
                azwin,
                cflag,
                deramp,
            )

        ca = self._clean_args(locals(), inspect.signature(self.init_offset))
        result = self._gamma_call("ISP", "init_offset", ca)
        return result

    def _validate_bridge(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        bridge: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to bridge.

        """

        assert int.exists(), f"{int} does not exist"
        assert int.stat().st_size > 0, f"{int} has zero file size"

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

        assert bridge.exists(), f"{bridge} does not exist"
        assert bridge.stat().st_size > 0, f"{bridge} has zero file size"

    def _mock_bridge_outputs(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        bridge: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Mock the program bridge.

        """

        if not unw.exists():
            unw.touch()

    def bridge(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        bridge: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Phase unwrap new regions with bridges to regions already unwrapped


        input parameters:
          int     (input) interferogram (fcomplex)
          flag    (input) unwrapping flag file
          unw     (input/output) unwrapped phase (float)
          bridge  (input) bridge data file (text format)
          width   number of samples/row
          xmin    starting range pixel offset to unwrap (default = 0)
          xmax    last range pixel offset to unwrap (default=width-1)
          ymin    starting azimuth row offset to unwrap, relative to start (default = 0)
          ymax    last azimuth row offset to unwrap, relative to start (default = nlines-1)


        """

        if self.validate_inputs:
            self._validate_bridge(int, flag, unw, bridge, width, xmin, xmax, ymin, ymax)

        if self.mock_outputs:
            self._mock_bridge_outputs(
                int, flag, unw, bridge, width, xmin, xmax, ymin, ymax
            )

        ca = self._clean_args(locals(), inspect.signature(self.bridge))
        result = self._gamma_call("ISP", "bridge", ca)

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        return result

    def _validate_par_ERSDAC_PALSAR(self, SLC_par: Path) -> None:
        """

        Validate the arguments to par_ERSDAC_PALSAR.

        """

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        pass

    def _mock_par_ERSDAC_PALSAR_outputs(self, SLC_par: Path) -> None:
        """

        Mock the program par_ERSDAC_PALSAR.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ERSDAC_PALSAR(self, SLC_par: Path) -> Tuple[int, List[str], List[str]]:
        """

        Generate the ISP image parameter file from ERSDAC PALSAR level 1.1 SLC data


        input parameters:
        ERSDAC_SLC_par (input) ERSDAC SLC parameter file Level 1.1 (PASL11*.SLC.par)
        SLC_par        (output) ISP image parameter file (example: yyyymmdd.slc.par)

        """

        if self.validate_inputs:
            self._validate_par_ERSDAC_PALSAR(SLC_par)

        if self.mock_outputs:
            self._mock_par_ERSDAC_PALSAR_outputs(SLC_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_ERSDAC_PALSAR))
        result = self._gamma_call("ISP", "par_ERSDAC_PALSAR", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_SR_to_GRD(
        self,
        MLI_par: Path,
        OFF_par: Optional[Path],
        GRD_par: Path,
        in_file: Path,
        out_file: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        interp_mode: Optional[int] = None,
        grd_rsp: Optional[int] = None,
        grd_azsp: Optional[int] = None,
        degree: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SR_to_GRD.

        """

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert in_file.exists(), f"{in_file} does not exist"
        assert in_file.stat().st_size > 0, f"{in_file} has zero file size"

        assert not out_file.exists(), f"{out_file} should _not_ exist!"

    def _mock_SR_to_GRD_outputs(
        self,
        MLI_par: Path,
        OFF_par: Optional[Path],
        GRD_par: Path,
        in_file: Path,
        out_file: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        interp_mode: Optional[int] = None,
        grd_rsp: Optional[int] = None,
        grd_azsp: Optional[int] = None,
        degree: Optional[int] = None,
    ) -> None:
        """

        Mock the program SR_to_GRD.

        """

        if not GRD_par.exists():
            GRD_par.touch()

        if out_file is not None and str(out_file) != "-":
            out_file.touch()

    def SR_to_GRD(
        self,
        MLI_par: Path,
        OFF_par: Optional[Path],
        GRD_par: Path,
        in_file: Path,
        out_file: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        interp_mode: Optional[int] = None,
        grd_rsp: Optional[int] = None,
        grd_azsp: Optional[int] = None,
        degree: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Conversion to ground range for ISP MLI and INSAR data of type FLOAT


        input parameters:
          MLI_par      (input) MLI image parameter file of the slant-range image
          OFF_par      (input) ISP OFF_par of the input image (enter - when the image geometry specified by the MLI_par)
          GRD_par      (input/output) image parameter file of output ground range image
          in_file      (input) slant range image (FLOAT)
          out_file     (output) ground range image (FLOAT)
          rlks         multi-looking in range (prior to resampling, enter - for default: 1)
          azlks        multi-looking in azimuth (prior to resampling, enter - for default: 1)
          interp_mode  interpolation mode (enter - for default)
                         0: nearest-neighbor
                         1: bicubic spline
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 3)
                         5: B-spline interpolation sqrt(x) (default) (default B-spline degree: 3)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          grd_rsp      output image ground range sample spacing (m) (enter - for default: (input image azimuth spacing) * azlks)
          grd_azsp     output image azimuth sample spacing (m) (default = (input image azimuth spacing) * azlks)
          degree       B-spline degree (2->9) (enter - for default: 3)


        """

        if self.validate_inputs:
            self._validate_SR_to_GRD(
                MLI_par,
                OFF_par,
                GRD_par,
                in_file,
                out_file,
                rlks,
                azlks,
                interp_mode,
                grd_rsp,
                grd_azsp,
                degree,
            )

        if self.mock_outputs:
            self._mock_SR_to_GRD_outputs(
                MLI_par,
                OFF_par,
                GRD_par,
                in_file,
                out_file,
                rlks,
                azlks,
                interp_mode,
                grd_rsp,
                grd_azsp,
                degree,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SR_to_GRD))
        result = self._gamma_call("ISP", "SR_to_GRD", ca)

        assert GRD_par.exists(), f"{GRD_par} does not exist"
        assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        assert out_file.exists(), f"{out_file} does not exist"
        assert out_file.stat().st_size > 0, f"{out_file} has zero file size"

        return result

    def _validate_par_ACS_ERS(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        """

        Validate the arguments to par_ACS_ERS.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

    def _mock_par_ACS_ERS_outputs(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        """

        Mock the program par_ACS_ERS.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ACS_ERS(
        self, CEOS_SAR_leader: Path, SLC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file generation for ERS SLC data from the ACS processor


        input parameters:
        CEOS_SAR_leader  (input) ERS CEOS SAR leader file
        SLC_par          (output) ISP SLC parameter file (example <orbit>.slc.par)


        """

        if self.validate_inputs:
            self._validate_par_ACS_ERS(CEOS_SAR_leader, SLC_par)

        if self.mock_outputs:
            self._mock_par_ACS_ERS_outputs(CEOS_SAR_leader, SLC_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_ACS_ERS))
        result = self._gamma_call("ISP", "par_ACS_ERS", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_mk_tab3(
        self,
    ) -> None:
        """

        Validate the arguments to mk_tab3.

        """

        pass

    def _mock_mk_tab3_outputs(
        self,
    ) -> None:
        """

        Mock the program mk_tab3.

        """
        pass

    def mk_tab3(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC_tab, MLI_tab, or RAW_list for processing

            dir   (input) directory including paths that contain the data files
            ext-1 (input) pattern to select data files (examples: slc, raw...), (enter - for all files in the directory)
            ext-2 (input) pattern to select parameter files that match the data (enter -  for none, examples: slc.par, raw_par, raw.par)
            ext-3 (input) pattern to select parameter files that match the data (enter -  for none, examples: ppar)
            tab   (output) list of data filenames and associated parameter files (including paths) (text)

            NOTE: The current directory is denoted using .


        """

        if self.validate_inputs:
            self._validate_mk_tab3()

        if self.mock_outputs:
            self._mock_mk_tab3_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.mk_tab3))
        result = self._gamma_call("ISP", "mk_tab3", ca)
        return result

    def _validate_offset_fit(
        self,
        offs: Path,
        ccp: Path,
        OFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[float] = None,
        npoly: Optional[int] = None,
        interact_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_fit.

        """

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        if coffs is not None:
            assert not coffs.exists(), f"{coffs} should _not_ exist!"

        if coffsets is not None:
            assert not coffsets.exists(), f"{coffsets} should _not_ exist!"

    def _mock_offset_fit_outputs(
        self,
        offs: Path,
        ccp: Path,
        OFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[float] = None,
        npoly: Optional[int] = None,
        interact_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_fit.

        """

        if coffs is not None and str(coffs) != "-":
            coffs.touch()

        if coffsets is not None and str(coffsets) != "-":
            coffsets.touch()

    def offset_fit(
        self,
        offs: Path,
        ccp: Path,
        OFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[float] = None,
        npoly: Optional[int] = None,
        interact_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Range and azimuth offset polynomial estimation


        input parameters:
          offs          (input) range and azimuth offset estimates for each patch (fcomplex)
          ccp           (input) cross-correlation or SNR of each patch (float)
          OFF_par       (input) ISP offset/interferogram parameter file
          coffs         (output) culled range and azimuth offset estimates (fcomplex, enter - for none)
          coffsets      (output) culled offset estimates and cross-correlation values (text format, enter - for none)
          thres         cross-correlation threshold (enter - for default from OFF_par)
          npoly         number of model polynomial parameters (enter - for default, 1, 3, 4, 6, default: 4)
          interact_mode interactive culling of input data:
                          0: off (default)
                          1: on

        """

        if self.validate_inputs:
            self._validate_offset_fit(
                offs, ccp, OFF_par, coffs, coffsets, thres, npoly, interact_flag
            )

        if self.mock_outputs:
            self._mock_offset_fit_outputs(
                offs, ccp, OFF_par, coffs, coffsets, thres, npoly, interact_flag
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_fit))
        result = self._gamma_call("ISP", "offset_fit", ca)

        if coffs is not None:
            assert coffs.exists(), f"{coffs} does not exist"
            assert coffs.stat().st_size > 0, f"{coffs} has zero file size"

        if coffsets is not None:
            assert coffsets.exists(), f"{coffsets} does not exist"
            assert coffsets.stat().st_size > 0, f"{coffsets} has zero file size"

        return result

    def _validate_radcal_PRI(
        self,
        PRI: Path,
        PRI_par: Path,
        GRD: Path,
        GRD_par: Path,
        K_dB: Optional[int] = None,
        inc_ref: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to radcal_PRI.

        """

        assert PRI.exists(), f"{PRI} does not exist"
        assert PRI.stat().st_size > 0, f"{PRI} has zero file size"

        assert PRI_par.exists(), f"{PRI_par} does not exist"
        assert PRI_par.stat().st_size > 0, f"{PRI_par} has zero file size"

        assert not GRD.exists(), f"{GRD} should _not_ exist!"

        assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

    def _mock_radcal_PRI_outputs(
        self,
        PRI: Path,
        PRI_par: Path,
        GRD: Path,
        GRD_par: Path,
        K_dB: Optional[int] = None,
        inc_ref: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Mock the program radcal_PRI.

        """

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

    def radcal_PRI(
        self,
        PRI: Path,
        PRI_par: Path,
        GRD: Path,
        GRD_par: Path,
        K_dB: Optional[int] = None,
        inc_ref: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Convert ESA processed short integer format PRI to radiometrically calibrated GRD image (float)


        input parameters:
          PRI       (input) PRI ground-range image (short integer, sqrt(backscat. intensity)
          PRI_PAR   (input) SLC parameter file of input PRI ground-range image (yyyymmdd.pri.par)
          GRD       (output) calibrated ground-range image (float, backscat. intensity)
          GRD_PAR   (output) ISP image parameter file of output calibrated ground-range image (yyyymmdd.grd.par)
          K_dB      calibration factor in decibels (default: 59.75 dB)
                    ERS1 (D-Paf,ESRIN): 58.24 dB, ERS2 (D-Paf,ESRIN,I-Paf,UK-Paf after 1997): 59.75 dB
                    ENVISAT ASAR: 55.0 dB (all modes)
                    for details see product specifications and ESA publications.
          inc_ref   reference incidence angle in deg. (default: 23.0 deg.)
                    ENVISAT ASAR: 90.0 deg. (all modes)
          roff      offset to starting range sample (default: 0)
          nr        number of range samples (default: 0, to end of line)
          loff      offset to starting line (default: 0, 1 header line in the input file is assumed for ERS)
          nl        number of lines to copy (default: 0, to end of file)


        """

        if self.validate_inputs:
            self._validate_radcal_PRI(
                PRI, PRI_par, GRD, GRD_par, K_dB, inc_ref, roff, nr, loff, nl
            )

        if self.mock_outputs:
            self._mock_radcal_PRI_outputs(
                PRI, PRI_par, GRD, GRD_par, K_dB, inc_ref, roff, nr, loff, nl
            )

        ca = self._clean_args(locals(), inspect.signature(self.radcal_PRI))
        result = self._gamma_call("ISP", "radcal_PRI", ca)

        assert GRD.exists(), f"{GRD} does not exist"
        assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        assert GRD_par.exists(), f"{GRD_par} does not exist"
        assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        return result

    def _validate_gcp_phase(
        self,
        unw: Path,
        OFF_par: Path,
        gcp: Path,
        gcp_ph: Path,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gcp_phase.

        """

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert gcp.exists(), f"{gcp} does not exist"
        assert gcp.stat().st_size > 0, f"{gcp} has zero file size"

        assert not gcp_ph.exists(), f"{gcp_ph} should _not_ exist!"

    def _mock_gcp_phase_outputs(
        self,
        unw: Path,
        OFF_par: Path,
        gcp: Path,
        gcp_ph: Path,
        win_sz: Optional[int] = None,
    ) -> None:
        """

        Mock the program gcp_phase.

        """

        if gcp_ph is not None and str(gcp_ph) != "-":
            gcp_ph.touch()

    def gcp_phase(
        self,
        unw: Path,
        OFF_par: Path,
        gcp: Path,
        gcp_ph: Path,
        win_sz: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract unwrapped phase at GCP locations


        input parameters:
          unw      (input) unwrapped interferometric phase
          OFF_par  (input) ISP interferogram/offset parameter file
          gcp      (input) ground control point data (text format)
          gcp_ph   (output) ground control point data + extracted unwrapped phase (text)
          win_sz   window size for averaging phase for each GCP, must be odd (default: 1)


        """

        if self.validate_inputs:
            self._validate_gcp_phase(unw, OFF_par, gcp, gcp_ph, win_sz)

        if self.mock_outputs:
            self._mock_gcp_phase_outputs(unw, OFF_par, gcp, gcp_ph, win_sz)

        ca = self._clean_args(locals(), inspect.signature(self.gcp_phase))
        result = self._gamma_call("ISP", "gcp_phase", ca)

        assert gcp_ph.exists(), f"{gcp_ph} does not exist"
        assert gcp_ph.stat().st_size > 0, f"{gcp_ph} has zero file size"

        return result

    def _validate_par_MSP(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SLC_par: Path,
        image_format: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_MSP.

        """

        assert SAR_par.exists(), f"{SAR_par} does not exist"
        assert SAR_par.stat().st_size > 0, f"{SAR_par} has zero file size"

        assert PROC_par.exists(), f"{PROC_par} does not exist"
        assert PROC_par.stat().st_size > 0, f"{PROC_par} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

    def _mock_par_MSP_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SLC_par: Path,
        image_format: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_MSP.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_MSP(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SLC_par: Path,
        image_format: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP image parameter file from MSP processing parameter and sensor files


        input parameters:
          SAR_par       (input) MSP SAR sensor parameter file
          PROC_par      (input) MSP processing parameter file
          SLC/MLI_par   (output) ISP SLC/MLI image parameter file
          image_format  image format flag (default: from MSP processing parameter file)
                          0: FCOMPLEX (pairs of 4-byte float)
                          1: SCOMPLEX (pairs of 2-byte short integer)
                          2: FLOAT (4-bytes/value)

        """

        if self.validate_inputs:
            self._validate_par_MSP(SAR_par, PROC_par, SLC_par, image_format)

        if self.mock_outputs:
            self._mock_par_MSP_outputs(SAR_par, PROC_par, SLC_par, image_format)

        ca = self._clean_args(locals(), inspect.signature(self.par_MSP))
        result = self._gamma_call("ISP", "par_MSP", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_SLC_deramp_ScanSAR(
        self, SLC1_tab: Path, SLC2_tab: Path, mode: int, phflg: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to SLC_deramp_ScanSAR.

        """

        assert SLC1_tab.exists(), f"{SLC1_tab} does not exist"
        assert SLC1_tab.stat().st_size > 0, f"{SLC1_tab} has zero file size"

        self._check_tab_file(SLC1_tab, "SLC1_tab")

        assert SLC2_tab.exists(), f"{SLC2_tab} does not exist"
        assert SLC2_tab.stat().st_size > 0, f"{SLC2_tab} has zero file size"

        self._check_tab_file(SLC2_tab, "SLC2_tab")

    def _mock_SLC_deramp_ScanSAR_outputs(
        self, SLC1_tab: Path, SLC2_tab: Path, mode: int, phflg: Optional[int] = None
    ) -> None:
        """

        Mock the program SLC_deramp_ScanSAR.

        """
        pass

    def SLC_deramp_ScanSAR(
        self, SLC1_tab: Path, SLC2_tab: Path, mode: int, phflg: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate and subtract ScanSAR or TOPS Doppler phase from burst SLC data


        input parameters:
          SLC1_tab   (input) 3 column list of input ScanSAR SLC, swaths are listed in order from near to far range:
                     SLC_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_tab   (input) 3 column list of output ScanSAR SLC, swaths are listed in order from near to far range
          mode       mode of operation:
                       0: subtract ScanSAR Doppler phase (deramp)
                       1: add Doppler phase ramp (reramp)
          phflg      deramp phase flag (enter - for default)
                       0: do not save ScanSAR Doppler phase (default)
                       1: save ScanSAR Doppler phase, output filename is the same as the deramped SLC with extension .dph


        """

        if self.validate_inputs:
            self._validate_SLC_deramp_ScanSAR(SLC1_tab, SLC2_tab, mode, phflg)

        if self.mock_outputs:
            self._mock_SLC_deramp_ScanSAR_outputs(SLC1_tab, SLC2_tab, mode, phflg)

        ca = self._clean_args(locals(), inspect.signature(self.SLC_deramp_ScanSAR))
        result = self._gamma_call("ISP", "SLC_deramp_ScanSAR", ca)
        return result

    def _validate_offset_pwr_tracking2(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        OFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwr_tracking2.

        """

        assert SLC1.exists(), f"{SLC1} does not exist"
        assert SLC1.stat().st_size > 0, f"{SLC1} has zero file size"

        assert SLC2.exists(), f"{SLC2} does not exist"
        assert SLC2.stat().st_size > 0, f"{SLC2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not ccp.exists(), f"{ccp} should _not_ exist!"

        if OFF_par2 is not None:
            assert OFF_par2.exists(), f"{OFF_par2} does not exist"
            assert OFF_par2.stat().st_size > 0, f"{OFF_par2} has zero file size"

        if offs2 is not None:
            assert offs2.exists(), f"{offs2} does not exist"
            assert offs2.stat().st_size > 0, f"{offs2} has zero file size"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

        if ccs is not None:
            assert not ccs.exists(), f"{ccs} should _not_ exist!"

    def _mock_offset_pwr_tracking2_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        OFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Mock the program offset_pwr_tracking2.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if ccp is not None and str(ccp) != "-":
            ccp.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_tracking2(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        OFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Intensity cross-correlation offset tracking with the initial offset for each patch determined from input offset map


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          OFF_par2  (input) ISP offset/interferogram parameter file of the offset map to determine initial offsets (enter - for none)
          offs2     (input) input range and azimuth offset map to determine initial offsets (enter - for none)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          deramp    deramp SLC phase flag (enter - for default)
                      0: no deramp (Doppler centroid close to 0) (default)
                      1: deramp SLC phase
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)

        NOTE: ScanSAR and TOPS data need to be previously deramped


        """

        if self.validate_inputs:
            self._validate_offset_pwr_tracking2(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                OFF_par2,
                offs2,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        if self.mock_outputs:
            self._mock_offset_pwr_tracking2_outputs(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                OFF_par2,
                offs2,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_pwr_tracking2))
        result = self._gamma_call("ISP", "offset_pwr_tracking2", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        if ccs is not None:
            assert ccs.exists(), f"{ccs} does not exist"
            assert ccs.stat().st_size > 0, f"{ccs} has zero file size"

        return result

    def _validate_offset_tracking(
        self,
        offs: Path,
        ccp: Path,
        SLC_par: Path,
        OFF_par: Path,
        disp_map: Path,
        disp_val: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[float] = None,
        poly_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_tracking.

        """

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not disp_map.exists(), f"{disp_map} should _not_ exist!"

        if disp_val is not None:
            assert not disp_val.exists(), f"{disp_val} should _not_ exist!"

    def _mock_offset_tracking_outputs(
        self,
        offs: Path,
        ccp: Path,
        SLC_par: Path,
        OFF_par: Path,
        disp_map: Path,
        disp_val: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[float] = None,
        poly_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_tracking.

        """

        if disp_map is not None and str(disp_map) != "-":
            disp_map.touch()

        if disp_val is not None and str(disp_val) != "-":
            disp_val.touch()

    def offset_tracking(
        self,
        offs: Path,
        ccp: Path,
        SLC_par: Path,
        OFF_par: Path,
        disp_map: Path,
        disp_val: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[float] = None,
        poly_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Conversion of range and azimuth offsets files to displacement map


        input parameters:
          offs       (input) range and azimuth offset estimates (fcomplex)
          ccp        (input) cross-correlation of the offset estimates (float)
          SLC_par    (input) SLC parameter file of reference SLC
          OFF_par    (input) offset parameter file used in the offset tracking
          disp_map   (output) range and azimuth displacement estimates (fcomplex)
          disp_val   (output) range and azimuth displacement estimates and cross-correlation values (enter - for none) (text)
          mode       flag indicating displacement mode:
                       0: displacement in range and azimuth pixels
                       1: displacement in meters in slant range and azimuth directions
                       2: displacement in meters in ground range and azimuth directions (default)
          thres      cross-correlation threshold to accept offset value (default from OFF_par)
          poly_flag  flag indicating if trend calculated using offset polynomials from OFF_par is subtracted:
                       0: do not subtract polynomial trend from offset data
                       1: subtract polynomial trend from offset data (default)


        """

        if self.validate_inputs:
            self._validate_offset_tracking(
                offs, ccp, SLC_par, OFF_par, disp_map, disp_val, mode, thres, poly_flag
            )

        if self.mock_outputs:
            self._mock_offset_tracking_outputs(
                offs, ccp, SLC_par, OFF_par, disp_map, disp_val, mode, thres, poly_flag
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_tracking))
        result = self._gamma_call("ISP", "offset_tracking", ca)

        assert disp_map.exists(), f"{disp_map} does not exist"
        assert disp_map.stat().st_size > 0, f"{disp_map} has zero file size"

        if disp_val is not None:
            assert disp_val.exists(), f"{disp_val} does not exist"
            assert disp_val.stat().st_size > 0, f"{disp_val} has zero file size"

        return result

    def _validate_SLC_interp_ScanSAR(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        OFF_par: Path,
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_interp_ScanSAR.

        """

        assert SLC2_tab.exists(), f"{SLC2_tab} does not exist"
        assert SLC2_tab.stat().st_size > 0, f"{SLC2_tab} has zero file size"

        self._check_tab_file(SLC2_tab, "SLC2_tab")

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert SLC1_tab.exists(), f"{SLC1_tab} does not exist"
        assert SLC1_tab.stat().st_size > 0, f"{SLC1_tab} has zero file size"

        self._check_tab_file(SLC1_tab, "SLC1_tab")

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        if SLC_2R is not None:
            assert not SLC_2R.exists(), f"{SLC_2R} should _not_ exist!"

        if SLC2R_par is not None:
            assert not SLC2R_par.exists(), f"{SLC2R_par} should _not_ exist!"

    def _mock_SLC_interp_ScanSAR_outputs(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        OFF_par: Path,
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_interp_ScanSAR.

        """

        if not SLC2R_tab.exists():
            SLC2R_tab.touch()

        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()

        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp_ScanSAR(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        OFF_par: Path,
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Resample ScanSAR burst mode SLC using global offset polynomial


        input parameters:
          SLC2_tab    (input) 3 column list of ScanSAR SLC-2 swaths to be resampled into the geometry of SLC-1 listed in order from near to far range
                        SLC2_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_par    (input) SLC parameter file of ScanSAR SLC-2 mosaic, SLC-2 is generated from the ScanSAR swaths listed in SLC2_tab
          SLC1_tab    (input) 3 column list of the reference ScanSAR SLC swaths listed in order from near to far range
          SLC1_par    (input) SLC parameter file of the reference ScanSAR SLC-1 mosaic, SLC-1 is generated from the ScanSAR swaths listed in SLC1_tab
          OFF_par     (input) global ISP offset and interferogram parameter file, the offset model is determined from the ScanSAR SLC mosaics
                      NOTE: The OFF_par specifies the number of range and azimuth looks required to determine valid data bounds (burst windows)
          SLC2R_tab   (input/output) 3 column list of the resampled ScanSAR SLC2 swaths listed in order from near to far range
                      NOTE: If the SLC2R_tab does not yet exist, the entires will be created with file names derived from the filenames in SLC2_tab and the SLC2R_dir
                            The file extensions of the new entries are changed from slc to rslc
          SLC-2R      (output) mosaic generated from the resampled swaths listed in SLC2R_tab, coregistered to the reference mosaic of SLC-1 (enter - for none)
          SLC2R_par   (output) SLC parameter file associated with the mosaic created from the resampled swaths SLC-2R (enter - for none)
          mode        complex data interpolation mode (enter - for default)
                        0: Lanczos (default)
                        1: B-spline
          order       Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)
          SLC2R_dir   directory for resampled burst SLC2R data, ignored if the DIFF_tab already exists (enter - for default: current directory)


        """

        if self.validate_inputs:
            self._validate_SLC_interp_ScanSAR(
                SLC2_tab,
                SLC2_par,
                SLC1_tab,
                SLC1_par,
                OFF_par,
                SLC2R_tab,
                SLC_2R,
                SLC2R_par,
                mode,
                order,
                SLC2R_dir,
            )

        if self.mock_outputs:
            self._mock_SLC_interp_ScanSAR_outputs(
                SLC2_tab,
                SLC2_par,
                SLC1_tab,
                SLC1_par,
                OFF_par,
                SLC2R_tab,
                SLC_2R,
                SLC2R_par,
                mode,
                order,
                SLC2R_dir,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_interp_ScanSAR))
        result = self._gamma_call("ISP", "SLC_interp_ScanSAR", ca)

        assert SLC2R_tab.exists(), f"{SLC2R_tab} does not exist"
        assert SLC2R_tab.stat().st_size > 0, f"{SLC2R_tab} has zero file size"

        if SLC_2R is not None:
            assert SLC_2R.exists(), f"{SLC_2R} does not exist"
            assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        if SLC2R_par is not None:
            assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
            assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        return result

    def _validate_error_stat(
        self,
        d1: Path,
        d2: Path,
        width: int,
        dtype: int,
        roff: Optional[int],
        loff: Optional[int],
        nr: int,
        nl: Optional[int],
        report: int,
    ) -> None:
        """

        Validate the arguments to error_stat.

        """

        assert d1.exists(), f"{d1} does not exist"
        assert d1.stat().st_size > 0, f"{d1} has zero file size"

        assert d2.exists(), f"{d2} does not exist"
        assert d2.stat().st_size > 0, f"{d2} has zero file size"

    def _mock_error_stat_outputs(
        self,
        d1: Path,
        d2: Path,
        width: int,
        dtype: int,
        roff: Optional[int],
        loff: Optional[int],
        nr: int,
        nl: Optional[int],
        report: int,
    ) -> None:
        """

        Mock the program error_stat.

        """
        pass

    def error_stat(
        self,
        d1: Path,
        d2: Path,
        width: int,
        dtype: int,
        roff: Optional[int],
        loff: Optional[int],
        nr: int,
        nl: Optional[int],
        report: int,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate statistics for two data files and their difference (FLOAT or FCOMPLEX)


        input parameters:
          d1      (input) data file 1
          d2      (input) data file 2
          width   image line width (samples/line)
          dtype   data type for d1 and d2:
                    0: FLOAT
                    1: FCOMPLEX
          roff    sample offset to region start (enter - for default: 0)
          loff    line offset to region start (enter - for default: 0)
          nr      region width (samples, enter - for default: width - roff)
          nl      number of lines in the region (enter - for default: data_lines - loff)
          report  output text file (keyword:value format)
                  keywords: data_1, data_2, d1_mean, d2_mean, d1_stddev, d2_stddev, root_mean_square_error, normalized_mean_square_error,
                   cross_correlation_coefficient, cross_correlation_angle, total_samples, non_zero_samples, valid_fraction


        """

        if self.validate_inputs:
            self._validate_error_stat(d1, d2, width, dtype, roff, loff, nr, nl, report)

        if self.mock_outputs:
            self._mock_error_stat_outputs(
                d1, d2, width, dtype, roff, loff, nr, nl, report
            )

        ca = self._clean_args(locals(), inspect.signature(self.error_stat))
        result = self._gamma_call("ISP", "error_stat", ca)
        return result

    def _validate_par_SICD_SLC(
        self,
        NITF: Path,
        radcal: Optional[int],
        noise: Optional[int],
        SLC_par: Path,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_SICD_SLC.

        """

        assert NITF.exists(), f"{NITF} does not exist"
        assert NITF.stat().st_size > 0, f"{NITF} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_SICD_SLC_outputs(
        self,
        NITF: Path,
        radcal: Optional[int],
        noise: Optional[int],
        SLC_par: Path,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_SICD_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_SICD_SLC(
        self,
        NITF: Path,
        radcal: Optional[int],
        noise: Optional[int],
        SLC_par: Path,
        SLC: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for SICD SLC data


        input parameters:
          NITF      (input) Sensor Independent Complex Data (SICD) file in NITF 2.1 container file (e.g.: CAPELLA_C03_SM_SICD_HH_20210512034455_20210512034459.ntf)
          radcal    radiometric calibration flag (enter - for default)
                      0: none
                      1: beta0 (default)
                      2: sigma0
                      3: gamma0
          noise     noise levels flag (enter - for default)
                      0: do not use noise levels (default)
                      1: use noise levels
          SLC_par   (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC       (output) SLC data file (enter - for none, example: yyyymmdd.slc)


        """

        if self.validate_inputs:
            self._validate_par_SICD_SLC(NITF, radcal, noise, SLC_par, SLC)

        if self.mock_outputs:
            self._mock_par_SICD_SLC_outputs(NITF, radcal, noise, SLC_par, SLC)

        ca = self._clean_args(locals(), inspect.signature(self.par_SICD_SLC))
        result = self._gamma_call("ISP", "par_SICD_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_res_map(
        self,
        hgt: Path,
        gr: Path,
        data: Path,
        SLC_par: Path,
        OFF_par: Path,
        res_hgt: Path,
        res_data: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        azps_res: Optional[Path] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to res_map.

        """

        assert hgt.exists(), f"{hgt} does not exist"
        assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        assert gr.exists(), f"{gr} does not exist"
        assert gr.stat().st_size > 0, f"{gr} has zero file size"

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not res_hgt.exists(), f"{res_hgt} should _not_ exist!"

        assert not res_data.exists(), f"{res_data} should _not_ exist!"

    def _mock_res_map_outputs(
        self,
        hgt: Path,
        gr: Path,
        data: Path,
        SLC_par: Path,
        OFF_par: Path,
        res_hgt: Path,
        res_data: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        azps_res: Optional[Path] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program res_map.

        """

        if res_hgt is not None and str(res_hgt) != "-":
            res_hgt.touch()

        if res_data is not None and str(res_data) != "-":
            res_data.touch()

    def res_map(
        self,
        hgt: Path,
        gr: Path,
        data: Path,
        SLC_par: Path,
        OFF_par: Path,
        res_hgt: Path,
        res_data: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        azps_res: Optional[Path] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Slant range to ground range transformation based on interferometric ground-range


        input parameters:
          hgt        (input) height file in slant range geometry
          gr         (input) ground range file in slant range geometry
          data       (input) data file in slant range geometry (float) (intensity *.pwr or correlation *.cc)
          SLC_par    (input) ISP parameter file of reference SLC
          OFF_par    (input) offset/interferogram processing parameters
          res_hgt    (output) resampled height file in ground range geometry
          res_data   (output) resampled data file in ground range geometry
          nr         number of range samples for L.S. estimate (default=7, must be odd)
          naz        number of azimuth samples for L.S. extimate (default=7, must be odd)
          azps_res   azimuth output map sample spacing in meters (default=azimuth spacing)
          loff       offset to starting line for height calculations (default=0)
          nlines     number of lines to calculate (default=to end of file)


        """

        if self.validate_inputs:
            self._validate_res_map(
                hgt,
                gr,
                data,
                SLC_par,
                OFF_par,
                res_hgt,
                res_data,
                nr,
                naz,
                azps_res,
                loff,
                nlines,
            )

        if self.mock_outputs:
            self._mock_res_map_outputs(
                hgt,
                gr,
                data,
                SLC_par,
                OFF_par,
                res_hgt,
                res_data,
                nr,
                naz,
                azps_res,
                loff,
                nlines,
            )

        ca = self._clean_args(locals(), inspect.signature(self.res_map))
        result = self._gamma_call("ISP", "res_map", ca)

        assert res_hgt.exists(), f"{res_hgt} does not exist"
        assert res_hgt.stat().st_size > 0, f"{res_hgt} has zero file size"

        assert res_data.exists(), f"{res_data} does not exist"
        assert res_data.stat().st_size > 0, f"{res_data} has zero file size"

        return result

    def _validate_RSAT2_vec(
        self, SLC_par: Path, RSAT2_orb: int, nstate: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to RSAT2_vec.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

    def _mock_RSAT2_vec_outputs(
        self, SLC_par: Path, RSAT2_orb: int, nstate: Optional[int] = None
    ) -> None:
        """

        Mock the program RSAT2_vec.

        """
        pass

    def RSAT2_vec(
        self, SLC_par: Path, RSAT2_orb: int, nstate: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract Radarsat-2 state vectors from a definitive orbit file


        input parameters:
          SLC_par    (input) ISP image parameter file
          RSAT2_orb  Radarsat-2 definitive orbit data file available from MDA (orbit_number_def.orb)
          nstate     number of state vectors to extract (enter - for default: 9)


        """

        if self.validate_inputs:
            self._validate_RSAT2_vec(SLC_par, RSAT2_orb, nstate)

        if self.mock_outputs:
            self._mock_RSAT2_vec_outputs(SLC_par, RSAT2_orb, nstate)

        ca = self._clean_args(locals(), inspect.signature(self.RSAT2_vec))
        result = self._gamma_call("ISP", "RSAT2_vec", ca)
        return result

    def _validate_par_S1_GRD(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        calibration_XML: Optional[Path],
        noise_XML: Optional[Path],
        MLI_par: Path,
        MLI: Path,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        eflg: Optional[int] = None,
        rps: Optional[int] = None,
        noise_pwr: Optional[int] = None,
        edge_flag: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_S1_GRD.

        """

        if GeoTIFF is not None:
            assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
            assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert annotation_XML.exists(), f"{annotation_XML} does not exist"
        assert annotation_XML.stat().st_size > 0, f"{annotation_XML} has zero file size"

        if calibration_XML is not None:
            assert calibration_XML.exists(), f"{calibration_XML} does not exist"
            assert (
                calibration_XML.stat().st_size > 0
            ), f"{calibration_XML} has zero file size"

        if noise_XML is not None:
            assert noise_XML.exists(), f"{noise_XML} does not exist"
            assert noise_XML.stat().st_size > 0, f"{noise_XML} has zero file size"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        assert not MLI.exists(), f"{MLI} should _not_ exist!"

        if GRD_par is not None:
            assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_S1_GRD_outputs(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        calibration_XML: Optional[Path],
        noise_XML: Optional[Path],
        MLI_par: Path,
        MLI: Path,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        eflg: Optional[int] = None,
        rps: Optional[int] = None,
        noise_pwr: Optional[int] = None,
        edge_flag: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_S1_GRD.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_S1_GRD(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        calibration_XML: Optional[Path],
        noise_XML: Optional[Path],
        MLI_par: Path,
        MLI: Path,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        eflg: Optional[int] = None,
        rps: Optional[int] = None,
        noise_pwr: Optional[int] = None,
        edge_flag: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate MLI and GRD images and parameter files from a Sentinel-1 GRD product


        input parameters:
          GeoTIFF         (input) image data file in GeoTIFF format (enter - for none, *.tiff)
          annotation_XML  (input) Sentinel-1 L1 XML annotation file
          calibration_XML (input) Sentinel-1 L1 radiometric calibration XML file (enter - for no radiometric calibration)
          noise_XML       (input) Sentinel-1 L1 noise XML file (enter - to not subtract thermal noise power level)
          MLI_par         (output) MLI parameter file (example: yyyymmdd_pp.mli.par)
          MLI             (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par         (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD             (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          eflg            GR-SR grid extrapolation flag (enter - for default)
                            0: no extrapolation of the GR-SR grid beyond the grid boundaries
                            1: permit extrapolation of the GR-SR grid to cover the entire image (default)
                          NOTE: extrapolation of the GR-SR grid may introduce geocoding errors
          rps             slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)
          noise_pwr       noise intensity for each MLI sample in slant range using data from noise_XML
                          NOTE: when the noise_pwr file is specified, noise power correction will NOT be applied to the MLI data values
          edge_flag       edge cleaning flag (enter - for default)
                            0: do not clean edges (default for Sentinel-1 IPF version >= 2.90)
                            1: basic method
                            2: elaborate method based on Canny edge detection (default for Sentinel-1 IPF version < 2.90)
                            3: force basic method when Sentinel-1 IPF version >= 2.90
                            4: force elaborate method based on Canny edge detection when Sentinel-1 IPF version >= 2.90
                          NOTE: options 1 and 2 are changed to 0 when Sentinel-1 IPF version >= 2.90
          loff            offset to starting line of the input segment (default: 0)
          nl              number of lines to read from the file beginning at loff (default: to end of file)


        """

        if self.validate_inputs:
            self._validate_par_S1_GRD(
                GeoTIFF,
                annotation_XML,
                calibration_XML,
                noise_XML,
                MLI_par,
                MLI,
                GRD_par,
                GRD,
                eflg,
                rps,
                noise_pwr,
                edge_flag,
                loff,
                nl,
            )

        if self.mock_outputs:
            self._mock_par_S1_GRD_outputs(
                GeoTIFF,
                annotation_XML,
                calibration_XML,
                noise_XML,
                MLI_par,
                MLI,
                GRD_par,
                GRD,
                eflg,
                rps,
                noise_pwr,
                edge_flag,
                loff,
                nl,
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_S1_GRD))
        result = self._gamma_call("ISP", "par_S1_GRD", ca)

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        if GRD_par is not None:
            assert GRD_par.exists(), f"{GRD_par} does not exist"
            assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_offset_plot_az(
        self,
    ) -> None:
        """

        Validate the arguments to offset_plot_az.

        """

        pass

    def _mock_offset_plot_az_outputs(
        self,
    ) -> None:
        """

        Mock the program offset_plot_az.

        """
        pass

    def offset_plot_az(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        IPTA script: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/offset_plot_az
        extract range and azimuth offsets for a range window from an text offset file


            offset   (input) list of range and azimuth offsets generated by offset_pwr (text)
            rmin     minimum range pixel number to extract range and azimuth offsets
            rmax     minimum range pixel number to extract range and azimuth offsets
            r_plot   range offsets xmgrace plot file
            az_plot  azimuth offsets xmgrace plot file


        """

        if self.validate_inputs:
            self._validate_offset_plot_az()

        if self.mock_outputs:
            self._mock_offset_plot_az_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.offset_plot_az))
        result = self._gamma_call("ISP", "offset_plot_az", ca)
        return result

    def _validate_SLC_deramp_S1_TOPS(
        self,
    ) -> None:
        """

        Validate the arguments to SLC_deramp_S1_TOPS.

        """

        pass

    def _mock_SLC_deramp_S1_TOPS_outputs(
        self,
    ) -> None:
        """

        Mock the program SLC_deramp_S1_TOPS.

        """
        pass

    def SLC_deramp_S1_TOPS(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ******************************************************************************************
        NOTE: SLC_deramp_S1_TOPS has been replaced by SLC_deramp_ScanSAR. The command line
        options are unchanged, please consider renaming the program in your scripts.
        ******************************************************************************************
        cmd: SLC_deramp_ScanSAR

        SLC_deramp_ScanSAR: Command not found.

        """

        if self.validate_inputs:
            self._validate_SLC_deramp_S1_TOPS()

        if self.mock_outputs:
            self._mock_SLC_deramp_S1_TOPS_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SLC_deramp_S1_TOPS))
        result = self._gamma_call("ISP", "SLC_deramp_S1_TOPS", ca)
        return result

    def _validate_multi_S1_TOPS(
        self,
    ) -> None:
        """

        Validate the arguments to multi_S1_TOPS.

        """

        pass

    def _mock_multi_S1_TOPS_outputs(
        self,
    ) -> None:
        """

        Mock the program multi_S1_TOPS.

        """
        pass

    def multi_S1_TOPS(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ************************************************************************************
        NOTE: multi_S1_TOPS has been replaced by multi_look_ScanSAR. The command line
        options are unchanged, please consider renaming the program in your scripts.
        ************************************************************************************
        multi_look_ScanSAR
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/multi_S1_TOPS: line 7: multi_look_ScanSAR: command not found

        """

        if self.validate_inputs:
            self._validate_multi_S1_TOPS()

        if self.mock_outputs:
            self._mock_multi_S1_TOPS_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.multi_S1_TOPS))
        result = self._gamma_call("ISP", "multi_S1_TOPS", ca)
        return result

    def _validate_adf2(
        self,
        interf: Path,
        cc_interf: Path,
        sm: float,
        cc_filt: Path,
        width: int,
        alpha_max: Optional[int] = None,
        nfft: Optional[int] = None,
        cc_win: Optional[int] = None,
        step: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to adf2.

        """

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        assert cc_interf.exists(), f"{cc_interf} does not exist"
        assert cc_interf.stat().st_size > 0, f"{cc_interf} has zero file size"

        assert not cc_filt.exists(), f"{cc_filt} should _not_ exist!"

    def _mock_adf2_outputs(
        self,
        interf: Path,
        cc_interf: Path,
        sm: float,
        cc_filt: Path,
        width: int,
        alpha_max: Optional[int] = None,
        nfft: Optional[int] = None,
        cc_win: Optional[int] = None,
        step: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[int] = None,
    ) -> None:
        """

        Mock the program adf2.

        """

        if cc_filt is not None and str(cc_filt) != "-":
            cc_filt.touch()

    def adf2(
        self,
        interf: Path,
        cc_interf: Path,
        sm: float,
        cc_filt: Path,
        width: int,
        alpha_max: Optional[int] = None,
        nfft: Optional[int] = None,
        cc_win: Optional[int] = None,
        step: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Adaptive interferogram filter based on the power spectral density and correlation coefficient


        input parameters:
          interf      (input) complex interferogram (fcomplex)
          cc_interf   (input) correlation coefficient of the input interferogram (float)
          sm          (output) filtered interferogram (fcomplex)
          cc_filt     (output) filtered interferogram correlation coefficient (float)
          width       number of samples/line
          alpha_max   maximum value for the adaptive filter exponent (enter - for default: 0.50)
          nfft        filter window FFT size, 2**N, 8->512, (enter - for default: 32)
          cc_win      filtered interferogram correlation estimation window size odd, max: 21 (enter - for default: 9)
          step        processing step in range and azimuth (enter - for default: nfft/8)
          loff        offset to starting line to process (enter - for default: 0)
          nlines      number of lines to process (enter - for default: to end of file)
          wfrac       minimum fraction of points required to be non-zero in the filter window (enter - for default: 0.200)


        """

        if self.validate_inputs:
            self._validate_adf2(
                interf,
                cc_interf,
                sm,
                cc_filt,
                width,
                alpha_max,
                nfft,
                cc_win,
                step,
                loff,
                nlines,
                wfrac,
            )

        if self.mock_outputs:
            self._mock_adf2_outputs(
                interf,
                cc_interf,
                sm,
                cc_filt,
                width,
                alpha_max,
                nfft,
                cc_win,
                step,
                loff,
                nlines,
                wfrac,
            )

        ca = self._clean_args(locals(), inspect.signature(self.adf2))
        result = self._gamma_call("ISP", "adf2", ca)

        assert cc_filt.exists(), f"{cc_filt} does not exist"
        assert cc_filt.stat().st_size > 0, f"{cc_filt} has zero file size"

        return result

    def _validate_par_RSAT_SGF(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
        sc_dB: Optional[int] = None,
        dt: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_RSAT_SGF.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_RSAT_SGF_outputs(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
        sc_dB: Optional[int] = None,
        dt: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_RSAT_SGF.

        """

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_RSAT_SGF(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
        sc_dB: Optional[int] = None,
        dt: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file for RSI/Atlantis Radarsat SGF (ground range) and SCANSAR SCW16 data


        input parameters:
          CEOS_leader (input) CEOS leader file (RSI SGF or SCW16 products, LEA_01.001)
          CEOS_data   (input) CEOS data file (RSI SGF or SCW16 products, DAT_01.001)
          GRD_par     (output) ISP ground range image parameter file (example <orbit>.mli.par)
          GRD         (output) ISP ground range image (example <orbit>.grd.par) (enter -  for none, float)
          sc_dB       intensity scale factor in dB (enter - for default:   0.00)
          dt          azimuth image time offset (s) (enter - for default = 0.0)


        """

        if self.validate_inputs:
            self._validate_par_RSAT_SGF(CEOS_leader, CEOS_data, GRD_par, GRD, sc_dB, dt)

        if self.mock_outputs:
            self._mock_par_RSAT_SGF_outputs(
                CEOS_leader, CEOS_data, GRD_par, GRD, sc_dB, dt
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RSAT_SGF))
        result = self._gamma_call("ISP", "par_RSAT_SGF", ca)

        assert GRD_par.exists(), f"{GRD_par} does not exist"
        assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_par_ICEYE_GRD(
        self,
        GeoTIFF: Optional[Path],
        MLI_par: Path,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_ICEYE_GRD.

        """

        if GeoTIFF is not None:
            assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
            assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        if GRD_par is not None:
            assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_ICEYE_GRD_outputs(
        self,
        GeoTIFF: Optional[Path],
        MLI_par: Path,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_ICEYE_GRD.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_ICEYE_GRD(
        self,
        GeoTIFF: Optional[Path],
        MLI_par: Path,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate MLI and GRD image and parameter files for ICEYE GRD data


        input parameters:
          GeoTIFF   (input) ICEYE GRD data file in GeoTIFF format (enter - for none, *.tif)
          XML       (input) ICEYE XML annotation file
          MLI_par   (output) MLI parameter file (example: yyyymmdd.mli.par)
          MLI       (output) MLI data file in slant range geometry (example: yyyymmdd.mli, enter - for none)
          GRD_par   (output) GRD parameter file (example: yyyymmdd.grd.par, enter - for none)
          GRD       (output) GRD data file (example: yyyymmdd.grd, enter - for none)
          rps       slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)


        """

        if self.validate_inputs:
            self._validate_par_ICEYE_GRD(GeoTIFF, MLI_par, GRD_par, GRD, rps)

        if self.mock_outputs:
            self._mock_par_ICEYE_GRD_outputs(GeoTIFF, MLI_par, GRD_par, GRD, rps)

        ca = self._clean_args(locals(), inspect.signature(self.par_ICEYE_GRD))
        result = self._gamma_call("ISP", "par_ICEYE_GRD", ca)

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if GRD_par is not None:
            assert GRD_par.exists(), f"{GRD_par} does not exist"
            assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_par_CS_SLC_TIF(self, GeoTIFF: Path, XML: Path, trunk: Path) -> None:
        """

        Validate the arguments to par_CS_SLC_TIF.

        """

        assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
        assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert XML.exists(), f"{XML} does not exist"
        assert XML.stat().st_size > 0, f"{XML} has zero file size"

        assert not trunk.exists(), f"{trunk} should _not_ exist!"

    def _mock_par_CS_SLC_TIF_outputs(self, GeoTIFF: Path, XML: Path, trunk: Path) -> None:
        """

        Mock the program par_CS_SLC_TIF.

        """

        if trunk is not None and str(trunk) != "-":
            trunk.touch()

    def par_CS_SLC_TIF(
        self, GeoTIFF: Path, XML: Path, trunk: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate ISP SLC parameter and image files for Cosmo Skymed SCS data in GeoTIFF format


        input parameters:
          GeoTIFF  (input) SCS data file in GeoTIFF format
          XML      (input) SCS meta data file in XML format
          trunk    (output) output file name trunk used for output filenames
                   (example: yyyymmdd -> yyyymmdd_pol_beamid.slc yyyymmdd_pol_beamid.slc.par)


        """

        if self.validate_inputs:
            self._validate_par_CS_SLC_TIF(GeoTIFF, XML, trunk)

        if self.mock_outputs:
            self._mock_par_CS_SLC_TIF_outputs(GeoTIFF, XML, trunk)

        ca = self._clean_args(locals(), inspect.signature(self.par_CS_SLC_TIF))
        result = self._gamma_call("ISP", "par_CS_SLC_TIF", ca)

        assert trunk.exists(), f"{trunk} does not exist"
        assert trunk.stat().st_size > 0, f"{trunk} has zero file size"

        return result

    def _validate_unw_correction_filt(
        self,
    ) -> None:
        """

        Validate the arguments to unw_correction_filt.

        """

        pass

    def _mock_unw_correction_filt_outputs(
        self,
    ) -> None:
        """

        Mock the program unw_correction_filt.

        """
        pass

    def unw_correction_filt(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        unw_correction_filt: Phase unwrapping ambiguity error correction relative to spatially filtered phase

               unw_in            (input) unwrapped phase file to correct (float)
               unw_out           (output) corrected  unwrapped phase file (float)
               width             number of range samples per line
               fsize             maximum filter radius in pixels (default = 5)
               thresh1           upper threshold for negative phase differences (default = -3.0)
               thresh2           lower threshold for positive phase differences (default =  3.0)
               iterations        number of iterations to run (default =  1)
               cleaning          cleaning flag indicating if intermediary files are deleted (default = 1: yes,   0: no)

        The difference between the unfiltered and spatially filtered phase (using fspf) is used
        to determine an correct phase unwrapping ambiguity errors

        """

        if self.validate_inputs:
            self._validate_unw_correction_filt()

        if self.mock_outputs:
            self._mock_unw_correction_filt_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.unw_correction_filt))
        result = self._gamma_call("ISP", "unw_correction_filt", ca)
        return result

    def _validate_DORIS_vec(
        self, SLC_par: Path, DOR: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to DORIS_vec.

        """

        assert DOR.exists(), f"{DOR} does not exist"
        assert DOR.stat().st_size > 0, f"{DOR} has zero file size"

    def _mock_DORIS_vec_outputs(
        self, SLC_par: Path, DOR: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Mock the program DORIS_vec.

        """

        if not SLC_par.exists():
            SLC_par.touch()

    def DORIS_vec(
        self, SLC_par: Path, DOR: Path, nstate: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract ENVISAT DORIS state vectors and write to an ISP image parameter file


        input parameters:
          SLC_par  (input/output)ISP SLC/MLI image parameter file
          DOR      (input) ASAR DORIS data file (DOR_VOR_AXVF)
          nstate   number of state vectors to extract (enter - for default: 11)

        """

        if self.validate_inputs:
            self._validate_DORIS_vec(SLC_par, DOR, nstate)

        if self.mock_outputs:
            self._mock_DORIS_vec_outputs(SLC_par, DOR, nstate)

        ca = self._clean_args(locals(), inspect.signature(self.DORIS_vec))
        result = self._gamma_call("ISP", "DORIS_vec", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_SLC_interp_S1_TOPS(
        self,
    ) -> None:
        """

        Validate the arguments to SLC_interp_S1_TOPS.

        """

        pass

    def _mock_SLC_interp_S1_TOPS_outputs(
        self,
    ) -> None:
        """

        Mock the program SLC_interp_S1_TOPS.

        """
        pass

    def SLC_interp_S1_TOPS(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ******************************************************************************************
        NOTE: SLC_interp_S1_TOPS has been replaced by SLC_interp_ScanSAR. The command line
        options are unchanged, please consider renaming the program in your scripts.
        ******************************************************************************************
        SLC_interp_ScanSAR
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/SLC_interp_S1_TOPS: line 7: SLC_interp_ScanSAR: command not found

        """

        if self.validate_inputs:
            self._validate_SLC_interp_S1_TOPS()

        if self.mock_outputs:
            self._mock_SLC_interp_S1_TOPS_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SLC_interp_S1_TOPS))
        result = self._gamma_call("ISP", "SLC_interp_S1_TOPS", ca)
        return result

    def _validate_bpf(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        fc_x: int,
        bw_x: int,
        fc_y: int,
        bw_y: int,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        dtype: Optional[int] = None,
        zflag: Optional[int] = None,
        beta: Optional[int] = None,
        fir_len: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to bpf.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_bpf_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        fc_x: int,
        bw_x: int,
        fc_y: int,
        bw_y: int,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        dtype: Optional[int] = None,
        zflag: Optional[int] = None,
        beta: Optional[int] = None,
        fir_len: Optional[int] = None,
    ) -> None:
        """

        Mock the program bpf.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def bpf(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        fc_x: int,
        bw_x: int,
        fc_y: int,
        bw_y: int,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        dtype: Optional[int] = None,
        zflag: Optional[int] = None,
        beta: Optional[int] = None,
        fir_len: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Interferometric SAR Processor (ISP): Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/bpf.c
        Bandpass filter for 2-dimensional image data (FCOMPLEX, SCOMPLEX, and FLOAT)


        input parameters:
          data_in   (input) input image data  file
          data_out  (output) bandpass filtered image data
          width     number of samples/line
          fc_x      normalized x-coord. (across) filter center frequency (range: -0.5 --> 0.5)
          bw_x      normalized x-coord. bandwidth (range: 0 --> 1.0)
          fc_y      normalized y-coord. (down) filter center frequency (range: -0.5 --> 0.5)
          bw_y      normalized y-coord. bandwidth (range: 0 --> 1.0)
          roff      offset to starting range to filter (enter - for default: 0)
          azoff     offset to starting azimuth to filter (enter - for default: 0)
          nr        number of range pixels to filter  (enter - for default: width - roff)
          naz       number of azimuth lines to filter (enter - for default: nlines - azoff)
          dtype     data type (enter - for default):
                      0: FCOMPLEX (default)
                      1: SCOMPLEX
                      2: FLOAT
          zflag     zero data flag (enter - for default):
                      0: set output to 0.0 when the input data are 0.0 (no_data)(default)
                      1: 0.0 values are considered as valid data
          beta      Kaiser window beta parameter (enter - for default:    4.538)
          fir_len   finite impulse response filter length (default - : 64)


        """

        if self.validate_inputs:
            self._validate_bpf(
                data_in,
                data_out,
                width,
                fc_x,
                bw_x,
                fc_y,
                bw_y,
                roff,
                azoff,
                nr,
                naz,
                dtype,
                zflag,
                beta,
                fir_len,
            )

        if self.mock_outputs:
            self._mock_bpf_outputs(
                data_in,
                data_out,
                width,
                fc_x,
                bw_x,
                fc_y,
                bw_y,
                roff,
                azoff,
                nr,
                naz,
                dtype,
                zflag,
                beta,
                fir_len,
            )

        ca = self._clean_args(locals(), inspect.signature(self.bpf))
        result = self._gamma_call("ISP", "bpf", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_image_stat(
        self,
        image: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        report: Optional[int] = None,
        median_flg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to image_stat.

        """

        assert image.exists(), f"{image} does not exist"
        assert image.stat().st_size > 0, f"{image} has zero file size"

    def _mock_image_stat_outputs(
        self,
        image: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        report: Optional[int] = None,
        median_flg: Optional[int] = None,
    ) -> None:
        """

        Mock the program image_stat.

        """
        pass

    def image_stat(
        self,
        image: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        report: Optional[int] = None,
        median_flg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate mean, standard deviation, number of non-zero values, min, max and median for a rectangular image region (FLOAT format)


        input parameters:
          image         (input) image data file (FLOAT)
          width         image line width (samples/line)
          roff          sample offset to region start (enter - for default: 0)
          loff          line offset to region start (enter - for default: 0)
          nr            region width (samples, enter - for default: width - roff)
          nl            number of lines in the region (enter - for default: image_lines - loff)
          report        output text file (keyword:value format, enter - for none)
                        keywords: file, mean, stdev, total_samples, non_zero_samples, fraction_valid, min, max, median
          median_flg    median calculation flag (enter - for default)
                          0: do not calculate median
                          1: calculate median (default, memory use may be large)

          NOTE: only the non-zero samples are considered in the statistical values


        """

        if self.validate_inputs:
            self._validate_image_stat(
                image, width, roff, loff, nr, nl, report, median_flg
            )

        if self.mock_outputs:
            self._mock_image_stat_outputs(
                image, width, roff, loff, nr, nl, report, median_flg
            )

        ca = self._clean_args(locals(), inspect.signature(self.image_stat))
        result = self._gamma_call("ISP", "image_stat", ca)
        return result

    def _validate_clear_flag(
        self,
        flag: Path,
        width: int,
        flag_bits: int,
        xmin: int,
        xmax: int,
        ymin: int,
        ymax: int,
    ) -> None:
        """

        Validate the arguments to clear_flag.

        """

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

    def _mock_clear_flag_outputs(
        self,
        flag: Path,
        width: int,
        flag_bits: int,
        xmin: int,
        xmax: int,
        ymin: int,
        ymax: int,
    ) -> None:
        """

        Mock the program clear_flag.

        """
        pass

    def clear_flag(
        self,
        flag: Path,
        width: int,
        flag_bits: int,
        xmin: int,
        xmax: int,
        ymin: int,
        ymax: int,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Clear phase unwrapping flag bits


        input parameters:
          flag       (input)phase unwrapping flag filename
          width      number of samples/row
          flag_bits  byte with value of flag(s) to be cleared:

                Charges = 3	Guides = 4	Low SNR = 8	Visited = 16
                BRANCH PT. = 32	Cuts   = 64	Lawn    = 128

          xmin       starting range pixel offset (default = 0)
          xmax       last range pixel offset (default = width-1)
          ymin       starting azimuth row offset, relative to start (default = 0)
          ymax       last azimuth row offset, relative to start (default = nlines-1)


        """

        if self.validate_inputs:
            self._validate_clear_flag(flag, width, flag_bits, xmin, xmax, ymin, ymax)

        if self.mock_outputs:
            self._mock_clear_flag_outputs(flag, width, flag_bits, xmin, xmax, ymin, ymax)

        ca = self._clean_args(locals(), inspect.signature(self.clear_flag))
        result = self._gamma_call("ISP", "clear_flag", ca)
        return result

    def _validate_ScanSAR_burst_cc_wave(
        self,
    ) -> None:
        """

        Validate the arguments to ScanSAR_burst_cc_wave.

        """

        pass

    def _mock_ScanSAR_burst_cc_wave_outputs(
        self,
    ) -> None:
        """

        Mock the program ScanSAR_burst_cc_wave.

        """
        pass

    def ScanSAR_burst_cc_wave(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate interferometric coherence for ScanSAR burst data using cc_wave

          DIFF_tab    (input) 3 column list of the DIFF swaths listed in order from near to far range
                        DIFF_tab line entries:  DIFF  MLI_par  TOPS_par
          MLI1_tab    (input) 3 column list of the reference ScanSAR MLI swaths listed in order from near to far range (enter - for none)
                        MLI1_tab line entries:   MLI  MLI_par  TOPS_par
          MLI2R_tab   (input) 3 column list of ScanSAR MLI swaths listed in order from near to far range, coregistered with MLI1 (enter - for none)
                        MLI2R_tab line entries:  MLI  MLI_par  TOPS_par
          CC_tab      (input/output) 3 column list of the CC swaths listed in order from near to far range
                        CC_tab line entries:      CC  MLI_par  TOPS_par
                      NOTE: if CC_tab does not exist, it will be created in the current directory.
                            The binary file will be named from the differential interferogram name, with the addition of a ".cc" extension.
                            The MLI_par and TOPS_par files are copied from MLI1_tab if available, from DIFF_tab otherwise.
          log         (output) processing log file
          bx          estimation window size in columns (enter - for default: 5.0)
          by          estimation window size in lines (enter - for default: 5.0)
          wflg        estimation window (enter - for default):
                        0: rectangular (default)
                        1: triangular
                        2: Gaussian
                        3: normalized vector sum with rectangular window
                           NOTE: This estimator does not use the MLI data, even when specified

        """

        if self.validate_inputs:
            self._validate_ScanSAR_burst_cc_wave()

        if self.mock_outputs:
            self._mock_ScanSAR_burst_cc_wave_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_burst_cc_wave))
        result = self._gamma_call("ISP", "ScanSAR_burst_cc_wave", ca)
        return result

    def _validate_RSAT2_SLC_preproc(
        self,
    ) -> None:
        """

        Validate the arguments to RSAT2_SLC_preproc.

        """

        pass

    def _mock_RSAT2_SLC_preproc_outputs(
        self,
    ) -> None:
        """

        Mock the program RSAT2_SLC_preproc.

        """
        pass

    def RSAT2_SLC_preproc(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Preprocessing of a set of RSAT2 SLC images using par_RSAT2_SLC
        Preprocessing of Radarsat-2 SLC products

            SLC_list  (input) parameter file with 2 entries/line
                          1. directory (including path) containing RSAT2 SLC products (RS2...SLC)
                          2. unique scene identifier (date)
            pol       polarization to extract: HH, HV, VH, VV
            out_dir   directory for output SLC data files and SLC parameter files
            log       (output) processing log file

            -u        (option) update flag, only process SLCs that do not yet exist

        """

        if self.validate_inputs:
            self._validate_RSAT2_SLC_preproc()

        if self.mock_outputs:
            self._mock_RSAT2_SLC_preproc_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.RSAT2_SLC_preproc))
        result = self._gamma_call("ISP", "RSAT2_SLC_preproc", ca)
        return result

    def _validate_UNWRAP(
        self,
    ) -> None:
        """

        Validate the arguments to UNWRAP.

        """

        pass

    def _mock_UNWRAP_outputs(
        self,
    ) -> None:
        """

        Mock the program UNWRAP.

        """
        pass

    def UNWRAP(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        UNWRAP: unwrap phase with using parameters from the ISP interferogram parameter file

               interf           interferogram filename  (*.int, *.flt)
               cc               correlation filename (*.cc)
               pwr              intensity image (*.pwr, *.mli)
               unwrap           unwrap output file (*.unw)
               flag             unwapping flag file (*.flag)
               width            interferogram width
               lines            number of interferogram lines
               corr_thr         threshold for correlation in the unwrapping mask (default=.3)
               pwr_thr          intensity threshold for phase unwrapping neutrons, multiples of average (default = 6.)
               r_init           range seed location in the interferogram
               az_init          azimuth seed location in the interferogram
               r1               starting range sample offset to unwrap
               r2               ending range sample offset to unwrap
               l1               starting line offset to unwrap
               l2               ending line offset to unwrap\n

        """

        if self.validate_inputs:
            self._validate_UNWRAP()

        if self.mock_outputs:
            self._mock_UNWRAP_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.UNWRAP))
        result = self._gamma_call("ISP", "UNWRAP", ca)
        return result

    def _validate_par_NovaSAR_GRD(
        self,
        GeoTIFF: Optional[Path],
        XML: Path,
        polarization: int,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_NovaSAR_GRD.

        """

        if GeoTIFF is not None:
            assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
            assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert XML.exists(), f"{XML} does not exist"
        assert XML.stat().st_size > 0, f"{XML} has zero file size"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        if MLI is not None:
            assert not MLI.exists(), f"{MLI} should _not_ exist!"

        if GRD_par is not None:
            assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_NovaSAR_GRD_outputs(
        self,
        GeoTIFF: Optional[Path],
        XML: Path,
        polarization: int,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_NovaSAR_GRD.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_NovaSAR_GRD(
        self,
        GeoTIFF: Optional[Path],
        XML: Path,
        polarization: int,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate MLI and GRD image and parameter files for NovaSAR GRD and SCD data


        input parameters:
          GeoTIFF       (input) NovaSAR image data file in GeoTIFF format (enter - for none, *.tif)
          XML           (input) NovaSAR XML annotation file
          polarization  image polarization: HH, VV, HV, VH, CH, CV
          MLI_par       (output) MLI parameter file (example: yyyymmdd_pp.mli.par)
          MLI           (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par       (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD           (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          rps           slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)
          radcal        radiometric calibration flag (enter - for default)
                          0: beta0 (default)
                          1: sigma0
          noise         noise levels flag (enter - for default)
                          0: do not use noise levels (default)
                          1: use noise levels


        """

        if self.validate_inputs:
            self._validate_par_NovaSAR_GRD(
                GeoTIFF, XML, polarization, MLI_par, MLI, GRD_par, GRD, rps, radcal, noise
            )

        if self.mock_outputs:
            self._mock_par_NovaSAR_GRD_outputs(
                GeoTIFF, XML, polarization, MLI_par, MLI, GRD_par, GRD, rps, radcal, noise
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_NovaSAR_GRD))
        result = self._gamma_call("ISP", "par_NovaSAR_GRD", ca)

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if MLI is not None:
            assert MLI.exists(), f"{MLI} does not exist"
            assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        if GRD_par is not None:
            assert GRD_par.exists(), f"{GRD_par} does not exist"
            assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_bpf_ssi(
        self,
    ) -> None:
        """

        Validate the arguments to bpf_ssi.

        """

        pass

    def _mock_bpf_ssi_outputs(
        self,
    ) -> None:
        """

        Mock the program bpf_ssi.

        """
        pass

    def bpf_ssi(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        bpf_ssi: Apply band-pass filtering for split-spectrum interferometry


               SLC                 (input) SLC (FCOMPLEX or SCOMPLEX, SLC should not be resampled)
               SLC_par             (input) SLC parameter file
               SLC_flow            (output) low frequency band filtered SLC (FCOMPLEX or SCOMPLEX)
               SLC_flow_par        (output) low frequency band filtered SLC parameter file
               SLC_fhigh           (output) high frequency band filtered SLC (FCOMPLEX or SCOMPLEX)
               SLC_fhigh_par       (output) high frequency band filtered SLC parameter file (FCOMPLEX or SCOMPLEX)
               rbs                 relative range spectrum band separation (default = 0.6666 --> lowest and highest third of processing bandwidth)

                                   indicate - for the output files to only calculate filtering parameters

        """

        if self.validate_inputs:
            self._validate_bpf_ssi()

        if self.mock_outputs:
            self._mock_bpf_ssi_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.bpf_ssi))
        result = self._gamma_call("ISP", "bpf_ssi", ca)
        return result

    def _validate_slant_range(self, SLC_par: Path, slr: Path) -> None:
        """

        Validate the arguments to slant_range.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not slr.exists(), f"{slr} should _not_ exist!"

    def _mock_slant_range_outputs(self, SLC_par: Path, slr: Path) -> None:
        """

        Mock the program slant_range.

        """

        if slr is not None and str(slr) != "-":
            slr.touch()

    def slant_range(self, SLC_par: Path, slr: Path) -> Tuple[int, List[str], List[str]]:
        """

        Calculate slant range for every range sample


        input parameters:
          SLC_par  (input) SLC or MLI image parameter file
          slr      (output) slant range for every sample in the image (float)


        """

        if self.validate_inputs:
            self._validate_slant_range(SLC_par, slr)

        if self.mock_outputs:
            self._mock_slant_range_outputs(SLC_par, slr)

        ca = self._clean_args(locals(), inspect.signature(self.slant_range))
        result = self._gamma_call("ISP", "slant_range", ca)

        assert slr.exists(), f"{slr} does not exist"
        assert slr.stat().st_size > 0, f"{slr} has zero file size"

        return result

    def _validate_par_IECAS_SLC(
        self,
        aux_data: Path,
        slc_Re: Path,
        slc_Im: Path,
        date: Path,
        SLC_par: Path,
        SLC: Path,
    ) -> None:
        """

        Validate the arguments to par_IECAS_SLC.

        """

        assert aux_data.exists(), f"{aux_data} does not exist"
        assert aux_data.stat().st_size > 0, f"{aux_data} has zero file size"

        assert slc_Re.exists(), f"{slc_Re} does not exist"
        assert slc_Re.stat().st_size > 0, f"{slc_Re} has zero file size"

        assert slc_Im.exists(), f"{slc_Im} does not exist"
        assert slc_Im.stat().st_size > 0, f"{slc_Im} has zero file size"

        assert date.exists(), f"{date} does not exist"
        assert date.stat().st_size > 0, f"{date} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_IECAS_SLC_outputs(
        self,
        aux_data: Path,
        slc_Re: Path,
        slc_Im: Path,
        date: Path,
        SLC_par: Path,
        SLC: Path,
    ) -> None:
        """

        Mock the program par_IECAS_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_IECAS_SLC(
        self,
        aux_data: Path,
        slc_Re: Path,
        slc_Im: Path,
        date: Path,
        SLC_par: Path,
        SLC: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for IECAS SLC data


        input parameters:
          aux_data   (input) IECAS SAR auxillary data (POS*.dat)
          slc_Re     (input) real part of complex SLC data
          slc_Im     (input) imaginary part of complex SLC data
          date       (input) acquistion date format: YYYYMMDD (example 20110121) from aux_data filename
          SLC_par    (output) ISP SLC parameter file
          SLC        (output) SLC image

        """

        if self.validate_inputs:
            self._validate_par_IECAS_SLC(aux_data, slc_Re, slc_Im, date, SLC_par, SLC)

        if self.mock_outputs:
            self._mock_par_IECAS_SLC_outputs(aux_data, slc_Re, slc_Im, date, SLC_par, SLC)

        ca = self._clean_args(locals(), inspect.signature(self.par_IECAS_SLC))
        result = self._gamma_call("ISP", "par_IECAS_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_corr_flag(
        self,
        corr: Path,
        flag: Path,
        width: int,
        corr_thr: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        border: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to corr_flag.

        """

        assert corr.exists(), f"{corr} does not exist"
        assert corr.stat().st_size > 0, f"{corr} has zero file size"

    def _mock_corr_flag_outputs(
        self,
        corr: Path,
        flag: Path,
        width: int,
        corr_thr: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        border: Optional[int] = None,
    ) -> None:
        """

        Mock the program corr_flag.

        """

        if not flag.exists():
            flag.touch()

    def corr_flag(
        self,
        corr: Path,
        flag: Path,
        width: int,
        corr_thr: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        border: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Low correlation region detection for phase unwrapping


        input parameters:
          corr      (input)interferometric correlation file
          flag      (input/output) phase unwrapping flag filename
          width     number of samples/row
          corr_thr  correlation threshold (0 --> 1.0)
          xmin      starting range pixel offset (default = 0)
          xmax      last range pixel offset (default = width-1)
          ymin      starting azimuth row offset, relative to start (default = 0)
          ymax      last azimuth row offset, relative to start (default = nlines-1)
          border    effective range of low coherence pixels to set low coherence flag (default=2)


        """

        if self.validate_inputs:
            self._validate_corr_flag(
                corr, flag, width, corr_thr, xmin, xmax, ymin, ymax, border
            )

        if self.mock_outputs:
            self._mock_corr_flag_outputs(
                corr, flag, width, corr_thr, xmin, xmax, ymin, ymax, border
            )

        ca = self._clean_args(locals(), inspect.signature(self.corr_flag))
        result = self._gamma_call("ISP", "corr_flag", ca)

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

        return result

    def _validate_ptarg_cal_MLI(
        self,
        MLI_par: Path,
        MLI: Path,
        r_samp: int,
        az_samp: int,
        psigma: int,
        c_r_samp: int,
        c_az_samp: int,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[int] = None,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
        psz: Optional[int] = None,
        csz: Optional[int] = None,
        theta_inc: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ptarg_cal_MLI.

        """

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        assert not ptr_image.exists(), f"{ptr_image} should _not_ exist!"

        assert not r_plot.exists(), f"{r_plot} should _not_ exist!"

        assert not az_plot.exists(), f"{az_plot} should _not_ exist!"

        assert not pcal.exists(), f"{pcal} should _not_ exist!"

    def _mock_ptarg_cal_MLI_outputs(
        self,
        MLI_par: Path,
        MLI: Path,
        r_samp: int,
        az_samp: int,
        psigma: int,
        c_r_samp: int,
        c_az_samp: int,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[int] = None,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
        psz: Optional[int] = None,
        csz: Optional[int] = None,
        theta_inc: Optional[int] = None,
    ) -> None:
        """

        Mock the program ptarg_cal_MLI.

        """

        if ptr_image is not None and str(ptr_image) != "-":
            ptr_image.touch()

        if r_plot is not None and str(r_plot) != "-":
            r_plot.touch()

        if az_plot is not None and str(az_plot) != "-":
            az_plot.touch()

        if pcal is not None and str(pcal) != "-":
            pcal.touch()

    def ptarg_cal_MLI(
        self,
        MLI_par: Path,
        MLI: Path,
        r_samp: int,
        az_samp: int,
        psigma: int,
        c_r_samp: int,
        c_az_samp: int,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[int] = None,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
        psz: Optional[int] = None,
        csz: Optional[int] = None,
        theta_inc: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Point target analysis and radiometric calibration of slant-range and ground-range (GRD) images


        input parameters:
          MLI_par    (input) slant-range or ground-range image parameter file for detected intensity data
          MLI        (input) ground-range or slant range detected image in FLOAT format
          r_samp     point target range sample number, target region size is 16x16
          az_samp    point target azimuth line number, target region size is 16x16
          psigma     radar cross-section of the calibration target in m**2
          c_r_samp   clutter region center range sample number, clutter region size is 16x16
          c_az_samp  clutter region center azimuth line number, clutter region size is 16x16
          ptr_image  (output) oversampled point target image, with and without phase gradient, nominal width: 256
          r_plot     (output) range point target response plot data (text format)
          az_plot    (output) azimuth point target response plot data (text format)
          pcal       (output) measured point target parameters and radiometric calibration factor (text format)
          osf        image over-sampling factor, 2, 4, 8, 16, 32, 64 (enter - for default: 16)
          win        maximum search window offset (samples) (enter - for default: 1)
          pltflg     plotting mode flag:
                       0: none
                       1: output plots in PNG format (default)
                       2: screen output
                       3: output plots in PDF format
          psz        point target region size (samples) (enter - for default: 16)
          csz        clutter region size (samples) (enter - for default: 16)
          theta_inc  incidence angle required for calibration of terrain corrrected RISAT-1 images

        """

        if self.validate_inputs:
            self._validate_ptarg_cal_MLI(
                MLI_par,
                MLI,
                r_samp,
                az_samp,
                psigma,
                c_r_samp,
                c_az_samp,
                ptr_image,
                r_plot,
                az_plot,
                pcal,
                osf,
                win,
                pltflg,
                psz,
                csz,
                theta_inc,
            )

        if self.mock_outputs:
            self._mock_ptarg_cal_MLI_outputs(
                MLI_par,
                MLI,
                r_samp,
                az_samp,
                psigma,
                c_r_samp,
                c_az_samp,
                ptr_image,
                r_plot,
                az_plot,
                pcal,
                osf,
                win,
                pltflg,
                psz,
                csz,
                theta_inc,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ptarg_cal_MLI))
        result = self._gamma_call("ISP", "ptarg_cal_MLI", ca)

        assert ptr_image.exists(), f"{ptr_image} does not exist"
        assert ptr_image.stat().st_size > 0, f"{ptr_image} has zero file size"

        assert r_plot.exists(), f"{r_plot} does not exist"
        assert r_plot.stat().st_size > 0, f"{r_plot} has zero file size"

        assert az_plot.exists(), f"{az_plot} does not exist"
        assert az_plot.stat().st_size > 0, f"{az_plot} has zero file size"

        assert pcal.exists(), f"{pcal} does not exist"
        assert pcal.stat().st_size > 0, f"{pcal} has zero file size"

        return result

    def _validate_S1_BURST_tab_from_zipfile(
        self,
    ) -> None:
        """

        Validate the arguments to S1_BURST_tab_from_zipfile.

        """

        pass

    def _mock_S1_BURST_tab_from_zipfile_outputs(
        self,
    ) -> None:
        """

        Mock the program S1_BURST_tab_from_zipfile.

        """
        pass

    def S1_BURST_tab_from_zipfile(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        S1_BURST_tab_from_zipfile: Script used to generate S1_BURST_tab to support burst selection

        ******************************************************************************
        NOTE: S1_BURST_tab_from_zipfile now calls S1_BURST_tab_from_zipfile.py
              Using directly S1_BURST_tab_from_zipfile.py gives access to
              additional useful options and is therefore recommended.
        ******************************************************************************

               zipfile_list           (input) ASCII file containing S1 zip filename(s) of one data take
                                      indicate - to generate burst_number_table of reference TOPS SLC
               zipfile_ref            (input) S1 zip filename for the reference TOPS SLC
               burst_number_table_ref (input) ASCII file containing first/last burst numbers selected
                                      indicate - to use all bursts as present in the reference TOPS SLC zipfile
               cleaning               flag to indicate if intermediate files are deleted (default=1: yes, 0: not deleted)

        intermediate and output filenames are generated based on the zip file names


        """

        if self.validate_inputs:
            self._validate_S1_BURST_tab_from_zipfile()

        if self.mock_outputs:
            self._mock_S1_BURST_tab_from_zipfile_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.S1_BURST_tab_from_zipfile))
        result = self._gamma_call("ISP", "S1_BURST_tab_from_zipfile", ca)
        return result

    def _validate_ORB_filt(
        self,
        SLC_par_in: Path,
        SLC_par_out: Path,
        interval: Optional[int] = None,
        extra: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ORB_filt.

        """

        assert SLC_par_in.exists(), f"{SLC_par_in} does not exist"
        assert SLC_par_in.stat().st_size > 0, f"{SLC_par_in} has zero file size"

        assert not SLC_par_out.exists(), f"{SLC_par_out} should _not_ exist!"

    def _mock_ORB_filt_outputs(
        self,
        SLC_par_in: Path,
        SLC_par_out: Path,
        interval: Optional[int] = None,
        extra: Optional[int] = None,
    ) -> None:
        """

        Mock the program ORB_filt.

        """

        if SLC_par_out is not None and str(SLC_par_out) != "-":
            SLC_par_out.touch()

    def ORB_filt(
        self,
        SLC_par_in: Path,
        SLC_par_out: Path,
        interval: Optional[int] = None,
        extra: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Filter state vectors using a least-squares polynomial model


        input parameters:
          SLC_par_in   (input) ISP image parameter file at least 5 state vectors
          SLC_par_out  (output) ISP image parameter file with state vectors filtered using least-squares
          interval     time interval between state vectors (enter - for default: state vector time interval in SLC_par)
          extra        extra time for state vectors at start and end of image (sec.) (enter - for default: 5.0)

        """

        if self.validate_inputs:
            self._validate_ORB_filt(SLC_par_in, SLC_par_out, interval, extra)

        if self.mock_outputs:
            self._mock_ORB_filt_outputs(SLC_par_in, SLC_par_out, interval, extra)

        ca = self._clean_args(locals(), inspect.signature(self.ORB_filt))
        result = self._gamma_call("ISP", "ORB_filt", ca)

        assert SLC_par_out.exists(), f"{SLC_par_out} does not exist"
        assert SLC_par_out.stat().st_size > 0, f"{SLC_par_out} has zero file size"

        return result

    def _validate_offset_sub(self, offs: Path, OFF_par: Path, offs_sub: Path) -> None:
        """

        Validate the arguments to offset_sub.

        """

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not offs_sub.exists(), f"{offs_sub} should _not_ exist!"

    def _mock_offset_sub_outputs(self, offs: Path, OFF_par: Path, offs_sub: Path) -> None:
        """

        Mock the program offset_sub.

        """

        if offs_sub is not None and str(offs_sub) != "-":
            offs_sub.touch()

    def offset_sub(
        self, offs: Path, OFF_par: Path, offs_sub: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Subtraction of polynomial from range and azimuth offset estimates


        input parameters:
          offs      (input) range and azimuth offset estimates (fcomplex)
          OFF_par   (input) ISP offset/interferogram parameter file
          offs_sub  (output) range and azimuth offset estimates after polynomial subtraction (fcomplex)

        """

        if self.validate_inputs:
            self._validate_offset_sub(offs, OFF_par, offs_sub)

        if self.mock_outputs:
            self._mock_offset_sub_outputs(offs, OFF_par, offs_sub)

        ca = self._clean_args(locals(), inspect.signature(self.offset_sub))
        result = self._gamma_call("ISP", "offset_sub", ca)

        assert offs_sub.exists(), f"{offs_sub} does not exist"
        assert offs_sub.stat().st_size > 0, f"{offs_sub} has zero file size"

        return result

    def _validate_gamma_doc(self, inputpar: int) -> None:
        """

        Validate the arguments to gamma_doc.

        """

        pass

    def _mock_gamma_doc_outputs(self, inputpar: int) -> None:
        """

        Mock the program gamma_doc.

        """
        pass

    def gamma_doc(self, inputpar: int) -> Tuple[int, List[str], List[str]]:
        """

        The file /Gamma_documentation.html does not exist.
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/gamma_doc
        Opens the HTML documentation for a given program, script, or package in the default web browser


        input parameters:
            inputpar can be:
                     1. A program name of an existing program of the GAMMA software,
                        e.g.: gamma_doc gc_map .
                        This command will open the HTML documentation gc_map.html in the default web browser.
                        Note, that not all programs possess their individual HTML documentation.
                        If in doubt use option 2 or 3 to get an overview of available programs and scripts.
                     2. The name of an GAMMA software module,
                        e.g.: gamma_doc DISP .
                        This will open the DISP_documentation.html file (top level documentation file
                        of the DISP module) in the default web browser.
                     3. If no input argument is given, this help message is displayed on the command line
                        and the top level html file of the GAMMA software html documentation is opened
                        in the default web browser.


        """

        if self.validate_inputs:
            self._validate_gamma_doc(inputpar)

        if self.mock_outputs:
            self._mock_gamma_doc_outputs(inputpar)

        ca = self._clean_args(locals(), inspect.signature(self.gamma_doc))
        result = self._gamma_call("ISP", "gamma_doc", ca)
        return result

    def _validate_radcal_MLI(
        self,
        MLI: Path,
        MLI_par: Path,
        OFF_par: Optional[Path],
        CMLI: Path,
        antenna: Optional[Path] = None,
        rloss_flag: Optional[int] = None,
        ant_flag: Optional[int] = None,
        refarea_flag: Optional[int] = None,
        sc_dB: Optional[int] = None,
        K_dB: Optional[int] = None,
        pix_area: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to radcal_MLI.

        """

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not CMLI.exists(), f"{CMLI} should _not_ exist!"

        if antenna is not None:
            assert antenna.exists(), f"{antenna} does not exist"
            assert antenna.stat().st_size > 0, f"{antenna} has zero file size"

        if pix_area is not None:
            assert not pix_area.exists(), f"{pix_area} should _not_ exist!"

    def _mock_radcal_MLI_outputs(
        self,
        MLI: Path,
        MLI_par: Path,
        OFF_par: Optional[Path],
        CMLI: Path,
        antenna: Optional[Path] = None,
        rloss_flag: Optional[int] = None,
        ant_flag: Optional[int] = None,
        refarea_flag: Optional[int] = None,
        sc_dB: Optional[int] = None,
        K_dB: Optional[int] = None,
        pix_area: Optional[Path] = None,
    ) -> None:
        """

        Mock the program radcal_MLI.

        """

        if CMLI is not None and str(CMLI) != "-":
            CMLI.touch()

        if pix_area is not None and str(pix_area) != "-":
            pix_area.touch()

    def radcal_MLI(
        self,
        MLI: Path,
        MLI_par: Path,
        OFF_par: Optional[Path],
        CMLI: Path,
        antenna: Optional[Path] = None,
        rloss_flag: Optional[int] = None,
        ant_flag: Optional[int] = None,
        refarea_flag: Optional[int] = None,
        sc_dB: Optional[int] = None,
        K_dB: Optional[int] = None,
        pix_area: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Radiometric calibration for multi-look intensity (MLI) data


        input parameters:
          MLI           (input) MLI image (float)
          MLI_PAR       (input) SLC parameter file of input MLI image
          OFF_par       (input) ISP offset/interferogram parameter file (enter - for images in MLI geometry)
          CMLI          (output) radiometrically calibrated output MLI (float)
          antenna       (input) 1-way antenna gain pattern file or - if not provided
          rloss_flag    range spreading loss correction:
                           0: no correction (default)
                           1: apply r^3 correction  (all modes except ASAR APS)
                           2: apply r^4 correction (used only for ASAR APS mode)
                          -1: undo r^3 correction
                          -2: undo r^4 correction)
          ant_flag      antenna pattern correction:
                           0: no correction (default)
                           1: apply antenna pattern correction
                          -1: undo antenna pattern correction)
          refarea_flag  reference pixel area correction:
                           0: no pixel area correction (default)
                           1: calculate sigma0, scale area by sin(inc_ang)/sin(ref_inc_ang)
                           2: calculate gamma0, scale area by sin(inc_ang)/(cos(inc_ang)*sin(ref_inc_ang)
                          -1: undo sigma0 area scaling factor
                          -2: undo gamma0 area scaling factor
          sc_dB         scale factor in dB (default: 0.0)
          K_dB          calibration factor in dB (default: -(value from MLI_PAR))
          pix_area      (output) ellipsoid-based ground range sigma0 or gamma0 pixel reference area (float)
                           refarea_flag 1 or -1: sigma0 ref. area
                           refarea_flag 2 or -2: gamma0 ref. area


        """

        if self.validate_inputs:
            self._validate_radcal_MLI(
                MLI,
                MLI_par,
                OFF_par,
                CMLI,
                antenna,
                rloss_flag,
                ant_flag,
                refarea_flag,
                sc_dB,
                K_dB,
                pix_area,
            )

        if self.mock_outputs:
            self._mock_radcal_MLI_outputs(
                MLI,
                MLI_par,
                OFF_par,
                CMLI,
                antenna,
                rloss_flag,
                ant_flag,
                refarea_flag,
                sc_dB,
                K_dB,
                pix_area,
            )

        ca = self._clean_args(locals(), inspect.signature(self.radcal_MLI))
        result = self._gamma_call("ISP", "radcal_MLI", ca)

        assert CMLI.exists(), f"{CMLI} does not exist"
        assert CMLI.stat().st_size > 0, f"{CMLI} has zero file size"

        if pix_area is not None:
            assert pix_area.exists(), f"{pix_area} does not exist"
            assert pix_area.stat().st_size > 0, f"{pix_area} has zero file size"

        return result

    def _validate_UNWRAP_PAR(
        self,
    ) -> None:
        """

        Validate the arguments to UNWRAP_PAR.

        """

        pass

    def _mock_UNWRAP_PAR_outputs(
        self,
    ) -> None:
        """

        Mock the program UNWRAP_PAR.

        """
        pass

    def UNWRAP_PAR(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        UNWRAP_PAR: unwrap phase with using parameters from the ISP interferogram parameter file

               interf_par       interferogram parameter file *.off
               interf           interferogram filename  (*.int, *.flt)
               cc               correlation filename (*.cc)
               pwr              intensity image (*.pwr, *.mli)
               unwrap           unwrap output file (*.unw)
               flag             unwapping flag file (*.flag)
               corr_thr         threshold for correlation in the unwrapping mask (default=.3)
               pwr_thr          intensity threshold for phase unwrapping neutrons, multiples of average (default = 6.)
               r_init           range seed location in the interferogram
               az_init          azimuth seed location in the interferogram
               r1               starting range sample offset to unwrap
               r2               ending range sample offset to unwrap
               l1               starting line offset to unwrap
               l2               ending line offset to unwrap\n

        """

        if self.validate_inputs:
            self._validate_UNWRAP_PAR()

        if self.mock_outputs:
            self._mock_UNWRAP_PAR_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.UNWRAP_PAR))
        result = self._gamma_call("ISP", "UNWRAP_PAR", ca)
        return result

    def _validate_S1_OPOD_vec(
        self, SLC_par: Path, OPOD: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to S1_OPOD_vec.

        """

        assert OPOD.exists(), f"{OPOD} does not exist"
        assert OPOD.stat().st_size > 0, f"{OPOD} has zero file size"

    def _mock_S1_OPOD_vec_outputs(
        self, SLC_par: Path, OPOD: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Mock the program S1_OPOD_vec.

        """

        if not SLC_par.exists():
            SLC_par.touch()

    def S1_OPOD_vec(
        self, SLC_par: Path, OPOD: Path, nstate: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract Sentinel-1 OPOD state vectors and copy into the ISP image parameter file


        input parameters:
          SLC_par  (input/output)ISP SLC/MLI image parameter file
          OPOD     (input) Sentinel-1 OPOD orbit data file (AUX_POEORB or AUX_RESORB)
                   https://qc.sentinel1.eo.esa.int/aux_resorb/
          nstate   number of state vectors to extract (default: include 60 sec extention at the start and end of the SLC data)

        """

        if self.validate_inputs:
            self._validate_S1_OPOD_vec(SLC_par, OPOD, nstate)

        if self.mock_outputs:
            self._mock_S1_OPOD_vec_outputs(SLC_par, OPOD, nstate)

        ca = self._clean_args(locals(), inspect.signature(self.S1_OPOD_vec))
        result = self._gamma_call("ISP", "S1_OPOD_vec", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_par_RCM_GRD(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_RCM_GRD.

        """

        assert RCM_dir.exists(), f"{RCM_dir} does not exist"
        assert RCM_dir.stat().st_size > 0, f"{RCM_dir} has zero file size"

        if MLI_par is not None:
            assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        if MLI is not None:
            assert not MLI.exists(), f"{MLI} should _not_ exist!"

        if GRD_par is not None:
            assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

        if noise_pwr is not None:
            assert not noise_pwr.exists(), f"{noise_pwr} should _not_ exist!"

    def _mock_par_RCM_GRD_outputs(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_RCM_GRD.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

        if noise_pwr is not None and str(noise_pwr) != "-":
            noise_pwr.touch()

    def par_RCM_GRD(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
        noise_pwr: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate MLI and GRD images and parameter files from a Radarsat Constellation GRD (Ground Range georeferenced Detected) product


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM1_OK1001327_PK1001418_1_3M28_20160417_013625_HH_GRD)
          polarization   image polarization: HH, VV, HV, VH, CH, CV
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise          noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          MLI_par        (output) MLI parameter file (example: yyyymmdd_pp.mli.par, enter - for none)
          MLI            (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par        (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD            (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          rps            slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)
          noise_pwr      (output) noise intensity for each MLI sample in slant range using data from noise levels file (enter - for none)
                         NOTE: when the noise_pwr file is specified, noise power correction will NOT be applied to the GRD / MLI data values


        """

        if self.validate_inputs:
            self._validate_par_RCM_GRD(
                RCM_dir,
                polarization,
                radcal,
                noise,
                MLI_par,
                MLI,
                GRD_par,
                GRD,
                rps,
                noise_pwr,
            )

        if self.mock_outputs:
            self._mock_par_RCM_GRD_outputs(
                RCM_dir,
                polarization,
                radcal,
                noise,
                MLI_par,
                MLI,
                GRD_par,
                GRD,
                rps,
                noise_pwr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RCM_GRD))
        result = self._gamma_call("ISP", "par_RCM_GRD", ca)

        if MLI_par is not None:
            assert MLI_par.exists(), f"{MLI_par} does not exist"
            assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if MLI is not None:
            assert MLI.exists(), f"{MLI} does not exist"
            assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        if GRD_par is not None:
            assert GRD_par.exists(), f"{GRD_par} does not exist"
            assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        if noise_pwr is not None:
            assert noise_pwr.exists(), f"{noise_pwr} does not exist"
            assert noise_pwr.stat().st_size > 0, f"{noise_pwr} has zero file size"

        return result

    def _validate_offset_pwr_tracking(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwr_tracking.

        """

        assert SLC1.exists(), f"{SLC1} does not exist"
        assert SLC1.stat().st_size > 0, f"{SLC1} has zero file size"

        assert SLC2.exists(), f"{SLC2} does not exist"
        assert SLC2.stat().st_size > 0, f"{SLC2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not ccp.exists(), f"{ccp} should _not_ exist!"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

        if ccs is not None:
            assert not ccs.exists(), f"{ccs} should _not_ exist!"

    def _mock_offset_pwr_tracking_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Mock the program offset_pwr_tracking.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if ccp is not None and str(ccp) != "-":
            ccp.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_tracking(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offset tracking between SLC images using intensity cross-correlation


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          deramp    deramp SLC phase flag (enter - for default)
                      0: no deramp (Doppler centroid close to 0) (default)
                      1: deramp SLC phase
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)

        NOTE: ScanSAR and TOPS data need to be previously deramped


        """

        if self.validate_inputs:
            self._validate_offset_pwr_tracking(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        if self.mock_outputs:
            self._mock_offset_pwr_tracking_outputs(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_pwr_tracking))
        result = self._gamma_call("ISP", "offset_pwr_tracking", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        if ccs is not None:
            assert ccs.exists(), f"{ccs} does not exist"
            assert ccs.stat().st_size > 0, f"{ccs} has zero file size"

        return result

    def _validate_ionosphere_check(
        self,
    ) -> None:
        """

        Validate the arguments to ionosphere_check.

        """

        pass

    def _mock_ionosphere_check_outputs(
        self,
    ) -> None:
        """

        Mock the program ionosphere_check.

        """
        pass

    def ionosphere_check(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ionosphere_check: Determine azimuth spectrum sub-band range and azimuth offsets of a single SLC
        Significant non-zero azimuth offsets are a clear indication for the presence of ionospheric effects


               SLC         (input) SLC image (e.g. 20070214.slc)
               par         (input) SLC parameter file (e.g. 20070214.slc.par)
               rwin        range window size used in offset estimation (default = 256)
               azwin       azimuth window size used in offset estimation (default = 256)
               thresh      threshold value used in offset estimation (default = 0.1)
               rstep       range step used in offset estimation (default = rwin/4)
               azstep      azimuth step used in offset estimation (default = azwin/4)


        """

        if self.validate_inputs:
            self._validate_ionosphere_check()

        if self.mock_outputs:
            self._mock_ionosphere_check_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.ionosphere_check))
        result = self._gamma_call("ISP", "ionosphere_check", ca)
        return result

    def _validate_SLC_phase_shift(
        self, SLC_1: Path, SLC_par1: Path, SLC_2: Path, SLC_par2: Path, ph_shift: int
    ) -> None:
        """

        Validate the arguments to SLC_phase_shift.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_par1.exists(), f"{SLC_par1} does not exist"
        assert SLC_par1.stat().st_size > 0, f"{SLC_par1} has zero file size"

        assert not SLC_2.exists(), f"{SLC_2} should _not_ exist!"

        assert not SLC_par2.exists(), f"{SLC_par2} should _not_ exist!"

    def _mock_SLC_phase_shift_outputs(
        self, SLC_1: Path, SLC_par1: Path, SLC_2: Path, SLC_par2: Path, ph_shift: int
    ) -> None:
        """

        Mock the program SLC_phase_shift.

        """

        if SLC_2 is not None and str(SLC_2) != "-":
            SLC_2.touch()

        if SLC_par2 is not None and str(SLC_par2) != "-":
            SLC_par2.touch()

    def SLC_phase_shift(
        self, SLC_1: Path, SLC_par1: Path, SLC_2: Path, SLC_par2: Path, ph_shift: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        Add a constant phase from an SLC image


        input parameters:
          SLC-1     (input) SLC data file (fcomplex or scomplex format)
          SLC_par1  (input) SLC parameter file
          SLC-2     (output) SLC with phase shift
          SLC_par2  (output) SLC parameter file for the output SLC
          ph_shift  phase shift to add to SLC phase (radians)

          NOTE: Used to apply a constant phase shift of -1.25 radians to Sentinel-1 TOPS SLC data
                from swath IW1 acquired up to 10-Mar-2015.

                Used to apply a constant phase shift of -3.83 radians to Sentinel-1 TOPS SLC data with
                H-POL on receive (e.g. VH) acquired up to 10-Mar-2015.


        """

        if self.validate_inputs:
            self._validate_SLC_phase_shift(SLC_1, SLC_par1, SLC_2, SLC_par2, ph_shift)

        if self.mock_outputs:
            self._mock_SLC_phase_shift_outputs(SLC_1, SLC_par1, SLC_2, SLC_par2, ph_shift)

        ca = self._clean_args(locals(), inspect.signature(self.SLC_phase_shift))
        result = self._gamma_call("ISP", "SLC_phase_shift", ca)

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC_par2.exists(), f"{SLC_par2} does not exist"
        assert SLC_par2.stat().st_size > 0, f"{SLC_par2} has zero file size"

        return result

    def _validate_S1_path_number(
        self,
    ) -> None:
        """

        Validate the arguments to S1_path_number.

        """

        pass

    def _mock_S1_path_number_outputs(
        self,
    ) -> None:
        """

        Mock the program S1_path_number.

        """
        pass

    def S1_path_number(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        S1_path_number: Script to determine S1 path (or track) number

               S1_zipfile            (input) S1 zip filename for the TOPS SLC


        """

        if self.validate_inputs:
            self._validate_S1_path_number()

        if self.mock_outputs:
            self._mock_S1_path_number_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.S1_path_number))
        result = self._gamma_call("ISP", "S1_path_number", ca)
        return result

    def _validate_unw_model(
        self,
        interf: Path,
        unw_model: Path,
        unw: Path,
        width: int,
        xinit: Optional[int] = None,
        yinit: Optional[int] = None,
        ref_ph: Optional[int] = None,
        width_model: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to unw_model.

        """

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        assert unw_model.exists(), f"{unw_model} does not exist"
        assert unw_model.stat().st_size > 0, f"{unw_model} has zero file size"

        assert not unw.exists(), f"{unw} should _not_ exist!"

    def _mock_unw_model_outputs(
        self,
        interf: Path,
        unw_model: Path,
        unw: Path,
        width: int,
        xinit: Optional[int] = None,
        yinit: Optional[int] = None,
        ref_ph: Optional[int] = None,
        width_model: Optional[int] = None,
    ) -> None:
        """

        Mock the program unw_model.

        """

        if unw is not None and str(unw) != "-":
            unw.touch()

    def unw_model(
        self,
        interf: Path,
        unw_model: Path,
        unw: Path,
        width: int,
        xinit: Optional[int] = None,
        yinit: Optional[int] = None,
        ref_ph: Optional[int] = None,
        width_model: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Phase unwrapping using a model of the unwrapped phase


        input parameters:
          interf       (input) complex interferogram
          unw_model    (input) approximate unwrapped phase model (float)
          unw          (output) unwrapped phase (float)
          width        number of samples/row of the interferogram
          xinit        offset to phase reference location in range (col)
          yinit        offset to phase reference location in azimuth (row)
          ref_ph       reference point phase (radians) (enter - for phase at the reference point )
          width_model  number of samples/row of the unwrapped phase model (default: interferogram width)


        """

        if self.validate_inputs:
            self._validate_unw_model(
                interf, unw_model, unw, width, xinit, yinit, ref_ph, width_model
            )

        if self.mock_outputs:
            self._mock_unw_model_outputs(
                interf, unw_model, unw, width, xinit, yinit, ref_ph, width_model
            )

        ca = self._clean_args(locals(), inspect.signature(self.unw_model))
        result = self._gamma_call("ISP", "unw_model", ca)

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        return result

    def _validate_par_TX_SLC(
        self,
        annotation_XML: Path,
        COSAR: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        pol: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_TX_SLC.

        """

        assert annotation_XML.exists(), f"{annotation_XML} does not exist"
        assert annotation_XML.stat().st_size > 0, f"{annotation_XML} has zero file size"

        assert COSAR.exists(), f"{COSAR} does not exist"
        assert COSAR.stat().st_size > 0, f"{COSAR} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_TX_SLC_outputs(
        self,
        annotation_XML: Path,
        COSAR: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        pol: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_TX_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_TX_SLC(
        self,
        annotation_XML: Path,
        COSAR: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        pol: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter file and SLC image from a Terrasar-X SSC data set


        input parameters:
          annotation_XML (input) TerraSAR-X product annotation XML file
          COSAR          (input) COSAR SSC stripmap or spotlight mode SLC data file
          SLC_par        (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC            (output) SLC data file, example: yyyymmdd.slc (enter - for none, SLC output will not be produced)
          pol            polarisation HH, HV, VH, VV (enter - for default: first polarisation found in the annotation_XML)
          dtype          output data type (enter - for default)
                           0: same as input (default)
                           1: FCOMPLEX


        """

        if self.validate_inputs:
            self._validate_par_TX_SLC(annotation_XML, COSAR, SLC_par, SLC, pol, dtype)

        if self.mock_outputs:
            self._mock_par_TX_SLC_outputs(annotation_XML, COSAR, SLC_par, SLC, pol, dtype)

        ca = self._clean_args(locals(), inspect.signature(self.par_TX_SLC))
        result = self._gamma_call("ISP", "par_TX_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_ScanSAR_burst_MLI(
        self,
        SLC_tab: Path,
        MLI_tab: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        MLI_dir: Optional[int] = None,
        scale: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to ScanSAR_burst_MLI.

        """

        assert SLC_tab.exists(), f"{SLC_tab} does not exist"
        assert SLC_tab.stat().st_size > 0, f"{SLC_tab} has zero file size"

        self._check_tab_file(SLC_tab, "SLC_tab")

        assert not MLI_tab.exists(), f"{MLI_tab} should _not_ exist!"

        if SLCR_tab is not None:
            assert SLCR_tab.exists(), f"{SLCR_tab} does not exist"
            assert SLCR_tab.stat().st_size > 0, f"{SLCR_tab} has zero file size"

    def _mock_ScanSAR_burst_MLI_outputs(
        self,
        SLC_tab: Path,
        MLI_tab: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        MLI_dir: Optional[int] = None,
        scale: Optional[float] = None,
    ) -> None:
        """

        Mock the program ScanSAR_burst_MLI.

        """

        if MLI_tab is not None and str(MLI_tab) != "-":
            MLI_tab.touch()

    def ScanSAR_burst_MLI(
        self,
        SLC_tab: Path,
        MLI_tab: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        MLI_dir: Optional[int] = None,
        scale: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate MLI burst data from ScanSAR burst SLC data (Sentinel-1, RCM, and TSX)


        input parameters:
          SLC_tab   (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par
          MLI_tab   (output) 3 column list of MLI swaths listed in order from near to far range
                      MLI_tab line entries:   MLI   MLI_par  TOPS_par
                    NOTE: if the MLI_tab does not yet exist, the file entries will be created with names derived from the SLC_tab entries
          rlks      number of range looks  (1...80)
          azlks     number of azimuth look (1...20)
          bflg      burst window calculation flag (enter - for default):
                      0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                      1: calculate burst window parameters from burst parameters and the number of range and azimuth looks
          SLCR_tab  (input) 3 column list of the reference scene with swaths, listed in order from near to far range, enter - for none
                      SLCR_tab line entries:   SLC    SLC_par   TOPS_par
          MLI_dir   directory for output burst MLI data, ignored if the MLI_tab already exists (default: current directory)
          scale     scale factor for output MLI (enter - for default: calculate from calibration gain in SLC parameter file)


        """

        if self.validate_inputs:
            self._validate_ScanSAR_burst_MLI(
                SLC_tab, MLI_tab, rlks, azlks, bflg, SLCR_tab, MLI_dir, scale
            )

        if self.mock_outputs:
            self._mock_ScanSAR_burst_MLI_outputs(
                SLC_tab, MLI_tab, rlks, azlks, bflg, SLCR_tab, MLI_dir, scale
            )

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_burst_MLI))
        result = self._gamma_call("ISP", "ScanSAR_burst_MLI", ca)

        assert MLI_tab.exists(), f"{MLI_tab} does not exist"
        assert MLI_tab.stat().st_size > 0, f"{MLI_tab} has zero file size"

        return result

    def _validate_SLC_copy_S1_TOPS(
        self,
    ) -> None:
        """

        Validate the arguments to SLC_copy_S1_TOPS.

        """

        pass

    def _mock_SLC_copy_S1_TOPS_outputs(
        self,
    ) -> None:
        """

        Mock the program SLC_copy_S1_TOPS.

        """
        pass

    def SLC_copy_S1_TOPS(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        **************************************************************************************
        NOTE: SLC_copy_S1_TOPS has been replaced by SLC_copy_ScanSAR. The command line
        options are unchanged, please consider renaming the program in your scripts.
        **************************************************************************************
        SLC_copy_ScanSAR
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/SLC_copy_S1_TOPS: line 7: SLC_copy_ScanSAR: command not found

        """

        if self.validate_inputs:
            self._validate_SLC_copy_S1_TOPS()

        if self.mock_outputs:
            self._mock_SLC_copy_S1_TOPS_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SLC_copy_S1_TOPS))
        result = self._gamma_call("ISP", "SLC_copy_S1_TOPS", ca)
        return result

    def _validate_base_copy(
        self,
        SLC1_par: Path,
        baseline_1: Path,
        SLC2_par: Path,
        baseline_2: Path,
        time_rev: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to base_copy.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert baseline_1.exists(), f"{baseline_1} does not exist"
        assert baseline_1.stat().st_size > 0, f"{baseline_1} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert not baseline_2.exists(), f"{baseline_2} should _not_ exist!"

    def _mock_base_copy_outputs(
        self,
        SLC1_par: Path,
        baseline_1: Path,
        SLC2_par: Path,
        baseline_2: Path,
        time_rev: Optional[int] = None,
    ) -> None:
        """

        Mock the program base_copy.

        """

        if baseline_2 is not None and str(baseline_2) != "-":
            baseline_2.touch()

    def base_copy(
        self,
        SLC1_par: Path,
        baseline_1: Path,
        SLC2_par: Path,
        baseline_2: Path,
        time_rev: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate baseline file for a subsection of a reference SLC


        input parameters:
          SLC1_par    (input) ISP image parameter file of the reference SLC
          baseline-1  (input) baseline file derived using the reference SLC geometry
          SLC2_par    (input) ISP image parameter file corresponding to the subsecton of the reference SLC
          baseline-2  (output) baseline file derived using the geometry and timing of the SLC subsection
          time_rev    SLC image normal=1,  time-reversed = -1 (default=1)


        """

        if self.validate_inputs:
            self._validate_base_copy(SLC1_par, baseline_1, SLC2_par, baseline_2, time_rev)

        if self.mock_outputs:
            self._mock_base_copy_outputs(
                SLC1_par, baseline_1, SLC2_par, baseline_2, time_rev
            )

        ca = self._clean_args(locals(), inspect.signature(self.base_copy))
        result = self._gamma_call("ISP", "base_copy", ca)

        assert baseline_2.exists(), f"{baseline_2} does not exist"
        assert baseline_2.stat().st_size > 0, f"{baseline_2} has zero file size"

        return result

    def _validate_SLC_interp_map(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        OFF_par2: Path,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_interp_map.

        """

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not SLC_2R.exists(), f"{SLC_2R} should _not_ exist!"

        assert not SLC2R_par.exists(), f"{SLC2R_par} should _not_ exist!"

        assert OFF_par2.exists(), f"{OFF_par2} does not exist"
        assert OFF_par2.stat().st_size > 0, f"{OFF_par2} has zero file size"

    def _mock_SLC_interp_map_outputs(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        OFF_par2: Path,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_interp_map.

        """

        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()

        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp_map(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        OFF_par2: Path,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        SLC image resampling using a 2-D offset map


        input parameters:
          SLC-2      (input) SLC-2 image to be resampled to the reference SLC-1 reference image
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2_par   (input) SLC-2 ISP image parameter file
          OFF_par    (input) ISP offset/interferogram parameter file
          SLC-2R     (output) single-look complex image 2 coregistered to SLC-1
          SLC2R_par  (output) SLC-2R ISP image parameter file for co-registered image
          OFF_par2   (input) ISP offset/interferogram parameter file used for residual offsets map (coffs2_sm)
          coffs2_sm  (input) smoothed residual range and azimuth offsets (fcomplex)
          loff       offset to first valid output line (in SLC-1 lines) (enter - for default: 0)
          nlines     number of valid output lines (enter - or 0 for default: to end of file)
          mode       interpolation mode (enter - for default)
                       0: Lanczos (default)
                       1: B-spline
          order      Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)


        """

        if self.validate_inputs:
            self._validate_SLC_interp_map(
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                SLC_2R,
                SLC2R_par,
                OFF_par2,
                loff,
                nlines,
            )

        if self.mock_outputs:
            self._mock_SLC_interp_map_outputs(
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                SLC_2R,
                SLC2R_par,
                OFF_par2,
                loff,
                nlines,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_interp_map))
        result = self._gamma_call("ISP", "SLC_interp_map", ca)

        assert SLC_2R.exists(), f"{SLC_2R} does not exist"
        assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        return result

    def _validate_base_perp(
        self,
        baseline: Path,
        SLC1_par: Path,
        OFF_par: Path,
        time_rev: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to base_perp.

        """

        assert baseline.exists(), f"{baseline} does not exist"
        assert baseline.stat().st_size > 0, f"{baseline} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

    def _mock_base_perp_outputs(
        self,
        baseline: Path,
        SLC1_par: Path,
        OFF_par: Path,
        time_rev: Optional[int] = None,
    ) -> None:
        """

        Mock the program base_perp.

        """
        pass

    def base_perp(
        self,
        baseline: Path,
        SLC1_par: Path,
        OFF_par: Path,
        time_rev: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate baseline components perpendicular and parallel to look vector


        input parameters:
          baseline  (input) baseline file (text)
          SLC1_par  (input) ISP parameter file of SLC-1 (reference SLC)
          OFF_par   (input) ISP interferogram/offset parameter file
          time_rev  SLC image normal=1 (default), image time-reversed = -1


        """

        if self.validate_inputs:
            self._validate_base_perp(baseline, SLC1_par, OFF_par, time_rev)

        if self.mock_outputs:
            self._mock_base_perp_outputs(baseline, SLC1_par, OFF_par, time_rev)

        ca = self._clean_args(locals(), inspect.signature(self.base_perp))
        result = self._gamma_call("ISP", "base_perp", ca)
        return result

    def _validate_SLC_RFI_filt(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[int] = None,
        nfft_r: Optional[int] = None,
        nfft_az: Optional[int] = None,
        r_step: Optional[int] = None,
        az_step: Optional[int] = None,
        mwin_r: Optional[int] = None,
        mwin_az: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_RFI_filt.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not SLC_filt.exists(), f"{SLC_filt} should _not_ exist!"

    def _mock_SLC_RFI_filt_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[int] = None,
        nfft_r: Optional[int] = None,
        nfft_az: Optional[int] = None,
        r_step: Optional[int] = None,
        az_step: Optional[int] = None,
        mwin_r: Optional[int] = None,
        mwin_az: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_RFI_filt.

        """

        if SLC_filt is not None and str(SLC_filt) != "-":
            SLC_filt.touch()

    def SLC_RFI_filt(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[int] = None,
        nfft_r: Optional[int] = None,
        nfft_az: Optional[int] = None,
        r_step: Optional[int] = None,
        az_step: Optional[int] = None,
        mwin_r: Optional[int] = None,
        mwin_az: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Adaptive RFI filtering for SLC image using median spectral filtering


        input parameters:
          SLC          (input) SLC to be filtered (FCOMPLEX or SCOMPLEX)
          SLC_par      (input) reference SLC parameter file
          SLC_filt     (output) output filtered SLC using the power spectrum of the reference SLC
          rfi_thres    RFI threshold (default: 10.00)
          nfft_r       range filter FFT window size, 2**N, 16->1024, (enter - for default: 128)
          nfft_az      azimuth filter FFT window size, 2**N, 16->1024, (enter - for default: 128)
          r_step       range processing step (enter - for default: nfft_r/4)
          az_step      azimuth processing step (enter - for default: nfft_az/4)
          mwin_r       range median window size for median PSD filtering (enter - for default: 5)
          mwin_az      azimuth median window size for median PSD filtering (enter - for default: 5)


        """

        if self.validate_inputs:
            self._validate_SLC_RFI_filt(
                SLC,
                SLC_par,
                SLC_filt,
                rfi_thres,
                nfft_r,
                nfft_az,
                r_step,
                az_step,
                mwin_r,
                mwin_az,
            )

        if self.mock_outputs:
            self._mock_SLC_RFI_filt_outputs(
                SLC,
                SLC_par,
                SLC_filt,
                rfi_thres,
                nfft_r,
                nfft_az,
                r_step,
                az_step,
                mwin_r,
                mwin_az,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_RFI_filt))
        result = self._gamma_call("ISP", "SLC_RFI_filt", ca)

        assert SLC_filt.exists(), f"{SLC_filt} does not exist"
        assert SLC_filt.stat().st_size > 0, f"{SLC_filt} has zero file size"

        return result

    def _validate_SLC_adf(
        self,
        SLC: Path,
        ref_SLC: Path,
        ref_SLC_par: Path,
        SLC_filt: Path,
        mode: Optional[int] = None,
        alpha: Optional[int] = None,
        nfft_r: Optional[int] = None,
        nfft_az: Optional[int] = None,
        r_step: Optional[int] = None,
        az_step: Optional[int] = None,
        mwin_r: Optional[int] = None,
        mwin_az: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_adf.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert ref_SLC.exists(), f"{ref_SLC} does not exist"
        assert ref_SLC.stat().st_size > 0, f"{ref_SLC} has zero file size"

        assert ref_SLC_par.exists(), f"{ref_SLC_par} does not exist"
        assert ref_SLC_par.stat().st_size > 0, f"{ref_SLC_par} has zero file size"

        assert not SLC_filt.exists(), f"{SLC_filt} should _not_ exist!"

    def _mock_SLC_adf_outputs(
        self,
        SLC: Path,
        ref_SLC: Path,
        ref_SLC_par: Path,
        SLC_filt: Path,
        mode: Optional[int] = None,
        alpha: Optional[int] = None,
        nfft_r: Optional[int] = None,
        nfft_az: Optional[int] = None,
        r_step: Optional[int] = None,
        az_step: Optional[int] = None,
        mwin_r: Optional[int] = None,
        mwin_az: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_adf.

        """

        if SLC_filt is not None and str(SLC_filt) != "-":
            SLC_filt.touch()

    def SLC_adf(
        self,
        SLC: Path,
        ref_SLC: Path,
        ref_SLC_par: Path,
        SLC_filt: Path,
        mode: Optional[int] = None,
        alpha: Optional[int] = None,
        nfft_r: Optional[int] = None,
        nfft_az: Optional[int] = None,
        r_step: Optional[int] = None,
        az_step: Optional[int] = None,
        mwin_r: Optional[int] = None,
        mwin_az: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Adaptive filtering of SLC data based on the local PSD of a reference SLC image


        input parameters:
          SLC           (input) SLC to be filtered (FCOMPLEX or SCOMPLEX)
          ref_SLC       (input) reference SLC
          ref_SLC_par   (input) reference SLC parameter file
          SLC_filt      (output) output filtered SLC using the power spectrum of the reference SLC
          mode          SLC filtering mode (enter - for default):
                          0: 1D range PSD filter
                          1: 1D azimuth PSD filter
                          2: 2D range PSD * azimuth PSD filter
                          3: 2D median-filtered PSD filtering (default)
          alpha         exponent to apply to PSD value (enter - for default: 0.30)
          nfft_r        range filter FFT window size, 2**N, 16->1024, (enter - for default: 128)
          nfft_az       azimuth filter FFT window size, 2**N, 16->1024, (enter - for default: 128)
          r_step        range processing step (enter - for default: nfft_r/4)
          az_step       azimuth processing step (enter - for default: nfft_az/4)
          mwin_r        range median window size for median PSD filtering (enter - for default: 5)
          mwin_az       azimuth median window size for median PSD filtering (enter - for default: 5)


        """

        if self.validate_inputs:
            self._validate_SLC_adf(
                SLC,
                ref_SLC,
                ref_SLC_par,
                SLC_filt,
                mode,
                alpha,
                nfft_r,
                nfft_az,
                r_step,
                az_step,
                mwin_r,
                mwin_az,
            )

        if self.mock_outputs:
            self._mock_SLC_adf_outputs(
                SLC,
                ref_SLC,
                ref_SLC_par,
                SLC_filt,
                mode,
                alpha,
                nfft_r,
                nfft_az,
                r_step,
                az_step,
                mwin_r,
                mwin_az,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_adf))
        result = self._gamma_call("ISP", "SLC_adf", ca)

        assert SLC_filt.exists(), f"{SLC_filt} does not exist"
        assert SLC_filt.stat().st_size > 0, f"{SLC_filt} has zero file size"

        return result

    def _validate_ScanSAR_burst_cc_ad(
        self,
    ) -> None:
        """

        Validate the arguments to ScanSAR_burst_cc_ad.

        """

        pass

    def _mock_ScanSAR_burst_cc_ad_outputs(
        self,
    ) -> None:
        """

        Mock the program ScanSAR_burst_cc_ad.

        """
        pass

    def ScanSAR_burst_cc_ad(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate interferometric coherence for ScanSAR burst data using cc_ad

          DIFF_tab    (input) 3 column list of the DIFF swaths listed in order from near to far range
                        DIFF_tab line entries:  DIFF  MLI_par  TOPS_par
          MLI1_tab    (input) 3 column list of the reference ScanSAR MLI swaths listed in order from near to far range (enter - for none)
                        MLI1_tab line entries:   MLI  MLI_par  TOPS_par
          MLI2R_tab   (input) 3 column list of ScanSAR MLI swaths listed in order from near to far range, coregistered with MLI1 (enter - for none)
                        MLI2R_tab line entries:  MLI  MLI_par  TOPS_par
          slope_tab   (input) 1 column list of ScanSAR phase slope swaths listed in order from near to far range (enter - for none)
          texture_tab (input) 1 column list of ScanSAR backscatter texture swaths listed in order from near to far range (enter - for none)
          CC_tab      (input/output) 3 column list of the CC swaths listed in order from near to far range
                        CC_tab line entries:      CC  MLI_par  TOPS_par
                      NOTE: if CC_tab does not exist, it will be created in the current directory.
                            The binary file will be named from the differential interferogram name, with the addition of a ".cc" extension.
                            The MLI_par and TOPS_par files are copied from MLI1_tab if available, from DIFF_tab otherwise.
          log         (output) processing log file
          box_min     smallest correlation average box size (enter - for default: 3.0)
          box_max     largest correlation average box size  (enter - for default: 9.0)
          wgt_flag    weighting function (enter - for default)
                        0: constant (default)
                        1: gaussian


        """

        if self.validate_inputs:
            self._validate_ScanSAR_burst_cc_ad()

        if self.mock_outputs:
            self._mock_ScanSAR_burst_cc_ad_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_burst_cc_ad))
        result = self._gamma_call("ISP", "ScanSAR_burst_cc_ad", ca)
        return result

    def _validate_offset_SLC(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        ISZ: Optional[int] = None,
        pflag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_SLC.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not snr.exists(), f"{snr} should _not_ exist!"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

    def _mock_offset_SLC_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        ISZ: Optional[int] = None,
        pflag: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_SLC.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if snr is not None and str(snr) != "-":
            snr.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

    def offset_SLC(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        ISZ: Optional[int] = None,
        pflag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offsets between SLC images using fringe visibility


        input parameters:
          SLC-1     (input) single-look complex image 1 (reference)
          SLC-2     (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates (fcomplex)
          snr       (output) offset estimation SNR (float)
          rwin      search window size (range pixels, (enter - for default from offset parameter file))
          azwin     search window size (azimuth lines, (enter - for default from offset parameter file))
          offsets   (output) range and azimuth offsets and SNR data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4) default = 2)
          nr        number of offset estimates in range direction (enter - for default from offset parameter file)
          naz       number of offset estimates in azimuth direction (enter - for default from offset parameter file)
          thres     offset estimation quality threshold (enter - for default from offset parameter file)
          ISZ       search chip interferogram size (in non-oversampled pixels, default=16)
          pflag     print flag (0:print offset summary  default=1:print all offset data)


        """

        if self.validate_inputs:
            self._validate_offset_SLC(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                snr,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                ISZ,
                pflag,
            )

        if self.mock_outputs:
            self._mock_offset_SLC_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                snr,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                ISZ,
                pflag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_SLC))
        result = self._gamma_call("ISP", "offset_SLC", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert snr.exists(), f"{snr} does not exist"
        assert snr.stat().st_size > 0, f"{snr} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        return result

    def _validate_adf(
        self,
        interf: Path,
        sm: Path,
        cc: Path,
        width: int,
        alpha: Optional[int] = None,
        nfft: Optional[int] = None,
        cc_win: Optional[int] = None,
        step: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to adf.

        """

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        assert not sm.exists(), f"{sm} should _not_ exist!"

        assert not cc.exists(), f"{cc} should _not_ exist!"

    def _mock_adf_outputs(
        self,
        interf: Path,
        sm: Path,
        cc: Path,
        width: int,
        alpha: Optional[int] = None,
        nfft: Optional[int] = None,
        cc_win: Optional[int] = None,
        step: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[int] = None,
    ) -> None:
        """

        Mock the program adf.

        """

        if sm is not None and str(sm) != "-":
            sm.touch()

        if cc is not None and str(cc) != "-":
            cc.touch()

    def adf(
        self,
        interf: Path,
        sm: Path,
        cc: Path,
        width: int,
        alpha: Optional[int] = None,
        nfft: Optional[int] = None,
        cc_win: Optional[int] = None,
        step: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Adaptive interferogram bandpass filter based on the power spectral density


        input parameters:
          interf  (input) interferogram (fcomplex)
          sm      (output) filtered interferogram (fcomplex)
          cc      (output) filtered interferogram correlation coefficient (float)
          width   number of samples/line
          alpha   exponent for non-linear filtering (enter - for default: 0.40)
          nfft    filtering FFT window size, 2**N, 8 --> 512, (enter - for default: 32)
          cc_win  correlation parameter estimation window size odd, max: 15 (enter - for default: 5)
          step    processing step (enter - for default: nfft/8)
          loff    offset to starting line to process (enter - for default: 0)
          nlines  number of lines to process (enter - for default: to end of file)
          wfrac   minimum fraction of points required to be non-zero in the filter window (enter - for default: 0.200)


        """

        if self.validate_inputs:
            self._validate_adf(
                interf, sm, cc, width, alpha, nfft, cc_win, step, loff, nlines, wfrac
            )

        if self.mock_outputs:
            self._mock_adf_outputs(
                interf, sm, cc, width, alpha, nfft, cc_win, step, loff, nlines, wfrac
            )

        ca = self._clean_args(locals(), inspect.signature(self.adf))
        result = self._gamma_call("ISP", "adf", ca)

        assert sm.exists(), f"{sm} does not exist"
        assert sm.stat().st_size > 0, f"{sm} has zero file size"

        assert cc.exists(), f"{cc} does not exist"
        assert cc.stat().st_size > 0, f"{cc} has zero file size"

        return result

    def _validate_PRC_vec(
        self, SLC_par: Path, PRC: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to PRC_vec.

        """

        assert PRC.exists(), f"{PRC} does not exist"
        assert PRC.stat().st_size > 0, f"{PRC} has zero file size"

    def _mock_PRC_vec_outputs(
        self, SLC_par: Path, PRC: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Mock the program PRC_vec.

        """

        if not SLC_par.exists():
            SLC_par.touch()

    def PRC_vec(
        self, SLC_par: Path, PRC: Path, nstate: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        State vectors from ERS PRC orbit data for ISP processing clw/uw


        input parameters:
          SLC_par  (input/output) ISP SLC/MLI image parameter file
          PRC      (input) PRC state vector file
          nstate   number of state vectors (default=5, maximum=1024)


        """

        if self.validate_inputs:
            self._validate_PRC_vec(SLC_par, PRC, nstate)

        if self.mock_outputs:
            self._mock_PRC_vec_outputs(SLC_par, PRC, nstate)

        ca = self._clean_args(locals(), inspect.signature(self.PRC_vec))
        result = self._gamma_call("ISP", "PRC_vec", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_SLC_cat_S1_TOPS(
        self,
    ) -> None:
        """

        Validate the arguments to SLC_cat_S1_TOPS.

        """

        pass

    def _mock_SLC_cat_S1_TOPS_outputs(
        self,
    ) -> None:
        """

        Mock the program SLC_cat_S1_TOPS.

        """
        pass

    def SLC_cat_S1_TOPS(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        *************************************************************************************
        NOTE: SLC_cat_S1_TOPS has been replaced by SLC_cat_ScanSAR. The command line
        options are unchanged, please consider renaming the program in your scripts.
        *************************************************************************************
        SLC_cat_ScanSAR
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/SLC_cat_S1_TOPS: line 7: SLC_cat_ScanSAR: command not found

        """

        if self.validate_inputs:
            self._validate_SLC_cat_S1_TOPS()

        if self.mock_outputs:
            self._mock_SLC_cat_S1_TOPS_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SLC_cat_S1_TOPS))
        result = self._gamma_call("ISP", "SLC_cat_S1_TOPS", ca)
        return result

    def _validate_get_GAMMA_RASTER(
        self,
    ) -> None:
        """

        Validate the arguments to get_GAMMA_RASTER.

        """

        pass

    def _mock_get_GAMMA_RASTER_outputs(
        self,
    ) -> None:
        """

        Mock the program get_GAMMA_RASTER.

        """
        pass

    def get_GAMMA_RASTER(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Script to determine the default extension for raster images or the operating system type


          mode  Specify the script string output:
                  0: raster file extension (ras, bmp, or tif)
                  1: OS type: Linux, MINGW64_NT-10.0, CYGWIN_NT-10.0, darwin...

        NOTE: The default raster format on Linux systems is SUN_RASTER (*.ras), for all other operating systems it is BMP (*.bmp).
              SUN_RASTER and BMP images are limited in size to 32767 x 32767. TIFF files do not have this limitation.
              To set the default image raster format for Gamma programs, set the environment variable GAMMA_RASTER as follows:

              bash:
                  export GAMMA_RASTER=SUN_RASTER  #extension: ras
                  export GAMMA_RASTER=BMP         #extension: bmp
                  export GAMMA_RASTER=TIFF        #extension: tif

              csh,tcsh:
                  setenv GAMMA_RASTER SUN_RASTER  #extension: ras
                  setenv GAMMA_RASTER BMP         #extension: bmp
                  setenv GAMMA_RASTER TIFF        #extension: tif

              Environment variables can be set either in processing scripts, or in the shell initialization file (e.g. .bashrc)
              Programs in the Gamma software that generate raster image files query the value of GAMMA_RASTER if it has been defined.
              This script can be called from within another script to determine the default raster image format or OS type:

              bash:        $ext=`get_GAMMA_RASTER 0`
              csh,tcsh: set ext=`get_GAMMA_RASTER 0`

              The variable $ext can then be used to specify the format of the output raster file by using it to construct
              the output file name:

              bash:        $my_raster=$my_name"."$ext
              csh/tcsh: set my_raster=$my_name"."$ext

        OS: Darwin
        GAMMA_RASTER: Undefined variable.

        """

        if self.validate_inputs:
            self._validate_get_GAMMA_RASTER()

        if self.mock_outputs:
            self._mock_get_GAMMA_RASTER_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.get_GAMMA_RASTER))
        result = self._gamma_call("ISP", "get_GAMMA_RASTER", ca)
        return result

    def _validate_par_Capella_SLC(
        self,
        GeoTIFF: Path,
        ext_JSON: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_Capella_SLC.

        """

        assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
        assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert ext_JSON.exists(), f"{ext_JSON} does not exist"
        assert ext_JSON.stat().st_size > 0, f"{ext_JSON} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_Capella_SLC_outputs(
        self,
        GeoTIFF: Path,
        ext_JSON: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_Capella_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_Capella_SLC(
        self,
        GeoTIFF: Path,
        ext_JSON: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for Capella SLC data


        input parameters:
          GeoTIFF       (input) Capella image data file in GeoTIFF format (*.tif)
          ext_JSON      (input) Capella extended metadata file in JSON format (*_extended.json)
          SLC_par       (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC           (output) SLC data file (enter - for none, example: yyyymmdd.slc)
          radcal        radiometric calibration flag (enter - for default)
                          0: beta0 (default)
                          1: sigma0
          noise         noise levels flag (enter - for default)
                          0: do not use noise levels (default)
                          1: use noise levels

        NOTE: Capella terrain geocoded data in GeoTIFF format can be read using par_Capella_geo program


        """

        if self.validate_inputs:
            self._validate_par_Capella_SLC(GeoTIFF, ext_JSON, SLC_par, SLC, radcal, noise)

        if self.mock_outputs:
            self._mock_par_Capella_SLC_outputs(
                GeoTIFF, ext_JSON, SLC_par, SLC, radcal, noise
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_Capella_SLC))
        result = self._gamma_call("ISP", "par_Capella_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_S1_deramp_TOPS_slave(
        self,
    ) -> None:
        """

        Validate the arguments to S1_deramp_TOPS_slave.

        """

        pass

    def _mock_S1_deramp_TOPS_slave_outputs(
        self,
    ) -> None:
        """

        Mock the program S1_deramp_TOPS_slave.

        """
        pass

    def S1_deramp_TOPS_slave(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ******************************************************************************
        NOTE: S1_deramp_TOPS_slave has been replaced by ScanSAR_deramp_2nd.py.
        The command line options are unchanged, please consider renaming the
        program in your scripts.
        ******************************************************************************
        cmd: ScanSAR_deramp_2nd.py

        ScanSAR_deramp_2nd.py: Command not found.

        """

        if self.validate_inputs:
            self._validate_S1_deramp_TOPS_slave()

        if self.mock_outputs:
            self._mock_S1_deramp_TOPS_slave_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.S1_deramp_TOPS_slave))
        result = self._gamma_call("ISP", "S1_deramp_TOPS_slave", ca)
        return result

    def _validate_make_tab(self, list: Path, tab: Path, template: int) -> None:
        """

        Validate the arguments to make_tab.

        """

        assert list.exists(), f"{list} does not exist"
        assert list.stat().st_size > 0, f"{list} has zero file size"

    def _mock_make_tab_outputs(self, list: Path, tab: Path, template: int) -> None:
        """

        Mock the program make_tab.

        """

        if tab is not None and str(tab) != "-":
            tab.touch()

    def make_tab(
        self, list: Path, tab: Path, template: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/make_tab
        Generate a table file from a list or multi-colum table using a text template


        input parameters:
          list        (input) list or multi-column table (text)
          tab         (output) table file (text)
          template    template definition used to generate a line of the output table, entered between single quotes.
                      Placeholders , , ... specify the columns of the input table.
                        (example 1: '$1.slc $1.slc.par')
                        (example 2: '$1_$2.base $1_$2.off')


        """

        if self.validate_inputs:
            self._validate_make_tab(list, tab, template)

        if self.mock_outputs:
            self._mock_make_tab_outputs(list, tab, template)

        ca = self._clean_args(locals(), inspect.signature(self.make_tab))
        result = self._gamma_call("ISP", "make_tab", ca)

        assert tab.exists(), f"{tab} does not exist"
        assert tab.stat().st_size > 0, f"{tab} has zero file size"

        return result

    def _validate_adapt_filt(
        self,
        int: Path,
        sm: float,
        width: int,
        filt_width: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to adapt_filt.

        """

        assert int.exists(), f"{int} does not exist"
        assert int.stat().st_size > 0, f"{int} has zero file size"

    def _mock_adapt_filt_outputs(
        self,
        int: Path,
        sm: float,
        width: int,
        filt_width: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Mock the program adapt_filt.

        """
        pass

    def adapt_filt(
        self,
        int: Path,
        sm: float,
        width: int,
        filt_width: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Adaptive bandpass filtering of interferograms


        input parameters:
          int          (input) complex interferogram image filename
          sm           (output) smoothed interferogram filename
          width        number of samples/row
          low_snr_thr  low SNR threshold (default = .25);
          filt_width   filter width in pixels (default = 1.0)
          xmin         offset to starting range pixel(default = 0)
          xmax         offset last range pixel (default = width-1)
          ymin         offset to starting azimuth row (default = 0)
          ymax         offset to last azimuth row (default = nlines-1)


        """

        if self.validate_inputs:
            self._validate_adapt_filt(int, sm, width, filt_width, xmin, xmax, ymin, ymax)

        if self.mock_outputs:
            self._mock_adapt_filt_outputs(
                int, sm, width, filt_width, xmin, xmax, ymin, ymax
            )

        ca = self._clean_args(locals(), inspect.signature(self.adapt_filt))
        result = self._gamma_call("ISP", "adapt_filt", ca)
        return result

    def _validate_par_RSAT2_SG(
        self,
        product_XML: Path,
        lut_XML: Path,
        GeoTIFF: Path,
        polarization: Path,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_RSAT2_SG.

        """

        assert product_XML.exists(), f"{product_XML} does not exist"
        assert product_XML.stat().st_size > 0, f"{product_XML} has zero file size"

        assert lut_XML.exists(), f"{lut_XML} does not exist"
        assert lut_XML.stat().st_size > 0, f"{lut_XML} has zero file size"

        assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
        assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert polarization.exists(), f"{polarization} does not exist"
        assert polarization.stat().st_size > 0, f"{polarization} has zero file size"

        if MLI_par is not None:
            assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        if MLI is not None:
            assert not MLI.exists(), f"{MLI} should _not_ exist!"

        if GRD_par is not None:
            assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_RSAT2_SG_outputs(
        self,
        product_XML: Path,
        lut_XML: Path,
        GeoTIFF: Path,
        polarization: Path,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_RSAT2_SG.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_RSAT2_SG(
        self,
        product_XML: Path,
        lut_XML: Path,
        GeoTIFF: Path,
        polarization: Path,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate MLI and GRD images and parameter files from Radarsat 2 SGF/SGX/SCF data


        input parameters:
          product_XML    (input) Radarsat-2 product annotation XML file (product.xml)
          lut_XML        (input) Radarsat-2 calibration XML file (lutSigma.xml), use - for no calibration
          GeoTIFF        (input) image data file in GeoTIFF format (imagery_PP.tif)
          polarization   (input) image polarization: HH, VV, HV, VH
          MLI_par        (output) MLI parameter file (example: yyyymmdd_pp.mli.par, enter - for none)
          MLI            (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par        (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD            (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          rps            slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)

        NOTE: Ground range geometry is less accurate than slant range geometry and should be avoided


        """

        if self.validate_inputs:
            self._validate_par_RSAT2_SG(
                product_XML,
                lut_XML,
                GeoTIFF,
                polarization,
                MLI_par,
                MLI,
                GRD_par,
                GRD,
                rps,
            )

        if self.mock_outputs:
            self._mock_par_RSAT2_SG_outputs(
                product_XML,
                lut_XML,
                GeoTIFF,
                polarization,
                MLI_par,
                MLI,
                GRD_par,
                GRD,
                rps,
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RSAT2_SG))
        result = self._gamma_call("ISP", "par_RSAT2_SG", ca)

        if MLI_par is not None:
            assert MLI_par.exists(), f"{MLI_par} does not exist"
            assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if MLI is not None:
            assert MLI.exists(), f"{MLI} does not exist"
            assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        if GRD_par is not None:
            assert GRD_par.exists(), f"{GRD_par} does not exist"
            assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_ScanSAR_burst_corners(
        self, SLC_par: Path, TOPS_par: Path, KML: Optional[Path] = None
    ) -> None:
        """

        Validate the arguments to ScanSAR_burst_corners.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert TOPS_par.exists(), f"{TOPS_par} does not exist"
        assert TOPS_par.stat().st_size > 0, f"{TOPS_par} has zero file size"

        if KML is not None:
            assert not KML.exists(), f"{KML} should _not_ exist!"

    def _mock_ScanSAR_burst_corners_outputs(
        self, SLC_par: Path, TOPS_par: Path, KML: Optional[Path] = None
    ) -> None:
        """

        Mock the program ScanSAR_burst_corners.

        """

        if KML is not None and str(KML) != "-":
            KML.touch()

    def ScanSAR_burst_corners(
        self, SLC_par: Path, TOPS_par: Path, KML: Optional[Path] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate corner geographic coordinates of ScanSAR burst data and generate a KML with burst rectangles


        input parameters:
          SLC_par   (input) SLC parameter file for the ScanSAR burst data
          TOPS_par  (input) ScanSAR burst parameter file
          KML       (output) KML output file


        """

        if self.validate_inputs:
            self._validate_ScanSAR_burst_corners(SLC_par, TOPS_par, KML)

        if self.mock_outputs:
            self._mock_ScanSAR_burst_corners_outputs(SLC_par, TOPS_par, KML)

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_burst_corners))
        result = self._gamma_call("ISP", "ScanSAR_burst_corners", ca)

        if KML is not None:
            assert KML.exists(), f"{KML} does not exist"
            assert KML.stat().st_size > 0, f"{KML} has zero file size"

        return result

    def _validate_SBI_INT(
        self,
    ) -> None:
        """

        Validate the arguments to SBI_INT.

        """

        pass

    def _mock_SBI_INT_outputs(
        self,
    ) -> None:
        """

        Mock the program SBI_INT.

        """
        pass

    def SBI_INT(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        SBI_INT: Script to generate azimuth Split-Beam Interferogram from a coregistered interferometric SLC pair

               RSLC1       (input) master single-look complex image (fcomplex or scomplex)
               RSLC_par1   (input) SLC ISP image parameter file of RSLC1
               RSLC2       (input) co-registered slave SLC image (fcomplex or scomplex)
               RSLC_par2   (input) SLC ISP image parameter file of RSLC2
               sbi         (output) multi-look split-beam interferogram (fcomplex)
               off         (output) ISP offset parameter file for multi-look split-beam interferogram (ascii)
               sbi_pwr     (output) multi-look reference backscatter intensity image (float)
               par_out     (output) SLC/MLI ISP image parameter file of sbi_pwr
               norm_sq     normalized squint difference parameter (default: 0.5)
               rlks        number of range looks in output split-beam interferogram (default: 1)
               azlks       number of azimuth looks in output split-beam interferogram (default: 1)
               iwflg       inverse weighting flag:
                             0: do not remove azimuth processing spectral window  (default)
                             1: apply inverse of azimuth compression processing window
               cflg        flag to indicate if intermediate data (e.g. filtered slc) are deleted
                             0: intermediate data are deleted (default)
                             1: intermediate data are NOT deleted

              file names for band-pass filtered SLC are generated automatically
              by adding the letter  b / f  for the backward / foward looking beam


        """

        if self.validate_inputs:
            self._validate_SBI_INT()

        if self.mock_outputs:
            self._mock_SBI_INT_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SBI_INT))
        result = self._gamma_call("ISP", "SBI_INT", ca)
        return result

    def _validate_par_RCM_SLC_ScanSAR(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int],
        noise_in: Optional[int],
        root_name: Path,
        SLC_tab: Optional[Path] = None,
        beam: Optional[int] = None,
        noise_out: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_RCM_SLC_ScanSAR.

        """

        assert RCM_dir.exists(), f"{RCM_dir} does not exist"
        assert RCM_dir.stat().st_size > 0, f"{RCM_dir} has zero file size"

        assert not root_name.exists(), f"{root_name} should _not_ exist!"

        if SLC_tab is not None:
            assert not SLC_tab.exists(), f"{SLC_tab} should _not_ exist!"

    def _mock_par_RCM_SLC_ScanSAR_outputs(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int],
        noise_in: Optional[int],
        root_name: Path,
        SLC_tab: Optional[Path] = None,
        beam: Optional[int] = None,
        noise_out: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_RCM_SLC_ScanSAR.

        """

        if root_name is not None and str(root_name) != "-":
            root_name.touch()

        if SLC_tab is not None and str(SLC_tab) != "-":
            SLC_tab.touch()

    def par_RCM_SLC_ScanSAR(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int],
        noise_in: Optional[int],
        root_name: Path,
        SLC_tab: Optional[Path] = None,
        beam: Optional[int] = None,
        noise_out: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files from Radarsat Constellation ScanSAR SLC data in GeoTIFF or NITF format


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM2_OK1002260_PK1002436_3_SC50MB_20160417_002427_VH_VV_SLC)
          polarization   image polarization: HH, VV, HV, VH, CH, CV
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise_in       noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          root_name      (output) root name of the generated output files (example: yyyymmdd_pp)
                         NOTE: the program will automatically complete the root_name with beam numbers and extensions for the SLC, SLC_par, and TOPS_par files
          SLC_tab        (output) 3 column list of SLC, SLC_par, and TOPS_par files, with the beams sorted from near to far range (example: yyyymmdd_pp.SLC_tab)
          beam           number specifying the desired ScanSAR beam number (enter - for default: extract all beams)
                         NOTE: enter 0 to get the list of the available beams
          noise_out      output noise intensity for each SLC sample in slant range flag (enter - for default)
                           0: do not write noise intensity files (default)
                           1: write noise intensity files (file name(s) automatically defined)
                         NOTE: when noise intensity files are written, noise power correction will NOT be applied to the SLC data values


        """

        if self.validate_inputs:
            self._validate_par_RCM_SLC_ScanSAR(
                RCM_dir,
                polarization,
                radcal,
                noise_in,
                root_name,
                SLC_tab,
                beam,
                noise_out,
            )

        if self.mock_outputs:
            self._mock_par_RCM_SLC_ScanSAR_outputs(
                RCM_dir,
                polarization,
                radcal,
                noise_in,
                root_name,
                SLC_tab,
                beam,
                noise_out,
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RCM_SLC_ScanSAR))
        result = self._gamma_call("ISP", "par_RCM_SLC_ScanSAR", ca)

        assert root_name.exists(), f"{root_name} does not exist"
        assert root_name.stat().st_size > 0, f"{root_name} has zero file size"

        if SLC_tab is not None:
            assert SLC_tab.exists(), f"{SLC_tab} does not exist"
            assert SLC_tab.stat().st_size > 0, f"{SLC_tab} has zero file size"

        return result

    def _validate_offset_add(
        self, OFF_par1: Path, OFF_par2: Path, OFF_par3: Path
    ) -> None:
        """

        Validate the arguments to offset_add.

        """

        assert OFF_par1.exists(), f"{OFF_par1} does not exist"
        assert OFF_par1.stat().st_size > 0, f"{OFF_par1} has zero file size"

        assert OFF_par2.exists(), f"{OFF_par2} does not exist"
        assert OFF_par2.stat().st_size > 0, f"{OFF_par2} has zero file size"

        assert not OFF_par3.exists(), f"{OFF_par3} should _not_ exist!"

    def _mock_offset_add_outputs(
        self, OFF_par1: Path, OFF_par2: Path, OFF_par3: Path
    ) -> None:
        """

        Mock the program offset_add.

        """

        if OFF_par3 is not None and str(OFF_par3) != "-":
            OFF_par3.touch()

    def offset_add(
        self, OFF_par1: Path, OFF_par2: Path, OFF_par3: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Add range and azimuth offset polynomial coefficients


        input parameters:
          OFF_par1  (input) ISP offset/interferogram parameter file
          OFF_par2  (input) ISP offset/interferogram parameter file
          OFF_par3  (output) ISP offset/interferogram parameter file with sums of the
                    range and azimuth offset polynomials in OFF_par1 and OFF_par2


        """

        if self.validate_inputs:
            self._validate_offset_add(OFF_par1, OFF_par2, OFF_par3)

        if self.mock_outputs:
            self._mock_offset_add_outputs(OFF_par1, OFF_par2, OFF_par3)

        ca = self._clean_args(locals(), inspect.signature(self.offset_add))
        result = self._gamma_call("ISP", "offset_add", ca)

        assert OFF_par3.exists(), f"{OFF_par3} does not exist"
        assert OFF_par3.stat().st_size > 0, f"{OFF_par3} has zero file size"

        return result

    def _validate_multi_SLC_WSS(
        self, SLC: Path, SLC_par: Path, MLI: Path, MLI_par: Path
    ) -> None:
        """

        Validate the arguments to multi_SLC_WSS.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not MLI.exists(), f"{MLI} should _not_ exist!"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

    def _mock_multi_SLC_WSS_outputs(
        self, SLC: Path, SLC_par: Path, MLI: Path, MLI_par: Path
    ) -> None:
        """

        Mock the program multi_SLC_WSS.

        """

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def multi_SLC_WSS(
        self, SLC: Path, SLC_par: Path, MLI: Path, MLI_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate multi-look intensity image (MLI) from a ASAR Wide-Swath SLC


        input parameters:
          SLC      (input) ASAR Wide-Swath SLC image
          SLC_par  (input) ASAR Wide-Swath SLC image parameter file
          MLI      (output) multi-look intensity image
          MLI_par  (output) MLI image parameter file

        """

        if self.validate_inputs:
            self._validate_multi_SLC_WSS(SLC, SLC_par, MLI, MLI_par)

        if self.mock_outputs:
            self._mock_multi_SLC_WSS_outputs(SLC, SLC_par, MLI, MLI_par)

        ca = self._clean_args(locals(), inspect.signature(self.multi_SLC_WSS))
        result = self._gamma_call("ISP", "multi_SLC_WSS", ca)

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        return result

    def _validate_doppler_2d_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        dop2d: Optional[Path] = None,
        loff: Optional[int] = None,
        blsz: Optional[int] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to doppler_2d_SLC.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if dop2d is not None:
            assert not dop2d.exists(), f"{dop2d} should _not_ exist!"

    def _mock_doppler_2d_SLC_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        dop2d: Optional[Path] = None,
        loff: Optional[int] = None,
        blsz: Optional[int] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> None:
        """

        Mock the program doppler_2d_SLC.

        """

        if dop2d is not None and str(dop2d) != "-":
            dop2d.touch()

    def doppler_2d_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        dop2d: Optional[Path] = None,
        loff: Optional[int] = None,
        blsz: Optional[int] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        2-D Doppler centroid trend estimation from SLC data


        input parameters:
          SLC      (input) SLC image (SCOMPLEX or FCOMPLEX format)
          SLC_par  (input) SLC parameter file
          dop2d    (output) estimated doppler centroid as a function of range for each block (text format) (enter - for none)
          loff     number of lines offset (enter - for default: 0)
          blsz     block size lines, minimum: 256 (enter - for default: 2048)
          nbl      number of blocks (enter - for default: calculated automatically)
          a2_flg   fit a2 for second derivative of the Doppler centroid w.r.t.range (Hz/m/m) (enter - for default)
                     0: no (default)
                     1: yes
          b0_flg   fit b0 for first derivative of the Doppler centroid w.r.t. along-track time (Hz/sec) (enter - for default)
                     0: no
                     1: yes (default)
          b1_flg   fit b1 for along-track rate of the change in slope of Doppler w.r.t. range (Hz/sec/m)(enter - for default)
                     0: no
                     1: yes (default)
          c0_flg   fit c0 for second derivative of the Doppler centroid w.r.t. along-track time (Hz/sec/sec) (enter - for default)
                     0: no (default)
                     1: yes
          namb     user defined number of Doppler ambiguities to add to the Doppler function (enter - for default: 0)


        """

        if self.validate_inputs:
            self._validate_doppler_2d_SLC(
                SLC, SLC_par, dop2d, loff, blsz, nbl, a2_flg, b0_flg, b1_flg, c0_flg, namb
            )

        if self.mock_outputs:
            self._mock_doppler_2d_SLC_outputs(
                SLC, SLC_par, dop2d, loff, blsz, nbl, a2_flg, b0_flg, b1_flg, c0_flg, namb
            )

        ca = self._clean_args(locals(), inspect.signature(self.doppler_2d_SLC))
        result = self._gamma_call("ISP", "doppler_2d_SLC", ca)

        if dop2d is not None:
            assert dop2d.exists(), f"{dop2d} does not exist"
            assert dop2d.stat().st_size > 0, f"{dop2d} has zero file size"

        return result

    def _validate_SLC_cat_ScanSAR(
        self, SLC_tab1: Path, SLC_tab2: Path, SLC_tab3: Path
    ) -> None:
        """

        Validate the arguments to SLC_cat_ScanSAR.

        """

        assert SLC_tab1.exists(), f"{SLC_tab1} does not exist"
        assert SLC_tab1.stat().st_size > 0, f"{SLC_tab1} has zero file size"

        self._check_tab_file(SLC_tab1, "SLC_tab1")

        assert SLC_tab2.exists(), f"{SLC_tab2} does not exist"
        assert SLC_tab2.stat().st_size > 0, f"{SLC_tab2} has zero file size"

        self._check_tab_file(SLC_tab2, "SLC_tab2")

    def _mock_SLC_cat_ScanSAR_outputs(
        self, SLC_tab1: Path, SLC_tab2: Path, SLC_tab3: Path
    ) -> None:
        """

        Mock the program SLC_cat_ScanSAR.

        """
        pass

    def SLC_cat_ScanSAR(
        self, SLC_tab1: Path, SLC_tab2: Path, SLC_tab3: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Concatenate sequential ScanSAR burst SLC images


        input parameters:
          SLC_tab1  (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range (earlier time)
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par
          SLC_tab2  (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range (later time)
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par
          SLC_tab3  (input) 3 column list of concatenated ScanSAR SLC, swaths are listed in order from near to far range
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par


        """

        if self.validate_inputs:
            self._validate_SLC_cat_ScanSAR(SLC_tab1, SLC_tab2, SLC_tab3)

        if self.mock_outputs:
            self._mock_SLC_cat_ScanSAR_outputs(SLC_tab1, SLC_tab2, SLC_tab3)

        ca = self._clean_args(locals(), inspect.signature(self.SLC_cat_ScanSAR))
        result = self._gamma_call("ISP", "SLC_cat_ScanSAR", ca)
        return result

    def _validate_par_RSAT_SLC(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        sc_dB: Optional[int] = None,
        dt: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_RSAT_SLC.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_RSAT_SLC_outputs(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        sc_dB: Optional[int] = None,
        dt: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_RSAT_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_RSAT_SLC(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        sc_dB: Optional[int] = None,
        dt: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file for RSI/Atlantis/ASF processed Radarsat SLC data


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file (example: lea_01.001)
          SLC_par      (output) ISP SLC parameter file (example: <date>.slc.par)
          CEOS_data    (input) CEOS data file (example: dat_01.001)
          SLC          (output) SLC data with file and line headers removed (example: <date>.slc)
          sc_dB        intensity scale factor in dB (enter - for default:  60.00)
          dt           azimuth image time offset (s) (enter - for default = 0.0)


        """

        if self.validate_inputs:
            self._validate_par_RSAT_SLC(CEOS_leader, SLC_par, CEOS_data, SLC, sc_dB, dt)

        if self.mock_outputs:
            self._mock_par_RSAT_SLC_outputs(
                CEOS_leader, SLC_par, CEOS_data, SLC, sc_dB, dt
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RSAT_SLC))
        result = self._gamma_call("ISP", "par_RSAT_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_base_est_fft(
        self,
        interf: Path,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        nazfft: Optional[int] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[int] = None,
        nrfft: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to base_est_fft.

        """

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not baseline.exists(), f"{baseline} should _not_ exist!"

    def _mock_base_est_fft_outputs(
        self,
        interf: Path,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        nazfft: Optional[int] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[int] = None,
        nrfft: Optional[int] = None,
    ) -> None:
        """

        Mock the program base_est_fft.

        """

        if baseline is not None and str(baseline) != "-":
            baseline.touch()

    def base_est_fft(
        self,
        interf: Path,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        nazfft: Optional[int] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[int] = None,
        nrfft: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate baseline from interferogram phase spectrum

        input parameters:
          interf    (input) multilook interferogram with residual range and azimuth fringes
          SLC1_par  (input) SLC-1 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          baseline  (output) baseline file
          nazfft    size of azimuth FFT (2**N) (default: 512)
          r_samp    range pixel offset to center of the FFT window (enter - for default: center)
          az_line   line offset from start of the interf. for the  FFT window (enter - for default: center)
          nrfft     size of the range FFT (2**N), minimum: 32 (enter - for default: 512)


        """

        if self.validate_inputs:
            self._validate_base_est_fft(
                interf, SLC1_par, OFF_par, baseline, nazfft, r_samp, az_line, nrfft
            )

        if self.mock_outputs:
            self._mock_base_est_fft_outputs(
                interf, SLC1_par, OFF_par, baseline, nazfft, r_samp, az_line, nrfft
            )

        ca = self._clean_args(locals(), inspect.signature(self.base_est_fft))
        result = self._gamma_call("ISP", "base_est_fft", ca)

        assert baseline.exists(), f"{baseline} does not exist"
        assert baseline.stat().st_size > 0, f"{baseline} has zero file size"

        return result

    def _validate_par_RCM_GRC(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
        SLC_par: Optional[Path] = None,
        SLC: Optional[Path] = None,
        GRC_par: Optional[Path] = None,
        GRC: Optional[Path] = None,
        rps: Optional[int] = None,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_RCM_GRC.

        """

        assert RCM_dir.exists(), f"{RCM_dir} does not exist"
        assert RCM_dir.stat().st_size > 0, f"{RCM_dir} has zero file size"

        if SLC_par is not None:
            assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

        if GRC_par is not None:
            assert not GRC_par.exists(), f"{GRC_par} should _not_ exist!"

        if GRC is not None:
            assert not GRC.exists(), f"{GRC} should _not_ exist!"

        if noise_pwr is not None:
            assert not noise_pwr.exists(), f"{noise_pwr} should _not_ exist!"

    def _mock_par_RCM_GRC_outputs(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
        SLC_par: Optional[Path] = None,
        SLC: Optional[Path] = None,
        GRC_par: Optional[Path] = None,
        GRC: Optional[Path] = None,
        rps: Optional[int] = None,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_RCM_GRC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

        if GRC_par is not None and str(GRC_par) != "-":
            GRC_par.touch()

        if GRC is not None and str(GRC) != "-":
            GRC.touch()

        if noise_pwr is not None and str(noise_pwr) != "-":
            noise_pwr.touch()

    def par_RCM_GRC(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
        SLC_par: Optional[Path] = None,
        SLC: Optional[Path] = None,
        GRC_par: Optional[Path] = None,
        GRC: Optional[Path] = None,
        rps: Optional[int] = None,
        noise_pwr: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate slant and ground range complex images and parameter files from a Radarsat Constellation GRC (Ground Range georeferenced Complex) product


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM3_OK1001322_PK1001415_1_5M4_20160417_004803_VV_GRC)
          polarization   image polarization: HH, VV, HV, VH, CH, CV
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise          noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          SLC_par        (output) SLC parameter file (example: yyyymmdd_pp.slc.par, enter - for none)
          SLC            (output) SLC data file in slant range geometry (example: yyyymmdd_pp.slc, enter - for none)
          GRC_par        (output) GRC parameter file (example: yyyymmdd_pp.grc.par, enter - for none)
          GRC            (output) GRC data file (example: yyyymmdd_pp.grc, enter - for none)
          rps            slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)
          noise_pwr      (output) noise intensity for each SLC sample in slant range using data from noise levels file (enter - for none)
                         NOTE: when the noise_pwr file is specified, noise power correction will NOT be applied to the GRC / SLC data values


        """

        if self.validate_inputs:
            self._validate_par_RCM_GRC(
                RCM_dir,
                polarization,
                radcal,
                noise,
                SLC_par,
                SLC,
                GRC_par,
                GRC,
                rps,
                noise_pwr,
            )

        if self.mock_outputs:
            self._mock_par_RCM_GRC_outputs(
                RCM_dir,
                polarization,
                radcal,
                noise,
                SLC_par,
                SLC,
                GRC_par,
                GRC,
                rps,
                noise_pwr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RCM_GRC))
        result = self._gamma_call("ISP", "par_RCM_GRC", ca)

        if SLC_par is not None:
            assert SLC_par.exists(), f"{SLC_par} does not exist"
            assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        if GRC_par is not None:
            assert GRC_par.exists(), f"{GRC_par} does not exist"
            assert GRC_par.stat().st_size > 0, f"{GRC_par} has zero file size"

        if GRC is not None:
            assert GRC.exists(), f"{GRC} does not exist"
            assert GRC.stat().st_size > 0, f"{GRC} has zero file size"

        if noise_pwr is not None:
            assert noise_pwr.exists(), f"{noise_pwr} does not exist"
            assert noise_pwr.stat().st_size > 0, f"{noise_pwr} has zero file size"

        return result

    def _validate_base_orbit(
        self, SLC1_par: Path, SLC2_par: Path, baseline: Path
    ) -> None:
        """

        Validate the arguments to base_orbit.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert not baseline.exists(), f"{baseline} should _not_ exist!"

    def _mock_base_orbit_outputs(
        self, SLC1_par: Path, SLC2_par: Path, baseline: Path
    ) -> None:
        """

        Mock the program base_orbit.

        """

        if baseline is not None and str(baseline) != "-":
            baseline.touch()

    def base_orbit(
        self, SLC1_par: Path, SLC2_par: Path, baseline: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate baseline from orbit state vectors


        input parameters:
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          baseline  (output) baseline file (text format, enter - for none)


        """

        if self.validate_inputs:
            self._validate_base_orbit(SLC1_par, SLC2_par, baseline)

        if self.mock_outputs:
            self._mock_base_orbit_outputs(SLC1_par, SLC2_par, baseline)

        ca = self._clean_args(locals(), inspect.signature(self.base_orbit))
        result = self._gamma_call("ISP", "base_orbit", ca)

        assert baseline.exists(), f"{baseline} does not exist"
        assert baseline.stat().st_size > 0, f"{baseline} has zero file size"

        return result

    def _validate_par_KS_DGM(
        self,
    ) -> None:
        """

        Validate the arguments to par_KS_DGM.

        """

        pass

    def _mock_par_KS_DGM_outputs(
        self,
    ) -> None:
        """

        Mock the program par_KS_DGM.

        """
        pass

    def par_KS_DGM(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        dyld[70967]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_KS_DGM'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)

        """

        if self.validate_inputs:
            self._validate_par_KS_DGM()

        if self.mock_outputs:
            self._mock_par_KS_DGM_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.par_KS_DGM))
        result = self._gamma_call("ISP", "par_KS_DGM", ca)
        return result

    def _validate_bpf_ssi_S1(
        self,
    ) -> None:
        """

        Validate the arguments to bpf_ssi_S1.

        """

        pass

    def _mock_bpf_ssi_S1_outputs(
        self,
    ) -> None:
        """

        Mock the program bpf_ssi_S1.

        """
        pass

    def bpf_ssi_S1(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        bpf_ssi_S1: Apply band-pass filtering for split-spectrum interferometry for S1 TOPS data


               SLC_tab             (input) SLC_tab
               SLC_tab_flow        (output) output SLC_tab filename for low frequency band filtered SLC
               SLC_tab_high        (output) output SLC_tab filename for high frequency band filtered SLC
               rbs                 relative range spectrum band separation (default = 0.6666 --> lowest and highest third of processing bandwidth)

                                   indicate - for the output files to only calculate filtering parameters
                                   The filename in SLC_tab_flow and SLC_tab_high are automatically generated by adding .flow and .fhigh

        """

        if self.validate_inputs:
            self._validate_bpf_ssi_S1()

        if self.mock_outputs:
            self._mock_bpf_ssi_S1_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.bpf_ssi_S1))
        result = self._gamma_call("ISP", "bpf_ssi_S1", ca)
        return result

    def _validate_INTF_SLC(
        self,
    ) -> None:
        """

        Validate the arguments to INTF_SLC.

        """

        pass

    def _mock_INTF_SLC_outputs(
        self,
    ) -> None:
        """

        Mock the program INTF_SLC.

        """
        pass

    def INTF_SLC(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        INTF_SLC: calculate interferogram, co-registered SLC, intensity images, and correlation

               pass1       pass 1 identifier (example: pass number) reference
               pass2       pass 2 identifier (example: pass number)
               rlks        number of range looks
               azlks       number of azimuth looks
               algorithm   algorithm used to determine offsets:
                           1=intensity image cross correlation (default)
                           2=fringe visibility
               cc_win      window used for estimation of the correlation coefficient (default=3)
               r_pos       range position of center of image patch for initial offset
               az_pos      azimuth position of center of image patch for initial offset


        """

        if self.validate_inputs:
            self._validate_INTF_SLC()

        if self.mock_outputs:
            self._mock_INTF_SLC_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.INTF_SLC))
        result = self._gamma_call("ISP", "INTF_SLC", ca)
        return result

    def _validate_par_RSI_ERS(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        """

        Validate the arguments to par_RSI_ERS.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

    def _mock_par_RSI_ERS_outputs(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        """

        Mock the program par_RSI_ERS.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_RSI_ERS(
        self, CEOS_SAR_leader: Path, SLC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file for RSI processed ERS SLC data


        input parameters:
        CEOS_SAR_leader (input) ERS CEOS SAR leader file
        SLC_par         (output) ISP SLC parameter file (example <orbit>.slc.par)


        """

        if self.validate_inputs:
            self._validate_par_RSI_ERS(CEOS_SAR_leader, SLC_par)

        if self.mock_outputs:
            self._mock_par_RSI_ERS_outputs(CEOS_SAR_leader, SLC_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_RSI_ERS))
        result = self._gamma_call("ISP", "par_RSI_ERS", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_af_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        thres: Optional[float] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to af_SLC.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

    def _mock_af_SLC_outputs(
        self,
        SLC_par: Path,
        SLC: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        thres: Optional[float] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
    ) -> None:
        """

        Mock the program af_SLC.

        """

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

    def af_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        dr: Optional[int] = None,
        daz: Optional[int] = None,
        thres: Optional[float] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Focus testing for SLC data using autofocus estimation of effective velocity


        input parameters:
          SLC_par    (input) ISP SLC image parameter file
          SLC        (input) single-look complex image
          rwin       range window size (enter - for default: 1024)
          azwin      azimuth window size (enter - for default: 4096)
          dr         range sample increment (enter - for default: 1024,  enter 0 for single patch)
          daz        azimuth line increment (enter - for default: 8192,  enter 0 for single patch)
          thres      offset estimation SNR threshold (enter - for default: 10.000)
          a1_flg     fit a1 for first derivative of the effective velocity w.r.t.range
                       0: no (default)
                       1: yes
          b0_flg     fit b0 for first derivative of the effective velocity w.r.t. along-track time
                       0: no (default)
                       1: yes
          offsets    (output) range and azimuth offsets and SNR data in text format, enter - for no output
          n_ovr      SLC oversampling factor (1,2,4: enter - for default: 1)
          roff       range offset for single patch center
          azoff      azimuth offset for single patch center

        """

        if self.validate_inputs:
            self._validate_af_SLC(
                SLC_par,
                SLC,
                rwin,
                azwin,
                dr,
                daz,
                thres,
                a1_flg,
                b0_flg,
                offsets,
                n_ovr,
                roff,
                azoff,
            )

        if self.mock_outputs:
            self._mock_af_SLC_outputs(
                SLC_par,
                SLC,
                rwin,
                azwin,
                dr,
                daz,
                thres,
                a1_flg,
                b0_flg,
                offsets,
                n_ovr,
                roff,
                azoff,
            )

        ca = self._clean_args(locals(), inspect.signature(self.af_SLC))
        result = self._gamma_call("ISP", "af_SLC", ca)

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        return result

    def _validate_par_EORC_JERS_SLC(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_data: Optional[Path] = None
    ) -> None:
        """

        Validate the arguments to par_EORC_JERS_SLC.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if CEOS_data is not None:
            assert CEOS_data.exists(), f"{CEOS_data} does not exist"
            assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

    def _mock_par_EORC_JERS_SLC_outputs(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_data: Optional[Path] = None
    ) -> None:
        """

        Mock the program par_EORC_JERS_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_EORC_JERS_SLC(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_data: Optional[Path] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Reformat EORC processed JERS-1 SLC and generate the ISP parameter file


        input parameters:
          CEOS_SAR_leader  (input) CEOS SAR leader file for JERS SLC processed by EORC
          SLC_par          (output) ISP image parameter file
          CEOS_data        (input) CEOS format SLC data (IMOP_01.DAT, enter - for none)
          SLC              (output) reformated JERS SLC (example: yyyymmdd.slc, enter - for none)

        """

        if self.validate_inputs:
            self._validate_par_EORC_JERS_SLC(CEOS_SAR_leader, SLC_par, CEOS_data)

        if self.mock_outputs:
            self._mock_par_EORC_JERS_SLC_outputs(CEOS_SAR_leader, SLC_par, CEOS_data)

        ca = self._clean_args(locals(), inspect.signature(self.par_EORC_JERS_SLC))
        result = self._gamma_call("ISP", "par_EORC_JERS_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_fill_gaps(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        method: Optional[int] = None,
        max_dist: Optional[int] = None,
        bp_flag: Optional[int] = None,
        win: Optional[int] = None,
        ds_method: Optional[int] = None,
        ds_size: Optional[int] = None,
        ds_data: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to fill_gaps.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

        if ds_data is not None:
            assert not ds_data.exists(), f"{ds_data} should _not_ exist!"

    def _mock_fill_gaps_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        method: Optional[int] = None,
        max_dist: Optional[int] = None,
        bp_flag: Optional[int] = None,
        win: Optional[int] = None,
        ds_method: Optional[int] = None,
        ds_size: Optional[int] = None,
        ds_data: Optional[Path] = None,
    ) -> None:
        """

        Mock the program fill_gaps.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

        if ds_data is not None and str(ds_data) != "-":
            ds_data.touch()

    def fill_gaps(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        method: Optional[int] = None,
        max_dist: Optional[int] = None,
        bp_flag: Optional[int] = None,
        win: Optional[int] = None,
        ds_method: Optional[int] = None,
        ds_size: Optional[int] = None,
        ds_data: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Fill gaps in 2D raster file


        input parameters:
          data_in     (input) input data file (FLOAT / FCOMPLEX)
          width       width of input data
          data_out    (output) output data file (FLOAT / FCOMPLEX)
          dtype       input and output data type (enter - for default)
                        0: FLOAT (default)
                        1: FCOMPLEX
          method      method flag (enter - for default: 4)
                        0: Laplace interpolation and linear extrapolation - least squares solution
                        1: Laplace interpolation and linear extrapolation - smaller system of linear equations than in method #0 in case of few missing values - least squares solution
                        2: Laplace interpolation and linear extrapolation - solves a direct linear system of equations for the missing values (not a least squares solution)
                        3: biharmonic interpolation - implementation similar to method #1 - least squares solution
                        4: spring analogy: assumes springs (with a nominal length of zero) connect each node with every neighbor - least squares solution (default)
                        5: average of the 8 nearest neighbors - this method solves a direct linear system for the missing values (not a least squares solution)
                      NOTE: small gaps: use method #0, #1 or #3 - large gaps: use method #2, #4 or #5 - most demanding: method #3
          max_dist    maximum interpolation / extrapolation distance in pixels (enter - or 0 for default: unlimited)
          bp_flag     perform block processing (enter - for default: 0)
                        0: no block processing (default)
                        1: block processing (faster, avoid overflow, however might be slightly less accurate)
                      NOTE: when block processing is selected, a two-step process is carried out: 1: solving the downsampled array (coarse processing), 2: block processing
          win         block size (pixels, 10 < win < 1000, enter - for default: 100)
          ds_method   method flag (0 - 5, same choices as for [method] option) (enter - for default: same as [method])
                      NOTE: for an input containing large gaps, method #2, #4 or #5 may yield more appropriate results.
          ds_size     maximum size of downsampled data (for both width and height) (pixels, ds_size > 10, enter - for default: 400)
          ds_data     (output) write intermediate data after solving the downsampled array (FLOAT / FCOMPLEX)


        """

        if self.validate_inputs:
            self._validate_fill_gaps(
                data_in,
                width,
                data_out,
                dtype,
                method,
                max_dist,
                bp_flag,
                win,
                ds_method,
                ds_size,
                ds_data,
            )

        if self.mock_outputs:
            self._mock_fill_gaps_outputs(
                data_in,
                width,
                data_out,
                dtype,
                method,
                max_dist,
                bp_flag,
                win,
                ds_method,
                ds_size,
                ds_data,
            )

        ca = self._clean_args(locals(), inspect.signature(self.fill_gaps))
        result = self._gamma_call("ISP", "fill_gaps", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        if ds_data is not None:
            assert ds_data.exists(), f"{ds_data} does not exist"
            assert ds_data.stat().st_size > 0, f"{ds_data} has zero file size"

        return result

    def _validate_S1_GRD_preproc(
        self,
    ) -> None:
        """

        Validate the arguments to S1_GRD_preproc.

        """

        pass

    def _mock_S1_GRD_preproc_outputs(
        self,
    ) -> None:
        """

        Mock the program S1_GRD_preproc.

        """
        pass

    def S1_GRD_preproc(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Preprocessing of Sentinel-1 TOPS GRD products, extract GRD data and generate MLI prodcuts

          S1_list  (input) single column text file. Entries are directories (including path) containing Sentinel-1 TOPS GRD products
          MLI_dir  directory for output SLC data files and SLC parameter files
                   NOTE: output file names have the form : 20150119_hh.mli
          pol      SLC polarization to extract (hh,hv,vh,vv)
          log      (output) S1 GRD pre-processing log file

          -c       (option) apply radiometric calibration factor without noise subtraction
          -n       (option) apply radiometric calibration factor with noise subtraction
          -t       (option) include full timestamp YYYYMMDDtHHMMSSin SLC and SLC_par filenames, default YYYYMMDD

        """

        if self.validate_inputs:
            self._validate_S1_GRD_preproc()

        if self.mock_outputs:
            self._mock_S1_GRD_preproc_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.S1_GRD_preproc))
        result = self._gamma_call("ISP", "S1_GRD_preproc", ca)
        return result

    def _validate_rascc_mask_thinning(
        self,
        ras_in: Path,
        in_file: Path,
        width: int,
        ras_out: Path,
        nmax: Optional[int] = None,
        thresh_1: Optional[int] = None,
        thresh_nmax: Optional[float] = None,
        *args,
    ) -> None:
        """

        Validate the arguments to rascc_mask_thinning.

        """

        assert ras_in.exists(), f"{ras_in} does not exist"
        assert ras_in.stat().st_size > 0, f"{ras_in} has zero file size"

        assert in_file.exists(), f"{in_file} does not exist"
        assert in_file.stat().st_size > 0, f"{in_file} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

    def _mock_rascc_mask_thinning_outputs(
        self,
        ras_in: Path,
        in_file: Path,
        width: int,
        ras_out: Path,
        nmax: Optional[int] = None,
        thresh_1: Optional[int] = None,
        thresh_nmax: Optional[float] = None,
        *args,
    ) -> None:
        """

        Mock the program rascc_mask_thinning.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def rascc_mask_thinning(
        self,
        ras_in: Path,
        in_file: Path,
        width: int,
        ras_out: Path,
        nmax: Optional[int] = None,
        thresh_1: Optional[int] = None,
        thresh_nmax: Optional[float] = None,
        *args,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Adaptive sampling reduction for phase unwrapping validity mask


        input parameters:
          ras_in       (input) validity mask (SUN/BMP/TIFF raster format 8-bit image)
          in_file      (input) file used for adaptive sampling reduction, e.g. correlation coefficient (float)
          width        number of samples/row of in_file
          ras_out      (output) validity mask with reduced sampling (8-bit SUN rasterfile or BMP format image)
          nmax         number of sampling reduction runs (default: 3)
          thresh_1     first threshold (used for smallest scale sampling reduction)
          ...          further thresholds
          thresh_nmax  threshold nmax (used for largest scale sampling reduction)


        """

        if self.validate_inputs:
            self._validate_rascc_mask_thinning(
                ras_in, in_file, width, ras_out, nmax, thresh_1, thresh_nmax, *args
            )

        if self.mock_outputs:
            self._mock_rascc_mask_thinning_outputs(
                ras_in, in_file, width, ras_out, nmax, thresh_1, thresh_nmax, *args
            )

        ca = self._clean_args(locals(), inspect.signature(self.rascc_mask_thinning))
        result = self._gamma_call("ISP", "rascc_mask_thinning", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_mk_ptarg(
        self,
    ) -> None:
        """

        Validate the arguments to mk_ptarg.

        """

        pass

    def _mock_mk_ptarg_outputs(
        self,
    ) -> None:
        """

        Mock the program mk_ptarg.

        """
        pass

    def mk_ptarg(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/mk_ptarg
        Perform point target analysis on a stack of coregistered SLCs


            RSLC_tab  (input) two column list of coregistered SLC filenames and SLC parameter filenames (including paths) (ascii)
                        1. SLC filename  (includes path)
                        2. SLC parameter filename (includes path)
            cal_dir   directory for output calibration results
            r_samp    (input) calibration target range sample number
            az_samp   (input) calibration target azimuth line number
            osf       SLC over-sampling factor 2, 4, 8, 16, 32, 64 (default: 16)
            -s scale  (option) set image display scale factor (default: 0.3)
            -e exp    (option) set image display exponent (default: 0.5)

        """

        if self.validate_inputs:
            self._validate_mk_ptarg()

        if self.mock_outputs:
            self._mock_mk_ptarg_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.mk_ptarg))
        result = self._gamma_call("ISP", "mk_ptarg", ca)
        return result

    def _validate_GRD_to_SR(
        self,
        GRD_par: Path,
        OFF_par: Optional[Path],
        in_file: Path,
        out_file: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        interp_mode: Optional[int] = None,
        sr_rsp: Optional[int] = None,
        sr_azsp: Optional[int] = None,
        degree: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to GRD_to_SR.

        """

        assert GRD_par.exists(), f"{GRD_par} does not exist"
        assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert in_file.exists(), f"{in_file} does not exist"
        assert in_file.stat().st_size > 0, f"{in_file} has zero file size"

        assert not out_file.exists(), f"{out_file} should _not_ exist!"

    def _mock_GRD_to_SR_outputs(
        self,
        GRD_par: Path,
        OFF_par: Optional[Path],
        in_file: Path,
        out_file: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        interp_mode: Optional[int] = None,
        sr_rsp: Optional[int] = None,
        sr_azsp: Optional[int] = None,
        degree: Optional[int] = None,
    ) -> None:
        """

        Mock the program GRD_to_SR.

        """

        if out_file is not None and str(out_file) != "-":
            out_file.touch()

    def GRD_to_SR(
        self,
        GRD_par: Path,
        OFF_par: Optional[Path],
        in_file: Path,
        out_file: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        interp_mode: Optional[int] = None,
        sr_rsp: Optional[int] = None,
        sr_azsp: Optional[int] = None,
        degree: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Conversion to slant range for ISP MLI and INSAR ground range data of type FLOAT


        input parameters:
          GRD_par      (input) SLC parameter file of output ground range image
          MLI_par      (input/output) MLI ISP image parameter file for slant range image
                       NOTE: delete an existing MLI parameter file to recalculate the output MLI parameters
          OFF_par      (input) ISP offset/interferogram parameter file of input image (enter - image in MLI geometry)
          in_file      (input) ground range image (FLOAT)
          out_file     (output) slant range image (FLOAT)
          rlks         multi-looking in range (prior to resampling, enter - for default: 1)
          azlks        multi-looking in azimuth (prior to resampling, enter - for default: 1)
          interp_mode  interpolation mode (enter - for default)
                         0: nearest-neighbor
                         1: bicubic spline
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 3)
                         5: B-spline interpolation sqrt(x) (default) (default B-spline degree: 3)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          sr_rsp       output image slant range sample spacing (m) (enter - for default: c/(2*adc_sampling_rate)
          sr_azsp      output image azimuth sample spacing (m) (enter - for default: (input image azimuth spacing) * azlks)
          degree       B-spline degree (2->9) (enter - for default: 3)


        """

        if self.validate_inputs:
            self._validate_GRD_to_SR(
                GRD_par,
                OFF_par,
                in_file,
                out_file,
                rlks,
                azlks,
                interp_mode,
                sr_rsp,
                sr_azsp,
                degree,
            )

        if self.mock_outputs:
            self._mock_GRD_to_SR_outputs(
                GRD_par,
                OFF_par,
                in_file,
                out_file,
                rlks,
                azlks,
                interp_mode,
                sr_rsp,
                sr_azsp,
                degree,
            )

        ca = self._clean_args(locals(), inspect.signature(self.GRD_to_SR))
        result = self._gamma_call("ISP", "GRD_to_SR", ca)

        assert out_file.exists(), f"{out_file} does not exist"
        assert out_file.stat().st_size > 0, f"{out_file} has zero file size"

        return result

    def _validate_multi_look2(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        r_dec: int,
        az_dec: int,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to multi_look2.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not MLI.exists(), f"{MLI} should _not_ exist!"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

    def _mock_multi_look2_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        r_dec: int,
        az_dec: int,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Mock the program multi_look2.

        """

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def multi_look2(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        r_dec: int,
        az_dec: int,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate an MLI image from an SLC with separate averaging window dimensions and decimation factors


        input parameters:
          SLC      (input) single-look complex image (SCOMPLEX or FCOMPLEX)
          SLC_par  (input) SLC image parameter file
          MLI      (output) multi-look intensity image (FLOAT)
          MLI_par  (output) MLI image parameter file
          r_dec    range decimation factor (int)
          az_dec   azimuth decimation factor (int)
          rwin     averaging window width (int)  (enter - for default: r_dec)
          azwin    averaging window height (int) (enter - for default: az_dec)
          wflg     window weighting function (enter - for default):
                     0: rectangular (default)
                     1: Kaiser
                     2: circular Gaussian
          n_ovr    oversampling factor 1 -> 2 (enter - for default: 1)
          lanczos  Lanczos interpolator order 5 -> 9 (enter - for default: 7)
          beta     Gaussian or Kaiser window parameter (enter - for default: 2.0)
          scale    scale factor for output MLI (enter - for default: 1.0)
          exp      exponent for the output MLI (enter - for default: 1.0)


        """

        if self.validate_inputs:
            self._validate_multi_look2(
                SLC,
                SLC_par,
                MLI,
                MLI_par,
                r_dec,
                az_dec,
                rwin,
                azwin,
                wflg,
                n_ovr,
                lanczos,
                beta,
                scale,
                exp,
            )

        if self.mock_outputs:
            self._mock_multi_look2_outputs(
                SLC,
                SLC_par,
                MLI,
                MLI_par,
                r_dec,
                az_dec,
                rwin,
                azwin,
                wflg,
                n_ovr,
                lanczos,
                beta,
                scale,
                exp,
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_look2))
        result = self._gamma_call("ISP", "multi_look2", ca)

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        return result

    def _validate_dcomp_sirc(
        self,
        infile: Path,
        outfile: Path,
        samples: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dcomp_sirc.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_dcomp_sirc_outputs(
        self,
        infile: Path,
        outfile: Path,
        samples: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program dcomp_sirc.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def dcomp_sirc(
        self,
        infile: Path,
        outfile: Path,
        samples: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract SIR-C SLC compressed single-pol data


        input parameters:
          infile     (input) SIR-C single-pol SLC compressed data
          outfile    (output) complex floating point data
          samples    number of polarimetric samples per input line (4 bytes/sample)
          loff       offset to starting line (default: 0)
          nlines     number of lines to copy(default: entire file, 0 = entire file)

        """

        if self.validate_inputs:
            self._validate_dcomp_sirc(infile, outfile, samples, loff, nlines)

        if self.mock_outputs:
            self._mock_dcomp_sirc_outputs(infile, outfile, samples, loff, nlines)

        ca = self._clean_args(locals(), inspect.signature(self.dcomp_sirc))
        result = self._gamma_call("ISP", "dcomp_sirc", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_subtract_phase(
        self,
        interf_in: Path,
        phase_file: Path,
        interf_out: Path,
        width: int,
        factor: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to subtract_phase.

        """

        assert interf_in.exists(), f"{interf_in} does not exist"
        assert interf_in.stat().st_size > 0, f"{interf_in} has zero file size"

        assert phase_file.exists(), f"{phase_file} does not exist"
        assert phase_file.stat().st_size > 0, f"{phase_file} has zero file size"

        assert not interf_out.exists(), f"{interf_out} should _not_ exist!"

    def _mock_subtract_phase_outputs(
        self,
        interf_in: Path,
        phase_file: Path,
        interf_out: Path,
        width: int,
        factor: Optional[int] = None,
    ) -> None:
        """

        Mock the program subtract_phase.

        """

        if interf_out is not None and str(interf_out) != "-":
            interf_out.touch()

    def subtract_phase(
        self,
        interf_in: Path,
        phase_file: Path,
        interf_out: Path,
        width: int,
        factor: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/subtract_phase
        Subtract scaled phase image from a complex interferogram


        input parameters:
          interf_in   (input) input interferogram (fcomplex format)
          phase_file  (input) unwrapped interferometric phase (float)
          interf_out  (output) output interferogram (input interferogram - scaled phase) (fcomplex)
          width       number of samples/line
          factor      constant scale factor for input phase data [default=1.0]


        """

        if self.validate_inputs:
            self._validate_subtract_phase(
                interf_in, phase_file, interf_out, width, factor
            )

        if self.mock_outputs:
            self._mock_subtract_phase_outputs(
                interf_in, phase_file, interf_out, width, factor
            )

        ca = self._clean_args(locals(), inspect.signature(self.subtract_phase))
        result = self._gamma_call("ISP", "subtract_phase", ca)

        assert interf_out.exists(), f"{interf_out} does not exist"
        assert interf_out.stat().st_size > 0, f"{interf_out} has zero file size"

        return result

    def _validate_dcomp_sirc_quad(
        self,
        infile: Path,
        outfile: Path,
        samples: int,
        parameter: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to dcomp_sirc_quad.

        """

        assert infile.exists(), f"{infile} does not exist"
        assert infile.stat().st_size > 0, f"{infile} has zero file size"

        assert not outfile.exists(), f"{outfile} should _not_ exist!"

    def _mock_dcomp_sirc_quad_outputs(
        self,
        infile: Path,
        outfile: Path,
        samples: int,
        parameter: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program dcomp_sirc_quad.

        """

        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def dcomp_sirc_quad(
        self,
        infile: Path,
        outfile: Path,
        samples: int,
        parameter: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract SIR-C MLC or SLC compressed quad-pol data


        input parameters:
          infile     (input) SIR-C SLC or MLC quad-pol compressed data
          outfile    (output) complex floating point data
          samples    number of polarimetric samples per input line (10 bytes/sample)
          parameter  polarimetric parameter to extract from SLC or MLC product:
                       0:  SLC total power
                       1:  SLC-HH
                       2:  SLC-HV
                       3:  SLC-VH
                       4:  SLC-VV
                       5:  MLC total power
                       6:  MLC-HVHV*
                       7:  MLC-VVVV*
                       8:  MLC-HHHH*
                       9:  MLC-HHHV*
                       10: MLC-HHVV*
                       11: MLC-HVVV*
          loff       offset to starting line (default: 0)
          nlines     number of lines to copy(default: entire file, 0 = entire file)

        """

        if self.validate_inputs:
            self._validate_dcomp_sirc_quad(
                infile, outfile, samples, parameter, loff, nlines
            )

        if self.mock_outputs:
            self._mock_dcomp_sirc_quad_outputs(
                infile, outfile, samples, parameter, loff, nlines
            )

        ca = self._clean_args(locals(), inspect.signature(self.dcomp_sirc_quad))
        result = self._gamma_call("ISP", "dcomp_sirc_quad", ca)

        assert outfile.exists(), f"{outfile} does not exist"
        assert outfile.stat().st_size > 0, f"{outfile} has zero file size"

        return result

    def _validate_SLC_copy_ScanSAR(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        BURST_tab: Path,
        dtype: Optional[int] = None,
        SLC2_dir: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_copy_ScanSAR.

        """

        assert SLC1_tab.exists(), f"{SLC1_tab} does not exist"
        assert SLC1_tab.stat().st_size > 0, f"{SLC1_tab} has zero file size"

        self._check_tab_file(SLC1_tab, "SLC1_tab")

        assert BURST_tab.exists(), f"{BURST_tab} does not exist"
        assert BURST_tab.stat().st_size > 0, f"{BURST_tab} has zero file size"

        self._check_tab_file(BURST_tab, "BURST_tab")

    def _mock_SLC_copy_ScanSAR_outputs(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        BURST_tab: Path,
        dtype: Optional[int] = None,
        SLC2_dir: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_copy_ScanSAR.

        """

        if not SLC2_tab.exists():
            SLC2_tab.touch()

    def SLC_copy_ScanSAR(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        BURST_tab: Path,
        dtype: Optional[int] = None,
        SLC2_dir: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Burst selection and copy from ScanSAR burst data (FCOMPLEX, SCOMPLEX)


        input parameters:
          SLC1_tab   (input) 3 column list of ScanSAR SLC-1 swaths in order from near to far range
                       SLC1_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_tab   (input/output) 3 column list of the burst data copied from the ScanSAR swaths listed in SLC1_tab, in order from near to far range
                       SLC2_tab line entries:   SLC    SLC_par   TOPS_par
                     NOTE: If the SLC2_tab does not yet exist, the SLC2_tab will be created with file names derived from the SLC1_tab entries and the SLC2_dir
                           The new file names will have _2 appended to the root file names of the entries in SLC1_tab
          BURST_tab  (input) 2 column list of the first and last burst to copy from each swath, one line for each swath
                     BURST_tab line entries: first_burst  last_burst
                     NOTES: 1. The first burst is 1, enter - to select last physical burst
                            2. If first_burst <= 0, then blank bursts are generated at the start of the output swath
                            3. If last_burst exceeds the number of bursts, then blank bursts are appended to the end of the output swath
          dtype      output data format for complex data (enter - for default: output data has the same format as input data):
                       0: FCOMPLEX
                       1: SCOMPLEX
          SLC2_dir   directory for ScanSAR burst data copied from SLC-1 data, ignored if the SLC2_tab already exists (default: current directory)


        """

        if self.validate_inputs:
            self._validate_SLC_copy_ScanSAR(
                SLC1_tab, SLC2_tab, BURST_tab, dtype, SLC2_dir
            )

        if self.mock_outputs:
            self._mock_SLC_copy_ScanSAR_outputs(
                SLC1_tab, SLC2_tab, BURST_tab, dtype, SLC2_dir
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_copy_ScanSAR))
        result = self._gamma_call("ISP", "SLC_copy_ScanSAR", ca)

        assert SLC2_tab.exists(), f"{SLC2_tab} does not exist"
        assert SLC2_tab.stat().st_size > 0, f"{SLC2_tab} has zero file size"

        return result

    def _validate_par_RISAT_SLC(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        SLC_par: Path,
        CEOS_image: Path,
        SLC: Optional[Path] = None,
        line_dir: Optional[int] = None,
        pix_dir: Optional[int] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_RISAT_SLC.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert BAND_META.exists(), f"{BAND_META} does not exist"
        assert BAND_META.stat().st_size > 0, f"{BAND_META} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        assert CEOS_image.exists(), f"{CEOS_image} does not exist"
        assert CEOS_image.stat().st_size > 0, f"{CEOS_image} has zero file size"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_RISAT_SLC_outputs(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        SLC_par: Path,
        CEOS_image: Path,
        SLC: Optional[Path] = None,
        line_dir: Optional[int] = None,
        pix_dir: Optional[int] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_RISAT_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_RISAT_SLC(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        SLC_par: Path,
        CEOS_image: Path,
        SLC: Optional[Path] = None,
        line_dir: Optional[int] = None,
        pix_dir: Optional[int] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Read RISAT-1 CEOS format SLC data and perform radiometric calibration


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file (example: lea_01.001)
          BAND_META    (input) BAND_META.txt, additional RISAT system parameters for the scene (format keywork=value)
          SLC_par      (output) ISP SLC image parameter file (example: YYYYMMDD.grd.par)
          CEOS_image   (input) CEOS SLC image file (example: dat_01.001)
          SLC          (output) SLC data with file and line headers removed (enter - for none: example: YYYYMMDD.grd)
          line_dir     set output image line direction (enter - for default):
                         0: used value derived from CEOS leader file
                         1: retain input data line direction  (default)
                        -1: reverse input data line direction
          pix_dir      set output pixel direction (enter - for default):
                         0: used value derived from CEOS leader file
                         1: retain input data pixel direction (default)
                        -1: reverse input data pixel direction
          cal_flg      calibration flag (enter - for default):
                         0: do not apply radiometric calibration
                         1: apply radiometric calibration including KdB and incidence angle correction (default)
          KdB          calibration constant (dB) (enter - to use value in the CEOS leader)


        """

        if self.validate_inputs:
            self._validate_par_RISAT_SLC(
                CEOS_leader,
                BAND_META,
                SLC_par,
                CEOS_image,
                SLC,
                line_dir,
                pix_dir,
                cal_flg,
                KdB,
            )

        if self.mock_outputs:
            self._mock_par_RISAT_SLC_outputs(
                CEOS_leader,
                BAND_META,
                SLC_par,
                CEOS_image,
                SLC,
                line_dir,
                pix_dir,
                cal_flg,
                KdB,
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RISAT_SLC))
        result = self._gamma_call("ISP", "par_RISAT_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_SLC_freq_shift(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_shift: Path,
        SLC_shift_par: Path,
        freq_shift: int,
    ) -> None:
        """

        Validate the arguments to SLC_freq_shift.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not SLC_shift.exists(), f"{SLC_shift} should _not_ exist!"

        assert not SLC_shift_par.exists(), f"{SLC_shift_par} should _not_ exist!"

    def _mock_SLC_freq_shift_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_shift: Path,
        SLC_shift_par: Path,
        freq_shift: int,
    ) -> None:
        """

        Mock the program SLC_freq_shift.

        """

        if SLC_shift is not None and str(SLC_shift) != "-":
            SLC_shift.touch()

        if SLC_shift_par is not None and str(SLC_shift_par) != "-":
            SLC_shift_par.touch()

    def SLC_freq_shift(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_shift: Path,
        SLC_shift_par: Path,
        freq_shift: int,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/SLC_freq_shift
        Shift the effective radar carrier frequency of an SLC image by a specified amount


        input parameters:
          SLC            (input) SLC file (FCOMPLEX or SCOMPLEX)
          SLC_par        (input) SLC parameter file
          SLC_shift      (output) SLC data with shifted radar carrier frequency
          SLC_shift_par  (output) SLC parameter file with shifted radar carrier frequency
          freq_shift     radar carrier frequency shift (Hz)


        """

        if self.validate_inputs:
            self._validate_SLC_freq_shift(
                SLC, SLC_par, SLC_shift, SLC_shift_par, freq_shift
            )

        if self.mock_outputs:
            self._mock_SLC_freq_shift_outputs(
                SLC, SLC_par, SLC_shift, SLC_shift_par, freq_shift
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_freq_shift))
        result = self._gamma_call("ISP", "SLC_freq_shift", ca)

        assert SLC_shift.exists(), f"{SLC_shift} does not exist"
        assert SLC_shift.stat().st_size > 0, f"{SLC_shift} has zero file size"

        assert SLC_shift_par.exists(), f"{SLC_shift_par} does not exist"
        assert SLC_shift_par.stat().st_size > 0, f"{SLC_shift_par} has zero file size"

        return result

    def _validate_DELFT_vec2(
        self,
        SLC_par: Path,
        DELFT_dir: int,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        ODR: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to DELFT_vec2.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

    def _mock_DELFT_vec2_outputs(
        self,
        SLC_par: Path,
        DELFT_dir: int,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        ODR: Optional[int] = None,
    ) -> None:
        """

        Mock the program DELFT_vec2.

        """
        pass

    def DELFT_vec2(
        self,
        SLC_par: Path,
        DELFT_dir: int,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        ODR: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract and interpolate DELFT ERS-1, ERS-2, and ENVISAT state vectors


        input parameters:
          SLC_par    (input) ISP image parameter file
          DELFT_dir  directory containing Delft orbit arclist and ODR files for ERS-1, ERS-2 or ENVISAT
                       NOTE: enter . for current directory
          nstate     number of state vectors to generate (enter - for default (>= 15)
          interval   time interval between state vectors in the ISP image parameter file (s) (default: 10.0)
          ODR        ODR file to use (include path) rather than ODR file determined from the Delft orbit arclist


        """

        if self.validate_inputs:
            self._validate_DELFT_vec2(SLC_par, DELFT_dir, nstate, interval, ODR)

        if self.mock_outputs:
            self._mock_DELFT_vec2_outputs(SLC_par, DELFT_dir, nstate, interval, ODR)

        ca = self._clean_args(locals(), inspect.signature(self.DELFT_vec2))
        result = self._gamma_call("ISP", "DELFT_vec2", ca)
        return result

    def _validate_SLC_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
        SLC_1s: Optional[int] = None,
        SLC_2Rs: Optional[int] = None,
        az_beta: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_intf.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2R.exists(), f"{SLC_2R} does not exist"
        assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not interf.exists(), f"{interf} should _not_ exist!"

    def _mock_SLC_intf_outputs(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
        SLC_1s: Optional[int] = None,
        SLC_2Rs: Optional[int] = None,
        az_beta: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_intf.

        """

        if interf is not None and str(interf) != "-":
            interf.touch()

    def SLC_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
        SLC_1s: Optional[int] = None,
        SLC_2Rs: Optional[int] = None,
        az_beta: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate interferogram from co-registered SLC image data


        input parameters:
          SLC-1      (input) single-look complex image 1 (reference)
          SLC-2R     (input) single-look complex image 2 coregistered to SLC-1
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2R_par  (input) SLC-2R ISP image parameter file for the co-registered image
          OFF_par    (input) ISP offset/interferogram parameter file
          interf     (output) interferogram from SLC-1 and SLC-2R
          rlks       number of range looks
          azlks      number of azimuth looks
          loff       offset to starting line relative to SLC-1 for interferogram (enter - for default: 0)
          nlines     number of SLC lines to process (enter - for default: to end of file)
          sps_flg    range spectral shift flag:
                       1: apply range spectral shift filter (default)
                       0: do not apply range spectral shift filter
          azf_flg    azimuth common band filter flag:
                       1: apply azimuth common-band filter (default)
                       0: do not apply azimuth common band filter
          rp1_flg    SLC-1 range phase mode
                       0: nearest approach (zero-Doppler) phase
                       1: ref. function center (Doppler centroid) (default)
          rp2_flg    SLC-2 range phase mode
                       0: nearest approach (zero-Doppler) phase
                       1: ref. function center (Doppler centroid) (default)
          SLC-1s     SLC-1 after range spectral shift and azimuth common-band filtering (FCOMPLEX format)  (enter - for none)
          SLC-2Rs    SLC-2R after range spectral shift and azimuth common-band filtering (FCOMPLEX format) (enter - for none)
          SLC1s_par  SLC-1s ISP image parameter file (enter - for none)
          SLC2Rs_par SLC-2Rs ISP image parameter file (enter - for none)
          az_beta    azimuth common-band filter Kaiser window parameter (default: 2.120)


        """

        if self.validate_inputs:
            self._validate_SLC_intf(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                interf,
                rlks,
                azlks,
                loff,
                nlines,
                sps_flg,
                azf_flg,
                rp1_flg,
                rp2_flg,
                SLC_1s,
                SLC_2Rs,
                az_beta,
            )

        if self.mock_outputs:
            self._mock_SLC_intf_outputs(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                interf,
                rlks,
                azlks,
                loff,
                nlines,
                sps_flg,
                azf_flg,
                rp1_flg,
                rp2_flg,
                SLC_1s,
                SLC_2Rs,
                az_beta,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_intf))
        result = self._gamma_call("ISP", "SLC_intf", ca)

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        return result

    def _validate_S1_extract_png(
        self,
    ) -> None:
        """

        Validate the arguments to S1_extract_png.

        """

        pass

    def _mock_S1_extract_png_outputs(
        self,
    ) -> None:
        """

        Mock the program S1_extract_png.

        """
        pass

    def S1_extract_png(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        S1_extract_png: Script used to extract (and rename) quicklook (png file) from a S1 ZIP file

               zipfile                (input) Sentinel-1 zipfile (GRD or SLC)


        """

        if self.validate_inputs:
            self._validate_S1_extract_png()

        if self.mock_outputs:
            self._mock_S1_extract_png_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.S1_extract_png))
        result = self._gamma_call("ISP", "S1_extract_png", ca)
        return result

    def _validate_ptarg_cal_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: int,
        az_samp: int,
        psigma: int,
        c_r_samp: int,
        c_az_samp: int,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[int] = None,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
        psz: Optional[int] = None,
        csz: Optional[int] = None,
        c_image: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to ptarg_cal_SLC.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert not ptr_image.exists(), f"{ptr_image} should _not_ exist!"

        assert not r_plot.exists(), f"{r_plot} should _not_ exist!"

        assert not az_plot.exists(), f"{az_plot} should _not_ exist!"

        assert not pcal.exists(), f"{pcal} should _not_ exist!"

        if c_image is not None:
            assert not c_image.exists(), f"{c_image} should _not_ exist!"

    def _mock_ptarg_cal_SLC_outputs(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: int,
        az_samp: int,
        psigma: int,
        c_r_samp: int,
        c_az_samp: int,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[int] = None,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
        psz: Optional[int] = None,
        csz: Optional[int] = None,
        c_image: Optional[Path] = None,
    ) -> None:
        """

        Mock the program ptarg_cal_SLC.

        """

        if ptr_image is not None and str(ptr_image) != "-":
            ptr_image.touch()

        if r_plot is not None and str(r_plot) != "-":
            r_plot.touch()

        if az_plot is not None and str(az_plot) != "-":
            az_plot.touch()

        if pcal is not None and str(pcal) != "-":
            pcal.touch()

        if c_image is not None and str(c_image) != "-":
            c_image.touch()

    def ptarg_cal_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: int,
        az_samp: int,
        psigma: int,
        c_r_samp: int,
        c_az_samp: int,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[int] = None,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
        psz: Optional[int] = None,
        csz: Optional[int] = None,
        c_image: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Point target analysis and radiometric calibration of SLC images


        input parameters:
          SLC_par    (input) SLC image parameter file
          SLC        (input) SLC image in FCOMPLEX or SCOMPLEX format
          r_samp     point target range sample number, target region size is 16x16
          az_samp    point target azimuth line number, target region size is 16x16
          psigma     radar cross-section of the calibration target in m**2
          c_r_samp   clutter region center range sample number, clutter region size is 16x16
          c_az_samp  clutter region center azimuth line number, clutter region size is 16x16
          ptr_image  (output) oversampled point target image, with and without phase gradient, nominal width: 256
          r_plot     (output) range point target response plot data (text format)
          az_plot    (output) azimuth point target response plot data (text format)
          pcal       (output) measured point target parameters and radiometric calibration factor (text format)
          osf        image over-sampling factor, 2, 4, 8, 16, 32, 64 (enter - for default: 16)
          win        maximum search window offset (samples) (enter - for default: 1)
          pltflg     plotting mode flag:
                       0: none
                       1: output plots in PNG format (default)
                       2: screen output
                       3: output plots in PDF format
          psz        point target region size (samples) (enter - for default: 16)
          csz        clutter region size (samples) (enter - for default: 16)
          c_image    (output) clutter region image (FCOMPLEX format)


        """

        if self.validate_inputs:
            self._validate_ptarg_cal_SLC(
                SLC_par,
                SLC,
                r_samp,
                az_samp,
                psigma,
                c_r_samp,
                c_az_samp,
                ptr_image,
                r_plot,
                az_plot,
                pcal,
                osf,
                win,
                pltflg,
                psz,
                csz,
                c_image,
            )

        if self.mock_outputs:
            self._mock_ptarg_cal_SLC_outputs(
                SLC_par,
                SLC,
                r_samp,
                az_samp,
                psigma,
                c_r_samp,
                c_az_samp,
                ptr_image,
                r_plot,
                az_plot,
                pcal,
                osf,
                win,
                pltflg,
                psz,
                csz,
                c_image,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ptarg_cal_SLC))
        result = self._gamma_call("ISP", "ptarg_cal_SLC", ca)

        assert ptr_image.exists(), f"{ptr_image} does not exist"
        assert ptr_image.stat().st_size > 0, f"{ptr_image} has zero file size"

        assert r_plot.exists(), f"{r_plot} does not exist"
        assert r_plot.stat().st_size > 0, f"{r_plot} has zero file size"

        assert az_plot.exists(), f"{az_plot} does not exist"
        assert az_plot.stat().st_size > 0, f"{az_plot} has zero file size"

        assert pcal.exists(), f"{pcal} does not exist"
        assert pcal.stat().st_size > 0, f"{pcal} has zero file size"

        if c_image is not None:
            assert c_image.exists(), f"{c_image} does not exist"
            assert c_image.stat().st_size > 0, f"{c_image} has zero file size"

        return result

    def _validate_sbi_filt(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        SLCf: Path,
        SLCf_par: Path,
        SLCb: Path,
        SLCb_par: Path,
        norm_sq: int,
        iwflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to sbi_filt.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        assert not SLCf.exists(), f"{SLCf} should _not_ exist!"

        assert not SLCf_par.exists(), f"{SLCf_par} should _not_ exist!"

        assert not SLCb.exists(), f"{SLCb} should _not_ exist!"

        assert not SLCb_par.exists(), f"{SLCb_par} should _not_ exist!"

    def _mock_sbi_filt_outputs(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        SLCf: Path,
        SLCf_par: Path,
        SLCb: Path,
        SLCb_par: Path,
        norm_sq: int,
        iwflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program sbi_filt.

        """

        if SLCf is not None and str(SLCf) != "-":
            SLCf.touch()

        if SLCf_par is not None and str(SLCf_par) != "-":
            SLCf_par.touch()

        if SLCb is not None and str(SLCb) != "-":
            SLCb.touch()

        if SLCb_par is not None and str(SLCb_par) != "-":
            SLCb_par.touch()

    def sbi_filt(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        SLCf: Path,
        SLCf_par: Path,
        SLCb: Path,
        SLCb_par: Path,
        norm_sq: int,
        iwflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Azimuth filtering of SLC data to support split-beam interferometry to measure azimuth offsets

        input parameters:
          SLC-1     (input) SLC image (SCOMPLEX or FCOMPLEX format)
          SLC1_par  (input) SLC image parameter file
          SLC2R_par (input) SLC2 ISP image parameter file for the co-registered image of the interferometric pair,
                    used to determine azimuth common-band for each output SLC (enter - for none)
          SLCf      (output) SLC image (forward-looking, FCOMPLEX format)
          SLCf_par  (output) SLC parameter file (forward-looking)
          SLCb      (output) SLC image (backward-looking, FCOMPLEX format)
          SLCb_par  (output) SLC parameter file (backward-looking)
          norm_sq   squint between beams as a fraction of the azimuth spectrum width (default: 0.5)
          iwflg     inverse weighting flag:
                      0: no compensation for azimuth spectrum weighting
                      1: compensate for the azimuth spectrum weighting (default)

        """

        if self.validate_inputs:
            self._validate_sbi_filt(
                SLC_1, SLC1_par, SLC2R_par, SLCf, SLCf_par, SLCb, SLCb_par, norm_sq, iwflg
            )

        if self.mock_outputs:
            self._mock_sbi_filt_outputs(
                SLC_1, SLC1_par, SLC2R_par, SLCf, SLCf_par, SLCb, SLCb_par, norm_sq, iwflg
            )

        ca = self._clean_args(locals(), inspect.signature(self.sbi_filt))
        result = self._gamma_call("ISP", "sbi_filt", ca)

        assert SLCf.exists(), f"{SLCf} does not exist"
        assert SLCf.stat().st_size > 0, f"{SLCf} has zero file size"

        assert SLCf_par.exists(), f"{SLCf_par} does not exist"
        assert SLCf_par.stat().st_size > 0, f"{SLCf_par} has zero file size"

        assert SLCb.exists(), f"{SLCb} does not exist"
        assert SLCb.stat().st_size > 0, f"{SLCb} has zero file size"

        assert SLCb_par.exists(), f"{SLCb_par} does not exist"
        assert SLCb_par.stat().st_size > 0, f"{SLCb_par} has zero file size"

        return result

    def _validate_par_NovaSAR_SRD(
        self,
        GeoTIFF: Optional[Path],
        XML: Path,
        polarization: int,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_NovaSAR_SRD.

        """

        if GeoTIFF is not None:
            assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
            assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert XML.exists(), f"{XML} does not exist"
        assert XML.stat().st_size > 0, f"{XML} has zero file size"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        if MLI is not None:
            assert not MLI.exists(), f"{MLI} should _not_ exist!"

    def _mock_par_NovaSAR_SRD_outputs(
        self,
        GeoTIFF: Optional[Path],
        XML: Path,
        polarization: int,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_NovaSAR_SRD.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

    def par_NovaSAR_SRD(
        self,
        GeoTIFF: Optional[Path],
        XML: Path,
        polarization: int,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate MLI image and parameter files for NovaSAR SRD data


        input parameters:
          GeoTIFF       (input) NovaSAR image data file in GeoTIFF format (enter - for none, *.tif)
          XML           (input) NovaSAR XML annotation file
          polarization  image polarization: HH, VV, HV, VH, CH, CV
          MLI_par       (output) MLI parameter file (example: yyyymmdd_pp.mli.par)
          MLI           (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          radcal        radiometric calibration flag (enter - for default)
                          0: beta0 (default)
                          1: sigma0
          noise         noise levels flag (enter - for default)
                          0: do not use noise levels (default)
                          1: use noise levels


        """

        if self.validate_inputs:
            self._validate_par_NovaSAR_SRD(
                GeoTIFF, XML, polarization, MLI_par, MLI, radcal, noise
            )

        if self.mock_outputs:
            self._mock_par_NovaSAR_SRD_outputs(
                GeoTIFF, XML, polarization, MLI_par, MLI, radcal, noise
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_NovaSAR_SRD))
        result = self._gamma_call("ISP", "par_NovaSAR_SRD", ca)

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if MLI is not None:
            assert MLI.exists(), f"{MLI} does not exist"
            assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        return result

    def _validate_ph_slope_base(
        self,
        int_in: Path,
        SLC_par: Path,
        OFF_par: Path,
        int_out: Path,
        int_type: Optional[int] = None,
        inverse: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ph_slope_base.

        """

        assert int_in.exists(), f"{int_in} does not exist"
        assert int_in.stat().st_size > 0, f"{int_in} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not int_out.exists(), f"{int_out} should _not_ exist!"

    def _mock_ph_slope_base_outputs(
        self,
        int_in: Path,
        SLC_par: Path,
        OFF_par: Path,
        int_out: Path,
        int_type: Optional[int] = None,
        inverse: Optional[int] = None,
    ) -> None:
        """

        Mock the program ph_slope_base.

        """

        if int_out is not None and str(int_out) != "-":
            int_out.touch()

    def ph_slope_base(
        self,
        int_in: Path,
        SLC_par: Path,
        OFF_par: Path,
        int_out: Path,
        int_type: Optional[int] = None,
        inverse: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Subtract/add interferogram flat-Earth phase trend as estimated from initial baseline


        input parameters:
          int_in    (input) interferogram (FCOMPLEX) or unwrapped phase (FLOAT) (unflattened)
          SLC_par   (input) ISP parameter file for the reference SLC
          OFF_par   (input) ISP offset/interferogram parameter file
          base      (input) baseline file
          int_out   (output) interferogram (FCOMPLEX) or unwrapped phase (FLOAT) with phase trend subtracted/added
          int_type  interferogram type: 0=unwrapped phase, 1=complex interf. (default=1)
          inverse   subtract/add inversion flag (0=subtract phase ramp, 1=add phase ramp (default=0)

        """

        if self.validate_inputs:
            self._validate_ph_slope_base(
                int_in, SLC_par, OFF_par, int_out, int_type, inverse
            )

        if self.mock_outputs:
            self._mock_ph_slope_base_outputs(
                int_in, SLC_par, OFF_par, int_out, int_type, inverse
            )

        ca = self._clean_args(locals(), inspect.signature(self.ph_slope_base))
        result = self._gamma_call("ISP", "ph_slope_base", ca)

        assert int_out.exists(), f"{int_out} does not exist"
        assert int_out.stat().st_size > 0, f"{int_out} has zero file size"

        return result

    def _validate_multi_look_ScanSAR(
        self,
        SLC_tab: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        scale: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to multi_look_ScanSAR.

        """

        assert SLC_tab.exists(), f"{SLC_tab} does not exist"
        assert SLC_tab.stat().st_size > 0, f"{SLC_tab} has zero file size"

        self._check_tab_file(SLC_tab, "SLC_tab")

        assert not MLI.exists(), f"{MLI} should _not_ exist!"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        if SLCR_tab is not None:
            assert SLCR_tab.exists(), f"{SLCR_tab} does not exist"
            assert SLCR_tab.stat().st_size > 0, f"{SLCR_tab} has zero file size"

    def _mock_multi_look_ScanSAR_outputs(
        self,
        SLC_tab: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        scale: Optional[float] = None,
    ) -> None:
        """

        Mock the program multi_look_ScanSAR.

        """

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def multi_look_ScanSAR(
        self,
        SLC_tab: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        scale: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate MLI mosaic from ScanSAR SLC burst data (Sentinel-1, TerraSAR-X, RCM...)


        input parameters:
          SLC_tab   (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par
          MLI       (output) mosaicked MLI image (non-overlapping burst windows)
          MLI_par   (output) MLI image parameter file
          rlks      number of range looks
          azlks     number of azimuth looks
          bflg      burst window calculation flag (enter - for default):
                      0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                      1: calculate burst window parameters from burst parameters and the number of range and azimuth looks
          SLCR_tab  (input) 3 column list of the reference scene, swaths are listed in order from near to far range, enter - for none
                      SLCR_tab line entries:   SLC    SLC_par   TOPS_par
          scale     scale factor for output MLI (enter - for default: calculate from calibration gain in SLC parameter file)

                    NOTE: When generating an MLI mosaic from resampled SLC data, the SLC_tab of the reference scene is required


        """

        if self.validate_inputs:
            self._validate_multi_look_ScanSAR(
                SLC_tab, MLI, MLI_par, rlks, azlks, bflg, SLCR_tab, scale
            )

        if self.mock_outputs:
            self._mock_multi_look_ScanSAR_outputs(
                SLC_tab, MLI, MLI_par, rlks, azlks, bflg, SLCR_tab, scale
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_look_ScanSAR))
        result = self._gamma_call("ISP", "multi_look_ScanSAR", ca)

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        return result

    def _validate_par_ASNARO2(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        reramp: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_ASNARO2.

        """

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_ASNARO2_outputs(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        reramp: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_ASNARO2.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_ASNARO2(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        reramp: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for ASNARO-2 Spotlight, Stripmap and ScanSAR level 1.1 data


        input parameters:
          CEOS_data     (input) CEOS format SLC data (IMG-PP-AS2*)
          CEOS_leader   (input) CEOS SAR leader file for ASNARO-2 data (LED-AS2*)
          SLC_par       (output) ISP SLC parameter file (example: yyyymmdd_pp.slc.par)
          SLC           (output) SLC (Spotlight and Stripmap) or SLI (ScanSAR) data file (enter - for none, example: yyyymmdd_pp.slc)
          reramp        reramp SLC phase flag (enter - for default)
                          0: no reramp
                          1: reramp SLC phase (default)

        NOTE: ASNARO2 geocoded and georeferenced data in GeoTIFF format (level 1.5) can be read using par_ASNARO2_geo program.


        """

        if self.validate_inputs:
            self._validate_par_ASNARO2(CEOS_data, CEOS_leader, SLC_par, SLC, reramp)

        if self.mock_outputs:
            self._mock_par_ASNARO2_outputs(CEOS_data, CEOS_leader, SLC_par, SLC, reramp)

        ca = self._clean_args(locals(), inspect.signature(self.par_ASNARO2))
        result = self._gamma_call("ISP", "par_ASNARO2", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_par_RSI_RSAT(
        self,
    ) -> None:
        """

        Validate the arguments to par_RSI_RSAT.

        """

        pass

    def _mock_par_RSI_RSAT_outputs(
        self,
    ) -> None:
        """

        Mock the program par_RSI_RSAT.

        """
        pass

    def par_RSI_RSAT(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """


        **********************************************************************
        NOTE: Program par_RSI_RSAT has been replaced by par_RSAT_SLC.
        Please replace all calls to par_RSAT_SLC.
        **********************************************************************

        par_RSAT_SLC: Command not found.

        """

        if self.validate_inputs:
            self._validate_par_RSI_RSAT()

        if self.mock_outputs:
            self._mock_par_RSI_RSAT_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.par_RSI_RSAT))
        result = self._gamma_call("ISP", "par_RSI_RSAT", ca)
        return result

    def _validate_grasses(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        xinit: Optional[int] = None,
        yinit: Optional[int] = None,
        init_ph: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to grasses.

        """

        assert int.exists(), f"{int} does not exist"
        assert int.stat().st_size > 0, f"{int} has zero file size"

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

        assert not unw.exists(), f"{unw} should _not_ exist!"

    def _mock_grasses_outputs(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        xinit: Optional[int] = None,
        yinit: Optional[int] = None,
        init_ph: Optional[int] = None,
    ) -> None:
        """

        Mock the program grasses.

        """

        if unw is not None and str(unw) != "-":
            unw.touch()

    def grasses(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        xinit: Optional[int] = None,
        yinit: Optional[int] = None,
        init_ph: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Phase unwrapping by region growing


        input parameters:
          int      (input) interferogram filename
          flag     (input) unwrapping flag filename
          unw      (output) unwrapped phase filename
          width    number of samples/row
          xmin     starting range pixel offset (default = 0)
          xmax     last range pixel offset (default=width-1)
          ymin     starting azimuth row offset, relative to start (default = 0)
          ymax     last azimuth row offset, relative to start (default = nlines-1)
          xinit    starting range pixel for unwrapping (default = width/2)
          yinit    starting row to unwrap (default = height/2)
          init_ph  flag to set phase at starting point to 0.0 (default 0: not set to 0.0, 1: set to 0.0)


        """

        if self.validate_inputs:
            self._validate_grasses(
                int, flag, unw, width, xmin, xmax, ymin, ymax, xinit, yinit, init_ph
            )

        if self.mock_outputs:
            self._mock_grasses_outputs(
                int, flag, unw, width, xmin, xmax, ymin, ymax, xinit, yinit, init_ph
            )

        ca = self._clean_args(locals(), inspect.signature(self.grasses))
        result = self._gamma_call("ISP", "grasses", ca)

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        return result

    def _validate_mk_ASF_CEOS_list(
        self,
    ) -> None:
        """

        Validate the arguments to mk_ASF_CEOS_list.

        """

        pass

    def _mock_mk_ASF_CEOS_list_outputs(
        self,
    ) -> None:
        """

        Mock the program mk_ASF_CEOS_list.

        """
        pass

    def mk_ASF_CEOS_list(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ls: */LED*: No such file or directory
        ls: */IMG*HH*: No such file or directory
        ls: */IMG*HV*: No such file or directory
        ls: */*.L: No such file or directory
        ls: */*.D: No such file or directory
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/mk_ASF_CEOS_list: line 7: $1: ambiguous redirect
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/mk_ASF_CEOS_list: line 8: $1: ambiguous redirect
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/mk_ASF_CEOS_list: line 10: $1: ambiguous redirect

        """

        if self.validate_inputs:
            self._validate_mk_ASF_CEOS_list()

        if self.mock_outputs:
            self._mock_mk_ASF_CEOS_list_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.mk_ASF_CEOS_list))
        result = self._gamma_call("ISP", "mk_ASF_CEOS_list", ca)
        return result

    def _validate_mask_data(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        mask: Path,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to mask_data.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

        assert mask.exists(), f"{mask} does not exist"
        assert mask.stat().st_size > 0, f"{mask} has zero file size"

    def _mock_mask_data_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        mask: Path,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program mask_data.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def mask_data(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        mask: Path,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Mask float or fcomplex data using an 8-bit SUN/BMP/TIFF format raster image


        input parameters:
          data_in  (input) data file (FLOAT or FCOMPLEX format)
          width    width of input data file
          data_out (output) data file, same data format as input
          mask     (input) mask file, SUN/BMP/TIFF raster format, 8-bits/pixel
                   output data values are set to 0.0 at all locations where the mask is black (0,0,0) or dn = 0
                   NOTE: mask file must have the same width as the input data file
          dtype    data format:
                      0: FLOAT (default)
                      1: FCOMPLEX


        """

        if self.validate_inputs:
            self._validate_mask_data(data_in, width, data_out, mask, dtype)

        if self.mock_outputs:
            self._mock_mask_data_outputs(data_in, width, data_out, mask, dtype)

        ca = self._clean_args(locals(), inspect.signature(self.mask_data))
        result = self._gamma_call("ISP", "mask_data", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_par_ESA_JERS_SEASAT_SLC(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_ESA_JERS_SEASAT_SLC.

        """

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_ESA_JERS_SEASAT_SLC_outputs(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_ESA_JERS_SEASAT_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_ESA_JERS_SEASAT_SLC(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for ESA-provided JERS and SEASAT SLC data


        input parameters:
          CEOS_data     (input) CEOS format SLC data (DAT_01.001)
          CEOS_leader   (input) CEOS SAR leader file for JERS SLC processed by ESA (LEA_01.001)
          SLC_par       (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC           (output) SLC data file (enter - for none, example: yyyymmdd.slc)


        """

        if self.validate_inputs:
            self._validate_par_ESA_JERS_SEASAT_SLC(CEOS_data, CEOS_leader, SLC_par, SLC)

        if self.mock_outputs:
            self._mock_par_ESA_JERS_SEASAT_SLC_outputs(
                CEOS_data, CEOS_leader, SLC_par, SLC
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_ESA_JERS_SEASAT_SLC))
        result = self._gamma_call("ISP", "par_ESA_JERS_SEASAT_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_ScanSAR_burst_overlap(
        self,
        SLC_tab: Path,
        root_name: Path,
        rlks: int,
        azlks: int,
        mode: Optional[int] = None,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        dburst: Optional[int] = None,
        bound: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ScanSAR_burst_overlap.

        """

        assert SLC_tab.exists(), f"{SLC_tab} does not exist"
        assert SLC_tab.stat().st_size > 0, f"{SLC_tab} has zero file size"

        self._check_tab_file(SLC_tab, "SLC_tab")

        assert not root_name.exists(), f"{root_name} should _not_ exist!"

        if SLCR_tab is not None:
            assert SLCR_tab.exists(), f"{SLCR_tab} does not exist"
            assert SLCR_tab.stat().st_size > 0, f"{SLCR_tab} has zero file size"

    def _mock_ScanSAR_burst_overlap_outputs(
        self,
        SLC_tab: Path,
        root_name: Path,
        rlks: int,
        azlks: int,
        mode: Optional[int] = None,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        dburst: Optional[int] = None,
        bound: Optional[int] = None,
    ) -> None:
        """

        Mock the program ScanSAR_burst_overlap.

        """

        if root_name is not None and str(root_name) != "-":
            root_name.touch()

    def ScanSAR_burst_overlap(
        self,
        SLC_tab: Path,
        root_name: Path,
        rlks: int,
        azlks: int,
        mode: Optional[int] = None,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        dburst: Optional[int] = None,
        bound: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract and mosaic overlapping parts of ScanSAR / TOPS burst data


        input parameters:
          SLC_tab     (input) 3 column list of SLC, SLC_par, Sentinel-1 TOPS_par sorted in the order IW1, IW2, IW3...
          root_name   (output) output data root name (example: yyyymmdd_pp_overlap)
          rlks        number of range looks used to determine burst window boundaries
          azlks       number of azimuth looks used to determine burst window boundaries
          mode        output mode (enter - for default)
                        0: output data are mosaics, non-overlapping parts are set to 0 (default)
                        1: output data are mosaics, non-overlapping parts are written
                        2: output data are burst data containing only overlapping parts
                        3: output data is a polygon file with polygons encompassing overlapping areas in the SLC mosaic
                        4: output data is a polygon file with polygons encompassing overlapping areas in the MLI mosaic
          bflg        burst window calculation flag (enter - for default)
                        0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                        1: recalculate burst window parameters from burst parameters and the number of range and azimuth looks
          SLCR_tab    (input) SLC_tab of the reference scene, 3 column list of SLC, SLC_par, TOPS_par sorted sorted in the order IW1, IW2, IW3
                      NOTE: When generating a mosaic of a resampled SLC, the SLC_tab of the reference scene is required
          dburst      delta burst number (1=overlap of subsequent bursts, enter - for default: 1)
          bound       boundary pixels in polygon (enter - for default: 0)


        """

        if self.validate_inputs:
            self._validate_ScanSAR_burst_overlap(
                SLC_tab, root_name, rlks, azlks, mode, bflg, SLCR_tab, dburst, bound
            )

        if self.mock_outputs:
            self._mock_ScanSAR_burst_overlap_outputs(
                SLC_tab, root_name, rlks, azlks, mode, bflg, SLCR_tab, dburst, bound
            )

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_burst_overlap))
        result = self._gamma_call("ISP", "ScanSAR_burst_overlap", ca)

        assert root_name.exists(), f"{root_name} does not exist"
        assert root_name.stat().st_size > 0, f"{root_name} has zero file size"

        return result

    def _validate_par_HISEA1_SLC(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        calibration_XML: Optional[Path],
        SLC_par: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[int] = None,
        shift: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_HISEA1_SLC.

        """

        if GeoTIFF is not None:
            assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
            assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert annotation_XML.exists(), f"{annotation_XML} does not exist"
        assert annotation_XML.stat().st_size > 0, f"{annotation_XML} has zero file size"

        if calibration_XML is not None:
            assert calibration_XML.exists(), f"{calibration_XML} does not exist"
            assert (
                calibration_XML.stat().st_size > 0
            ), f"{calibration_XML} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_HISEA1_SLC_outputs(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        calibration_XML: Optional[Path],
        SLC_par: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[int] = None,
        shift: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_HISEA1_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_HISEA1_SLC(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        calibration_XML: Optional[Path],
        SLC_par: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[int] = None,
        shift: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for Hisea-1 SLC data


        input parameters:
          GeoTIFF         (input) image data file in GeoTIFF format (enter - for none, *.tiff)
          annotation_XML  (input) Hisea-1 L1 XML annotation file
          calibration_XML (input) Hisea-1 L1 radiometric calibration XML file (enter - for no radiometric calibration)
          SLC_par         (output) ISP SLC parameter file (example: yyyymmdd_vv.slc.par)
          SLC             (output) SLC data file (enter - for none, example: yyyymmdd_vv.slc)
          dtype           output data type (enter - for default)
                            0: FCOMPLEX (default)
                            1: SCOMPLEX
          sc_dB           scale factor for FCOMPLEX -> SCOMPLEX, (enter - for default: HH,VV (dB): 60.0000,  VH,HV: 70.0000)
          shift           shift azimuth spectrum by fs/2 (enter - for default)
                            0: no
                            1: yes (default)


        """

        if self.validate_inputs:
            self._validate_par_HISEA1_SLC(
                GeoTIFF,
                annotation_XML,
                calibration_XML,
                SLC_par,
                SLC,
                dtype,
                sc_dB,
                shift,
            )

        if self.mock_outputs:
            self._mock_par_HISEA1_SLC_outputs(
                GeoTIFF,
                annotation_XML,
                calibration_XML,
                SLC_par,
                SLC,
                dtype,
                sc_dB,
                shift,
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_HISEA1_SLC))
        result = self._gamma_call("ISP", "par_HISEA1_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_ORB_prop_SLC(
        self,
        SLC_par: Path,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        extra: Optional[int] = None,
        mode: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ORB_prop_SLC.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

    def _mock_ORB_prop_SLC_outputs(
        self,
        SLC_par: Path,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        extra: Optional[int] = None,
        mode: Optional[int] = None,
    ) -> None:
        """

        Mock the program ORB_prop_SLC.

        """
        pass

    def ORB_prop_SLC(
        self,
        SLC_par: Path,
        nstate: Optional[int] = None,
        interval: Optional[int] = None,
        extra: Optional[int] = None,
        mode: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate state vectors using orbit propagation and interpolation


        input parameters:
          SLC_par   (input) ISP image parameter file with at least 1 state vector
          nstate    number of state vectors to calculate (enter - for default: nstate from image duration + extra)
          interval  time interval between state vectors (enter - for default: state vector time interval in SLC_par)
          extra     extra time for state vectors at start and end of image (sec.) (enter - for default: 30.0)
          mode      orbit propagation mode:
                      0: polynomial interpolation (default, if 3 or more state vectors available)
                      1: integration of the equations of motion (default, if less than 3 state vectors available)
                      2: interpolate between state vectors, minimum of 3 state vectors;
                         interpolation of the equations of motion outside of the time span of the existing state vectors


        """

        if self.validate_inputs:
            self._validate_ORB_prop_SLC(SLC_par, nstate, interval, extra, mode)

        if self.mock_outputs:
            self._mock_ORB_prop_SLC_outputs(SLC_par, nstate, interval, extra, mode)

        ca = self._clean_args(locals(), inspect.signature(self.ORB_prop_SLC))
        result = self._gamma_call("ISP", "ORB_prop_SLC", ca)
        return result

    def _validate_interp_ad(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        r_max: Optional[int] = None,
        np_min: Optional[int] = None,
        np_max: Optional[int] = None,
        w_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        cp_data: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to interp_ad.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_interp_ad_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        r_max: Optional[int] = None,
        np_min: Optional[int] = None,
        np_max: Optional[int] = None,
        w_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        cp_data: Optional[int] = None,
    ) -> None:
        """

        Mock the program interp_ad.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def interp_ad(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        r_max: Optional[int] = None,
        np_min: Optional[int] = None,
        np_max: Optional[int] = None,
        w_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        cp_data: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Weighted interpolation of gaps in 2D data using an adaptive smoothing window


        input parameters:
          data_in   (input) data with gaps
          data_out  (output) data with gaps filled by interpolation
          width     number of samples/row
          r_max     maximum interpolation window radius (default(-): 16)
          np_min    minimum number of points used for the interpolation (default(-): 16)
          np_max    maximum number of points used for the interpolation (default(-): 16)
          w_mode    data weighting mode (enter - for default):
                      0: constant
                      1: 1 - (r/r_max)
                      2: 1 - (r/r_max)**2  (default)
                      3: exp(-2.*(r**2/r_max**2))
          dtype     input and output data type:
                      0: FCOMPLEX
                      1: SCOMPLEX
                      2: FLOAT (default)
                      3: INT
                      4: SHORT
          cp_data   copy data flag:
                      0: do not copy input data values to output
                      1: copy input data values to output (default)


        """

        if self.validate_inputs:
            self._validate_interp_ad(
                data_in, data_out, width, r_max, np_min, np_max, w_mode, dtype, cp_data
            )

        if self.mock_outputs:
            self._mock_interp_ad_outputs(
                data_in, data_out, width, r_max, np_min, np_max, w_mode, dtype, cp_data
            )

        ca = self._clean_args(locals(), inspect.signature(self.interp_ad))
        result = self._gamma_call("ISP", "interp_ad", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_SLC_burst_corners(
        self,
    ) -> None:
        """

        Validate the arguments to SLC_burst_corners.

        """

        pass

    def _mock_SLC_burst_corners_outputs(
        self,
    ) -> None:
        """

        Mock the program SLC_burst_corners.

        """
        pass

    def SLC_burst_corners(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ********************************************************************************************
        NOTE: SLC_burst_corners has been replaced by ScanSAR_burst_corners. The command line
        options are unchanged, please consider renaming the program in your scripts.
        ********************************************************************************************
        ScanSAR_burst_corners
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/SLC_burst_corners: line 7: ScanSAR_burst_corners: command not found

        """

        if self.validate_inputs:
            self._validate_SLC_burst_corners()

        if self.mock_outputs:
            self._mock_SLC_burst_corners_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SLC_burst_corners))
        result = self._gamma_call("ISP", "SLC_burst_corners", ca)
        return result

    def _validate_par_RISAT_GRD(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        GRD_par: Path,
        CEOS_image: Path,
        GRD: Optional[Path] = None,
        line_dir: Optional[int] = None,
        pix_dir: Optional[int] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_RISAT_GRD.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert BAND_META.exists(), f"{BAND_META} does not exist"
        assert BAND_META.stat().st_size > 0, f"{BAND_META} has zero file size"

        assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        assert CEOS_image.exists(), f"{CEOS_image} does not exist"
        assert CEOS_image.stat().st_size > 0, f"{CEOS_image} has zero file size"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_RISAT_GRD_outputs(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        GRD_par: Path,
        CEOS_image: Path,
        GRD: Optional[Path] = None,
        line_dir: Optional[int] = None,
        pix_dir: Optional[int] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_RISAT_GRD.

        """

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_RISAT_GRD(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        GRD_par: Path,
        CEOS_image: Path,
        GRD: Optional[Path] = None,
        line_dir: Optional[int] = None,
        pix_dir: Optional[int] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Read RISAT-1 Ground-Range data from a CEOS data set and perform radiometric calibration


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file (example: lea_01.001)
          BAND_META    (input) BAND_META.txt, additional RISAT system parameters for the scene (format keywork=value)
          GRD_par      (output) ISP GRD parameter file (example: YYYYMMDD.grd.par)
          CEOS_image   (input) CEOS Ground-Range image file (example: dat_01.001)
          GRD          (output) Ground-Range data with file and line headers removed (enter - for none: example: YYYYMMDD.grd)
          line_dir     set output image line direction (enter - for default):
                         0: used value derived from CEOS leader file
                         1: retain input data line direction  (default)
                        -1: reverse input data line direction
          pix_dir      set output pixel direction (enter - for default):
                         0: used value derived from CEOS leader file
                         1: retain input data pixel direction (default)
                        -1: reverse input data pixel direction
          cal_flg      calibration flag (enter - for default):
                         0: do not apply radiometric calibration
                         1: apply radiometric calibration including KdB and incidence angle correction (default)
          KdB          calibration constant (dB) (enter - to use value in the CEOS leader)


        """

        if self.validate_inputs:
            self._validate_par_RISAT_GRD(
                CEOS_leader,
                BAND_META,
                GRD_par,
                CEOS_image,
                GRD,
                line_dir,
                pix_dir,
                cal_flg,
                KdB,
            )

        if self.mock_outputs:
            self._mock_par_RISAT_GRD_outputs(
                CEOS_leader,
                BAND_META,
                GRD_par,
                CEOS_image,
                GRD,
                line_dir,
                pix_dir,
                cal_flg,
                KdB,
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RISAT_GRD))
        result = self._gamma_call("ISP", "par_RISAT_GRD", ca)

        assert GRD_par.exists(), f"{GRD_par} does not exist"
        assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_par_RSAT_SCW(
        self,
        CEOS_leader: Path,
        CEOS_trailer: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
        sc_dB: Optional[int] = None,
        dt: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_RSAT_SCW.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert CEOS_trailer.exists(), f"{CEOS_trailer} does not exist"
        assert CEOS_trailer.stat().st_size > 0, f"{CEOS_trailer} has zero file size"

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_RSAT_SCW_outputs(
        self,
        CEOS_leader: Path,
        CEOS_trailer: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
        sc_dB: Optional[int] = None,
        dt: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_RSAT_SCW.

        """

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_RSAT_SCW(
        self,
        CEOS_leader: Path,
        CEOS_trailer: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
        sc_dB: Optional[int] = None,
        dt: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file for SCANSAR Wide Swath Data


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file
          CEOS_trailer (input) CEOS SAR trailer file
          CEOS_data    (input) CEOS data file binary)
          GRD_par      (output) ISP ground range image parameter file (example <orbit>.mli.par)
          GRD          (output) ISP ground range image (example <orbit>.mli) (enter -  for none, float)
          sc_dB        intensity scale factor in dB (enter - for default:   0.00)
          dt           azimuth image time offset (s) (enter - for default = 0.0)


        """

        if self.validate_inputs:
            self._validate_par_RSAT_SCW(
                CEOS_leader, CEOS_trailer, CEOS_data, GRD_par, GRD, sc_dB, dt
            )

        if self.mock_outputs:
            self._mock_par_RSAT_SCW_outputs(
                CEOS_leader, CEOS_trailer, CEOS_data, GRD_par, GRD, sc_dB, dt
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RSAT_SCW))
        result = self._gamma_call("ISP", "par_RSAT_SCW", ca)

        assert GRD_par.exists(), f"{GRD_par} does not exist"
        assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_neutron(
        self,
        intensity: Path,
        flag: Path,
        width: int,
        n_thres: int,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to neutron.

        """

        assert intensity.exists(), f"{intensity} does not exist"
        assert intensity.stat().st_size > 0, f"{intensity} has zero file size"

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

    def _mock_neutron_outputs(
        self,
        intensity: Path,
        flag: Path,
        width: int,
        n_thres: int,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Mock the program neutron.

        """
        pass

    def neutron(
        self,
        intensity: Path,
        flag: Path,
        width: int,
        n_thres: int,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate phase unwrapping neutrons using image intensity


        input parameters:
          intensity  (input) image intensity
          flag       (input) phase unwrapping flag file
          width      number of samples/row
          n_thres    neutron threshold, multiples of the average intensity (default=6.0)
          ymin       offset to starting azimuth row (default = 0)
          ymax       offset to last azimuth row (default = nlines-1)


        """

        if self.validate_inputs:
            self._validate_neutron(intensity, flag, width, n_thres, ymin, ymax)

        if self.mock_outputs:
            self._mock_neutron_outputs(intensity, flag, width, n_thres, ymin, ymax)

        ca = self._clean_args(locals(), inspect.signature(self.neutron))
        result = self._gamma_call("ISP", "neutron", ca)
        return result

    def _validate_SLC_mosaic_S1_TOPS(
        self,
    ) -> None:
        """

        Validate the arguments to SLC_mosaic_S1_TOPS.

        """

        pass

    def _mock_SLC_mosaic_S1_TOPS_outputs(
        self,
    ) -> None:
        """

        Mock the program SLC_mosaic_S1_TOPS.

        """
        pass

    def SLC_mosaic_S1_TOPS(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ******************************************************************************************
        NOTE: SLC_mosaic_S1_TOPS has been replaced by SLC_mosaic_ScanSAR. The command line
        options are unchanged, please consider renaming the program in your scripts.
        ******************************************************************************************
        cmd: SLC_mosaic_ScanSAR

        SLC_mosaic_ScanSAR: Command not found.

        """

        if self.validate_inputs:
            self._validate_SLC_mosaic_S1_TOPS()

        if self.mock_outputs:
            self._mock_SLC_mosaic_S1_TOPS_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SLC_mosaic_S1_TOPS))
        result = self._gamma_call("ISP", "SLC_mosaic_S1_TOPS", ca)
        return result

    def _validate_multi_look(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to multi_look.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not MLI.exists(), f"{MLI} should _not_ exist!"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

    def _mock_multi_look_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> None:
        """

        Mock the program multi_look.

        """

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def multi_look(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate a multi-look intensity (MLI) image from an SLC image


        input parameters:
          SLC      (input) single-look complex image (SCOMPLEX or FCOMPLEX)
          SLC_par  (input) SLC ISP image parameter file
          MLI      (output) multi-look intensity image (FLOAT)
          MLI_par  (output) MLI ISP image parameter file
          rlks     number of range looks (INT)
          azlks    number of azimuth looks (INT)
          loff     offset to starting line (enter - for default: 0)
          nlines   number of SLC lines to process (enter - for default: entire file)
          scale    scale factor for output MLI (enter - for default: 1.0)
          exp      exponent for the output MLI (enter - for default: 1.0)


        """

        if self.validate_inputs:
            self._validate_multi_look(
                SLC, SLC_par, MLI, MLI_par, rlks, azlks, loff, nlines, scale, exp
            )

        if self.mock_outputs:
            self._mock_multi_look_outputs(
                SLC, SLC_par, MLI, MLI_par, rlks, azlks, loff, nlines, scale, exp
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_look))
        result = self._gamma_call("ISP", "multi_look", ca)

        assert MLI.exists(), f"{MLI} does not exist"
        assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        return result

    def _validate_S1_TOPS_preproc(
        self,
    ) -> None:
        """

        Validate the arguments to S1_TOPS_preproc.

        """

        pass

    def _mock_S1_TOPS_preproc_outputs(
        self,
    ) -> None:
        """

        Mock the program S1_TOPS_preproc.

        """
        pass

    def S1_TOPS_preproc(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Preprocessing of Sentinel-1 TOPS SLC products, extract SLC data and generate SLC_tab

          S1_list  (input) single column text file. Enteries are directories (including path) containing Sentinel-1 TOPS SLC products
          SLC_dir  directory for output SLC data files and SLC parameter files
                   Note: output file names have the form : 20150119_iw1_hh.slc
          pol      SLC polarization to extract (hh,hv,vh,vv)
          log      (output) S1 SLC pre-processing log file

          -c          (option) apply radiometric calibration factor without noise subtraction
          -n          (option) apply radiometric calibration factor with noise subtraction
          -s          (option) output is SCOMPLEX format (default: FCOMPLEX)
          -t          (option) include full timestamp YYYYMMDDtHHMMSS in SLC and SLC_par filenames, default YYYYMMDD
          -m MLI_dir  (option) calculate MLI images and store in MLI_dir, enter . for current directory
          -r rlks     (option) number of MLI range looks (default: 10)
          -a azlks    (option) number of MLI azimuth looks (default: 2)
          -b SLC_tab  (option) SLC_tab filename, by default SLC_tab_YYMMDD or SLC_tab_YYYYMMDDtHHMMSS

        """

        if self.validate_inputs:
            self._validate_S1_TOPS_preproc()

        if self.mock_outputs:
            self._mock_S1_TOPS_preproc_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.S1_TOPS_preproc))
        result = self._gamma_call("ISP", "S1_TOPS_preproc", ca)
        return result

    def _validate_mosaic_WB(
        self, data_tab: Path, dtype: int, data_out: Path, data_par_out: Path
    ) -> None:
        """

        Validate the arguments to mosaic_WB.

        """

        assert data_tab.exists(), f"{data_tab} does not exist"
        assert data_tab.stat().st_size > 0, f"{data_tab} has zero file size"

        self._check_tab_file(data_tab, "data_tab")

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

        assert not data_par_out.exists(), f"{data_par_out} should _not_ exist!"

    def _mock_mosaic_WB_outputs(
        self, data_tab: Path, dtype: int, data_out: Path, data_par_out: Path
    ) -> None:
        """

        Mock the program mosaic_WB.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

        if data_par_out is not None and str(data_par_out) != "-":
            data_par_out.touch()

    def mosaic_WB(
        self, data_tab: Path, dtype: int, data_out: Path, data_par_out: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/mosaic_WB.c
        Mosaic Wide-Beam ScanSAR data processed by the MSP


        input parameters:
          data_tab      (input) 2 column list of data  and ISP image parameter files for the beams in the mosaic (text)
          dtype         (input) input data type:
                           0: FLOAT
                           1: FCOMPLEX
          data_out      (output) output image mosaic
          data_par_out  (output) ISP image parameter file for output image mosaic
          sc_flg        intensity scaling flag:
                          0: do not scale different beam data values
                          1: use overlap regions to scale beam intensities (default)


        """

        if self.validate_inputs:
            self._validate_mosaic_WB(data_tab, dtype, data_out, data_par_out)

        if self.mock_outputs:
            self._mock_mosaic_WB_outputs(data_tab, dtype, data_out, data_par_out)

        ca = self._clean_args(locals(), inspect.signature(self.mosaic_WB))
        result = self._gamma_call("ISP", "mosaic_WB", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        assert data_par_out.exists(), f"{data_par_out} does not exist"
        assert data_par_out.stat().st_size > 0, f"{data_par_out} has zero file size"

        return result

    def _validate_ScanSAR_burst_to_mosaic(
        self,
        DATA_tab: Path,
        mosaic: Path,
        MLI_par: Path,
        mflg: Optional[int] = None,
        min_ovr: Optional[int] = None,
        max_ovr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ScanSAR_burst_to_mosaic.

        """

        assert DATA_tab.exists(), f"{DATA_tab} does not exist"
        assert DATA_tab.stat().st_size > 0, f"{DATA_tab} has zero file size"

        self._check_tab_file(DATA_tab, "DATA_tab")

        assert not mosaic.exists(), f"{mosaic} should _not_ exist!"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

    def _mock_ScanSAR_burst_to_mosaic_outputs(
        self,
        DATA_tab: Path,
        mosaic: Path,
        MLI_par: Path,
        mflg: Optional[int] = None,
        min_ovr: Optional[int] = None,
        max_ovr: Optional[int] = None,
    ) -> None:
        """

        Mock the program ScanSAR_burst_to_mosaic.

        """

        if mosaic is not None and str(mosaic) != "-":
            mosaic.touch()

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def ScanSAR_burst_to_mosaic(
        self,
        DATA_tab: Path,
        mosaic: Path,
        MLI_par: Path,
        mflg: Optional[int] = None,
        min_ovr: Optional[int] = None,
        max_ovr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate mosaic of multilook ScanSAR burst data (FLOAT or FCOMPLEX)


        input parameters:
          DATA_tab      (input) 3 column list of swaths in ML_DATA burst geometry listed in the order from near to far range
                          DATA_tab line entries:   DATA   MLI_par  TOPS_par
                        NOTE: The data type (FLOAT or FCOMPLEX) is specified in the MLI_par and the burst parameters (TOPS_par) must agree
          mosaic        (output) mosaic image from bursts in multi-look geometry
          MLI_par       (output) mosaic image parameter file
          mflg          mosaicking option flag (enter - for default)
                          0: no overlap between bursts or image swaths (default)
                          1: average data in the overlap between bursts and in the overlap between image swaths
                          2: average data in the overlap between bursts but not in the overlap between image swaths
          DATA_tab_ref  (input) reference scene DATA_tab, 3 column list of DATA, MLI_par, TOPS_par listed in order from near to far range (enter - for none)
                        NOTE: When generating a mosaic produced using data from a resampled scene, the MLI_tab of the reference scene is required
          min_ovr       minimum number of overlapping bursts (using mflg = 1 or 2, enter - for default: 1)
          max_ovr       maximum number of overlapping bursts (using mflg = 1 or 2, enter - for default: unlimited)


        """

        if self.validate_inputs:
            self._validate_ScanSAR_burst_to_mosaic(
                DATA_tab, mosaic, MLI_par, mflg, min_ovr, max_ovr
            )

        if self.mock_outputs:
            self._mock_ScanSAR_burst_to_mosaic_outputs(
                DATA_tab, mosaic, MLI_par, mflg, min_ovr, max_ovr
            )

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_burst_to_mosaic))
        result = self._gamma_call("ISP", "ScanSAR_burst_to_mosaic", ca)

        assert mosaic.exists(), f"{mosaic} does not exist"
        assert mosaic.stat().st_size > 0, f"{mosaic} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        return result

    def _validate_offset_plot_r(
        self,
    ) -> None:
        """

        Validate the arguments to offset_plot_r.

        """

        pass

    def _mock_offset_plot_r_outputs(
        self,
    ) -> None:
        """

        Mock the program offset_plot_r.

        """
        pass

    def offset_plot_r(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        IPTA script: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/offset_plot_r
        extract range and azimuth offsets for an azimuth window from an text offset file


            offset      (input) list of range and azimuth offsets generated by offset_pwr (text)
            az_min      minimum azimuth line number to extract range and azimuth offsets
            az_max      minimum azimuth line number to extract range and azimuth offsets
            r_plot      range offsets xmgrace plot file
            az_plot     azimuth offsets xmgrace plot file

        """

        if self.validate_inputs:
            self._validate_offset_plot_r()

        if self.mock_outputs:
            self._mock_offset_plot_r_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.offset_plot_r))
        result = self._gamma_call("ISP", "offset_plot_r", ca)
        return result

    def _validate_par_UAVSAR_SLC(
        self,
        ann: Path,
        SLC_par: Path,
        image_type: Optional[int] = None,
        image_format: Optional[int] = None,
        DOP: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_UAVSAR_SLC.

        """

        assert ann.exists(), f"{ann} does not exist"
        assert ann.stat().st_size > 0, f"{ann} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if DOP is not None:
            assert DOP.exists(), f"{DOP} does not exist"
            assert DOP.stat().st_size > 0, f"{DOP} has zero file size"

    def _mock_par_UAVSAR_SLC_outputs(
        self,
        ann: Path,
        SLC_par: Path,
        image_type: Optional[int] = None,
        image_format: Optional[int] = None,
        DOP: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_UAVSAR_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_UAVSAR_SLC(
        self,
        ann: Path,
        SLC_par: Path,
        image_type: Optional[int] = None,
        image_format: Optional[int] = None,
        DOP: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP image parameter file from UAVSAR annotation file (ann) for SLC and MLC products


        input parameters:
          ann           (input) UAVSAR annotation file (*ann.txt or *.ann)
          SLC/MLC_in    (input) UAVSAR binary data file (required for annotation file version 1.2) (enter - for none)
          SLC/MLI_par   (output) ISP image parameter file
          SLC/MLI_out   (output) SLC data file (enter - for none)
          image_type    image type flag (enter - for default)
                          0: SLC (slc) in slant range coordinates (default)
                          1: MLC (mlc) in slant range coordinates
                             HHHH*, VVVV*, HVHV* are FLOAT format
                             HHHV*, HHVV*, HVVV* are FCOMPLEX format
          image_format  image data format flag (enter - for default)
                          0: FCOMPLEX (pairs of 4-byte float (re,im)) (default)
                          2: FLOAT  (4-bytes/value)
          DOP           (input) UAVSAR Doppler look-up table (if not zero-Doppler) (enter - for none)

        """

        if self.validate_inputs:
            self._validate_par_UAVSAR_SLC(ann, SLC_par, image_type, image_format, DOP)

        if self.mock_outputs:
            self._mock_par_UAVSAR_SLC_outputs(ann, SLC_par, image_type, image_format, DOP)

        ca = self._clean_args(locals(), inspect.signature(self.par_UAVSAR_SLC))
        result = self._gamma_call("ISP", "par_UAVSAR_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_ave_cpx(
        self,
        cpx_list: Path,
        width: int,
        cpx_ave: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ave_cpx.

        """

        assert cpx_list.exists(), f"{cpx_list} does not exist"
        assert cpx_list.stat().st_size > 0, f"{cpx_list} has zero file size"

        assert not cpx_ave.exists(), f"{cpx_ave} should _not_ exist!"

    def _mock_ave_cpx_outputs(
        self,
        cpx_list: Path,
        width: int,
        cpx_ave: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        """

        Mock the program ave_cpx.

        """

        if cpx_ave is not None and str(cpx_ave) != "-":
            cpx_ave.touch()

    def ave_cpx(
        self,
        cpx_list: Path,
        width: int,
        cpx_ave: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate average of a set of FCOMPLEX images


        input parameters:
          cpx_list  (input) list of coregistered images (FCOMPLEX)
          width     number of samples/line
          cpx_ave   (output) average of images listed in cpx_list (FCOMPLEX)
          start     starting line (enter - for default: 1)
          nlines    number of lines to process (enter - for default: entire file)
          zflag     zero flag (enter - for default)
                      0: interpret 0.0 as missing data value (default)
                      1: interpret 0.0 as valid data


        """

        if self.validate_inputs:
            self._validate_ave_cpx(cpx_list, width, cpx_ave, start, nlines, zflag)

        if self.mock_outputs:
            self._mock_ave_cpx_outputs(cpx_list, width, cpx_ave, start, nlines, zflag)

        ca = self._clean_args(locals(), inspect.signature(self.ave_cpx))
        result = self._gamma_call("ISP", "ave_cpx", ca)

        assert cpx_ave.exists(), f"{cpx_ave} does not exist"
        assert cpx_ave.stat().st_size > 0, f"{cpx_ave} has zero file size"

        return result

    def _validate_ScanSAR_burst_copy(
        self,
        SLC: Path,
        SLC_par: Path,
        TOPS_par: Path,
        SLC_out: Path,
        SLC_out_par: Path,
        burst_num: int,
        drflg: Optional[int] = None,
        SLC_par2: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ScanSAR_burst_copy.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert TOPS_par.exists(), f"{TOPS_par} does not exist"
        assert TOPS_par.stat().st_size > 0, f"{TOPS_par} has zero file size"

        assert not SLC_out.exists(), f"{SLC_out} should _not_ exist!"

        assert not SLC_out_par.exists(), f"{SLC_out_par} should _not_ exist!"

        if SLC_par2 is not None:
            assert not SLC_par2.exists(), f"{SLC_par2} should _not_ exist!"

    def _mock_ScanSAR_burst_copy_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        TOPS_par: Path,
        SLC_out: Path,
        SLC_out_par: Path,
        burst_num: int,
        drflg: Optional[int] = None,
        SLC_par2: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program ScanSAR_burst_copy.

        """

        if SLC_out is not None and str(SLC_out) != "-":
            SLC_out.touch()

        if SLC_out_par is not None and str(SLC_out_par) != "-":
            SLC_out_par.touch()

        if SLC_par2 is not None and str(SLC_par2) != "-":
            SLC_par2.touch()

    def ScanSAR_burst_copy(
        self,
        SLC: Path,
        SLC_par: Path,
        TOPS_par: Path,
        SLC_out: Path,
        SLC_out_par: Path,
        burst_num: int,
        drflg: Optional[int] = None,
        SLC_par2: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Copy selected burst from Sentinel-1 TOPS SLC to a file


        input parameters:
          SLC          (input) ScanSAR mode burst SLC
          SLC_par      (input) SLC parameter file for the ScanSAR burst scene
          TOPS_par     (input) burst parameter file for the ScanSAR burst SLC
          SLC_out      (output) SLC file containing a single burst
          SLC_out_par  (output) SLC parameter file for the single burst
          burst_num    burst number of selected burst (1 -> number of bursts in the SLC)
          drflg        deramp phase flag (enter - for default)
                         0: no modification of the burst SLC phase (default)
                         1: subtract TOPS mode Doppler phase ramp for Sentinel-1 (deramp)
          SLC_par2     (output) SLC parameter file for the single burst SLC with deramped phase (drflg: 1, enter - for none)
          dtype        output data type (enter - for default: same as input data):
                         0: FCOMPLEX
                         1: SCOMPLEX


        """

        if self.validate_inputs:
            self._validate_ScanSAR_burst_copy(
                SLC,
                SLC_par,
                TOPS_par,
                SLC_out,
                SLC_out_par,
                burst_num,
                drflg,
                SLC_par2,
                dtype,
            )

        if self.mock_outputs:
            self._mock_ScanSAR_burst_copy_outputs(
                SLC,
                SLC_par,
                TOPS_par,
                SLC_out,
                SLC_out_par,
                burst_num,
                drflg,
                SLC_par2,
                dtype,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_burst_copy))
        result = self._gamma_call("ISP", "ScanSAR_burst_copy", ca)

        assert SLC_out.exists(), f"{SLC_out} does not exist"
        assert SLC_out.stat().st_size > 0, f"{SLC_out} has zero file size"

        assert SLC_out_par.exists(), f"{SLC_out_par} does not exist"
        assert SLC_out_par.stat().st_size > 0, f"{SLC_out_par} has zero file size"

        if SLC_par2 is not None:
            assert SLC_par2.exists(), f"{SLC_par2} does not exist"
            assert SLC_par2.stat().st_size > 0, f"{SLC_par2} has zero file size"

        return result

    def _validate_hgt_map(
        self,
        unw: Path,
        SLC_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        gr: Path,
        ph_flag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to hgt_map.

        """

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert baseline.exists(), f"{baseline} does not exist"
        assert baseline.stat().st_size > 0, f"{baseline} has zero file size"

        assert not hgt.exists(), f"{hgt} should _not_ exist!"

        assert not gr.exists(), f"{gr} should _not_ exist!"

        if SLC2R_par is not None:
            assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
            assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

    def _mock_hgt_map_outputs(
        self,
        unw: Path,
        SLC_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        gr: Path,
        ph_flag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> None:
        """

        Mock the program hgt_map.

        """

        if hgt is not None and str(hgt) != "-":
            hgt.touch()

        if gr is not None and str(gr) != "-":
            gr.touch()

    def hgt_map(
        self,
        unw: Path,
        SLC_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        gr: Path,
        ph_flag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Interferometric height/ground range estimation vs. slant range


        input parameters:
          unw        (input) unwrapped interferometric phase
          SLC_par    (input) ISP parameter file for the reference SLC
          OFF_par    (input) ISP offset/interferogram processing parameters
          baseline   (input) baseline parameter file
          hgt        (output) height file (in slant range geometry) relative to the WGS-84 ellipsoid
          gr         (output) cross-track ground ranges on the WGS-84 ellipsoid (in slant range geometry)
          ph_flag    restore phase slope flag (0:no phase change  default=1:add back phase ramp)
          loff       offset to starting line (default = 0)
          nlines     number of lines to calculate (enter - for default: to end of file)
          SLC2R_par  (input) parameter file of resampled SLC, required if SLC-2 frequency differs from SLC-1


        """

        if self.validate_inputs:
            self._validate_hgt_map(
                unw, SLC_par, OFF_par, baseline, hgt, gr, ph_flag, loff, nlines, SLC2R_par
            )

        if self.mock_outputs:
            self._mock_hgt_map_outputs(
                unw, SLC_par, OFF_par, baseline, hgt, gr, ph_flag, loff, nlines, SLC2R_par
            )

        ca = self._clean_args(locals(), inspect.signature(self.hgt_map))
        result = self._gamma_call("ISP", "hgt_map", ca)

        assert hgt.exists(), f"{hgt} does not exist"
        assert hgt.stat().st_size > 0, f"{hgt} has zero file size"

        assert gr.exists(), f"{gr} does not exist"
        assert gr.stat().st_size > 0, f"{gr} has zero file size"

        return result

    def _validate_par_CS_SLC(
        self,
    ) -> None:
        """

        Validate the arguments to par_CS_SLC.

        """

        pass

    def _mock_par_CS_SLC_outputs(
        self,
    ) -> None:
        """

        Mock the program par_CS_SLC.

        """
        pass

    def par_CS_SLC(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        dyld[70935]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_CS_SLC'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)

        """

        if self.validate_inputs:
            self._validate_par_CS_SLC()

        if self.mock_outputs:
            self._mock_par_CS_SLC_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.par_CS_SLC))
        result = self._gamma_call("ISP", "par_CS_SLC", ca)
        return result

    def _validate_par_TX_GRD(
        self, annotation_XML: Path, GRD_par: Path, GRD: Path, pol: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to par_TX_GRD.

        """

        assert annotation_XML.exists(), f"{annotation_XML} does not exist"
        assert annotation_XML.stat().st_size > 0, f"{annotation_XML} has zero file size"

        assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_TX_GRD_outputs(
        self, annotation_XML: Path, GRD_par: Path, GRD: Path, pol: Optional[int] = None
    ) -> None:
        """

        Mock the program par_TX_GRD.

        """

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_TX_GRD(
        self, annotation_XML: Path, GRD_par: Path, GRD: Path, pol: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate ground range image and image parameter file for Terrasar-X MGD data in GeoTIFF format


        input parameters:
          annotation_XML (input) Terrasar-X product annotation XML file
          GeoTIFF  (input) image data file in geotiff format
                    NOTE: make sure the data set contains the selected polarisation)
          GRD_par   ISP ground range image parameter file (example: yyyymmdd.grd.par
          GRD       (output) calibrated ground range data file (example: yyyymmdd.grd)
          pol       polarisation: HH, HV, VH, VV (default: first polarisation found in the annotation_XML)


        """

        if self.validate_inputs:
            self._validate_par_TX_GRD(annotation_XML, GRD_par, GRD, pol)

        if self.mock_outputs:
            self._mock_par_TX_GRD_outputs(annotation_XML, GRD_par, GRD, pol)

        ca = self._clean_args(locals(), inspect.signature(self.par_TX_GRD))
        result = self._gamma_call("ISP", "par_TX_GRD", ca)

        assert GRD.exists(), f"{GRD} does not exist"
        assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_split_WB(
        self, data_in: Path, data_par_in: Path, data_tab: Path, dtype: int
    ) -> None:
        """

        Validate the arguments to split_WB.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert data_par_in.exists(), f"{data_par_in} does not exist"
        assert data_par_in.stat().st_size > 0, f"{data_par_in} has zero file size"

        assert data_tab.exists(), f"{data_tab} does not exist"
        assert data_tab.stat().st_size > 0, f"{data_tab} has zero file size"

        self._check_tab_file(data_tab, "data_tab")

    def _mock_split_WB_outputs(
        self, data_in: Path, data_par_in: Path, data_tab: Path, dtype: int
    ) -> None:
        """

        Mock the program split_WB.

        """
        pass

    def split_WB(
        self, data_in: Path, data_par_in: Path, data_tab: Path, dtype: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/split_WB
        Split WB mosaic image into individual beams using ISP parameter files


        input parameters:
          data_in      (input) input mosaicked data in slant-range geometry (e.g. DEM data)
          data_par_in  (input) ISP image parameter file for data in the input mosaic
          data_tab     (input) 2 column list of output data filenames and ISP image parameter files for each beam in the mosaic (text)
          dtype        (input) input data type:
                          0: FLOAT
                          1: FCOMPLEX

        """

        if self.validate_inputs:
            self._validate_split_WB(data_in, data_par_in, data_tab, dtype)

        if self.mock_outputs:
            self._mock_split_WB_outputs(data_in, data_par_in, data_tab, dtype)

        ca = self._clean_args(locals(), inspect.signature(self.split_WB))
        result = self._gamma_call("ISP", "split_WB", ca)
        return result

    def _validate_base_init(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Optional[Path],
        interf: Optional[Path],
        baseline: Path,
        mflag: Optional[int] = None,
        nrfft: Optional[int] = None,
        nazfft: Optional[int] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to base_init.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        if OFF_par is not None:
            assert OFF_par.exists(), f"{OFF_par} does not exist"
            assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        if interf is not None:
            assert interf.exists(), f"{interf} does not exist"
            assert interf.stat().st_size > 0, f"{interf} has zero file size"

        assert not baseline.exists(), f"{baseline} should _not_ exist!"

    def _mock_base_init_outputs(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Optional[Path],
        interf: Optional[Path],
        baseline: Path,
        mflag: Optional[int] = None,
        nrfft: Optional[int] = None,
        nazfft: Optional[int] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[int] = None,
    ) -> None:
        """

        Mock the program base_init.

        """

        if baseline is not None and str(baseline) != "-":
            baseline.touch()

    def base_init(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Optional[Path],
        interf: Optional[Path],
        baseline: Path,
        mflag: Optional[int] = None,
        nrfft: Optional[int] = None,
        nazfft: Optional[int] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate initial baseline using orbit state vectors, offsets, and interferogram phase


        input parameters:
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file (enter - for none)
          interf    (input) unflattened interferogram (enter - for none)
          baseline  (output) baseline parameter file
          mflag     baseline estimation method flag (enter - for default)
                    mflag    b_para    b_perp    input
                      0:     orbits    orbits    p1,p2  (default)
                      1:     offsets   offsets   p1,p2,off
                      2:     orbits    fft       p1,p2,off,int
                      3:     offsets   fft       p1,p2,off,int
                      4:     fft       fft       p1,off,int
          nrfft     size of range FFT   (512, 1024,...) (enter - for default determined from image width)
          nazfft    size of azimuth FFT (512, 1024,...) (enter - for default determined from image azimuth lines)
          r_samp    range pixel offset to center of the FFT window (enter - for default, default: range center)
          az_line   line offset from start of the interf. for the  FFT window (enter - for default, default: azimuth center)

          NOTE: Not all  input data files are required for the different methods

                enter - for files that are not provided


        """

        if self.validate_inputs:
            self._validate_base_init(
                SLC1_par,
                SLC2_par,
                OFF_par,
                interf,
                baseline,
                mflag,
                nrfft,
                nazfft,
                r_samp,
                az_line,
            )

        if self.mock_outputs:
            self._mock_base_init_outputs(
                SLC1_par,
                SLC2_par,
                OFF_par,
                interf,
                baseline,
                mflag,
                nrfft,
                nazfft,
                r_samp,
                az_line,
            )

        ca = self._clean_args(locals(), inspect.signature(self.base_init))
        result = self._gamma_call("ISP", "base_init", ca)

        assert baseline.exists(), f"{baseline} does not exist"
        assert baseline.stat().st_size > 0, f"{baseline} has zero file size"

        return result

    def _validate_par_SAOCOM_SLC(
        self,
        data: Optional[Path],
        XML: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        RSLC_par: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_SAOCOM_SLC.

        """

        if data is not None:
            assert data.exists(), f"{data} does not exist"
            assert data.stat().st_size > 0, f"{data} has zero file size"

        assert XML.exists(), f"{XML} does not exist"
        assert XML.stat().st_size > 0, f"{XML} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

        if TOPS_par is not None:
            assert not TOPS_par.exists(), f"{TOPS_par} should _not_ exist!"

        if RSLC_par is not None:
            assert RSLC_par.exists(), f"{RSLC_par} does not exist"
            assert RSLC_par.stat().st_size > 0, f"{RSLC_par} has zero file size"

    def _mock_par_SAOCOM_SLC_outputs(
        self,
        data: Optional[Path],
        XML: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        RSLC_par: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_SAOCOM_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

        if TOPS_par is not None and str(TOPS_par) != "-":
            TOPS_par.touch()

    def par_SAOCOM_SLC(
        self,
        data: Optional[Path],
        XML: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        RSLC_par: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for SAOCOM stripmap and TOPS SLC data


        input parameters:
          data          (input) SAOCOM image data file in binary format (enter - for none, e.g. slc-acqId0000089010-a-tna-0000000000-s3qp-hh)
          XML           (input) SAOCOM XML annotation file (e.g. slc-acqId0000089010-a-tna-0000000000-s3qp-hh.xml)
          SLC_par       (output) SLC parameter file (example: yyyymmdd_s3_pp.slc.par)
          SLC           (output) SLC data file (FCOMPLEX, enter - for none, example: yyyymmdd_s3_pp.slc)
          TOPS_par      (output) SLC burst annotation file, TOPS data only (enter - for none, example: yyyymmdd_s3_vv.slc.tops_par)
          RSLC_par      (input) reference SLC parameter file to keep consistent range pixel spacing (example: yyyymmdd_s1_pp.slc.par)

        NOTE: SAOCOM geocoded data in GeoTIFF format (GEC and GTC / level 1C and 1D data) can be read using par_SAOCOM_geo program


        """

        if self.validate_inputs:
            self._validate_par_SAOCOM_SLC(data, XML, SLC_par, SLC, TOPS_par, RSLC_par)

        if self.mock_outputs:
            self._mock_par_SAOCOM_SLC_outputs(data, XML, SLC_par, SLC, TOPS_par, RSLC_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_SAOCOM_SLC))
        result = self._gamma_call("ISP", "par_SAOCOM_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        if TOPS_par is not None:
            assert TOPS_par.exists(), f"{TOPS_par} does not exist"
            assert TOPS_par.stat().st_size > 0, f"{TOPS_par} has zero file size"

        return result

    def _validate_S1_import_SLC_from_zipfiles(
        self,
    ) -> None:
        """

        Validate the arguments to S1_import_SLC_from_zipfiles.

        """

        pass

    def _mock_S1_import_SLC_from_zipfiles_outputs(
        self,
    ) -> None:
        """

        Mock the program S1_import_SLC_from_zipfiles.

        """
        pass

    def S1_import_SLC_from_zipfiles(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        S1_import_SLC_from_zipfiles: Script to read in and concatenate S1 TOPS SLC from zip files

               zipfile_list            (input) ASCII file containing S1 zip filename(s) of one data take (one per line, in correct sequence)
               burst_number_table_ref  (input) ASCII file containing first/last burst numbers selected
                                       indicate - to use all bursts present in the indicated zipfiles
               pol                     polarization flag (default: -, other values are vv, vh, hh, hv)
                                       indicate - to use all polarizations available in the indicated zipfiles
               dtype                   output data type: default = 0: FCOMPLEX, 1: SCOMPLEX
               swath_flag              flag to select sub-swaths to read (default = 0 (as listed in burst_number_table_ref, all if no
                                       burst_number_table_ref provided), 1,2,3 (1 sub-swath only), 4 (1&2), 5 (2&3)
               OPOD_dir                directory with OPOD state vector files (default: .)
               cleaning                flag to indicate if intermediate files are deleted (default = 1: deleted, 0: not deleted)
               noise_mode              noise mode (default = 1: apply noise correction, 2: do not apply and write out noise file

        resulting files: burst SLC files (per polarization, with SLC_tab, SLC, SLC_par, TOPS_par and optionally SLC.noise)
        (concatenated, empty bursts added where necessary) at selected polarizations


        """

        if self.validate_inputs:
            self._validate_S1_import_SLC_from_zipfiles()

        if self.mock_outputs:
            self._mock_S1_import_SLC_from_zipfiles_outputs()

        ca = self._clean_args(
            locals(), inspect.signature(self.S1_import_SLC_from_zipfiles)
        )
        result = self._gamma_call("ISP", "S1_import_SLC_from_zipfiles", ca)
        return result

    def _validate_par_SIRC(self, CEOS_leader: Path, SLC_par: Path) -> None:
        """

        Validate the arguments to par_SIRC.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

    def _mock_par_SIRC_outputs(self, CEOS_leader: Path, SLC_par: Path) -> None:
        """

        Mock the program par_SIRC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_SIRC(
        self, CEOS_leader: Path, SLC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP SLC parameter file from SIR-C CEOS leader file


        input parameters:
          CEOS_leader   (input) JPL SIR-C CEOS leader file
          SLC_par       (output) ISP SLC parameter file
          UTC/MET       time reference for state vectors:
                        MET (Mission Elapsed Time) or UTC (default=UTC)

        """

        if self.validate_inputs:
            self._validate_par_SIRC(CEOS_leader, SLC_par)

        if self.mock_outputs:
            self._mock_par_SIRC_outputs(CEOS_leader, SLC_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_SIRC))
        result = self._gamma_call("ISP", "par_SIRC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_rascc_mask(
        self,
        cc: Path,
        pwr: Optional[Path],
        width: int,
        start_cc: Optional[int] = None,
        start_pwr: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        cc_thres: Optional[Path] = None,
        pwr_thres: Optional[Path] = None,
        cc_min: Optional[int] = None,
        cc_max: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        LR: Optional[int] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to rascc_mask.

        """

        assert cc.exists(), f"{cc} does not exist"
        assert cc.stat().st_size > 0, f"{cc} has zero file size"

        if pwr is not None:
            assert pwr.exists(), f"{pwr} does not exist"
            assert pwr.stat().st_size > 0, f"{pwr} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_rascc_mask_outputs(
        self,
        cc: Path,
        pwr: Optional[Path],
        width: int,
        start_cc: Optional[int] = None,
        start_pwr: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        cc_thres: Optional[Path] = None,
        pwr_thres: Optional[Path] = None,
        cc_min: Optional[int] = None,
        cc_max: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        LR: Optional[int] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Mock the program rascc_mask.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rascc_mask(
        self,
        cc: Path,
        pwr: Optional[Path],
        width: int,
        start_cc: Optional[int] = None,
        start_pwr: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        cc_thres: Optional[Path] = None,
        pwr_thres: Optional[Path] = None,
        cc_min: Optional[int] = None,
        cc_max: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        LR: Optional[int] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate phase unwrapping validity mask using correlation and intensity


        input parameters:
          cc         (input)interferometric correlation image (float)
          pwr        (input)intensity image (float, enter - if not available)
          width      number of samples/row
          start_cc   starting line of coherence image (default: 1)
          start_pwr  starting line of intensity image (default: 1)
          nlines     number of lines to display (default=0: to end of file)
          pixavr     number of pixels to average in range (default: 1)
          pixavaz    number of pixels to average in azimuth (default: 1)
          cc_thres   coherence threshold for masking, pixels with cc < cc_thres are set to 0 (default: 0.0)
          pwr_thres  relative intensity threshold for masking, pixels with intensity < pwr_thres * average intensity are set to 0 (default: 0)
          cc_min     minimum coherence value used for color display (default: 0.1)
          cc_max     maximum coherence value used for color display (default: 0.9)
          scale      intensity display scale factor (default: 1.)
          exp        intensity display exponent (default: .35)
          LR         left/right mirror image flag, (1: normal (default), -1: mirror image)
          rasf       (output) image filename, extension determines the format, enter - for default: *.bmp
                       *.bmp BMP format
                       *.ras Sun raster format
                       *.tif TIFF format

        """

        if self.validate_inputs:
            self._validate_rascc_mask(
                cc,
                pwr,
                width,
                start_cc,
                start_pwr,
                nlines,
                pixavr,
                pixavaz,
                cc_thres,
                pwr_thres,
                cc_min,
                cc_max,
                scale,
                exp,
                LR,
                rasf,
            )

        if self.mock_outputs:
            self._mock_rascc_mask_outputs(
                cc,
                pwr,
                width,
                start_cc,
                start_pwr,
                nlines,
                pixavr,
                pixavaz,
                cc_thres,
                pwr_thres,
                cc_min,
                cc_max,
                scale,
                exp,
                LR,
                rasf,
            )

        ca = self._clean_args(locals(), inspect.signature(self.rascc_mask))
        result = self._gamma_call("ISP", "rascc_mask", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_SLC_mosaic_ScanSAR(
        self,
        SLC_tab: Path,
        SLC: Path,
        SLC_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to SLC_mosaic_ScanSAR.

        """

        assert SLC_tab.exists(), f"{SLC_tab} does not exist"
        assert SLC_tab.stat().st_size > 0, f"{SLC_tab} has zero file size"

        self._check_tab_file(SLC_tab, "SLC_tab")

        assert not SLC.exists(), f"{SLC} should _not_ exist!"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLCR_tab is not None:
            assert SLCR_tab.exists(), f"{SLCR_tab} does not exist"
            assert SLCR_tab.stat().st_size > 0, f"{SLCR_tab} has zero file size"

    def _mock_SLC_mosaic_ScanSAR_outputs(
        self,
        SLC_tab: Path,
        SLC: Path,
        SLC_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
    ) -> None:
        """

        Mock the program SLC_mosaic_ScanSAR.

        """

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def SLC_mosaic_ScanSAR(
        self,
        SLC_tab: Path,
        SLC: Path,
        SLC_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate SLC mosaic of ScanSAR SLC burst data (Sentinel-1, TerraSAR-X, RCM...)


        input parameters:
          SLC_tab    (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range
                       SLC_tab line entries:   SLC   SLC_par   TOPS_par
          SLC        (output) SLC mosaic image
          SLC_par    (output) SLC mosaic image parameter file
          rlks       number of range looks used to determine burst window boundaries for the mosaic
          azlks      number of azimuth looks used to determine burst window boundaries for the mosaic
          bflg       burst window calculation flag:
                       0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                       1: calculate burst window parameters from burst parameters and the number of range and azimuth looks
          SLCR_tab   (input) 3 column list of the reference scene, swaths are listed in order from near to far range, enter - for none
                       SLCR_tab line entries:   SLC   SLC_par   TOPS_par
                     NOTE: When generating a mosaic of a resampled SLC, the SLC_tab of the reference scene is required


        """

        if self.validate_inputs:
            self._validate_SLC_mosaic_ScanSAR(
                SLC_tab, SLC, SLC_par, rlks, azlks, bflg, SLCR_tab
            )

        if self.mock_outputs:
            self._mock_SLC_mosaic_ScanSAR_outputs(
                SLC_tab, SLC, SLC_par, rlks, azlks, bflg, SLCR_tab
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_mosaic_ScanSAR))
        result = self._gamma_call("ISP", "SLC_mosaic_ScanSAR", ca)

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_init_offset_orbit(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        cflag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to init_offset_orbit.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

    def _mock_init_offset_orbit_outputs(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        cflag: Optional[int] = None,
    ) -> None:
        """

        Mock the program init_offset_orbit.

        """

        if not OFF_par.exists():
            OFF_par.touch()

    def init_offset_orbit(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rpos: Optional[int] = None,
        azpos: Optional[int] = None,
        cflag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Initial SLC image offset estimation from orbit state-vectors and image parameters


        input parameters:
          SLC1_par  (input) SLC-1 parameter file
          SLC2_par  (input) SLC-2 parameter file
          OFF_par   (input/output) ISP/offset parameter file
          rpos      range position for offset estimation (enter - for default: center of SLC-1)
          azpos     azimuth position for offset estimation (enter - for default: center of SLC-1)
          cflag     copy offsets to the range and azimuth offset polynomials in the OFF_par
                      0: do not copy
                      1: copy constant range and azimuth offset (default)


        """

        if self.validate_inputs:
            self._validate_init_offset_orbit(
                SLC1_par, SLC2_par, OFF_par, rpos, azpos, cflag
            )

        if self.mock_outputs:
            self._mock_init_offset_orbit_outputs(
                SLC1_par, SLC2_par, OFF_par, rpos, azpos, cflag
            )

        ca = self._clean_args(locals(), inspect.signature(self.init_offset_orbit))
        result = self._gamma_call("ISP", "init_offset_orbit", ca)

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        return result

    def _validate_interf_SLC(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        MLI_1: Path,
        MLI_2: Path,
        interf: int,
        nrlk: Optional[int] = None,
        nazlk: Optional[int] = None,
        loff: Optional[int] = None,
        nltot: Optional[int] = None,
        rfilt: Optional[int] = None,
        azfilt: Optional[int] = None,
        s_off: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to interf_SLC.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not MLI_1.exists(), f"{MLI_1} should _not_ exist!"

        assert not MLI_2.exists(), f"{MLI_2} should _not_ exist!"

    def _mock_interf_SLC_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        MLI_1: Path,
        MLI_2: Path,
        interf: int,
        nrlk: Optional[int] = None,
        nazlk: Optional[int] = None,
        loff: Optional[int] = None,
        nltot: Optional[int] = None,
        rfilt: Optional[int] = None,
        azfilt: Optional[int] = None,
        s_off: Optional[int] = None,
    ) -> None:
        """

        Mock the program interf_SLC.

        """

        if MLI_1 is not None and str(MLI_1) != "-":
            MLI_1.touch()

        if MLI_2 is not None and str(MLI_2) != "-":
            MLI_2.touch()

    def interf_SLC(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        MLI_1: Path,
        MLI_2: Path,
        interf: int,
        nrlk: Optional[int] = None,
        nazlk: Optional[int] = None,
        loff: Optional[int] = None,
        nltot: Optional[int] = None,
        rfilt: Optional[int] = None,
        azfilt: Optional[int] = None,
        s_off: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Interferogram generation using a pair of SLC images


        input parameters:
          SLC-1     (input) single-look complex image 1 (reference)
          SLC-2     (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          MLI-1     (output) multi-look intensity image 1
          MLI-2     (output) multi-look intensity image 2
          interf    interferogram from SLC-1 and SLC-2
          nrlk      number of interferogram range looks (default: 2)
          nazlk     number of interferogram azimuth looks (default: 10)
          loff      offset to starting line of interferogram (relative to start of SLC-1) (default: 0)
          nltot     number of SLC lines to process (default: 0, to end of file)
          rfilt     range common band filtering flag
                      0: OFF
                      1: ON (default)
          azfilt    azimuth common band filtering flag
                      0: OFF
                      1: ON (default)
          s_off     offset to the nominal range spectral shift (frac. of range sampling freq.) (default: 0.0)

        NOTE: enter - as filename to avoid creation of corresponding output file


        """

        if self.validate_inputs:
            self._validate_interf_SLC(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                MLI_1,
                MLI_2,
                interf,
                nrlk,
                nazlk,
                loff,
                nltot,
                rfilt,
                azfilt,
                s_off,
            )

        if self.mock_outputs:
            self._mock_interf_SLC_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                MLI_1,
                MLI_2,
                interf,
                nrlk,
                nazlk,
                loff,
                nltot,
                rfilt,
                azfilt,
                s_off,
            )

        ca = self._clean_args(locals(), inspect.signature(self.interf_SLC))
        result = self._gamma_call("ISP", "interf_SLC", ca)

        assert MLI_1.exists(), f"{MLI_1} does not exist"
        assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        assert MLI_2.exists(), f"{MLI_2} does not exist"
        assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

        return result

    def _validate_MLI_cat(
        self,
        MLI_1: Path,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        MLI_3: Path,
        MLI3_par: Path,
        dtype: Optional[int] = None,
        mflg: Optional[int] = None,
        overlap: Optional[int] = None,
        interp_mode: Optional[int] = None,
        degree: Optional[int] = None,
        extrapol: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to MLI_cat.

        """

        assert MLI_1.exists(), f"{MLI_1} does not exist"
        assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        assert MLI_2.exists(), f"{MLI_2} does not exist"
        assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

        assert MLI1_par.exists(), f"{MLI1_par} does not exist"
        assert MLI1_par.stat().st_size > 0, f"{MLI1_par} has zero file size"

        assert MLI2_par.exists(), f"{MLI2_par} does not exist"
        assert MLI2_par.stat().st_size > 0, f"{MLI2_par} has zero file size"

        assert not MLI_3.exists(), f"{MLI_3} should _not_ exist!"

        assert not MLI3_par.exists(), f"{MLI3_par} should _not_ exist!"

    def _mock_MLI_cat_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        MLI_3: Path,
        MLI3_par: Path,
        dtype: Optional[int] = None,
        mflg: Optional[int] = None,
        overlap: Optional[int] = None,
        interp_mode: Optional[int] = None,
        degree: Optional[int] = None,
        extrapol: Optional[int] = None,
    ) -> None:
        """

        Mock the program MLI_cat.

        """

        if MLI_3 is not None and str(MLI_3) != "-":
            MLI_3.touch()

        if MLI3_par is not None and str(MLI3_par) != "-":
            MLI3_par.touch()

    def MLI_cat(
        self,
        MLI_1: Path,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        MLI_3: Path,
        MLI3_par: Path,
        dtype: Optional[int] = None,
        mflg: Optional[int] = None,
        overlap: Optional[int] = None,
        interp_mode: Optional[int] = None,
        degree: Optional[int] = None,
        extrapol: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Concatenate two MLI images using B-spline interpolation


        input parameters:
          MLI-1         (input) MLI-1 image (single-look)
          MLI-2         (input) MLI-2 image to be appended to MLI-1
          MLI1_par      (input) MLI-1 ISP image parameter file
          MLI2_par      (input) MLI-2 ISP image parameter file
          MLI-3         (output) concatenated MLI image
          MLI3_par      (output) ISP image parameter file for concatenated image
          dtype         input/output data type (enter - for default)
                          0: FLOAT (default)
                          1: FCOMPLEX
                        NOTE: FCOMPLEX is for differential interferograms
          mflg          mosaicking option flag (enter - for default)
                          0: in overlapping areas, use MLI-2 data to fill MLI-1 empty areas (default)
                          1: in overlapping areas, do not use MLI-2 data to fill MLI-1 empty areas
          overlap       number of pixels at the edge of MLI-1 valid areas to replace by MLI-2 data (only if mflg=0, enter - for default: 0)
          interp_mode   interpolation mode in case of different geometries (enter - for default)
                          0: B-spline interpolation (default for FCOMPLEX)
                          1: B-spline interpolation sqrt(x) (default for FLOAT)
                        NOTE: sqrt interpolation mode should only be used with non-negative data!
          degree        B-spline degree (2->9) (enter - default: 4)
          extrapol      extrapolation flag (enter - for default)
                          0: do not extrapolate (default)
                          1: extrapolate last line if needed


        """

        if self.validate_inputs:
            self._validate_MLI_cat(
                MLI_1,
                MLI_2,
                MLI1_par,
                MLI2_par,
                MLI_3,
                MLI3_par,
                dtype,
                mflg,
                overlap,
                interp_mode,
                degree,
                extrapol,
            )

        if self.mock_outputs:
            self._mock_MLI_cat_outputs(
                MLI_1,
                MLI_2,
                MLI1_par,
                MLI2_par,
                MLI_3,
                MLI3_par,
                dtype,
                mflg,
                overlap,
                interp_mode,
                degree,
                extrapol,
            )

        ca = self._clean_args(locals(), inspect.signature(self.MLI_cat))
        result = self._gamma_call("ISP", "MLI_cat", ca)

        assert MLI_3.exists(), f"{MLI_3} does not exist"
        assert MLI_3.stat().st_size > 0, f"{MLI_3} has zero file size"

        assert MLI3_par.exists(), f"{MLI3_par} does not exist"
        assert MLI3_par.stat().st_size > 0, f"{MLI3_par} has zero file size"

        return result

    def _validate_par_RCM_SLC(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int],
        noise: Optional[int],
        SLC_par: Path,
        SLC: Path,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_RCM_SLC.

        """

        assert RCM_dir.exists(), f"{RCM_dir} does not exist"
        assert RCM_dir.stat().st_size > 0, f"{RCM_dir} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        assert not SLC.exists(), f"{SLC} should _not_ exist!"

        if noise_pwr is not None:
            assert not noise_pwr.exists(), f"{noise_pwr} should _not_ exist!"

    def _mock_par_RCM_SLC_outputs(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int],
        noise: Optional[int],
        SLC_par: Path,
        SLC: Path,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_RCM_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

        if noise_pwr is not None and str(noise_pwr) != "-":
            noise_pwr.touch()

    def par_RCM_SLC(
        self,
        RCM_dir: Path,
        polarization: int,
        radcal: Optional[int],
        noise: Optional[int],
        SLC_par: Path,
        SLC: Path,
        noise_pwr: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for Radarsat Constellation SLC data from GeoTIFF or NITF file


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM2_OK1002260_PK1002436_3_SC50MB_20160417_002427_VH_VV_SLC)
          polarization   image polarization: HH, VV, HV, VH, CH, CV
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise          noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          SLC_par        (output) ISP SLC parameter file (example: yyyymmdd_pp.slc.par)
          SLC            (output) SLC data file (example: yyyymmdd_pp.slc)
          noise_pwr      (output) noise intensity for each SLC sample in slant range using data from noise levels file (enter - for none)
                         NOTE: when the noise_pwr file is specified, noise power correction will NOT be applied to the SLC data values


        """

        if self.validate_inputs:
            self._validate_par_RCM_SLC(
                RCM_dir, polarization, radcal, noise, SLC_par, SLC, noise_pwr
            )

        if self.mock_outputs:
            self._mock_par_RCM_SLC_outputs(
                RCM_dir, polarization, radcal, noise, SLC_par, SLC, noise_pwr
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RCM_SLC))
        result = self._gamma_call("ISP", "par_RCM_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        if noise_pwr is not None:
            assert noise_pwr.exists(), f"{noise_pwr} does not exist"
            assert noise_pwr.stat().st_size > 0, f"{noise_pwr} has zero file size"

        return result

    def _validate_par_ESA_PALSAR_GDH(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_ESA_PALSAR_GDH.

        """

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

        if MLI is not None:
            assert not MLI.exists(), f"{MLI} should _not_ exist!"

        if GRD_par is not None:
            assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_ESA_PALSAR_GDH_outputs(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_ESA_PALSAR_GDH.

        """

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

        if MLI is not None and str(MLI) != "-":
            MLI.touch()

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_ESA_PALSAR_GDH(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate MLI and GRD image and parameter files for PALSAR + PALSAR2 level 1.5 GDH data provided by ESA


        input parameters:
          CEOS_data     (input) CEOS image file for PALSAR or PALSAR-2 Level 1.5 GDH data (IMG...)
          CEOS_leader   (input) CEOS leader file for PALSAR or PALSAR-2 Level 1.5 GDH data (LED...)
          MLI_par       (output) MLI parameter file (example: yyyymmdd_pp.mli.par)
          MLI           (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par       (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD           (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          rps           slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)


        """

        if self.validate_inputs:
            self._validate_par_ESA_PALSAR_GDH(
                CEOS_data, CEOS_leader, MLI_par, MLI, GRD_par, GRD, rps
            )

        if self.mock_outputs:
            self._mock_par_ESA_PALSAR_GDH_outputs(
                CEOS_data, CEOS_leader, MLI_par, MLI, GRD_par, GRD, rps
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_ESA_PALSAR_GDH))
        result = self._gamma_call("ISP", "par_ESA_PALSAR_GDH", ca)

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        if MLI is not None:
            assert MLI.exists(), f"{MLI} does not exist"
            assert MLI.stat().st_size > 0, f"{MLI} has zero file size"

        if GRD_par is not None:
            assert GRD_par.exists(), f"{GRD_par} does not exist"
            assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_phase_slope(
        self,
        interf: Path,
        slopes: Path,
        width: int,
        win_sz: Optional[int] = None,
        thres: Optional[float] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to phase_slope.

        """

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        assert not slopes.exists(), f"{slopes} should _not_ exist!"

    def _mock_phase_slope_outputs(
        self,
        interf: Path,
        slopes: Path,
        width: int,
        win_sz: Optional[int] = None,
        thres: Optional[float] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Mock the program phase_slope.

        """

        if slopes is not None and str(slopes) != "-":
            slopes.touch()

    def phase_slope(
        self,
        interf: Path,
        slopes: Path,
        width: int,
        win_sz: Optional[int] = None,
        thres: Optional[float] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate interferogram phase slopes in range and azimuth


        input parameters:
          interf  (input) interferogram (fcomplex)
          slopes  (output) range and azimuth phase slopes (fcomplex)
          width   number of samples/row
          win_sz  size of region used for slopes determination (default = 5)
          thres   correlation threshold for accepting slope estimates 0.0 -> 1.0 (default=.4)
          xmin    starting range pixel offset (default = 0)
          xmax    last range pixel offset (default = width-1)
          ymin    starting azimuth row offset (default = 0)
          ymax    last azimuth row offset (default = nlines-1)


        """

        if self.validate_inputs:
            self._validate_phase_slope(
                interf, slopes, width, win_sz, thres, xmin, xmax, ymin, ymax
            )

        if self.mock_outputs:
            self._mock_phase_slope_outputs(
                interf, slopes, width, win_sz, thres, xmin, xmax, ymin, ymax
            )

        ca = self._clean_args(locals(), inspect.signature(self.phase_slope))
        result = self._gamma_call("ISP", "phase_slope", ca)

        assert slopes.exists(), f"{slopes} does not exist"
        assert slopes.stat().st_size > 0, f"{slopes} has zero file size"

        return result

    def _validate_par_CSG_SLC(
        self,
    ) -> None:
        """

        Validate the arguments to par_CSG_SLC.

        """

        pass

    def _mock_par_CSG_SLC_outputs(
        self,
    ) -> None:
        """

        Mock the program par_CSG_SLC.

        """
        pass

    def par_CSG_SLC(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        dyld[70933]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_CSG_SLC'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)

        """

        if self.validate_inputs:
            self._validate_par_CSG_SLC()

        if self.mock_outputs:
            self._mock_par_CSG_SLC_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.par_CSG_SLC))
        result = self._gamma_call("ISP", "par_CSG_SLC", ca)
        return result

    def _validate_par_TX_ScanSAR(
        self,
        annot_XML: Path,
        swath: int,
        SLC_par: Path,
        SLC: Optional[Path],
        TOPS_par: Path,
        bwflg: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_TX_ScanSAR.

        """

        assert annot_XML.exists(), f"{annot_XML} does not exist"
        assert annot_XML.stat().st_size > 0, f"{annot_XML} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

        assert not TOPS_par.exists(), f"{TOPS_par} should _not_ exist!"

    def _mock_par_TX_ScanSAR_outputs(
        self,
        annot_XML: Path,
        swath: int,
        SLC_par: Path,
        SLC: Optional[Path],
        TOPS_par: Path,
        bwflg: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_TX_ScanSAR.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

        if TOPS_par is not None and str(TOPS_par) != "-":
            TOPS_par.touch()

    def par_TX_ScanSAR(
        self,
        annot_XML: Path,
        swath: int,
        SLC_par: Path,
        SLC: Optional[Path],
        TOPS_par: Path,
        bwflg: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC, SLC_par and TOPS_par from a Terrasar-X ScanSAR data set


        input parameters:
          annot_XML  (input) TerraSAR-X ScanSAR product annotation XML file including path
                     NOTE: The path to the image products is determined from the path to the XML annotation
          swath      number specifying the desired ScanSAR swath (1 -> maximum number of swaths (4 or 6))
                     NOTE: The image product name is specified in the XML file
          SLC_par    (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC        (output) SLC ScanSAR data file, example: yyyymmdd.slc (enter - for none, SLC output will not be produced)
          TOPS_par   (output) SLC ScanSAR burst annotation file (example: yyyymmdd_s1.slc.tops_par
          bwflg      burst window flag (enter - for default)
                       0: use first and last annotation line values specified in the annot_XML
                       1: extend first and last valid line to include all data lines (default)
          dtype      output data type (enter - for default)
                       0: same as input (default)
                       1: FCOMPLEX
          NOTE: While TSX ScanSAR data are not acquired in TOPS mode, the same data structure can be used for burst annotation


        """

        if self.validate_inputs:
            self._validate_par_TX_ScanSAR(
                annot_XML, swath, SLC_par, SLC, TOPS_par, bwflg, dtype
            )

        if self.mock_outputs:
            self._mock_par_TX_ScanSAR_outputs(
                annot_XML, swath, SLC_par, SLC, TOPS_par, bwflg, dtype
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_TX_ScanSAR))
        result = self._gamma_call("ISP", "par_TX_ScanSAR", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert TOPS_par.exists(), f"{TOPS_par} does not exist"
        assert TOPS_par.stat().st_size > 0, f"{TOPS_par} has zero file size"

        return result

    def _validate_ave_image(
        self,
        im_list: Path,
        width: int,
        ave_image: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
        nmin: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ave_image.

        """

        assert im_list.exists(), f"{im_list} does not exist"
        assert im_list.stat().st_size > 0, f"{im_list} has zero file size"

        assert not ave_image.exists(), f"{ave_image} should _not_ exist!"

    def _mock_ave_image_outputs(
        self,
        im_list: Path,
        width: int,
        ave_image: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
        nmin: Optional[int] = None,
    ) -> None:
        """

        Mock the program ave_image.

        """

        if ave_image is not None and str(ave_image) != "-":
            ave_image.touch()

    def ave_image(
        self,
        im_list: Path,
        width: int,
        ave_image: Path,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
        nmin: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate average of a set of FLOAT images


        input parameters:
          im_list    (input) list of coregistered images (FLOAT)
          width      number of samples/line
          ave_image  (output) average of images listed in im_list (FLOAT)
          start      starting line (enter - for default: 1)
          nlines     number of lines to process (enter - for default: entire file)
          pixav_x    number of pixels to average in width  (enter - for default: 1)
          pixav_y    number of pixels to average in height (enter - for default: 1)
          zflag      zero flag (enter - for default)
                       0: interpret 0.0 as missing data value (default)
                       1: interpret 0.0 as valid data
          nmin       minimum number of images required to calculate the average if zflag = 0 (enter - for default: 3/4*nfiles)


        """

        if self.validate_inputs:
            self._validate_ave_image(
                im_list, width, ave_image, start, nlines, pixav_x, pixav_y, zflag, nmin
            )

        if self.mock_outputs:
            self._mock_ave_image_outputs(
                im_list, width, ave_image, start, nlines, pixav_x, pixav_y, zflag, nmin
            )

        ca = self._clean_args(locals(), inspect.signature(self.ave_image))
        result = self._gamma_call("ISP", "ave_image", ca)

        assert ave_image.exists(), f"{ave_image} does not exist"
        assert ave_image.stat().st_size > 0, f"{ave_image} has zero file size"

        return result

    def _validate_par_STRIX(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_STRIX.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_STRIX_outputs(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_STRIX.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_STRIX(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for Synspective StriX SLC data


        input parameters:
          CEOS_leader  (input) CEOS leader file for STRIX-alpha SLC data (LED-STRIXA...)
          SLC_par      (output) ISP image parameter file (example: yyyymmdd.slc.par)
          CEOS_data    (input) STRIX-alpha CEOS format SLC (IMG-pp-STRIXA...)
          SLC          (output) reformatted STRIX SLC (example: yyyymmdd.slc, enter - for none)


        """

        if self.validate_inputs:
            self._validate_par_STRIX(CEOS_leader, SLC_par, CEOS_data, SLC)

        if self.mock_outputs:
            self._mock_par_STRIX_outputs(CEOS_leader, SLC_par, CEOS_data, SLC)

        ca = self._clean_args(locals(), inspect.signature(self.par_STRIX))
        result = self._gamma_call("ISP", "par_STRIX", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_ASAR_LO_phase_drift(
        self, SLC1_par: Path, SLC2_par: Path, OFF_par: Path, ph_drift: Path
    ) -> None:
        """

        Validate the arguments to ASAR_LO_phase_drift.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not ph_drift.exists(), f"{ph_drift} should _not_ exist!"

    def _mock_ASAR_LO_phase_drift_outputs(
        self, SLC1_par: Path, SLC2_par: Path, OFF_par: Path, ph_drift: Path
    ) -> None:
        """

        Mock the program ASAR_LO_phase_drift.

        """

        if ph_drift is not None and str(ph_drift) != "-":
            ph_drift.touch()

    def ASAR_LO_phase_drift(
        self, SLC1_par: Path, SLC2_par: Path, OFF_par: Path, ph_drift: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate interferometric phase correction due to drift of the ASAR local oscillator


        input parameters:
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          ph_drift  (output) interferometric phase correction due to drift of the ASAR LO (radians)

        """

        if self.validate_inputs:
            self._validate_ASAR_LO_phase_drift(SLC1_par, SLC2_par, OFF_par, ph_drift)

        if self.mock_outputs:
            self._mock_ASAR_LO_phase_drift_outputs(SLC1_par, SLC2_par, OFF_par, ph_drift)

        ca = self._clean_args(locals(), inspect.signature(self.ASAR_LO_phase_drift))
        result = self._gamma_call("ISP", "ASAR_LO_phase_drift", ca)

        assert ph_drift.exists(), f"{ph_drift} does not exist"
        assert ph_drift.stat().st_size > 0, f"{ph_drift} has zero file size"

        return result

    def _validate_par_RSI(
        self,
    ) -> None:
        """

        Validate the arguments to par_RSI.

        """

        pass

    def _mock_par_RSI_outputs(
        self,
    ) -> None:
        """

        Mock the program par_RSI.

        """
        pass

    def par_RSI(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """


        ****************************************************************
        NOTE: Program par_RSI has been replaced by par_RSI_ERS.
        Please replace all calls to par_RSI.
        ****************************************************************

        par_RSI_ERS: Command not found.

        """

        if self.validate_inputs:
            self._validate_par_RSI()

        if self.mock_outputs:
            self._mock_par_RSI_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.par_RSI))
        result = self._gamma_call("ISP", "par_RSI", ca)
        return result

    def _validate_radcal_pwr_stat(
        self,
        SLC_tab: Path,
        SLC_tab_cal: Optional[Path],
        plist: Path,
        MSR_cal: int,
        PWR_cal: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        plist_out: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to radcal_pwr_stat.

        """

        assert SLC_tab.exists(), f"{SLC_tab} does not exist"
        assert SLC_tab.stat().st_size > 0, f"{SLC_tab} has zero file size"

        self._check_tab_file(SLC_tab, "SLC_tab")

        if SLC_tab_cal is not None:
            assert SLC_tab_cal.exists(), f"{SLC_tab_cal} does not exist"
            assert SLC_tab_cal.stat().st_size > 0, f"{SLC_tab_cal} has zero file size"

        assert plist.exists(), f"{plist} does not exist"
        assert plist.stat().st_size > 0, f"{plist} has zero file size"

    def _mock_radcal_pwr_stat_outputs(
        self,
        SLC_tab: Path,
        SLC_tab_cal: Optional[Path],
        plist: Path,
        MSR_cal: int,
        PWR_cal: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        plist_out: Optional[int] = None,
    ) -> None:
        """

        Mock the program radcal_pwr_stat.

        """
        pass

    def radcal_pwr_stat(
        self,
        SLC_tab: Path,
        SLC_tab_cal: Optional[Path],
        plist: Path,
        MSR_cal: int,
        PWR_cal: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        plist_out: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate calibrated SLC image files using point targets determined from the Mean/Sigma Ratio and Intensity


        input parameters:
          SLC_tab      (input) two column list of the SLC filenames and SLC parameter filenames of the uncalibrated SLC images
          SLC_tab_cal  (input) two column list of the SLC filenames and SLC parameter filenames of the calibrated SLC images (enter - for none)
          plist        (input) point list for the point to use for calibraton (int, enter - to use the data to determine the calibration points)
          MSR_cal      mean/sigma ratio for point target selection for relative calibration between scenes:    1.500
          PWR_cal      intensity threshold ratio for point target selection for relative calibration between scenes:    1.000
          roff         offset to starting range of section to analyze (default -: 0)
          loff         offset to starting line of section to analyze (default -: 0)
          nr           number of range pixels to analyze (default -: to end of line)
          nl           number of azimuth lines to analyze (default -: to end of file)
          plist_out    point list of points used to determine calibration using MSR_cal and PWR_cal thresholds

        """

        if self.validate_inputs:
            self._validate_radcal_pwr_stat(
                SLC_tab,
                SLC_tab_cal,
                plist,
                MSR_cal,
                PWR_cal,
                roff,
                loff,
                nr,
                nl,
                plist_out,
            )

        if self.mock_outputs:
            self._mock_radcal_pwr_stat_outputs(
                SLC_tab,
                SLC_tab_cal,
                plist,
                MSR_cal,
                PWR_cal,
                roff,
                loff,
                nr,
                nl,
                plist_out,
            )

        ca = self._clean_args(locals(), inspect.signature(self.radcal_pwr_stat))
        result = self._gamma_call("ISP", "radcal_pwr_stat", ca)
        return result

    def _validate_par_ICEYE_SLC(
        self,
    ) -> None:
        """

        Validate the arguments to par_ICEYE_SLC.

        """

        pass

    def _mock_par_ICEYE_SLC_outputs(
        self,
    ) -> None:
        """

        Mock the program par_ICEYE_SLC.

        """
        pass

    def par_ICEYE_SLC(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        dyld[70961]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_ICEYE_SLC'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)

        """

        if self.validate_inputs:
            self._validate_par_ICEYE_SLC()

        if self.mock_outputs:
            self._mock_par_ICEYE_SLC_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.par_ICEYE_SLC))
        result = self._gamma_call("ISP", "par_ICEYE_SLC", ca)
        return result

    def _validate_offset_SLC_tracking(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rsw: Optional[int] = None,
        azsw: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        ISZ: Optional[int] = None,
        pflag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_SLC_tracking.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not snr.exists(), f"{snr} should _not_ exist!"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

    def _mock_offset_SLC_tracking_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rsw: Optional[int] = None,
        azsw: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        ISZ: Optional[int] = None,
        pflag: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_SLC_tracking.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if snr is not None and str(snr) != "-":
            snr.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

    def offset_SLC_tracking(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rsw: Optional[int] = None,
        azsw: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        thres: Optional[float] = None,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        ISZ: Optional[int] = None,
        pflag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offset tracking between SLC images using fringe visibility


        input parameters:
          SLC-1     (input) single-look complex image 1 (reference)
          SLC-2     (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates (fcomplex)
          snr       (output) offset estimation SNR (float)
          rsw       range search window size (range pixels) (enter - for default from offset parameter file)
          azsw      azimuth search window size (azimuth lines) (enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and SNR data in text format, enter - for no output
          n_ovr     SLC over-sampling factor (integer 2**N (1,2,4) default: 2)
          thres     offset estimation quality threshold (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rsw/2)
          azstep    step in azimuth pixels (enter - for default: azsw/2)
          rstart    starting range pixel (enter - for default: rsw/2)
          rstop     ending range pixel (enter - for default: nr - rsw/2)
          azstart   starting azimuth line (enter - for default: azsw/2)
          azstop    ending azimuth line  (enter - for default: nlines - azsw/2)
          ISZ       search chip interferogram size (in non-oversampled pixels, default: 16)
          pflag     print flag:
                      0: print offset summary  (default)
                      1: print all offset data

        """

        if self.validate_inputs:
            self._validate_offset_SLC_tracking(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                snr,
                rsw,
                azsw,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                ISZ,
                pflag,
            )

        if self.mock_outputs:
            self._mock_offset_SLC_tracking_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                snr,
                rsw,
                azsw,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                ISZ,
                pflag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_SLC_tracking))
        result = self._gamma_call("ISP", "offset_SLC_tracking", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert snr.exists(), f"{snr} does not exist"
        assert snr.stat().st_size > 0, f"{snr} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        return result

    def _validate_tree_cc(
        self,
        flag: Path,
        width: int,
        mbl: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to tree_cc.

        """

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

    def _mock_tree_cc_outputs(
        self,
        flag: Path,
        width: int,
        mbl: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Mock the program tree_cc.

        """
        pass

    def tree_cc(
        self,
        flag: Path,
        width: int,
        mbl: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Phase unwrapping tree generation with low correlation search (modified ARW algorithm)


        input parameters:
          flag   (input) phase unwrapping flag file
          width  number of samples/row
          mbl    maximum branch length (default=32, maximum=64)
          xmin   starting range pixel offset (default = 0)
          xmax   last range pixel offset (default = width-1)
          ymin   starting azimuth row, relative to start (default = 0)
          ymax   last azimuth row, relative to start (default = nlines-1)


        """

        if self.validate_inputs:
            self._validate_tree_cc(flag, width, mbl, xmin, xmax, ymin, ymax)

        if self.mock_outputs:
            self._mock_tree_cc_outputs(flag, width, mbl, xmin, xmax, ymin, ymax)

        ca = self._clean_args(locals(), inspect.signature(self.tree_cc))
        result = self._gamma_call("ISP", "tree_cc", ca)
        return result

    def _validate_MLI_copy(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to MLI_copy.

        """

        assert MLI_in.exists(), f"{MLI_in} does not exist"
        assert MLI_in.stat().st_size > 0, f"{MLI_in} has zero file size"

        assert MLI_in_par.exists(), f"{MLI_in_par} does not exist"
        assert MLI_in_par.stat().st_size > 0, f"{MLI_in_par} has zero file size"

        assert not MLI_out.exists(), f"{MLI_out} should _not_ exist!"

        assert not MLI_out_par.exists(), f"{MLI_out_par} should _not_ exist!"

    def _mock_MLI_copy_outputs(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Mock the program MLI_copy.

        """

        if MLI_out is not None and str(MLI_out) != "-":
            MLI_out.touch()

        if MLI_out_par is not None and str(MLI_out_par) != "-":
            MLI_out_par.touch()

    def MLI_copy(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Copy MLI data file with options for segment extraction


        input parameters:
          MLI_in       (input) multi-look intensity image (float format)
          MLI_in_par   (input) ISP image parameter file for input MLI
          MLI_out      (output) selected MLI section (float format)
          MLI_out_par  (output) ISP image parameter file for output MLI
          roff         offset to starting range sample (enter - for default: 0)
          nr           number of range samples (enter - for default: to end of line
          loff         offset to starting line (enter - for default: 0)
          nl           number of lines to copy (enter - for default: to end of file)

        """

        if self.validate_inputs:
            self._validate_MLI_copy(
                MLI_in, MLI_in_par, MLI_out, MLI_out_par, roff, nr, loff, nl
            )

        if self.mock_outputs:
            self._mock_MLI_copy_outputs(
                MLI_in, MLI_in_par, MLI_out, MLI_out_par, roff, nr, loff, nl
            )

        ca = self._clean_args(locals(), inspect.signature(self.MLI_copy))
        result = self._gamma_call("ISP", "MLI_copy", ca)

        assert MLI_out.exists(), f"{MLI_out} does not exist"
        assert MLI_out.stat().st_size > 0, f"{MLI_out} has zero file size"

        assert MLI_out_par.exists(), f"{MLI_out_par} does not exist"
        assert MLI_out_par.stat().st_size > 0, f"{MLI_out_par} has zero file size"

        return result

    def _validate_par_RCM_MLC(
        self, RCM_dir: Path, radcal: Optional[int], noise: Optional[int], root_name: Path
    ) -> None:
        """

        Validate the arguments to par_RCM_MLC.

        """

        assert RCM_dir.exists(), f"{RCM_dir} does not exist"
        assert RCM_dir.stat().st_size > 0, f"{RCM_dir} has zero file size"

        assert not root_name.exists(), f"{root_name} should _not_ exist!"

    def _mock_par_RCM_MLC_outputs(
        self, RCM_dir: Path, radcal: Optional[int], noise: Optional[int], root_name: Path
    ) -> None:
        """

        Mock the program par_RCM_MLC.

        """

        if root_name is not None and str(root_name) != "-":
            root_name.touch()

    def par_RCM_MLC(
        self, RCM_dir: Path, radcal: Optional[int], noise: Optional[int], root_name: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate parameter and image files for Radarsat Constellation MLC (Multi-Look Complex) data from GeoTIFF or NITF format


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM2_OK1782060_PK1782073_2_SC30MCPC_20200504_105537_CH_CV_MLC)
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise          noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          root_name      (output) root name of the generated output files (example: yyyymmdd)
                         NOTE: the program will automatically complete the root_name and add extensions for each covariance matrix element
                               for both data and parameter files, such as 20210927_CH.mlc, 20210927_CH.mlc.par, 20210927_XC.mlc, etc.


        """

        if self.validate_inputs:
            self._validate_par_RCM_MLC(RCM_dir, radcal, noise, root_name)

        if self.mock_outputs:
            self._mock_par_RCM_MLC_outputs(RCM_dir, radcal, noise, root_name)

        ca = self._clean_args(locals(), inspect.signature(self.par_RCM_MLC))
        result = self._gamma_call("ISP", "par_RCM_MLC", ca)

        assert root_name.exists(), f"{root_name} does not exist"
        assert root_name.stat().st_size > 0, f"{root_name} has zero file size"

        return result

    def _validate_ORRM_vec(
        self, SLC_par: Path, ORRM: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to ORRM_vec.

        """

        assert ORRM.exists(), f"{ORRM} does not exist"
        assert ORRM.stat().st_size > 0, f"{ORRM} has zero file size"

    def _mock_ORRM_vec_outputs(
        self, SLC_par: Path, ORRM: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Mock the program ORRM_vec.

        """

        if not SLC_par.exists():
            SLC_par.touch()

    def ORRM_vec(
        self, SLC_par: Path, ORRM: Path, nstate: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate state vectors extraction from ORRM file


        input parameters:
          SLC_par  (input/output) ISP SLC/MLI image parameter file
          ORRM     (input) ORRM state vector file
          nstate   number of state vectors (default=5, maximum=1024)


        """

        if self.validate_inputs:
            self._validate_ORRM_vec(SLC_par, ORRM, nstate)

        if self.mock_outputs:
            self._mock_ORRM_vec_outputs(SLC_par, ORRM, nstate)

        ca = self._clean_args(locals(), inspect.signature(self.ORRM_vec))
        result = self._gamma_call("ISP", "ORRM_vec", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_SLC_ovr(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_ovr: Path,
        SLC_ovr_par: Path,
        r_ovr: Optional[int] = None,
        az_ovr: Optional[int] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_ovr.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not SLC_ovr.exists(), f"{SLC_ovr} should _not_ exist!"

        assert not SLC_ovr_par.exists(), f"{SLC_ovr_par} should _not_ exist!"

    def _mock_SLC_ovr_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_ovr: Path,
        SLC_ovr_par: Path,
        r_ovr: Optional[int] = None,
        az_ovr: Optional[int] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_ovr.

        """

        if SLC_ovr is not None and str(SLC_ovr) != "-":
            SLC_ovr.touch()

        if SLC_ovr_par is not None and str(SLC_ovr_par) != "-":
            SLC_ovr_par.touch()

    def SLC_ovr(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_ovr: Path,
        SLC_ovr_par: Path,
        r_ovr: Optional[int] = None,
        az_ovr: Optional[int] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Oversample SLC data in range and azimuth using 2-D Lanczos or B-spline interpolation


        input parameters:
          SLC          (input) SLC image  (FCOMPLEX or SCOMPLEX format)
          SLC_par      (input) SLC image parameter file
          SLC_ovr      (output) oversampled SLC image
          SLC_ovr_par  (output) oversampled SLC image parameter file
          r_ovr        range oversampling factor (enter - for default: 1.0)
          az_ovr       azimuth oversampling factor (enter - for default: 1.0)
          mode         interpolation mode (enter - for default)
                         0: Lanczos interpolation (default)
                         1: B-spline interpolation
          order        Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)
          deramp       deramp flag (enter - for default)
                         0: do not deramp and reramp data
                         1: deramp data before interpolation and reramp afterwards (default)


        """

        if self.validate_inputs:
            self._validate_SLC_ovr(
                SLC, SLC_par, SLC_ovr, SLC_ovr_par, r_ovr, az_ovr, mode, order, deramp
            )

        if self.mock_outputs:
            self._mock_SLC_ovr_outputs(
                SLC, SLC_par, SLC_ovr, SLC_ovr_par, r_ovr, az_ovr, mode, order, deramp
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_ovr))
        result = self._gamma_call("ISP", "SLC_ovr", ca)

        assert SLC_ovr.exists(), f"{SLC_ovr} does not exist"
        assert SLC_ovr.stat().st_size > 0, f"{SLC_ovr} has zero file size"

        assert SLC_ovr_par.exists(), f"{SLC_ovr_par} does not exist"
        assert SLC_ovr_par.stat().st_size > 0, f"{SLC_ovr_par} has zero file size"

        return result

    def _validate_tree_gzw(
        self,
        flag: Path,
        width: int,
        mbl: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to tree_gzw.

        """

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

    def _mock_tree_gzw_outputs(
        self,
        flag: Path,
        width: int,
        mbl: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Mock the program tree_gzw.

        """
        pass

    def tree_gzw(
        self,
        flag: Path,
        width: int,
        mbl: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Phase unwrapping tree generation (GZW algorithm)


        input parameters:
          flag   (input) phase unwrapping flag file
          width  number of samples/row
          mbl    maximum branch length (default=32)
          xmin   starting range pixel offset (default = 0)
          xmax   last range pixel offset (default = width-1)
          ymin   starting azimuth row, relative to start (default = 0)
          ymax   last azimuth row, relative to start (default = nlines-1)


        """

        if self.validate_inputs:
            self._validate_tree_gzw(flag, width, mbl, xmin, xmax, ymin, ymax)

        if self.mock_outputs:
            self._mock_tree_gzw_outputs(flag, width, mbl, xmin, xmax, ymin, ymax)

        ca = self._clean_args(locals(), inspect.signature(self.tree_gzw))
        result = self._gamma_call("ISP", "tree_gzw", ca)
        return result

    def _validate_mcf(
        self,
        interf: Path,
        wgt: Optional[Path],
        mask: Optional[Path],
        unw: Path,
        width: int,
        tri_mode: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nlines: Optional[int] = None,
        npat_r: Optional[int] = None,
        npat_az: Optional[int] = None,
        ovrlap: Optional[int] = None,
        r_init: Optional[int] = None,
        az_init: Optional[int] = None,
        init_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to mcf.

        """

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        if wgt is not None:
            assert wgt.exists(), f"{wgt} does not exist"
            assert wgt.stat().st_size > 0, f"{wgt} has zero file size"

        if mask is not None:
            assert mask.exists(), f"{mask} does not exist"
            assert mask.stat().st_size > 0, f"{mask} has zero file size"

        assert not unw.exists(), f"{unw} should _not_ exist!"

    def _mock_mcf_outputs(
        self,
        interf: Path,
        wgt: Optional[Path],
        mask: Optional[Path],
        unw: Path,
        width: int,
        tri_mode: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nlines: Optional[int] = None,
        npat_r: Optional[int] = None,
        npat_az: Optional[int] = None,
        ovrlap: Optional[int] = None,
        r_init: Optional[int] = None,
        az_init: Optional[int] = None,
        init_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program mcf.

        """

        if unw is not None and str(unw) != "-":
            unw.touch()

    def mcf(
        self,
        interf: Path,
        wgt: Optional[Path],
        mask: Optional[Path],
        unw: Path,
        width: int,
        tri_mode: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nlines: Optional[int] = None,
        npat_r: Optional[int] = None,
        npat_az: Optional[int] = None,
        ovrlap: Optional[int] = None,
        r_init: Optional[int] = None,
        az_init: Optional[int] = None,
        init_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Phase unwrapping using Minimum Cost Flow (MCF) on a triangular mesh


        input parameters:
          interf     (input) interferogram (*.int,*.diff,*.flt) (FCOMPLEX)
          wgt        (input) weight factors (0 -> 1.0, e.g. coherence map) file (FLOAT) (enter - for uniform weights)
          mask       (input) validity mask (SUN/BMP/TIFF raster format, value 0 -> pixel not used) (enter - if no mask)
          unw        (output) unwrapped phase image (*.unw) (FLOAT)
          width      number of samples/row
          tri_mode   triangulation mode (enter - for default)
                       0: filled triangular mesh
                       1: Delaunay triangulation
                       2: filled triangular mesh, replacing gaps with noise (default)
                       3: filled triangular mesh, replacing gaps and outside boundary with noise
          roff       offset to starting range of section to unwrap (enter - for default: 0)
          loff       offset to starting line of section to unwrap (enter - for default: 0)
          nr         number of range samples of section to unwrap (enter - for default: width - roff)
          nlines     number of lines of section to unwrap (enter - for default: total number of lines - loff)
          npat_r     number of patches in range (enter - for default: 1, enter 0 to automatically define number of patches)
          npat_az    number of patches in azimuth (enter - for default: 1, enter 0 to automatically define number of patches)
          ovrlap     overlap between patches in pixels (overlap >= 7, enter - for default: 1024)
          r_init     phase reference point range offset (enter - for default: center of valid data bounding box)
          az_init    phase reference point azimuth offset (enter - for default: center of valid data bounding box)
          init_flag  flag to set phase at reference point (enter - for default)
                       0: use initial point phase value (default)
                       1: set phase to 0.0 at initial point


        """

        if self.validate_inputs:
            self._validate_mcf(
                interf,
                wgt,
                mask,
                unw,
                width,
                tri_mode,
                roff,
                loff,
                nr,
                nlines,
                npat_r,
                npat_az,
                ovrlap,
                r_init,
                az_init,
                init_flag,
            )

        if self.mock_outputs:
            self._mock_mcf_outputs(
                interf,
                wgt,
                mask,
                unw,
                width,
                tri_mode,
                roff,
                loff,
                nr,
                nlines,
                npat_r,
                npat_az,
                ovrlap,
                r_init,
                az_init,
                init_flag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.mcf))
        result = self._gamma_call("ISP", "mcf", ca)

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        return result

    def _validate_par_ESA_ERS(
        self,
        CEOS_SAR_leader: Path,
        SLC_par: Path,
        CEOS_DAT: Optional[Path] = None,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_ESA_ERS.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if CEOS_DAT is not None:
            assert CEOS_DAT.exists(), f"{CEOS_DAT} does not exist"
            assert CEOS_DAT.stat().st_size > 0, f"{CEOS_DAT} has zero file size"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_ESA_ERS_outputs(
        self,
        CEOS_SAR_leader: Path,
        SLC_par: Path,
        CEOS_DAT: Optional[Path] = None,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_ESA_ERS.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_ESA_ERS(
        self,
        CEOS_SAR_leader: Path,
        SLC_par: Path,
        CEOS_DAT: Optional[Path] = None,
        SLC: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file generation for ERS SLC data from the PGS, VMP, and SPF processors


        input parameters:
        CEOS_SAR_leader  (input) ERS CEOS SAR leader file
        SLC_par          (output) ISP SLC parameter file (example: <date>.slc.par)
        CEOS_DAT         (input) CEOS data file (example: DAT_01.001)
        SLC              (output) SLC data with file and line headers removed (example: <date>.slc)


        """

        if self.validate_inputs:
            self._validate_par_ESA_ERS(CEOS_SAR_leader, SLC_par, CEOS_DAT, SLC)

        if self.mock_outputs:
            self._mock_par_ESA_ERS_outputs(CEOS_SAR_leader, SLC_par, CEOS_DAT, SLC)

        ca = self._clean_args(locals(), inspect.signature(self.par_ESA_ERS))
        result = self._gamma_call("ISP", "par_ESA_ERS", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_offset_pwr_tracking_polygons(
        self,
        SLC_par: Path,
        OFF_par: Path,
        rlks: Optional[int],
        azlks: Optional[int],
        rwin: int,
        azwin: int,
        polygons: Path,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        rb: Optional[int] = None,
        azb: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwr_tracking_polygons.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not polygons.exists(), f"{polygons} should _not_ exist!"

    def _mock_offset_pwr_tracking_polygons_outputs(
        self,
        SLC_par: Path,
        OFF_par: Path,
        rlks: Optional[int],
        azlks: Optional[int],
        rwin: int,
        azwin: int,
        polygons: Path,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        rb: Optional[int] = None,
        azb: Optional[int] = None,
    ) -> None:
        """

        Mock the program offset_pwr_tracking_polygons.

        """

        if not OFF_par.exists():
            OFF_par.touch()

        if polygons is not None and str(polygons) != "-":
            polygons.touch()

    def offset_pwr_tracking_polygons(
        self,
        SLC_par: Path,
        OFF_par: Path,
        rlks: Optional[int],
        azlks: Optional[int],
        rwin: int,
        azwin: int,
        polygons: Path,
        rstep: Optional[int] = None,
        azstep: Optional[int] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        rb: Optional[int] = None,
        azb: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offset tracking polygon calculation in MLI coordinates


        input parameters:
          SLC_par   (input) reference SLC ISP image parameter file
          OFF_par   (input/output) ISP offset/interferogram parameter file
          rlks      range decimation factor for MLI geometry  (enter - for default: 1)
          azlks     azimuth decimation factor for the MLI geometry (enter - for default: 1)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          polygons  (output) polygon vertices in text format
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          rb        polygon range border in MLI samples: (enter - for default: 7)
          azb       polygon azimuth border in MLI lines: (enter - for default: 7)


        """

        if self.validate_inputs:
            self._validate_offset_pwr_tracking_polygons(
                SLC_par,
                OFF_par,
                rlks,
                azlks,
                rwin,
                azwin,
                polygons,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                rb,
                azb,
            )

        if self.mock_outputs:
            self._mock_offset_pwr_tracking_polygons_outputs(
                SLC_par,
                OFF_par,
                rlks,
                azlks,
                rwin,
                azwin,
                polygons,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                rb,
                azb,
            )

        ca = self._clean_args(
            locals(), inspect.signature(self.offset_pwr_tracking_polygons)
        )
        result = self._gamma_call("ISP", "offset_pwr_tracking_polygons", ca)

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert polygons.exists(), f"{polygons} does not exist"
        assert polygons.stat().st_size > 0, f"{polygons} has zero file size"

        return result

    def _validate_SLC_interp(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_interp.

        """

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not SLC_2R.exists(), f"{SLC_2R} should _not_ exist!"

        assert not SLC2R_par.exists(), f"{SLC2R_par} should _not_ exist!"

    def _mock_SLC_interp_outputs(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_interp.

        """

        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()

        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        SLC complex image resampling using 2-D Lanczos or B-spline interpolation


        input parameters:
          SLC-2      (input) SLC-2 image to be resampled to the geometry of the SLC-1 reference image
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2_par   (input) SLC-2 ISP image parameter file
          OFF_par    (input) ISP offset/interferogram parameter file
          SLC-2R     (output) single-look complex image 2 coregistered to SLC-1
          SLC2R_par  (output) SLC-2R ISP image parameter file for coregistered image
          loff       offset to first valid output line (in SLC-1 lines) (enter - for default: 0)
          nlines     number of valid output lines (enter - or 0 for default: to end of file)
          mode       interpolation mode (enter - for default)
                       0: Lanczos (default)
                       1: B-spline
          order      Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)


        """

        if self.validate_inputs:
            self._validate_SLC_interp(
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                SLC_2R,
                SLC2R_par,
                loff,
                nlines,
                mode,
                order,
            )

        if self.mock_outputs:
            self._mock_SLC_interp_outputs(
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                SLC_2R,
                SLC2R_par,
                loff,
                nlines,
                mode,
                order,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_interp))
        result = self._gamma_call("ISP", "SLC_interp", ca)

        assert SLC_2R.exists(), f"{SLC_2R} does not exist"
        assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        return result

    def _validate_par_S1_SLC(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        calibration_XML: Optional[Path],
        noise_XML: Optional[Path],
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[int] = None,
        noise_pwr: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_S1_SLC.

        """

        if GeoTIFF is not None:
            assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
            assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert annotation_XML.exists(), f"{annotation_XML} does not exist"
        assert annotation_XML.stat().st_size > 0, f"{annotation_XML} has zero file size"

        if calibration_XML is not None:
            assert calibration_XML.exists(), f"{calibration_XML} does not exist"
            assert (
                calibration_XML.stat().st_size > 0
            ), f"{calibration_XML} has zero file size"

        if noise_XML is not None:
            assert noise_XML.exists(), f"{noise_XML} does not exist"
            assert noise_XML.stat().st_size > 0, f"{noise_XML} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

        if TOPS_par is not None:
            assert not TOPS_par.exists(), f"{TOPS_par} should _not_ exist!"

    def _mock_par_S1_SLC_outputs(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        calibration_XML: Optional[Path],
        noise_XML: Optional[Path],
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[int] = None,
        noise_pwr: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_S1_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

        if TOPS_par is not None and str(TOPS_par) != "-":
            TOPS_par.touch()

    def par_S1_SLC(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        calibration_XML: Optional[Path],
        noise_XML: Optional[Path],
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[int] = None,
        noise_pwr: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for Sentinel-1 SLC data


        input parameters:
          GeoTIFF         (input) image data file in GeoTIFF format (enter - for none, *.tiff)
          annotation_XML  (input) Sentinel-1 L1 XML annotation file
          calibration_XML (input) Sentinel-1 L1 radiometric calibration XML file (enter - for no radiometric calibration)
          noise_XML       (input) Sentinel-1 L1 noise XML file (enter - to not subtract thermal noise power level)
          SLC_par         (output) ISP SLC parameter file (example: yyyymmdd_iw1_vv.slc.par)
          SLC             (output) SLC data file (enter - for none, example: yyyymmdd_iw1_vv.slc)
          TOPS_par        (output) SLC burst annotation file, TOPS and EW SLC data only (enter - for none, example: yyyymmdd_iw1_vv.slc.tops_par)
          dtype           output data type (enter - for default)
                            0: FCOMPLEX (default)
                            1: SCOMPLEX
          sc_dB           scale factor for FCOMPLEX -> SCOMPLEX, (enter - for default: HH,VV (dB): 60.0000,  VH,HV: 70.0000)
          noise_pwr       noise intensity for each SLC sample in slant range using data from noise_XML (enter - for none)
                          NOTE: when the noise_pwr file is specified, noise power will NOT be subtracted from the image data values


        """

        if self.validate_inputs:
            self._validate_par_S1_SLC(
                GeoTIFF,
                annotation_XML,
                calibration_XML,
                noise_XML,
                SLC_par,
                SLC,
                TOPS_par,
                dtype,
                sc_dB,
                noise_pwr,
            )

        if self.mock_outputs:
            self._mock_par_S1_SLC_outputs(
                GeoTIFF,
                annotation_XML,
                calibration_XML,
                noise_XML,
                SLC_par,
                SLC,
                TOPS_par,
                dtype,
                sc_dB,
                noise_pwr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_S1_SLC))
        result = self._gamma_call("ISP", "par_S1_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        if TOPS_par is not None:
            assert TOPS_par.exists(), f"{TOPS_par} does not exist"
            assert TOPS_par.stat().st_size > 0, f"{TOPS_par} has zero file size"

        return result

    def _validate_unw_correction_poly(
        self,
    ) -> None:
        """

        Validate the arguments to unw_correction_poly.

        """

        pass

    def _mock_unw_correction_poly_outputs(
        self,
    ) -> None:
        """

        Mock the program unw_correction_poly.

        """
        pass

    def unw_correction_poly(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        unw_correction_poly: Phase unwrapping ambiguity error correction for polygon areas

               unw_in            (input) unwrapped phase file to correct (float)
               unw_out           (output) corrected  unwrapped phase file (float)
               width             number of range samples per line
               poly              (input) polygon file (text)
               flag              ambiguity corrected flag (1: add 2PI;  -1: subtract 2PI)
               max_iter          maximum number of iterations done (default = 1)
                                 (iterations are used (a) if the ambiguity to correct is not 2PI but a
                                 multiple of 2PI and (b) if the ambiguity error is in an area with a
                                 significant phase slope)

        """

        if self.validate_inputs:
            self._validate_unw_correction_poly()

        if self.mock_outputs:
            self._mock_unw_correction_poly_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.unw_correction_poly))
        result = self._gamma_call("ISP", "unw_correction_poly", ca)
        return result

    def _validate_TX_SLC_preproc(
        self,
    ) -> None:
        """

        Validate the arguments to TX_SLC_preproc.

        """

        pass

    def _mock_TX_SLC_preproc_outputs(
        self,
    ) -> None:
        """

        Mock the program TX_SLC_preproc.

        """
        pass

    def TX_SLC_preproc(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Preprocessing of TerraSAR-X TDX1 and TSX1 SLC products using par_TX_SLC

          TX_list  (input) single column text file with directories (including path)
                   containing path to directory containing product XML for IMAGEDATA/*.cos files
          SLC_dir  directory for output SLC data files and SLC parameter files
          log      (output) processing log file

        """

        if self.validate_inputs:
            self._validate_TX_SLC_preproc()

        if self.mock_outputs:
            self._mock_TX_SLC_preproc_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.TX_SLC_preproc))
        result = self._gamma_call("ISP", "TX_SLC_preproc", ca)
        return result

    def _validate_run_all(
        self, list: Path, command: int, log: Optional[Path] = None
    ) -> None:
        """

        Validate the arguments to run_all.

        """

        assert list.exists(), f"{list} does not exist"
        assert list.stat().st_size > 0, f"{list} has zero file size"

        if log is not None:
            assert not log.exists(), f"{log} should _not_ exist!"

    def _mock_run_all_outputs(
        self, list: Path, command: int, log: Optional[Path] = None
    ) -> None:
        """

        Mock the program run_all.

        """

        if log is not None and str(log) != "-":
            log.touch()

    def run_all(
        self, list: Path, command: int, log: Optional[Path] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/run_all
        Run a single command iterating over arguments constructed from the elements of a list or multi-column table


        input parameters:
          list      (input) list or multi-column table (text)
          command   command template, entered between single quotes. Command arguments are constructed
                    with placeholders $1, $2, ... that specify the columns of the input table.
                      (example 1: 'multi_look $1.slc $1.slc.par $1.mli $1.mli.par 5 1')
                      (example 2: 'cp -r $1 $2')
          log       (output) log file that captures all screen output (both stdout and stderr)

          Example: run_all dates 'multi_look $1.slc $1.slc.par $1.mli $1.mli.par 5 1' log


        """

        if self.validate_inputs:
            self._validate_run_all(list, command, log)

        if self.mock_outputs:
            self._mock_run_all_outputs(list, command, log)

        ca = self._clean_args(locals(), inspect.signature(self.run_all))
        result = self._gamma_call("ISP", "run_all", ca)

        if log is not None:
            assert log.exists(), f"{log} does not exist"
            assert log.stat().st_size > 0, f"{log} has zero file size"

        return result

    def _validate_par_ASAR(self, output_name: Path, K_dB: Optional[int] = None) -> None:
        """

        Validate the arguments to par_ASAR.

        """

        assert not output_name.exists(), f"{output_name} should _not_ exist!"

        pass

    def _mock_par_ASAR_outputs(
        self, output_name: Path, K_dB: Optional[int] = None
    ) -> None:
        """

        Mock the program par_ASAR.

        """

        if output_name is not None and str(output_name) != "-":
            output_name.touch()

    def par_ASAR(
        self, output_name: Path, K_dB: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Extract SLC/MLI image parameters and images from ENVISAT ASAR SLC, WSS, APP, and PRI products


        input parameters:
          ASAR/ERS_file  (input) ASAR or ERS data in ASAR format (SAR_IMS_1P) including header and image as provided by ESA
          output_name    (output) common part of output file names (e.g. YYYMMDD date)
          K_dB           Calibration factor in dB (nominal value for all ASAR modes: 55.0)
                         NOTE: Use - to use the calibration factor provided in the ASAR file header

          NOTE: In the case that a calibration factor is specified on the command line, PRI images are converted
          to radiometrically calibrated ground-range intensity images in float format

        """

        if self.validate_inputs:
            self._validate_par_ASAR(output_name, K_dB)

        if self.mock_outputs:
            self._mock_par_ASAR_outputs(output_name, K_dB)

        ca = self._clean_args(locals(), inspect.signature(self.par_ASAR))
        result = self._gamma_call("ISP", "par_ASAR", ca)

        assert output_name.exists(), f"{output_name} does not exist"
        assert output_name.stat().st_size > 0, f"{output_name} has zero file size"

        return result

    def _validate_par_ASF_96(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        """

        Validate the arguments to par_ASF_96.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

    def _mock_par_ASF_96_outputs(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        """

        Mock the program par_ASF_96.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ASF_96(
        self, CEOS_SAR_leader: Path, SLC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file for ASF data 1996-->present v1.1


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR leader file
        SLC_par          (output) ISP SLC parameter file (example <orbit>.slc.par)

        """

        if self.validate_inputs:
            self._validate_par_ASF_96(CEOS_SAR_leader, SLC_par)

        if self.mock_outputs:
            self._mock_par_ASF_96_outputs(CEOS_SAR_leader, SLC_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_ASF_96))
        result = self._gamma_call("ISP", "par_ASF_96", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_ScanSAR_mosaic_to_burst(
        self, DATA: Path, MLI_par: Path, DATA_tab: int
    ) -> None:
        """

        Validate the arguments to ScanSAR_mosaic_to_burst.

        """

        assert DATA.exists(), f"{DATA} does not exist"
        assert DATA.stat().st_size > 0, f"{DATA} has zero file size"

    def _mock_ScanSAR_mosaic_to_burst_outputs(
        self, DATA: Path, MLI_par: Path, DATA_tab: int
    ) -> None:
        """

        Mock the program ScanSAR_mosaic_to_burst.

        """
        pass

    def ScanSAR_mosaic_to_burst(
        self, DATA: Path, MLI_par: Path, DATA_tab: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        Resample image data in the MLI mosaic geometry to burst MLI geometry (FLOAT or FCOMPLEX)


        input parameters:
          DATA      (input) data in mosaic geometry (FLOAT or FCOMPLEX data type)
          MLI_par   image parameter file in mosaic geometry
          DATA_tab  3 column list of the output data in burst geometry, swaths are in order from near to far range
                      MLI_tab line entries:  DATA   MLI_par  TOPS_par
                    NOTE: 1.The burst MLI_par and TOPS_par files describing the output geometry must already exist
                          2.The data type (FLOAT or FCOMPLEX) specified in the MLI_par and the burst parameters (TOPS_par) must agree


        """

        if self.validate_inputs:
            self._validate_ScanSAR_mosaic_to_burst(DATA, MLI_par, DATA_tab)

        if self.mock_outputs:
            self._mock_ScanSAR_mosaic_to_burst_outputs(DATA, MLI_par, DATA_tab)

        ca = self._clean_args(locals(), inspect.signature(self.ScanSAR_mosaic_to_burst))
        result = self._gamma_call("ISP", "ScanSAR_mosaic_to_burst", ca)
        return result

    def _validate_OPOD_vec(
        self, SLC_par: Path, OPOD_dir: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to OPOD_vec.

        """

        assert OPOD_dir.exists(), f"{OPOD_dir} does not exist"
        assert OPOD_dir.stat().st_size > 0, f"{OPOD_dir} has zero file size"

    def _mock_OPOD_vec_outputs(
        self, SLC_par: Path, OPOD_dir: Path, nstate: Optional[int] = None
    ) -> None:
        """

        Mock the program OPOD_vec.

        """

        if not SLC_par.exists():
            SLC_par.touch()

    def OPOD_vec(
        self, SLC_par: Path, OPOD_dir: Path, nstate: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/OPOD_vec
        Extract Sentinel-1 state vectors from an OPOD file and write these state vectors to an SLC parameter file


        input parameters:
          SLC_par  (input/output)ISP SLC/MLI image parameter file
          OPOD_dir (input) directory containing Sentinel-1 precise or restituted OPOD orbit data files (AUX_POEORB or AUX_RESORB)
                   orbit files can be downloaded from https://s1qc.asf.alaska.edu/ or https://scihub.copernicus.eu/gnss/#/home
                   (user/pw: gnssguest/gnssguest)
          nstate   number of state vectors to extract (default: include 60 sec extention at the start and end of the SLC data)


        """

        if self.validate_inputs:
            self._validate_OPOD_vec(SLC_par, OPOD_dir, nstate)

        if self.mock_outputs:
            self._mock_OPOD_vec_outputs(SLC_par, OPOD_dir, nstate)

        ca = self._clean_args(locals(), inspect.signature(self.OPOD_vec))
        result = self._gamma_call("ISP", "OPOD_vec", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_base_ls(
        self,
        SLC_par: Path,
        OFF_par: Path,
        gcp_ph: Path,
        baseline: Path,
        ph_flag: Optional[int] = None,
        bc_flag: Optional[int] = None,
        bn_flag: Optional[int] = None,
        bcdot_flag: Optional[int] = None,
        bndot_flag: Optional[int] = None,
        bperp_min: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to base_ls.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert gcp_ph.exists(), f"{gcp_ph} does not exist"
        assert gcp_ph.stat().st_size > 0, f"{gcp_ph} has zero file size"

        assert baseline.exists(), f"{baseline} does not exist"
        assert baseline.stat().st_size > 0, f"{baseline} has zero file size"

        if SLC2R_par is not None:
            assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
            assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

    def _mock_base_ls_outputs(
        self,
        SLC_par: Path,
        OFF_par: Path,
        gcp_ph: Path,
        baseline: Path,
        ph_flag: Optional[int] = None,
        bc_flag: Optional[int] = None,
        bn_flag: Optional[int] = None,
        bcdot_flag: Optional[int] = None,
        bndot_flag: Optional[int] = None,
        bperp_min: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> None:
        """

        Mock the program base_ls.

        """
        pass

    def base_ls(
        self,
        SLC_par: Path,
        OFF_par: Path,
        gcp_ph: Path,
        baseline: Path,
        ph_flag: Optional[int] = None,
        bc_flag: Optional[int] = None,
        bn_flag: Optional[int] = None,
        bcdot_flag: Optional[int] = None,
        bndot_flag: Optional[int] = None,
        bperp_min: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Least squares baseline estimation using terrain heights


        input parameters:
          SLC_par     (input) ISP parameter file of the reference SLC
          OFF_par     (input) ISP interferogram/offset parameter file
          gcp_ph      (input) ground control point heights + extracted unwrapped phase (text format)
          baseline    (input) baseline parameter file
          ph_flag     restore range phase ramp (default=0: do not restore  1: restore)
          bc_flag     cross-track baseline component estimate (0:orbit derived  1:estimate from data, default=1)
          bn_flag     normal baseline component estimate      (0:orbit derived  1:estimate from data, default=1)
          bcdot_flag  cross-track baseline rate estimate      (0:orbit derived  1:estimate from data, default=1)
          bndot_flag  normal baseline rate estimate           (0:orbit derived  1:estimate from data, default=0)
          bperp_min   minimum perpendicular baseline required for L.S estimation (m, default=  10.0)
          SLC2R_par   (input) parameter file of resampled SLC, required if SLC-2 frequency differs from SLC-1


        """

        if self.validate_inputs:
            self._validate_base_ls(
                SLC_par,
                OFF_par,
                gcp_ph,
                baseline,
                ph_flag,
                bc_flag,
                bn_flag,
                bcdot_flag,
                bndot_flag,
                bperp_min,
                SLC2R_par,
            )

        if self.mock_outputs:
            self._mock_base_ls_outputs(
                SLC_par,
                OFF_par,
                gcp_ph,
                baseline,
                ph_flag,
                bc_flag,
                bn_flag,
                bcdot_flag,
                bndot_flag,
                bperp_min,
                SLC2R_par,
            )

        ca = self._clean_args(locals(), inspect.signature(self.base_ls))
        result = self._gamma_call("ISP", "base_ls", ca)
        return result

    def _validate_az_spec_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        spectrum: Path,
        roff: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to az_spec_SLC.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not spectrum.exists(), f"{spectrum} should _not_ exist!"

    def _mock_az_spec_SLC_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        spectrum: Path,
        roff: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program az_spec_SLC.

        """

        if spectrum is not None and str(spectrum) != "-":
            spectrum.touch()

    def az_spec_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        spectrum: Path,
        roff: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Doppler centroid estimate from SLC images


        input parameters:
          SLC       (input) SAR image data file (fcomplex or scomplex format)
          SLC_par   (input) ISP SLC image parameter file
          spectrum  (output) Doppler spectrum (text format)
          roff      range sample offset to center of estimation window (enter - for default=center_swath)
          namb      number of multiples of the PRF to add to the estimated centroid (default=0)
          pltflg    azimuth spectrum plotting flag:
                      0: none (default)
                      1: output plot in PNG format


        """

        if self.validate_inputs:
            self._validate_az_spec_SLC(SLC, SLC_par, spectrum, roff, namb, pltflg)

        if self.mock_outputs:
            self._mock_az_spec_SLC_outputs(SLC, SLC_par, spectrum, roff, namb, pltflg)

        ca = self._clean_args(locals(), inspect.signature(self.az_spec_SLC))
        result = self._gamma_call("ISP", "az_spec_SLC", ca)

        assert spectrum.exists(), f"{spectrum} does not exist"
        assert spectrum.stat().st_size > 0, f"{spectrum} has zero file size"

        return result

    def _validate_SLC_copy(
        self,
        SLC_in: Path,
        SLC_par_in: Path,
        SLC_out: Path,
        SLC_par_out: Path,
        fcase: Optional[int] = None,
        sc: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swap: Optional[int] = None,
        header_lines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_copy.

        """

        assert SLC_in.exists(), f"{SLC_in} does not exist"
        assert SLC_in.stat().st_size > 0, f"{SLC_in} has zero file size"

        assert SLC_par_in.exists(), f"{SLC_par_in} does not exist"
        assert SLC_par_in.stat().st_size > 0, f"{SLC_par_in} has zero file size"

        assert not SLC_out.exists(), f"{SLC_out} should _not_ exist!"

        assert not SLC_par_out.exists(), f"{SLC_par_out} should _not_ exist!"

    def _mock_SLC_copy_outputs(
        self,
        SLC_in: Path,
        SLC_par_in: Path,
        SLC_out: Path,
        SLC_par_out: Path,
        fcase: Optional[int] = None,
        sc: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swap: Optional[int] = None,
        header_lines: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_copy.

        """

        if SLC_out is not None and str(SLC_out) != "-":
            SLC_out.touch()

        if SLC_par_out is not None and str(SLC_par_out) != "-":
            SLC_par_out.touch()

    def SLC_copy(
        self,
        SLC_in: Path,
        SLC_par_in: Path,
        SLC_out: Path,
        SLC_par_out: Path,
        fcase: Optional[int] = None,
        sc: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swap: Optional[int] = None,
        header_lines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Copy SLC with options for data format conversion, segment extraction, and byte swapping


        input parameters:
          SLC_in       (input) SLC (FCOMPLEX or SCOMPLEX format)
          SLC_par_in   (input) ISP SLC parameter file for input SLC
          SLC_out      (output) selected SLC section (FCOMPLEX or SCOMPLEX format)
          SLC_par_out  (output) ISP SLC parameter file of output SLC
          fcase        data format conversion (enter - for default: output format = input format)
                         1: FCOMPLEX --> FCOMPLEX (default sc = 1.0)
                         2: FCOMPLEX --> SCOMPLEX (default sc = 10000.0)
                         3: SCOMPLEX --> FCOMPLEX (default sc = 0.0001)
                         4: SCOMPLEX --> SCOMPLEX (default sc = 1.0)
          sc           scale factor for input SLC data (enter - for default)
          roff         offset to starting range sample (enter - for default: 0)
          nr           number of range samples (enter - for default: to end of line)
          loff         offset to starting line (enter - for default: 0)
          nl           number of lines to copy (enter - for default: to end of file)
          swap         swap data (enter - for default)
                         0: normal (default)
                         1: swap real/imaginary part of complex data
                         2: swap left/right (near/far range)
          header_lines  number of input file header lines (enter - for default: 0)
                        NOTE: CEOS format SLC data have 1 header line
                        NOTE: file offset pointer size (bytes): 8


        """

        if self.validate_inputs:
            self._validate_SLC_copy(
                SLC_in,
                SLC_par_in,
                SLC_out,
                SLC_par_out,
                fcase,
                sc,
                roff,
                nr,
                loff,
                nl,
                swap,
                header_lines,
            )

        if self.mock_outputs:
            self._mock_SLC_copy_outputs(
                SLC_in,
                SLC_par_in,
                SLC_out,
                SLC_par_out,
                fcase,
                sc,
                roff,
                nr,
                loff,
                nl,
                swap,
                header_lines,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_copy))
        result = self._gamma_call("ISP", "SLC_copy", ca)

        assert SLC_out.exists(), f"{SLC_out} does not exist"
        assert SLC_out.stat().st_size > 0, f"{SLC_out} has zero file size"

        assert SLC_par_out.exists(), f"{SLC_par_out} does not exist"
        assert SLC_par_out.stat().st_size > 0, f"{SLC_par_out} has zero file size"

        return result

    def _validate_az_integrate(
        self,
        data: Path,
        width: int,
        azi: Path,
        cflg: int,
        scale: Optional[float] = None,
        lz: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to az_integrate.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        assert not azi.exists(), f"{azi} should _not_ exist!"

    def _mock_az_integrate_outputs(
        self,
        data: Path,
        width: int,
        azi: Path,
        cflg: int,
        scale: Optional[float] = None,
        lz: Optional[int] = None,
    ) -> None:
        """

        Mock the program az_integrate.

        """

        if azi is not None and str(azi) != "-":
            azi.touch()

    def az_integrate(
        self,
        data: Path,
        width: int,
        azi: Path,
        cflg: int,
        scale: Optional[float] = None,
        lz: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate azimuth integral of float data (unwrapped phase or azimuth offsets)


        input parameters:
          data      (input) input data (example: SBI dtrapped phase) (float)
          width     (input) number of range samples/line
          azi       (output) input data integrated along azimuth (float)
          cflg      integration constant flag:
                       0: set azimuth integral value to 0.0 at specified line
                       1: set average of the azimuth integral to 0.0
          scale     scale factor to apply to the data (enter - for default, default: 1.0)
          lz        line offset where the azimuth integral is set to 0.0 (cflg = 0, enter - for default, default: 0)


        """

        if self.validate_inputs:
            self._validate_az_integrate(data, width, azi, cflg, scale, lz)

        if self.mock_outputs:
            self._mock_az_integrate_outputs(data, width, azi, cflg, scale, lz)

        ca = self._clean_args(locals(), inspect.signature(self.az_integrate))
        result = self._gamma_call("ISP", "az_integrate", ca)

        assert azi.exists(), f"{azi} does not exist"
        assert azi.stat().st_size > 0, f"{azi} has zero file size"

        return result

    def _validate_SLC_cat(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_3: Path,
        SLC3_par: Path,
        dopflg: Optional[int] = None,
        iflg: Optional[int] = None,
        phflg: Optional[int] = None,
        gainflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_cat.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not SLC_3.exists(), f"{SLC_3} should _not_ exist!"

        assert not SLC3_par.exists(), f"{SLC3_par} should _not_ exist!"

    def _mock_SLC_cat_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_3: Path,
        SLC3_par: Path,
        dopflg: Optional[int] = None,
        iflg: Optional[int] = None,
        phflg: Optional[int] = None,
        gainflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_cat.

        """

        if SLC_3 is not None and str(SLC_3) != "-":
            SLC_3.touch()

        if SLC3_par is not None and str(SLC3_par) != "-":
            SLC3_par.touch()

    def SLC_cat(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_3: Path,
        SLC3_par: Path,
        dopflg: Optional[int] = None,
        iflg: Optional[int] = None,
        phflg: Optional[int] = None,
        gainflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Concatenate a pair of SLC images with interpolation of the second scene


        input parameters:
          SLC-1      (input) SLC-1 image (FCOMPLEX or SCOMPLEX)
          SLC-2      (input) SLC-2 image to be appended to SLC-1 (same type as SLC-1)
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2_par   (input) SLC-2 ISP image parameter file
          OFF_par    (input) ISP offset parameter file containing offset polynomials between SLC-1 and SLC-2
          SLC-3      (output) concatenated SLC
          SLC3_par   (output) ISP image parameter file for concatenated image
          dopflg     Doppler flag (enter - for default)
                       0: ignore Doppler centroid information, assume 0 Hz Doppler centroid
                       1: use Doppler centroid information for interpolation (default)
          iflg       input data type flag (enter - for default)
                       0: input data are SLC images, use data type specified in SLC_par files (SCOMPLEX or FCOMPLEX) (default)
                       1: input scenes are interferograms, force FCOMPLEX data type
          phflg      phase offset correction flag (enter - for default)
                       0: no phase offset correction for SLC-2 (default)
                       1: apply constant phase offset correction to SLC-2
          gainflg    gain correction flag (enter - for default)
                       0: no gain correction for SLC-2 (default)
                       1: apply gain correction to SLC-2
          imode      interpolation mode for SLC-2 (enter - for default)
                       0: Lanczos interpolation (default)
                       1: B-spline interpolation
          order      Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)


        """

        if self.validate_inputs:
            self._validate_SLC_cat(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                SLC_3,
                SLC3_par,
                dopflg,
                iflg,
                phflg,
                gainflg,
                imode,
                order,
            )

        if self.mock_outputs:
            self._mock_SLC_cat_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                SLC_3,
                SLC3_par,
                dopflg,
                iflg,
                phflg,
                gainflg,
                imode,
                order,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_cat))
        result = self._gamma_call("ISP", "SLC_cat", ca)

        assert SLC_3.exists(), f"{SLC_3} does not exist"
        assert SLC_3.stat().st_size > 0, f"{SLC_3} has zero file size"

        assert SLC3_par.exists(), f"{SLC3_par} does not exist"
        assert SLC3_par.stat().st_size > 0, f"{SLC3_par} has zero file size"

        return result

    def _validate_SLC_ovr2(
        self,
    ) -> None:
        """

        Validate the arguments to SLC_ovr2.

        """

        pass

    def _mock_SLC_ovr2_outputs(
        self,
    ) -> None:
        """

        Mock the program SLC_ovr2.

        """
        pass

    def SLC_ovr2(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ***********************************************************************************************
        NOTE: SLC_ovr2 has been replaced by SLC_ovr. Existing options are unchanged, but new,
        additional options are available. Please consider renaming the program in your scripts.
        ***********************************************************************************************
        SLC_ovr2
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/SLC_ovr2: line 7: SLC_ovr: command not found

        """

        if self.validate_inputs:
            self._validate_SLC_ovr2()

        if self.mock_outputs:
            self._mock_SLC_ovr2_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SLC_ovr2))
        result = self._gamma_call("ISP", "SLC_ovr2", ca)
        return result

    def _validate_par_NovaSAR_SLC(
        self,
        GeoTIFF: Optional[Path],
        XML: Path,
        polarization: int,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_NovaSAR_SLC.

        """

        if GeoTIFF is not None:
            assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
            assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert XML.exists(), f"{XML} does not exist"
        assert XML.stat().st_size > 0, f"{XML} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_NovaSAR_SLC_outputs(
        self,
        GeoTIFF: Optional[Path],
        XML: Path,
        polarization: int,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_NovaSAR_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_NovaSAR_SLC(
        self,
        GeoTIFF: Optional[Path],
        XML: Path,
        polarization: int,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for NovaSAR SLC data


        input parameters:
          GeoTIFF       (input) NovaSAR image data file in GeoTIFF format (enter - for none, *.tif)
          XML           (input) NovaSAR XML annotation file
          polarization  image polarization: HH, VV, HV, VH, CH, CV
          SLC_par       (output) ISP SLC parameter file (example: yyyymmdd_pp.slc.par)
          SLC           (output) SLC data file (enter - for none, example: yyyymmdd_pp.slc)
          dtype         output data type (enter - for default: same as input)
                          0: FCOMPLEX
                          1: SCOMPLEX
          radcal        radiometric calibration flag (enter - for default)
                          0: beta0 (default)
                          1: sigma0
          noise         noise levels flag (enter - for default)
                          0: do not use noise levels (default)
                          1: use noise levels


        """

        if self.validate_inputs:
            self._validate_par_NovaSAR_SLC(
                GeoTIFF, XML, polarization, SLC_par, SLC, dtype, radcal, noise
            )

        if self.mock_outputs:
            self._mock_par_NovaSAR_SLC_outputs(
                GeoTIFF, XML, polarization, SLC_par, SLC, dtype, radcal, noise
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_NovaSAR_SLC))
        result = self._gamma_call("ISP", "par_NovaSAR_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_SLC_corners(
        self, SLC_par: Path, terra_alt: Optional[Path] = None, kml: Optional[Path] = None
    ) -> None:
        """

        Validate the arguments to SLC_corners.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if terra_alt is not None:
            assert terra_alt.exists(), f"{terra_alt} does not exist"
            assert terra_alt.stat().st_size > 0, f"{terra_alt} has zero file size"

        if kml is not None:
            assert not kml.exists(), f"{kml} should _not_ exist!"

    def _mock_SLC_corners_outputs(
        self, SLC_par: Path, terra_alt: Optional[Path] = None, kml: Optional[Path] = None
    ) -> None:
        """

        Mock the program SLC_corners.

        """

        if kml is not None and str(kml) != "-":
            kml.touch()

    def SLC_corners(
        self, SLC_par: Path, terra_alt: Optional[Path] = None, kml: Optional[Path] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate SLC/MLI image corners in geodetic latitude and longitude (deg.)


        input parameters:
          SLC_par   (input) ISP SLC/MLI image parameter file
          terra_alt (input) average terrain altitude (enter - for default: 300.000 meters)
          kml       (output) kml output file (enter - for none)


        """

        if self.validate_inputs:
            self._validate_SLC_corners(SLC_par, terra_alt, kml)

        if self.mock_outputs:
            self._mock_SLC_corners_outputs(SLC_par, terra_alt, kml)

        ca = self._clean_args(locals(), inspect.signature(self.SLC_corners))
        result = self._gamma_call("ISP", "SLC_corners", ca)

        if kml is not None:
            assert kml.exists(), f"{kml} does not exist"
            assert kml.stat().st_size > 0, f"{kml} has zero file size"

        return result

    def _validate_SLC_deramp(
        self,
        SLC_1: Path,
        SLC_par1: Path,
        SLC_2: Path,
        SLC_par2: Path,
        mode: int,
        dop_ph: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to SLC_deramp.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_par1.exists(), f"{SLC_par1} does not exist"
        assert SLC_par1.stat().st_size > 0, f"{SLC_par1} has zero file size"

        assert not SLC_2.exists(), f"{SLC_2} should _not_ exist!"

        assert not SLC_par2.exists(), f"{SLC_par2} should _not_ exist!"

        if dop_ph is not None:
            assert not dop_ph.exists(), f"{dop_ph} should _not_ exist!"

    def _mock_SLC_deramp_outputs(
        self,
        SLC_1: Path,
        SLC_par1: Path,
        SLC_2: Path,
        SLC_par2: Path,
        mode: int,
        dop_ph: Optional[Path] = None,
    ) -> None:
        """

        Mock the program SLC_deramp.

        """

        if SLC_2 is not None and str(SLC_2) != "-":
            SLC_2.touch()

        if SLC_par2 is not None and str(SLC_par2) != "-":
            SLC_par2.touch()

        if dop_ph is not None and str(dop_ph) != "-":
            dop_ph.touch()

    def SLC_deramp(
        self,
        SLC_1: Path,
        SLC_par1: Path,
        SLC_2: Path,
        SLC_par2: Path,
        mode: int,
        dop_ph: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate and subtract Doppler phase from an SLC image


        input parameters:
          SLC-1     (input) SLC data file (fcomplex or scomplex format)
          SLC_par1  (input) SLC parameter file with Doppler information
          SLC-2     (output) SLC with Doppler phase removed (or added)
          SLC_par2  (output) SLC parameter file for the output SLC
          mode      mode of operation:
                      0: subtract Doppler phase ramp (deramp)
                      1: add Doppler phase ramp (reramp)
          dop_ph   (output) Doppler phase (FLOAT)

        Note: SLC_par1 contains the Doppler polynomial that is used to calculate the Doppler phase ramp

        """

        if self.validate_inputs:
            self._validate_SLC_deramp(SLC_1, SLC_par1, SLC_2, SLC_par2, mode, dop_ph)

        if self.mock_outputs:
            self._mock_SLC_deramp_outputs(SLC_1, SLC_par1, SLC_2, SLC_par2, mode, dop_ph)

        ca = self._clean_args(locals(), inspect.signature(self.SLC_deramp))
        result = self._gamma_call("ISP", "SLC_deramp", ca)

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC_par2.exists(), f"{SLC_par2} does not exist"
        assert SLC_par2.stat().st_size > 0, f"{SLC_par2} has zero file size"

        if dop_ph is not None:
            assert dop_ph.exists(), f"{dop_ph} does not exist"
            assert dop_ph.stat().st_size > 0, f"{dop_ph} has zero file size"

        return result

    def _validate_residue(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to residue.

        """

        assert int.exists(), f"{int} does not exist"
        assert int.stat().st_size > 0, f"{int} has zero file size"

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

    def _mock_residue_outputs(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Mock the program residue.

        """
        pass

    def residue(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Determine interferometric phase unwrapping residues


        input parameters:
          int    (input) interferogram (fcomplex)
          flag   (input) flag file (unsigned char)
          width  number of samples/row
          xmin   offset to starting range pixel(default = 0)
          xmax   offset last range pixel (default = width-1)
          ymin   offset to starting azimuth row (default = 0)
          ymax   offset to last azimuth row (default = nlines-1)


        """

        if self.validate_inputs:
            self._validate_residue(int, flag, width, xmin, xmax, ymin, ymax)

        if self.mock_outputs:
            self._mock_residue_outputs(int, flag, width, xmin, xmax, ymin, ymax)

        ca = self._clean_args(locals(), inspect.signature(self.residue))
        result = self._gamma_call("ISP", "residue", ca)
        return result

    def _validate_par_PRI(
        self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path
    ) -> None:
        """

        Validate the arguments to par_PRI.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PRI_par.exists(), f"{PRI_par} should _not_ exist!"

        assert CEOS_DAT.exists(), f"{CEOS_DAT} does not exist"
        assert CEOS_DAT.stat().st_size > 0, f"{CEOS_DAT} has zero file size"

        assert not PRI.exists(), f"{PRI} should _not_ exist!"

    def _mock_par_PRI_outputs(
        self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path
    ) -> None:
        """

        Mock the program par_PRI.

        """

        if PRI_par is not None and str(PRI_par) != "-":
            PRI_par.touch()

        if PRI is not None and str(PRI) != "-":
            PRI.touch()

    def par_PRI(
        self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file generation for ERS PRI data from the PGS and VMP processors


        input parameters:
          CEOS_SAR_leader (input) ERS CEOS SAR leader file for PRI product
          PRI_par         (output) ISP image parameter file (example: <yyyymmdd>.pri.par)
          CEOS_DAT        (input) CEOS data file (example: DAT_01.001)
          PRI             (output) PRI data with file and line headers removed (example: <yyyymmdd>.pri)


        """

        if self.validate_inputs:
            self._validate_par_PRI(CEOS_SAR_leader, PRI_par, CEOS_DAT, PRI)

        if self.mock_outputs:
            self._mock_par_PRI_outputs(CEOS_SAR_leader, PRI_par, CEOS_DAT, PRI)

        ca = self._clean_args(locals(), inspect.signature(self.par_PRI))
        result = self._gamma_call("ISP", "par_PRI", ca)

        assert PRI_par.exists(), f"{PRI_par} does not exist"
        assert PRI_par.stat().st_size > 0, f"{PRI_par} has zero file size"

        assert PRI.exists(), f"{PRI} does not exist"
        assert PRI.stat().st_size > 0, f"{PRI} has zero file size"

        return result

    def _validate_create_offset(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        algorithm: Optional[int] = None,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to create_offset.

        """

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

    def _mock_create_offset_outputs(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        algorithm: Optional[int] = None,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program create_offset.

        """

        if not OFF_par.exists():
            OFF_par.touch()

    def create_offset(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        algorithm: Optional[int] = None,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Create and update ISP offset and interferogram parameter files


        input parameters:
          SLC1_par   (input) SLC-1/MLI-1 ISP image parameter filename (reference)
          SLC2_par   (input) SLC-2/MLI-2 ISP image parameter filename
          OFF_par    (input/output) ISP offset/interferogram parameter file
          algorithm  offset estimation algorithm
                       1: intensity cross-correlation (default)
                       2: fringe visibility
          rlks       number of interferogram range looks (enter -  for default: 1)
          azlks      number of interferogram azimuth looks (enter - for default: 1)
          iflg       interactive mode flag (enter -  for default)
                       0: non-interactive
                       1: interactive (default)


        """

        if self.validate_inputs:
            self._validate_create_offset(
                SLC1_par, SLC2_par, OFF_par, algorithm, rlks, azlks, iflg
            )

        if self.mock_outputs:
            self._mock_create_offset_outputs(
                SLC1_par, SLC2_par, OFF_par, algorithm, rlks, azlks, iflg
            )

        ca = self._clean_args(locals(), inspect.signature(self.create_offset))
        result = self._gamma_call("ISP", "create_offset", ca)

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        return result

    def _validate_mk_ptarg_cal(
        self,
    ) -> None:
        """

        Validate the arguments to mk_ptarg_cal.

        """

        pass

    def _mock_mk_ptarg_cal_outputs(
        self,
    ) -> None:
        """

        Mock the program mk_ptarg_cal.

        """
        pass

    def mk_ptarg_cal(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/mk_ptarg_cal
        Perform point target analysis and calibration factor evaluation for a set of point targers


            CR_tab  (input) 3 column list of row and sample number of corner reflectors
              1. Corner reflector id
              2. SLC column  (includes path)
              3. SLC row    (includes path)
            SLC       SLC image
            SLC_par   SLC_parameter file
            cal_dir   directory for output calibration results
            sigma     Radar cross-section of the corner reflectors
            c_rpos    range sample number of the center of the region used to estimate region
            c_azpos   azimuth line of the center of the region used to estimate clutter
            osf       SLC over-sampling factor 2, 4, 8, 16, 32, 64 (default: 16)
            -s scale  (option) set image display scale factor (default: 0.2)
            -e exp    (option) set image display exponent (default: 0.5)

        """

        if self.validate_inputs:
            self._validate_mk_ptarg_cal()

        if self.mock_outputs:
            self._mock_mk_ptarg_cal_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.mk_ptarg_cal))
        result = self._gamma_call("ISP", "mk_ptarg_cal", ca)
        return result

    def _validate_multi_look_MLI(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        e_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to multi_look_MLI.

        """

        assert MLI_in.exists(), f"{MLI_in} does not exist"
        assert MLI_in.stat().st_size > 0, f"{MLI_in} has zero file size"

        assert MLI_in_par.exists(), f"{MLI_in_par} does not exist"
        assert MLI_in_par.stat().st_size > 0, f"{MLI_in_par} has zero file size"

        assert not MLI_out.exists(), f"{MLI_out} should _not_ exist!"

        assert not MLI_out_par.exists(), f"{MLI_out_par} should _not_ exist!"

    def _mock_multi_look_MLI_outputs(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        e_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program multi_look_MLI.

        """

        if MLI_out is not None and str(MLI_out) != "-":
            MLI_out.touch()

        if MLI_out_par is not None and str(MLI_out_par) != "-":
            MLI_out_par.touch()

    def multi_look_MLI(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
        e_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Multilooking (averaging and decimation) of MLI images


        input parameters:
          MLI_in       (input) multi-look intensity image (MLI) file (float)
          MLI_in_par   (input) MLI parameter file
          MLI_out      (output) multi-looked MLI image (float)
          MLI_out_par  (output) MLI parameter file for output MLI
          rlks         range looks for multi-looking
          azlks        azimuth looks for multi-looking
          loff         offset to starting line (enter - for default: 0)
          nlines       number of input MLI lines to process (enter - for default: entire file)
          scale        scale factor for output MLI (enter - for default: 1.0)
          e_flag       extent flag (enter - for default)
                         0: only permit pixels with the full number of looks (default)
                         1: permit pixels without the full number of looks


        """

        if self.validate_inputs:
            self._validate_multi_look_MLI(
                MLI_in,
                MLI_in_par,
                MLI_out,
                MLI_out_par,
                rlks,
                azlks,
                loff,
                nlines,
                scale,
                e_flag,
            )

        if self.mock_outputs:
            self._mock_multi_look_MLI_outputs(
                MLI_in,
                MLI_in_par,
                MLI_out,
                MLI_out_par,
                rlks,
                azlks,
                loff,
                nlines,
                scale,
                e_flag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_look_MLI))
        result = self._gamma_call("ISP", "multi_look_MLI", ca)

        assert MLI_out.exists(), f"{MLI_out} does not exist"
        assert MLI_out.stat().st_size > 0, f"{MLI_out} has zero file size"

        assert MLI_out_par.exists(), f"{MLI_out_par} does not exist"
        assert MLI_out_par.stat().st_size > 0, f"{MLI_out_par} has zero file size"

        return result

    def _validate_multi_real(
        self,
        data_in: Path,
        OFF_par_in: Path,
        data_out: Path,
        OFF_par_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to multi_real.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert OFF_par_in.exists(), f"{OFF_par_in} does not exist"
        assert OFF_par_in.stat().st_size > 0, f"{OFF_par_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_multi_real_outputs(
        self,
        data_in: Path,
        OFF_par_in: Path,
        data_out: Path,
        OFF_par_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        """

        Mock the program multi_real.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

        if not OFF_par_out.exists():
            OFF_par_out.touch()

    def multi_real(
        self,
        data_in: Path,
        OFF_par_in: Path,
        data_out: Path,
        OFF_par_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate multi-look averaged or interpolated 2D image (float data)


        input parameters:
          data_in      (input) input float image file
          OFF_par_in   (input) interferogram/offset parameter file for input image
          data_out     (output) output multi-look or interpolated float data file
          OFF_par_out  (input/output) interferogram/offset parameter file for output, if already existing, used as input
          rlks         number of range looks, values < -1, interpreted as an image oversampling factor (default: 1)
          azlks        number azimuth looks,  values < -1, interpreted as an image oversampling factor (default: 1)
          loff         line offset to starting line (default:0)
          nlines       number of lines (default:0, to end of file)
          roff         offset to starting range sample (default:0)
          nsamp        number of range samples to extract (default:0, to end of line)


        """

        if self.validate_inputs:
            self._validate_multi_real(
                data_in,
                OFF_par_in,
                data_out,
                OFF_par_out,
                rlks,
                azlks,
                loff,
                nlines,
                roff,
                nsamp,
            )

        if self.mock_outputs:
            self._mock_multi_real_outputs(
                data_in,
                OFF_par_in,
                data_out,
                OFF_par_out,
                rlks,
                azlks,
                loff,
                nlines,
                roff,
                nsamp,
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_real))
        result = self._gamma_call("ISP", "multi_real", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        assert OFF_par_out.exists(), f"{OFF_par_out} does not exist"
        assert OFF_par_out.stat().st_size > 0, f"{OFF_par_out} has zero file size"

        return result

    def _validate_SLC_intf2(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        MLI_1: Optional[Path],
        MLI_2R: Optional[Path],
        MLI1_par: Optional[Path],
        MLI2R_par: Optional[Path],
        interf: Optional[Path],
        cc: Optional[Path],
        r_dec: int,
        az_dec: int,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_intf2.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2R.exists(), f"{SLC_2R} does not exist"
        assert SLC_2R.stat().st_size > 0, f"{SLC_2R} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2R_par.exists(), f"{SLC2R_par} does not exist"
        assert SLC2R_par.stat().st_size > 0, f"{SLC2R_par} has zero file size"

        if MLI_1 is not None:
            assert not MLI_1.exists(), f"{MLI_1} should _not_ exist!"

        if MLI_2R is not None:
            assert not MLI_2R.exists(), f"{MLI_2R} should _not_ exist!"

        if MLI1_par is not None:
            assert not MLI1_par.exists(), f"{MLI1_par} should _not_ exist!"

        if MLI2R_par is not None:
            assert not MLI2R_par.exists(), f"{MLI2R_par} should _not_ exist!"

        if interf is not None:
            assert not interf.exists(), f"{interf} should _not_ exist!"

        if cc is not None:
            assert not cc.exists(), f"{cc} should _not_ exist!"

        if sim_phase is not None:
            assert sim_phase.exists(), f"{sim_phase} does not exist"
            assert sim_phase.stat().st_size > 0, f"{sim_phase} has zero file size"

    def _mock_SLC_intf2_outputs(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        MLI_1: Optional[Path],
        MLI_2R: Optional[Path],
        MLI1_par: Optional[Path],
        MLI2R_par: Optional[Path],
        interf: Optional[Path],
        cc: Optional[Path],
        r_dec: int,
        az_dec: int,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_intf2.

        """

        if MLI_1 is not None and str(MLI_1) != "-":
            MLI_1.touch()

        if MLI_2R is not None and str(MLI_2R) != "-":
            MLI_2R.touch()

        if MLI1_par is not None and str(MLI1_par) != "-":
            MLI1_par.touch()

        if MLI2R_par is not None and str(MLI2R_par) != "-":
            MLI2R_par.touch()

        if interf is not None and str(interf) != "-":
            interf.touch()

        if cc is not None and str(cc) != "-":
            cc.touch()

    def SLC_intf2(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        MLI_1: Optional[Path],
        MLI_2R: Optional[Path],
        MLI1_par: Optional[Path],
        MLI2R_par: Optional[Path],
        interf: Optional[Path],
        cc: Optional[Path],
        r_dec: int,
        az_dec: int,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[int] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[int] = None,
        beta: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate interferogram and MLI images from SLCs with separate averaging window dimensions and decimation factors


        input parameters:
          SLC-1      (input) single-look complex image 1 (reference)
          SLC-2R     (input) single-look complex image 2 coregistered to SLC-1
          SLC1_par   (input) SLC-1 image parameter file
          SLC2R_par  (input) SLC-2R image parameter file for the co-registered image
          MLI-1      (output) multi-look intensity image derived from SLC-1 (enter - for none)
          MLI-2R     (output) multi-look intensity image derived from SLC-2R (enter - for none)
          MLI1_par   (output) MLI image parameter file derived from SLC1_par (enter - for none)
          MLI2R_par  (output) MLI image parameter file derived from SLC2R_par (enter - for none)
          interf     (output) complex interferogram from SLC-1 and SLC-2R  (enter - for none)
          cc         (output) interferometric correlation magnitude of SLC-1 and SLC-2R (enter - for none)
          r_dec      range decimation factor (int)
          az_dec     azimuth decimation factor (int)
          rwin       averaging window width (int) (enter - for default: r_dec)
          azwin      averaging window height (int) (enter - for default: az_dec)
          wflg       window weighting function (enter - for default):
                       0: rectangular (default)
                       1: Kaiser
                       2: circular Gaussian
          n_ovr      oversampling factor 1 -> 2 (enter - for default: 1)
          sim_phase  (input) simulated interferometric phase, coregistered MLI-1 (FLOAT, enter - for none)
          lanczos    Lanczos interpolator order 5 -> 9 (enter - for default: 7)
          beta       Gaussian or Kaiser window parameter (enter - for default: 2.0)


        """

        if self.validate_inputs:
            self._validate_SLC_intf2(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                MLI_1,
                MLI_2R,
                MLI1_par,
                MLI2R_par,
                interf,
                cc,
                r_dec,
                az_dec,
                rwin,
                azwin,
                wflg,
                n_ovr,
                sim_phase,
                lanczos,
                beta,
            )

        if self.mock_outputs:
            self._mock_SLC_intf2_outputs(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                MLI_1,
                MLI_2R,
                MLI1_par,
                MLI2R_par,
                interf,
                cc,
                r_dec,
                az_dec,
                rwin,
                azwin,
                wflg,
                n_ovr,
                sim_phase,
                lanczos,
                beta,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_intf2))
        result = self._gamma_call("ISP", "SLC_intf2", ca)

        if MLI_1 is not None:
            assert MLI_1.exists(), f"{MLI_1} does not exist"
            assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        if MLI_2R is not None:
            assert MLI_2R.exists(), f"{MLI_2R} does not exist"
            assert MLI_2R.stat().st_size > 0, f"{MLI_2R} has zero file size"

        if MLI1_par is not None:
            assert MLI1_par.exists(), f"{MLI1_par} does not exist"
            assert MLI1_par.stat().st_size > 0, f"{MLI1_par} has zero file size"

        if MLI2R_par is not None:
            assert MLI2R_par.exists(), f"{MLI2R_par} does not exist"
            assert MLI2R_par.stat().st_size > 0, f"{MLI2R_par} has zero file size"

        if interf is not None:
            assert interf.exists(), f"{interf} does not exist"
            assert interf.stat().st_size > 0, f"{interf} has zero file size"

        if cc is not None:
            assert cc.exists(), f"{cc} does not exist"
            assert cc.stat().st_size > 0, f"{cc} has zero file size"

        return result

    def _validate_SLC_copy_WB(
        self,
    ) -> None:
        """

        Validate the arguments to SLC_copy_WB.

        """

        pass

    def _mock_SLC_copy_WB_outputs(
        self,
    ) -> None:
        """

        Mock the program SLC_copy_WB.

        """
        pass

    def SLC_copy_WB(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/SLC_copy_WB
        Create a new set of SLCs for all beams in a PALSAR WB ScanSAR image

            SLC_tab    (input) two column list of input SLC files and SLC ISP image parameter files (including paths) (text)
            SLC2_dir   directory to contain copied segments of the input SLC data and the associated parameter files
            NOTE: current directory is denoted using .

        """

        if self.validate_inputs:
            self._validate_SLC_copy_WB()

        if self.mock_outputs:
            self._mock_SLC_copy_WB_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SLC_copy_WB))
        result = self._gamma_call("ISP", "SLC_copy_WB", ca)
        return result

    def _validate_S1_deramp_TOPS_reference(
        self,
    ) -> None:
        """

        Validate the arguments to S1_deramp_TOPS_reference.

        """

        pass

    def _mock_S1_deramp_TOPS_reference_outputs(
        self,
    ) -> None:
        """

        Mock the program S1_deramp_TOPS_reference.

        """
        pass

    def S1_deramp_TOPS_reference(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ****************************************************************************************
        NOTE: S1_deramp_TOPS_reference has been replaced by ScanSAR_deramp_reference.py.
        The command line options are unchanged, please consider renaming the program in
        your scripts.
        ****************************************************************************************
        cmd: ScanSAR_deramp_reference.py

        ScanSAR_deramp_reference.py: Command not found.

        """

        if self.validate_inputs:
            self._validate_S1_deramp_TOPS_reference()

        if self.mock_outputs:
            self._mock_S1_deramp_TOPS_reference_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.S1_deramp_TOPS_reference))
        result = self._gamma_call("ISP", "S1_deramp_TOPS_reference", ca)
        return result

    def _validate_SLC_burst_copy(
        self,
    ) -> None:
        """

        Validate the arguments to SLC_burst_copy.

        """

        pass

    def _mock_SLC_burst_copy_outputs(
        self,
    ) -> None:
        """

        Mock the program SLC_burst_copy.

        """
        pass

    def SLC_burst_copy(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        **************************************************************************************
        NOTE: SLC_burst_copy has been replaced by ScanSAR_burst_copy. The command line
        options are unchanged, please consider renaming the program in your scripts.
        **************************************************************************************
        ScanSAR_burst_copy
        /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/scripts/SLC_burst_copy: line 7: ScanSAR_burst_copy: command not found

        """

        if self.validate_inputs:
            self._validate_SLC_burst_copy()

        if self.mock_outputs:
            self._mock_SLC_burst_copy_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.SLC_burst_copy))
        result = self._gamma_call("ISP", "SLC_burst_copy", ca)
        return result

    def _validate_par_ASF_PRI(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_ASF_PRI.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        assert not GRD_par.exists(), f"{GRD_par} should _not_ exist!"

        if GRD is not None:
            assert not GRD.exists(), f"{GRD} should _not_ exist!"

    def _mock_par_ASF_PRI_outputs(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_ASF_PRI.

        """

        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()

        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_ASF_PRI(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file for ASF detected ground range images (L1) Sep 1996 --> present


        input parameters:
          CEOS_leader  (input) CEOS leader file
          CEOS_data    (input) CEOS data file binary
          GRD_par      (output) ISP ground range image parameter file
          GRD          (output) ISP ground range image (enter - for none, FLOAT intensity)


        """

        if self.validate_inputs:
            self._validate_par_ASF_PRI(CEOS_leader, CEOS_data, GRD_par, GRD)

        if self.mock_outputs:
            self._mock_par_ASF_PRI_outputs(CEOS_leader, CEOS_data, GRD_par, GRD)

        ca = self._clean_args(locals(), inspect.signature(self.par_ASF_PRI))
        result = self._gamma_call("ISP", "par_ASF_PRI", ca)

        assert GRD_par.exists(), f"{GRD_par} does not exist"
        assert GRD_par.stat().st_size > 0, f"{GRD_par} has zero file size"

        if GRD is not None:
            assert GRD.exists(), f"{GRD} does not exist"
            assert GRD.stat().st_size > 0, f"{GRD} has zero file size"

        return result

    def _validate_offset_pwr(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to offset_pwr.

        """

        assert SLC1.exists(), f"{SLC1} does not exist"
        assert SLC1.stat().st_size > 0, f"{SLC1} has zero file size"

        assert SLC2.exists(), f"{SLC2} does not exist"
        assert SLC2.stat().st_size > 0, f"{SLC2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert OFF_par.exists(), f"{OFF_par} does not exist"
        assert OFF_par.stat().st_size > 0, f"{OFF_par} has zero file size"

        assert not offs.exists(), f"{offs} should _not_ exist!"

        assert not ccp.exists(), f"{ccp} should _not_ exist!"

        if offsets is not None:
            assert not offsets.exists(), f"{offsets} should _not_ exist!"

        if ccs is not None:
            assert not ccs.exists(), f"{ccs} should _not_ exist!"

    def _mock_offset_pwr_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        """

        Mock the program offset_pwr.

        """

        if offs is not None and str(offs) != "-":
            offs.touch()

        if ccp is not None and str(ccp) != "-":
            ccp.touch()

        if offsets is not None and str(offsets) != "-":
            offsets.touch()

        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[int] = None,
        azwin: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[float] = None,
        lanczos: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Offset estimation between SLC images using intensity cross-correlation


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          nr        number of offset estimates in range direction (enter - for default from offset parameter file)
          naz       number of offset estimates in azimuth direction (enter - for default from offset parameter file)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          deramp    deramp SLC phase flag (enter - for default)
                      0: no deramp (Doppler centroid close to 0) (default)
                      1: deramp SLC phase
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)

        NOTE: ScanSAR and TOPS data need to be previously deramped


        """

        if self.validate_inputs:
            self._validate_offset_pwr(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        if self.mock_outputs:
            self._mock_offset_pwr_outputs(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )

        ca = self._clean_args(locals(), inspect.signature(self.offset_pwr))
        result = self._gamma_call("ISP", "offset_pwr", ca)

        assert offs.exists(), f"{offs} does not exist"
        assert offs.stat().st_size > 0, f"{offs} has zero file size"

        assert ccp.exists(), f"{ccp} does not exist"
        assert ccp.stat().st_size > 0, f"{ccp} has zero file size"

        if offsets is not None:
            assert offsets.exists(), f"{offsets} does not exist"
            assert offsets.stat().st_size > 0, f"{offsets} has zero file size"

        if ccs is not None:
            assert ccs.exists(), f"{ccs} does not exist"
            assert ccs.stat().st_size > 0, f"{ccs} has zero file size"

        return result

    def _validate_par_ATLSCI_ERS(
        self, CEOS_SAR_leader: Path, CEOS_Image: Path, SLC_par: Path
    ) -> None:
        """

        Validate the arguments to par_ATLSCI_ERS.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert CEOS_Image.exists(), f"{CEOS_Image} does not exist"
        assert CEOS_Image.stat().st_size > 0, f"{CEOS_Image} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

    def _mock_par_ATLSCI_ERS_outputs(
        self, CEOS_SAR_leader: Path, CEOS_Image: Path, SLC_par: Path
    ) -> None:
        """

        Mock the program par_ATLSCI_ERS.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ATLSCI_ERS(
        self, CEOS_SAR_leader: Path, CEOS_Image: Path, SLC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file for ATL-SCI ERS SLC data


        input parameters:
        CEOS_SAR_leader (input) CEOS SAR leader file (LEA_01.001)
        CEOS_Image      (input) CEOS image data segment (DAT_01.001)
        SLC_par         (output) ISP SLC parameter file (example <orbit>.slc.par)


        """

        if self.validate_inputs:
            self._validate_par_ATLSCI_ERS(CEOS_SAR_leader, CEOS_Image, SLC_par)

        if self.mock_outputs:
            self._mock_par_ATLSCI_ERS_outputs(CEOS_SAR_leader, CEOS_Image, SLC_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_ATLSCI_ERS))
        result = self._gamma_call("ISP", "par_ATLSCI_ERS", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_par_PRI_ESRIN_JERS(
        self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path
    ) -> None:
        """

        Validate the arguments to par_PRI_ESRIN_JERS.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not PRI_par.exists(), f"{PRI_par} should _not_ exist!"

        assert CEOS_DAT.exists(), f"{CEOS_DAT} does not exist"
        assert CEOS_DAT.stat().st_size > 0, f"{CEOS_DAT} has zero file size"

        assert not PRI.exists(), f"{PRI} should _not_ exist!"

    def _mock_par_PRI_ESRIN_JERS_outputs(
        self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path
    ) -> None:
        """

        Mock the program par_PRI_ESRIN_JERS.

        """

        if PRI_par is not None and str(PRI_par) != "-":
            PRI_par.touch()

        if PRI is not None and str(PRI) != "-":
            PRI.touch()

    def par_PRI_ESRIN_JERS(
        self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP GRD parameter file for ESRIN processed JERS PRI data


        input parameters:
          CEOS_SAR_leader (input) ERS CEOS SAR leader file for PRI product
          PRI_par         (output) ISP image parameter file (example: <yyyymmdd>.pri.par)
          CEOS_DAT        (input) CEOS data file (example: DAT_01.001)
          PRI             (output) PRI data with file and line headers removed (example: <yyyymmdd>.pri)


        """

        if self.validate_inputs:
            self._validate_par_PRI_ESRIN_JERS(CEOS_SAR_leader, PRI_par, CEOS_DAT, PRI)

        if self.mock_outputs:
            self._mock_par_PRI_ESRIN_JERS_outputs(CEOS_SAR_leader, PRI_par, CEOS_DAT, PRI)

        ca = self._clean_args(locals(), inspect.signature(self.par_PRI_ESRIN_JERS))
        result = self._gamma_call("ISP", "par_PRI_ESRIN_JERS", ca)

        assert PRI_par.exists(), f"{PRI_par} does not exist"
        assert PRI_par.stat().st_size > 0, f"{PRI_par} has zero file size"

        assert PRI.exists(), f"{PRI} does not exist"
        assert PRI.stat().st_size > 0, f"{PRI} has zero file size"

        return result

    def _validate_par_KC_PALSAR_slr(
        self,
        facter_m: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        pol: int,
        pls_mode: int,
        KC_data: Path,
        pwr: Optional[Path] = None,
        fdtab: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_KC_PALSAR_slr.

        """

        assert facter_m.exists(), f"{facter_m} does not exist"
        assert facter_m.stat().st_size > 0, f"{facter_m} has zero file size"

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        assert KC_data.exists(), f"{KC_data} does not exist"
        assert KC_data.stat().st_size > 0, f"{KC_data} has zero file size"

        if pwr is not None:
            assert not pwr.exists(), f"{pwr} should _not_ exist!"

        if fdtab is not None:
            assert not fdtab.exists(), f"{fdtab} should _not_ exist!"

    def _mock_par_KC_PALSAR_slr_outputs(
        self,
        facter_m: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        pol: int,
        pls_mode: int,
        KC_data: Path,
        pwr: Optional[Path] = None,
        fdtab: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_KC_PALSAR_slr.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if pwr is not None and str(pwr) != "-":
            pwr.touch()

        if fdtab is not None and str(fdtab) != "-":
            fdtab.touch()

    def par_KC_PALSAR_slr(
        self,
        facter_m: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        pol: int,
        pls_mode: int,
        KC_data: Path,
        pwr: Optional[Path] = None,
        fdtab: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate ISP parameter file, Doppler table, and images for PALSAR KC Slant-Range data

        input parameters:
          facter_m    (input) PALSAR Kyoto-Carbon parameter file
          CEOS_leader (input) PALSAR Kyoto-Carbon leader file (LED)
          SLC_par     (output) ISP image parameter file (example: yyyymmdd_pp.mli.par)
          pol         polarization e.g. HH or HV
          pls_mode    PALSAR acquisition mode:
                        1: Fine Beam Single
                        2: Fine Beam Double
                        3: Wide Beam
          KC_data     (input) PALSAR Kyoto-Carbon data (named sar_Q*.dat_*)
          pwr         (output) PALSAR Kyoto-Carbon data strip expressed as SAR intensity (enter - for none, example: yyyymmdd_pp.mli)
          fdtab       (output) table of output polynomials, one polynomial/block used as input to gc_map_fd (enter - for none)


        """

        if self.validate_inputs:
            self._validate_par_KC_PALSAR_slr(
                facter_m, CEOS_leader, SLC_par, pol, pls_mode, KC_data, pwr, fdtab
            )

        if self.mock_outputs:
            self._mock_par_KC_PALSAR_slr_outputs(
                facter_m, CEOS_leader, SLC_par, pol, pls_mode, KC_data, pwr, fdtab
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_KC_PALSAR_slr))
        result = self._gamma_call("ISP", "par_KC_PALSAR_slr", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if pwr is not None:
            assert pwr.exists(), f"{pwr} does not exist"
            assert pwr.stat().st_size > 0, f"{pwr} has zero file size"

        if fdtab is not None:
            assert fdtab.exists(), f"{fdtab} does not exist"
            assert fdtab.stat().st_size > 0, f"{fdtab} has zero file size"

        return result

    def _validate_ptarg_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: int,
        az_samp: int,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        ptr_par: Optional[Path] = None,
        osf: Optional[int] = None,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ptarg_SLC.

        """

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert not ptr_image.exists(), f"{ptr_image} should _not_ exist!"

        assert not r_plot.exists(), f"{r_plot} should _not_ exist!"

        assert not az_plot.exists(), f"{az_plot} should _not_ exist!"

        if ptr_par is not None:
            assert not ptr_par.exists(), f"{ptr_par} should _not_ exist!"

    def _mock_ptarg_SLC_outputs(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: int,
        az_samp: int,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        ptr_par: Optional[Path] = None,
        osf: Optional[int] = None,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program ptarg_SLC.

        """

        if ptr_image is not None and str(ptr_image) != "-":
            ptr_image.touch()

        if r_plot is not None and str(r_plot) != "-":
            r_plot.touch()

        if az_plot is not None and str(az_plot) != "-":
            az_plot.touch()

        if ptr_par is not None and str(ptr_par) != "-":
            ptr_par.touch()

    def ptarg_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: int,
        az_samp: int,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        ptr_par: Optional[Path] = None,
        osf: Optional[int] = None,
        win: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Point target response analysis and interpolation for SLC images


        input parameters:
          SLC_par    (input) SLC image parameter file
          SLC        (input) SLC image in FCOMPLEX or SCOMPLEX format
          r_samp     point target range sample number
          az_samp    point target azimuth line number
          ptr_image  (output) oversampled point target image (fcomplex, 1024x1024 samples), with and without phase gradient
          r_plot     (output) range point target response plot data (text format)
          az_plot    (output) azimuth point target response plot data (text format)
          ptr_par    (output) measured point target parameters (text format)
          osf        image over-sampling factor, 2, 4, 8, 16, 32, 64 (enter - for default: 16)
          win        maximum search window offset (samples) (enter - for default: 1)
          pltflg     plotting mode flag:
                       0: none
                       1: output plots in PNG format (default)
                       2: screen output
                       3: output plots in PDF format

        """

        if self.validate_inputs:
            self._validate_ptarg_SLC(
                SLC_par,
                SLC,
                r_samp,
                az_samp,
                ptr_image,
                r_plot,
                az_plot,
                ptr_par,
                osf,
                win,
                pltflg,
            )

        if self.mock_outputs:
            self._mock_ptarg_SLC_outputs(
                SLC_par,
                SLC,
                r_samp,
                az_samp,
                ptr_image,
                r_plot,
                az_plot,
                ptr_par,
                osf,
                win,
                pltflg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ptarg_SLC))
        result = self._gamma_call("ISP", "ptarg_SLC", ca)

        assert ptr_image.exists(), f"{ptr_image} does not exist"
        assert ptr_image.stat().st_size > 0, f"{ptr_image} has zero file size"

        assert r_plot.exists(), f"{r_plot} does not exist"
        assert r_plot.stat().st_size > 0, f"{r_plot} has zero file size"

        assert az_plot.exists(), f"{az_plot} does not exist"
        assert az_plot.stat().st_size > 0, f"{az_plot} has zero file size"

        if ptr_par is not None:
            assert ptr_par.exists(), f"{ptr_par} does not exist"
            assert ptr_par.stat().st_size > 0, f"{ptr_par} has zero file size"

        return result

    def _validate_par_EORC_PALSAR(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_EORC_PALSAR.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_EORC_PALSAR_outputs(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_EORC_PALSAR.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_EORC_PALSAR(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC image and parameter files for PALSAR + PALSAR2 level 1.1 SLC data produced by EORC/JAXA and ESA


        input parameters:
          CEOS_leader  (input) CEOS leader file for PALSAR or PALSAR-2 Level 1.1 SLC data (LED...)
          SLC_par      (output) ISP image parameter file (example: yyyymmdd.slc.par)
          CEOS_data    (input) PALSAR CEOS format Level 1.1 SLC (IMG...)
          SLC          (output) reformatted PALSAR SLC (example: yyyymmdd.slc, enter - for none)
          dtype        output data type (enter - for default)
                         0: FCOMPLEX (default)
                         1: SCOMPLEX
          sc_dB        scale factor for FCOMPLEX -> SCOMPLEX, (enter - for default: HH,VV (dB): 60.0000, VH,HV: 70.0000)


        """

        if self.validate_inputs:
            self._validate_par_EORC_PALSAR(
                CEOS_leader, SLC_par, CEOS_data, SLC, dtype, sc_dB
            )

        if self.mock_outputs:
            self._mock_par_EORC_PALSAR_outputs(
                CEOS_leader, SLC_par, CEOS_data, SLC, dtype, sc_dB
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_EORC_PALSAR))
        result = self._gamma_call("ISP", "par_EORC_PALSAR", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_S1_burstloc(self, annotation_XML: Path) -> None:
        """

        Validate the arguments to S1_burstloc.

        """

        assert annotation_XML.exists(), f"{annotation_XML} does not exist"
        assert annotation_XML.stat().st_size > 0, f"{annotation_XML} has zero file size"

    def _mock_S1_burstloc_outputs(self, annotation_XML: Path) -> None:
        """

        Mock the program S1_burstloc.

        """
        pass

    def S1_burstloc(self, annotation_XML: Path) -> Tuple[int, List[str], List[str]]:
        """

        Print Burst information found in the Sentinel-1 annotation file


        input parameters:
          annotation_XML  (input) Sentinel-1 L1 XML annotation file


        """

        if self.validate_inputs:
            self._validate_S1_burstloc(annotation_XML)

        if self.mock_outputs:
            self._mock_S1_burstloc_outputs(annotation_XML)

        ca = self._clean_args(locals(), inspect.signature(self.S1_burstloc))
        result = self._gamma_call("ISP", "S1_burstloc", ca)
        return result

    def _validate_par_GF3_SLC(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to par_GF3_SLC.

        """

        if GeoTIFF is not None:
            assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
            assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert annotation_XML.exists(), f"{annotation_XML} does not exist"
        assert annotation_XML.stat().st_size > 0, f"{annotation_XML} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_GF3_SLC_outputs(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
    ) -> None:
        """

        Mock the program par_GF3_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_GF3_SLC(
        self,
        GeoTIFF: Optional[Path],
        annotation_XML: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter file and SLC image from a Gaofen-3 data set in GeoTIFF format


        input parameters:
          GeoTIFF        (input) Gaofen-3 data file in GeoTIFF format (*.tiff) (enter - for none)
          annotation_XML (input) Gaofen-3 annotation file in XML format (*.meta.xml)
          SLC_par        (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC            (output) ISP SLC data file (example: yyyymmdd.slc) (enter - for none, SLC output will not be produced)


        """

        if self.validate_inputs:
            self._validate_par_GF3_SLC(GeoTIFF, annotation_XML, SLC_par, SLC)

        if self.mock_outputs:
            self._mock_par_GF3_SLC_outputs(GeoTIFF, annotation_XML, SLC_par, SLC)

        ca = self._clean_args(locals(), inspect.signature(self.par_GF3_SLC))
        result = self._gamma_call("ISP", "par_GF3_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_par_EORC_PALSAR_ScanSAR(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        afmrate: Optional[int] = None,
        reramp: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to par_EORC_PALSAR_ScanSAR.

        """

        assert CEOS_data.exists(), f"{CEOS_data} does not exist"
        assert CEOS_data.stat().st_size > 0, f"{CEOS_data} has zero file size"

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        if SLC is not None:
            assert not SLC.exists(), f"{SLC} should _not_ exist!"

        if TOPS_par is not None:
            assert not TOPS_par.exists(), f"{TOPS_par} should _not_ exist!"

    def _mock_par_EORC_PALSAR_ScanSAR_outputs(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        afmrate: Optional[int] = None,
        reramp: Optional[int] = None,
    ) -> None:
        """

        Mock the program par_EORC_PALSAR_ScanSAR.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

        if TOPS_par is not None and str(TOPS_par) != "-":
            TOPS_par.touch()

    def par_EORC_PALSAR_ScanSAR(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        afmrate: Optional[int] = None,
        reramp: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files from EORC PALSAR2 ScanSAR burst SLC data in CEOS format


        input parameters:
          CEOS_data    (input) CEOS image file for a PALSAR2 ScanSAR burst data subswath (IMG...)
          CEOS_leader  (input) CEOS leader file for PALSAR2 ScanSAR burst data (LED...)
          SLC_par      (output) ISP image parameter file (example: yyyymmdd_b1_hh.slc.par)
          SLC          (output) SLC data file (enter - for none, example: yyyymmdd_b1_hh.slc)
          TOPS_par     (output) SLC burst annotation file (enter - for none, example: yyyymmdd_b1_hh.slc.tops_par)
          afmrate      azimuth FM rate estimation method (enter - for default)
                         0: beam velocity on the ground
                         1: platform velocity (default)
          shift        shift azimuth spectrum by fs/2 (enter - for default)
                         0: no
                         1: yes (default)
          reramp       reramp data using Doppler centroid and azimuth FM rate estimate (enter - for default)
                         0: no
                         1: yes (default)


        """

        if self.validate_inputs:
            self._validate_par_EORC_PALSAR_ScanSAR(
                CEOS_data, CEOS_leader, SLC_par, SLC, TOPS_par, afmrate, reramp
            )

        if self.mock_outputs:
            self._mock_par_EORC_PALSAR_ScanSAR_outputs(
                CEOS_data, CEOS_leader, SLC_par, SLC, TOPS_par, afmrate, reramp
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_EORC_PALSAR_ScanSAR))
        result = self._gamma_call("ISP", "par_EORC_PALSAR_ScanSAR", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if SLC is not None:
            assert SLC.exists(), f"{SLC} does not exist"
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        if TOPS_par is not None:
            assert TOPS_par.exists(), f"{TOPS_par} does not exist"
            assert TOPS_par.stat().st_size > 0, f"{TOPS_par} has zero file size"

        return result

    def _validate_cc_wave(
        self,
        interf: Path,
        MLI_1: Optional[Path],
        MLI_2: Optional[Path],
        cc: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
        wflg: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to cc_wave.

        """

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        if MLI_1 is not None:
            assert MLI_1.exists(), f"{MLI_1} does not exist"
            assert MLI_1.stat().st_size > 0, f"{MLI_1} has zero file size"

        if MLI_2 is not None:
            assert MLI_2.exists(), f"{MLI_2} does not exist"
            assert MLI_2.stat().st_size > 0, f"{MLI_2} has zero file size"

        assert not cc.exists(), f"{cc} should _not_ exist!"

    def _mock_cc_wave_outputs(
        self,
        interf: Path,
        MLI_1: Optional[Path],
        MLI_2: Optional[Path],
        cc: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
        wflg: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Mock the program cc_wave.

        """

        if cc is not None and str(cc) != "-":
            cc.touch()

    def cc_wave(
        self,
        interf: Path,
        MLI_1: Optional[Path],
        MLI_2: Optional[Path],
        cc: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
        wflg: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Estimate interferometric correlation coefficient


        input parameters:
          interf  (input) normalized complex interferogram (FCOMPLEX)
          MLI-1   (input) multilook intensity image of the first scene (FLOAT) (enter - for none)
          MLI-2   (input) multilook intensity image of the second scene (FLOAT) (enter - for none)
          cc      (output) correlation coefficient (FLOAT)
          width   number of samples/line
          bx      estimation window size in columns (enter - for default: 5.0)
          by      estimation window size in lines (enter - for default: 5.0)
          wflg    estimation window (enter - for default):
                    0: rectangular (default)
                    1: triangular
                    2: Gaussian
                    3: normalized vector sum with rectangular window
                       NOTE: This estimator does not use the MLI data, even when specified
          xmin    starting range pixel offset (enter - for default: 0)
          xmax    last range pixel offset (enter - for default: width - 1)
          ymin    starting azimuth row offset, relative to start (enter -  for default: 0)
          ymax    last azimuth row offset, relative to start (enter - for default: nlines - 1)


        """

        if self.validate_inputs:
            self._validate_cc_wave(
                interf, MLI_1, MLI_2, cc, width, bx, by, wflg, xmin, xmax, ymin, ymax
            )

        if self.mock_outputs:
            self._mock_cc_wave_outputs(
                interf, MLI_1, MLI_2, cc, width, bx, by, wflg, xmin, xmax, ymin, ymax
            )

        ca = self._clean_args(locals(), inspect.signature(self.cc_wave))
        result = self._gamma_call("ISP", "cc_wave", ca)

        assert cc.exists(), f"{cc} does not exist"
        assert cc.stat().st_size > 0, f"{cc} has zero file size"

        return result

    def _validate_par_RSAT2_SLC(
        self,
        product_XML: Path,
        lut_XML: Path,
        GeoTIFF: Path,
        polarization: str,
        SLC_par: Path,
        SLC: Path,
    ) -> None:
        """

        Validate the arguments to par_RSAT2_SLC.

        """

        assert product_XML.exists(), f"{product_XML} does not exist"
        assert product_XML.stat().st_size > 0, f"{product_XML} has zero file size"

        assert lut_XML.exists(), f"{lut_XML} does not exist"
        assert lut_XML.stat().st_size > 0, f"{lut_XML} has zero file size"

        assert GeoTIFF.exists(), f"{GeoTIFF} does not exist"
        assert GeoTIFF.stat().st_size > 0, f"{GeoTIFF} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

        assert not SLC.exists(), f"{SLC} should _not_ exist!"

    def _mock_par_RSAT2_SLC_outputs(
        self,
        product_XML: Path,
        lut_XML: Path,
        GeoTIFF: Path,
        polarization: str,
        SLC_par: Path,
        SLC: Path,
    ) -> None:
        """

        Mock the program par_RSAT2_SLC.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_RSAT2_SLC(
        self,
        product_XML: Path,
        lut_XML: Path,
        GeoTIFF: Path,
        polarization: str,
        SLC_par: Path,
        SLC: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Generate SLC parameter and image files for Radarsat 2 SLC data from GeoTIFF


        input parameters:
          product_XML    (input) Radarsat-2 product annotation XML file (product.xml)
          lut_XML        (input) Radarsat-2 calibration XML file (lutSigma.xml), use - for no calibration
          GeoTIFF        (input) image data file in GeoTIFF format (imagery_PP.tif)
          polarization   (input) image polarization: HH, VV, HV, VH
          SLC_par        (output) ISP SLC parameter file (example: yyyymmdd_pp.slc.par)
          SLC            (output) SLC data file (example: yyyymmdd_pp.slc)

        """

        if self.validate_inputs:
            self._validate_par_RSAT2_SLC(
                product_XML, lut_XML, GeoTIFF, polarization, SLC_par, SLC
            )

        if self.mock_outputs:
            self._mock_par_RSAT2_SLC_outputs(
                product_XML, lut_XML, GeoTIFF, polarization, SLC_par, SLC
            )

        ca = self._clean_args(locals(), inspect.signature(self.par_RSAT2_SLC))
        result = self._gamma_call("ISP", "par_RSAT2_SLC", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"

        if not self.mock_outputs:
            assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert SLC.exists(), f"{SLC} does not exist"

        if not self.mock_outputs:
            assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        return result

    def _validate_residue_cc(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to residue_cc.

        """

        assert int.exists(), f"{int} does not exist"
        assert int.stat().st_size > 0, f"{int} has zero file size"

        assert flag.exists(), f"{flag} does not exist"
        assert flag.stat().st_size > 0, f"{flag} has zero file size"

    def _mock_residue_cc_outputs(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        """

        Mock the program residue_cc.

        """
        pass

    def residue_cc(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Determine interferometric phase unwrapping residues considering low coherence regions


        input parameters:
          int    (input) interferogram (fcomplex)
          flag   (input) flag file (unsigned char)
          width  number of samples/row
          xmin   offset to starting range pixel(default = 0)
          xmax   offset last range pixel (default = width-1)
          ymin   offset to starting azimuth row (default = 0)
          ymax   offset to last azimuth row (default = nlines-1)


        """

        if self.validate_inputs:
            self._validate_residue_cc(int, flag, width, xmin, xmax, ymin, ymax)

        if self.mock_outputs:
            self._mock_residue_cc_outputs(int, flag, width, xmin, xmax, ymin, ymax)

        ca = self._clean_args(locals(), inspect.signature(self.residue_cc))
        result = self._gamma_call("ISP", "residue_cc", ca)
        return result

    def _validate_par_PulSAR(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        """

        Validate the arguments to par_PulSAR.

        """

        assert CEOS_SAR_leader.exists(), f"{CEOS_SAR_leader} does not exist"
        assert CEOS_SAR_leader.stat().st_size > 0, f"{CEOS_SAR_leader} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

    def _mock_par_PulSAR_outputs(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        """

        Mock the program par_PulSAR.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_PulSAR(
        self, CEOS_SAR_leader: Path, SLC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP parameter file generation for ERS SLC data from the PULSAR SAR processor


        input parameters:
        CEOS_SAR_leader  (input) ERS CEOS SAR leader file
        SLC_par          (output) ISP SLC parameter file (example <orbit>.slc.par)


        """

        if self.validate_inputs:
            self._validate_par_PulSAR(CEOS_SAR_leader, SLC_par)

        if self.mock_outputs:
            self._mock_par_PulSAR_outputs(CEOS_SAR_leader, SLC_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_PulSAR))
        result = self._gamma_call("ISP", "par_PulSAR", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_par_ASF_91(
        self, CEOS_leader: Path, CEOS_trailer: Path, SLC_par: Path
    ) -> None:
        """

        Validate the arguments to par_ASF_91.

        """

        assert CEOS_leader.exists(), f"{CEOS_leader} does not exist"
        assert CEOS_leader.stat().st_size > 0, f"{CEOS_leader} has zero file size"

        assert CEOS_trailer.exists(), f"{CEOS_trailer} does not exist"
        assert CEOS_trailer.stat().st_size > 0, f"{CEOS_trailer} has zero file size"

        assert not SLC_par.exists(), f"{SLC_par} should _not_ exist!"

    def _mock_par_ASF_91_outputs(
        self, CEOS_leader: Path, CEOS_trailer: Path, SLC_par: Path
    ) -> None:
        """

        Mock the program par_ASF_91.

        """

        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ASF_91(
        self, CEOS_leader: Path, CEOS_trailer: Path, SLC_par: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        SLC parameter file for data data from theAlaska SAR Facility (1991-1996)


        input parameters:
          CEOS_leader   (input) ASF CEOS leader file
          CEOS_trailer  (input) ASF CEOS trailer file
          SLC_par       (output) ISP SLC image parameter file


        """

        if self.validate_inputs:
            self._validate_par_ASF_91(CEOS_leader, CEOS_trailer, SLC_par)

        if self.mock_outputs:
            self._mock_par_ASF_91_outputs(CEOS_leader, CEOS_trailer, SLC_par)

        ca = self._clean_args(locals(), inspect.signature(self.par_ASF_91))
        result = self._gamma_call("ISP", "par_ASF_91", ca)

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        return result

    def _validate_SLC_RFI_filt2(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[int] = None,
        method: Optional[int] = None,
        f_bs: Optional[int] = None,
        bs_width: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        azoff: Optional[int] = None,
        naz: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to SLC_RFI_filt2.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not SLC_filt.exists(), f"{SLC_filt} should _not_ exist!"

    def _mock_SLC_RFI_filt2_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[int] = None,
        method: Optional[int] = None,
        f_bs: Optional[int] = None,
        bs_width: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        azoff: Optional[int] = None,
        naz: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program SLC_RFI_filt2.

        """

        if SLC_filt is not None and str(SLC_filt) != "-":
            SLC_filt.touch()

    def SLC_RFI_filt2(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[int] = None,
        method: Optional[int] = None,
        f_bs: Optional[int] = None,
        bs_width: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        azoff: Optional[int] = None,
        naz: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        RFI filtering for SLC image using a band-stop filter


        input parameters:
          SLC         (input) SLC to be filtered (FCOMPLEX or SCOMPLEX)
          SLC_par     (input) reference SLC parameter file
          SLC_filt    (output) output filtered SLC (same format as SLC)
          rfi_thres   RFI threshold in dB above reference (enter - for default: auto)
          method      RFI detection method (enter - for default)
                        0: threshold above median
                        1: threshold using spectrum symmetry (default)
          f_bs        center or seed frequency of band-stop filter in Hz (-fadc/2.0 <= f_bs < fadc/2.0, enter - for default: auto)
          bs_width    width of band-stop filter in Hz (enter - for default: auto)
          roff        offset to starting range sample to filter (enter - for default: 0)
          nr          number of range samples to filter (enter - for default: to end of line)
          azoff       offset to starting azimuth line to filter (enter - for default: 0)
          naz         number of azimuth lines to filter (enter - for default: to end of file)
          pltflg      range spectrum plotting flag (enter - for default)
                        0: none
                        1: output plot in PNG format (default)
                        2: screen output plot


        """

        if self.validate_inputs:
            self._validate_SLC_RFI_filt2(
                SLC,
                SLC_par,
                SLC_filt,
                rfi_thres,
                method,
                f_bs,
                bs_width,
                roff,
                nr,
                azoff,
                naz,
                pltflg,
            )

        if self.mock_outputs:
            self._mock_SLC_RFI_filt2_outputs(
                SLC,
                SLC_par,
                SLC_filt,
                rfi_thres,
                method,
                f_bs,
                bs_width,
                roff,
                nr,
                azoff,
                naz,
                pltflg,
            )

        ca = self._clean_args(locals(), inspect.signature(self.SLC_RFI_filt2))
        result = self._gamma_call("ISP", "SLC_RFI_filt2", ca)

        assert SLC_filt.exists(), f"{SLC_filt} does not exist"
        assert SLC_filt.stat().st_size > 0, f"{SLC_filt} has zero file size"

        return result

    def _validate_fspf(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: Optional[int] = None,
        r_max: Optional[int] = None,
        spf_type: Optional[int] = None,
        MLI_par: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to fspf.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_fspf_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: Optional[int] = None,
        r_max: Optional[int] = None,
        spf_type: Optional[int] = None,
        MLI_par: Optional[Path] = None,
    ) -> None:
        """

        Mock the program fspf.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def fspf(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: Optional[int] = None,
        r_max: Optional[int] = None,
        spf_type: Optional[int] = None,
        MLI_par: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        ISP fspf: Fast spatial filter for 2D data


        input parameters:
          data_in    (input) input image data
          data_out   (output) spatially filtered image data
          width      number of samples/row
          dtype      data type (enter - for default):
                       0: FCOMPLEX
                       1: SCOMPLEX
                       2: FLOAT (default)
          r_max      maximum filter radius (range samples) (enter - for default: 64)
          spf_type   spatial filter type (enter - for default):
                       0: uniform average (default for FCOMPLEX and SCOMPLEX)
                       1: triangular weighted average: 1 - (r/r_max)
                       2: quadratic weighted average: 1 - (r/r_max)^2
                       3: Gaussian weighted average: exp(-2.*(r^2/r_max^2))
                       4: linear least-squares (default for FLOAT data)
                       5: median
          MLI_par    MLI or SLC parameter file with the same number of looks as the input image, required for GPRI data (enter - for none)


        """

        if self.validate_inputs:
            self._validate_fspf(data_in, data_out, width, dtype, r_max, spf_type, MLI_par)

        if self.mock_outputs:
            self._mock_fspf_outputs(
                data_in, data_out, width, dtype, r_max, spf_type, MLI_par
            )

        ca = self._clean_args(locals(), inspect.signature(self.fspf))
        result = self._gamma_call("ISP", "fspf", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_radcal_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        CSLC: Path,
        CSLC_par: Path,
        fcase: Optional[int] = None,
        antenna: Optional[int] = None,
        rloss_flag: Optional[int] = None,
        ant_flag: Optional[int] = None,
        refarea_flag: Optional[int] = None,
        sc_dB: Optional[int] = None,
        K_dB: Optional[int] = None,
        pix_area: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to radcal_SLC.

        """

        assert SLC.exists(), f"{SLC} does not exist"
        assert SLC.stat().st_size > 0, f"{SLC} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not CSLC.exists(), f"{CSLC} should _not_ exist!"

        assert not CSLC_par.exists(), f"{CSLC_par} should _not_ exist!"

        if pix_area is not None:
            assert not pix_area.exists(), f"{pix_area} should _not_ exist!"

    def _mock_radcal_SLC_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        CSLC: Path,
        CSLC_par: Path,
        fcase: Optional[int] = None,
        antenna: Optional[int] = None,
        rloss_flag: Optional[int] = None,
        ant_flag: Optional[int] = None,
        refarea_flag: Optional[int] = None,
        sc_dB: Optional[int] = None,
        K_dB: Optional[int] = None,
        pix_area: Optional[Path] = None,
    ) -> None:
        """

        Mock the program radcal_SLC.

        """

        if CSLC is not None and str(CSLC) != "-":
            CSLC.touch()

        if CSLC_par is not None and str(CSLC_par) != "-":
            CSLC_par.touch()

        if pix_area is not None and str(pix_area) != "-":
            pix_area.touch()

    def radcal_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        CSLC: Path,
        CSLC_par: Path,
        fcase: Optional[int] = None,
        antenna: Optional[int] = None,
        rloss_flag: Optional[int] = None,
        ant_flag: Optional[int] = None,
        refarea_flag: Optional[int] = None,
        sc_dB: Optional[int] = None,
        K_dB: Optional[int] = None,
        pix_area: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Radiometric calibration of SLC data


        input parameters:
          SLC           (input) SLC (fcomplex or scomplex)
          SLC_PAR       (input) SLC parameter file of input SLC
          CSLC          (output) radiometrically calibrated SLC (fcomplex or scomplex)
          CSLC_PAR      (output) SLC parameter file of output calibrated SLC
          fcase         format case (default = 1)
                          1: fcomplex --> fcomplex (pairs of float)
                          2: fcomplex --> scomplex (pairs of short integer)
                          3: scomplex --> fcomplex
                          4: scomplex --> scomplex
          antenna       1-way antenna gain pattern file or - (if not provided)
          rloss_flag    range spreading loss correction:
                          0: no correction (default)
                          1: apply r^3 correction  (all modes except ASAR APS)
                          2: apply r^4 correction (used only for ASAR APS mode)
                         -1: undo r^3 correction
                         -2: undo r^4 correction)
          ant_flag      antenna pattern correction:
                          0: no correction (default)
                          1: apply antenna pattern correction
                         -1: undo antenna pattern correction)
          refarea_flag  reference pixel area correction:
                          0: no pixel area correction (default)
                          1: calculate sigma0, scale area by sin(inc_ang)/sin(ref_inc_ang)
                          2: calculate gamma0, scale area by sin(inc_ang)/(cos(inc_ang)*sin(ref_inc_ang)
                         -1: undo sigma0 area scaling factor
                         -2: undo gamma0 area scaling factor
          sc_dB         scale factor in dB (default: 0.0)
          K_dB          calibration factor in dB (default: -(value from SLC_PAR) )
          pix_area      (output) ellipsoid-based ground range sigma0 or gamma0 pixel reference area (float)
                          refarea_flag 1 or -1: sigma0 ref. area
                          refarea_flag 2 or -2: gamma0 ref. area


        """

        if self.validate_inputs:
            self._validate_radcal_SLC(
                SLC,
                SLC_par,
                CSLC,
                CSLC_par,
                fcase,
                antenna,
                rloss_flag,
                ant_flag,
                refarea_flag,
                sc_dB,
                K_dB,
                pix_area,
            )

        if self.mock_outputs:
            self._mock_radcal_SLC_outputs(
                SLC,
                SLC_par,
                CSLC,
                CSLC_par,
                fcase,
                antenna,
                rloss_flag,
                ant_flag,
                refarea_flag,
                sc_dB,
                K_dB,
                pix_area,
            )

        ca = self._clean_args(locals(), inspect.signature(self.radcal_SLC))
        result = self._gamma_call("ISP", "radcal_SLC", ca)

        assert CSLC.exists(), f"{CSLC} does not exist"
        assert CSLC.stat().st_size > 0, f"{CSLC} has zero file size"

        assert CSLC_par.exists(), f"{CSLC_par} does not exist"
        assert CSLC_par.stat().st_size > 0, f"{CSLC_par} has zero file size"

        if pix_area is not None:
            assert pix_area.exists(), f"{pix_area} does not exist"
            assert pix_area.stat().st_size > 0, f"{pix_area} has zero file size"

        return result

    def _validate_line_interp(self, width: int) -> None:
        """

        Validate the arguments to line_interp.

        """

        pass

    def _mock_line_interp_outputs(self, width: int) -> None:
        """

        Mock the program line_interp.

        """
        pass

    def line_interp(self, width: int) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/line_interp.c
        1-D linear interpolator to fill data gaps

        input parameters:
          input file   input data containing 0.0 values (float)
          output file  output data with 0.0 values replaced (float)
          width        number of samples/line


        """

        if self.validate_inputs:
            self._validate_line_interp(width)

        if self.mock_outputs:
            self._mock_line_interp_outputs(width)

        ca = self._clean_args(locals(), inspect.signature(self.line_interp))
        result = self._gamma_call("LAT", "line_interp", ca)
        return result

    def _validate_product_cpx(
        self,
        f1: Path,
        f2: Path,
        f_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        conjg_flg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to product_cpx.

        """

        assert f1.exists(), f"{f1} does not exist"
        assert f1.stat().st_size > 0, f"{f1} has zero file size"

        assert f2.exists(), f"{f2} does not exist"
        assert f2.stat().st_size > 0, f"{f2} has zero file size"

        assert not f_out.exists(), f"{f_out} should _not_ exist!"

    def _mock_product_cpx_outputs(
        self,
        f1: Path,
        f2: Path,
        f_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        conjg_flg: Optional[int] = None,
    ) -> None:
        """

        Mock the program product_cpx.

        """

        if f_out is not None and str(f_out) != "-":
            f_out.touch()

    def product_cpx(
        self,
        f1: Path,
        f2: Path,
        f_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        conjg_flg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/product_cpx.c
        Calculate product of complex value data files


        input parameters:
          f1         (input) data file 1 (fcomplex)
          f2         (input) data file 2 (fcomplex)
          f_out      (output) output file f1 * f2 (fcomplex)
          width      number of data samples/line
          start      starting line (default: 1)
          nlines     number of lines to process (enter - for default, all lines)
          conjg_flg  conjugation flag
                       0: none (default)
                       1: conjugate f2 before multiply

        """

        if self.validate_inputs:
            self._validate_product_cpx(f1, f2, f_out, width, start, nlines, conjg_flg)

        if self.mock_outputs:
            self._mock_product_cpx_outputs(f1, f2, f_out, width, start, nlines, conjg_flg)

        ca = self._clean_args(locals(), inspect.signature(self.product_cpx))
        result = self._gamma_call("LAT", "product_cpx", ca)

        assert f_out.exists(), f"{f_out} does not exist"
        assert f_out.stat().st_size > 0, f"{f_out} has zero file size"

        return result

    def _validate_ras_majority(
        self,
        ras_in: Path,
        ras_out: Path,
        filter_width: Optional[int] = None,
        LR: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras_majority.

        """

        assert ras_in.exists(), f"{ras_in} does not exist"
        assert ras_in.stat().st_size > 0, f"{ras_in} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

    def _mock_ras_majority_outputs(
        self,
        ras_in: Path,
        ras_out: Path,
        filter_width: Optional[int] = None,
        LR: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras_majority.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_majority(
        self,
        ras_in: Path,
        ras_out: Path,
        filter_width: Optional[int] = None,
        LR: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program ras_majority.c
        Majority filtering of raster image, SUN, BMP, and TIFF format, 8-bits/pixel


        input parameters:
          ras_in        (input) raster classification image, SUN, BMP, or TIFF format, 8 bits/pixel
          ras_out       (output) raster classification image, SUN, BMP, or TIFF format, 8 bits/pixel
          filter_width  filter width (select from 3, 5, or 7, enter - for default: 3)
          LR            left/right mirror image flag (enter - for default: 1: normal (default), -1: mirror image)


        """

        if self.validate_inputs:
            self._validate_ras_majority(ras_in, ras_out, filter_width, LR)

        if self.mock_outputs:
            self._mock_ras_majority_outputs(ras_in, ras_out, filter_width, LR)

        ca = self._clean_args(locals(), inspect.signature(self.ras_majority))
        result = self._gamma_call("LAT", "ras_majority", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_average_filter(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[int] = None,
        wflg: Optional[int] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to average_filter.

        """

        assert din.exists(), f"{din} does not exist"
        assert din.stat().st_size > 0, f"{din} has zero file size"

        assert not dout.exists(), f"{dout} should _not_ exist!"

    def _mock_average_filter_outputs(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[int] = None,
        wflg: Optional[int] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program average_filter.

        """

        if dout is not None and str(dout) != "-":
            dout.touch()

    def average_filter(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[int] = None,
        wflg: Optional[int] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT average_filter: Averaging spatial filter (float data)


        input parameters:
          din     (input) input data file
          dout    (output) output averaged data file (filtered)
          width   number of samples/row
          bx      filter window width (columns): 1,3,5,7...
          by      filter window height (rows): 1,3,5,7.., (enter - for default: bx)
          wflg    weighting function (enter - for default)
                    0: constant weighting function (default)
                    1: linear weighting function
                    2: Gaussian weighting function
          min_pt  minimum number of points required in the filter window to evaluate the average value (enter - for default: (bx*by)/4)
          zflg    zero value flag (enter - for default)
                    0: data values that are equal to 0.0 (no data) are not changed (default)
                    1: data gaps are filled with average values if sufficient valid data points in the filter window


        """

        if self.validate_inputs:
            self._validate_average_filter(din, dout, width, bx, by, wflg, min_pt, zflg)

        if self.mock_outputs:
            self._mock_average_filter_outputs(
                din, dout, width, bx, by, wflg, min_pt, zflg
            )

        ca = self._clean_args(locals(), inspect.signature(self.average_filter))
        result = self._gamma_call("LAT", "average_filter", ca)

        assert dout.exists(), f"{dout} does not exist"
        assert dout.stat().st_size > 0, f"{dout} has zero file size"

        return result

    def _validate_mask_class(
        self,
        class_map: Path,
        file_in: Path,
        file_out: Path,
        format_flag: int,
        LR: Optional[int],
        selection_flag: Path,
        n_class: int,
        class_1: Path,
        class_n: Optional[Path] = None,
        null_value: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to mask_class.

        """

        assert class_map.exists(), f"{class_map} does not exist"
        assert class_map.stat().st_size > 0, f"{class_map} has zero file size"

        assert file_in.exists(), f"{file_in} does not exist"
        assert file_in.stat().st_size > 0, f"{file_in} has zero file size"

        assert not file_out.exists(), f"{file_out} should _not_ exist!"

    def _mock_mask_class_outputs(
        self,
        class_map: Path,
        file_in: Path,
        file_out: Path,
        format_flag: int,
        LR: Optional[int],
        selection_flag: Path,
        n_class: int,
        class_1: Path,
        class_n: Optional[Path] = None,
        null_value: Optional[Path] = None,
    ) -> None:
        """

        Mock the program mask_class.

        """

        if file_out is not None and str(file_out) != "-":
            file_out.touch()

    def mask_class(
        self,
        class_map: Path,
        file_in: Path,
        file_out: Path,
        format_flag: int,
        LR: Optional[int],
        selection_flag: Path,
        n_class: int,
        class_1: Path,
        class_n: Optional[Path] = None,
        null_value: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program mask_class.c
        Set image data values belonging to a single class or set of classes or the complement to a user-defined value


        input parameters:
          class_map       (input) class map (8-bit SUN raster(*.ras), BMP (*.bmp), TIFF (*.tif) class map file)
          file_in         (input) input data file
          file_out        (output) output data file
          format_flag     input/output data format flag
                            0: FLOAT
                            1: FCOMPLEX
                            2: SUN (*.ras), BMP (*.bmp), TIFF (*.tif) raster image
                            3: UNSIGNED CHAR
          LR              left/right mirror image flag (enter - for default: 1: normal (default), -1: mirror image)
          selection_flag  flag for mask behavior
                            1: mask is the region belonging to the selected classes
                           -1: mask is the complement of the region belonging to the selected classes
          n_class         number of classes to consider, up to 20 classes can be defined
          class_1         class map value 1
          ...             <n_class> class map values must be entered
          class_n         class map value n
          null_value      value written within the masked region:
                            FLOAT: default = 0.0
                            FCOMPLEX specify real and imaginary components: default = 0.0 0.0
                            SUN, BMP, TIFF raster image specify RGB: default RGB = 0 0 0
                            UNSIGNED CHAR: default = 0


        """

        if self.validate_inputs:
            self._validate_mask_class(
                class_map,
                file_in,
                file_out,
                format_flag,
                LR,
                selection_flag,
                n_class,
                class_1,
                class_n,
                null_value,
            )

        if self.mock_outputs:
            self._mock_mask_class_outputs(
                class_map,
                file_in,
                file_out,
                format_flag,
                LR,
                selection_flag,
                n_class,
                class_1,
                class_n,
                null_value,
            )

        ca = self._clean_args(locals(), inspect.signature(self.mask_class))
        result = self._gamma_call("LAT", "mask_class", ca)

        assert file_out.exists(), f"{file_out} does not exist"
        assert file_out.stat().st_size > 0, f"{file_out} has zero file size"

        return result

    def _validate_ras_ratio_dB(
        self,
        pwr1: Path,
        pwr2: Path,
        width: int,
        start_pwr1: Optional[int] = None,
        start_pwr2: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        LR: Optional[int] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to ras_ratio_dB.

        """

        assert pwr1.exists(), f"{pwr1} does not exist"
        assert pwr1.stat().st_size > 0, f"{pwr1} has zero file size"

        assert pwr2.exists(), f"{pwr2} does not exist"
        assert pwr2.stat().st_size > 0, f"{pwr2} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_ras_ratio_dB_outputs(
        self,
        pwr1: Path,
        pwr2: Path,
        width: int,
        start_pwr1: Optional[int] = None,
        start_pwr2: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        LR: Optional[int] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Mock the program ras_ratio_dB.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras_ratio_dB(
        self,
        pwr1: Path,
        pwr2: Path,
        width: int,
        start_pwr1: Optional[int] = None,
        start_pwr2: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        LR: Optional[int] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/ras_ratio_dB.c
        Ratio of 2 intensity images (dB scale) --> raster image (SUN, BMP, or TIFF format)


        input parameters:
          pwr1        (input) intensity image 1
          pwr2        (input)intensity image 2
          width       number of samples/row
          start_pwr1  starting line of intensity 1  image file (default=1)
          start_pwr2  starting line of intensity 2  image file (default=1)
          nlines      number of lines to display (default=0: entire file)
          pixavr      number of pixels to average in range (default=1)
          pixavaz     number of pixels to average in azimuth (default=1)
          min_value   min dB value displayed (default=-3.0)
          max_value   max dB value displayed (default= 3.0)
          dB_offset   dB value subtracted from ratio (default=0.0)
          LR          L=1 normal, LR= -1 mirror image (default=1)
          abs_flag    abs_flag=0 normal, abs_flag=1 absolute value(ratio) (default=0)
          rasf        (output) ratio raster file: *.ras SUN raster format, *.bmp BMP format, *.tif TIFF format


        """

        if self.validate_inputs:
            self._validate_ras_ratio_dB(
                pwr1,
                pwr2,
                width,
                start_pwr1,
                start_pwr2,
                nlines,
                pixavr,
                pixavaz,
                LR,
                rasf,
            )

        if self.mock_outputs:
            self._mock_ras_ratio_dB_outputs(
                pwr1,
                pwr2,
                width,
                start_pwr1,
                start_pwr2,
                nlines,
                pixavr,
                pixavaz,
                LR,
                rasf,
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras_ratio_dB))
        result = self._gamma_call("LAT", "ras_ratio_dB", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_linear_to_dB(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        inverse_flag: Optional[int] = None,
        null_value: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to linear_to_dB.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_linear_to_dB_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        inverse_flag: Optional[int] = None,
        null_value: Optional[int] = None,
    ) -> None:
        """

        Mock the program linear_to_dB.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def linear_to_dB(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        inverse_flag: Optional[int] = None,
        null_value: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/linear_to_dB.c
        Conversion of data between linear and dB scale


        input parameters:
          data_in       (input) image data file (float)
          data_out      (output) output image data file (float)
          width         number of samples/line
          inverse_flag  flag indicating direction of conversion (default=0)
                          0: converts linear scale (input) to dB scale (output)
                          1: converts dB values (input) to linear scale (output))
          null_value    null value to use for values that are <= 0 in linear scale, default=0.0)


        """

        if self.validate_inputs:
            self._validate_linear_to_dB(
                data_in, data_out, width, inverse_flag, null_value
            )

        if self.mock_outputs:
            self._mock_linear_to_dB_outputs(
                data_in, data_out, width, inverse_flag, null_value
            )

        ca = self._clean_args(locals(), inspect.signature(self.linear_to_dB))
        result = self._gamma_call("LAT", "linear_to_dB", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_histogram(
        self,
        data_in: Path,
        width: int,
        polygon: Optional[Path],
        hist: Path,
        stat: Path,
        min: float,
        max: float,
        nbins: Optional[int] = None,
        mode: Optional[int] = None,
        lin_log: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to histogram.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        if polygon is not None:
            assert polygon.exists(), f"{polygon} does not exist"
            assert polygon.stat().st_size > 0, f"{polygon} has zero file size"

        assert not hist.exists(), f"{hist} should _not_ exist!"

        assert not stat.exists(), f"{stat} should _not_ exist!"

    def _mock_histogram_outputs(
        self,
        data_in: Path,
        width: int,
        polygon: Optional[Path],
        hist: Path,
        stat: Path,
        min: float,
        max: float,
        nbins: Optional[int] = None,
        mode: Optional[int] = None,
        lin_log: Optional[int] = None,
    ) -> None:
        """

        Mock the program histogram.

        """

        if hist is not None and str(hist) != "-":
            hist.touch()

        if stat is not None and str(stat) != "-":
            stat.touch()

    def histogram(
        self,
        data_in: Path,
        width: int,
        polygon: Optional[Path],
        hist: Path,
        stat: Path,
        min: float,
        max: float,
        nbins: Optional[int] = None,
        mode: Optional[int] = None,
        lin_log: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/histogram.c
        Calculate histogram for a set of polygonal regions (FLOAT)


        input parameters:
          data_in     (input) input data (float)
          width       number of samples/line
          polygon     (input) polygon data file containing vertices of N polygons (enter - to use all the input data)
          hist        (output) histogram values as a table (text format)
                      format: data_value  data_fraction[0]  data_fraction[1]....data_fraction[N-1]
          stat        (output) mean, standard deviation, and sum of values (text format)
                      format: POLYGON:  ID   mean   standard_deviation  sum
          min         minimum histogram value
          max         maximum histogram value
          nbins       number of histogram bins (enter - for default: 50)
          mode        processing mode (enter - for default)
                        0: histogram and statistics are calculated for each polygonal region (default)
                        1: histogram and statistics are calculated for samples within the union of all the polygonal regions
          lin_log     data scaling (enter - for default)
                        0: linear scaling (default)
                        1: data are logarithmic scale (dB values)


        """

        if self.validate_inputs:
            self._validate_histogram(
                data_in, width, polygon, hist, stat, min, max, nbins, mode, lin_log
            )

        if self.mock_outputs:
            self._mock_histogram_outputs(
                data_in, width, polygon, hist, stat, min, max, nbins, mode, lin_log
            )

        ca = self._clean_args(locals(), inspect.signature(self.histogram))
        result = self._gamma_call("LAT", "histogram", ca)

        assert hist.exists(), f"{hist} does not exist"
        assert hist.stat().st_size > 0, f"{hist} has zero file size"

        assert stat.exists(), f"{stat} does not exist"
        assert stat.stat().st_size > 0, f"{stat} has zero file size"

        return result

    def _validate_gamma_map(
        self,
        input_data: Path,
        output_data: Path,
        width: int,
        nlooks: int,
        bx: int,
        by: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to gamma_map.

        """

        assert input_data.exists(), f"{input_data} does not exist"
        assert input_data.stat().st_size > 0, f"{input_data} has zero file size"

        assert not output_data.exists(), f"{output_data} should _not_ exist!"

    def _mock_gamma_map_outputs(
        self,
        input_data: Path,
        output_data: Path,
        width: int,
        nlooks: int,
        bx: int,
        by: Optional[int] = None,
    ) -> None:
        """

        Mock the program gamma_map.

        """

        if output_data is not None and str(output_data) != "-":
            output_data.touch()

    def gamma_map(
        self,
        input_data: Path,
        output_data: Path,
        width: int,
        nlooks: int,
        bx: int,
        by: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT gamma_map: Gamma Map Filter (Lopes et al., 1990)


        input parameters:
          input_data   (input) input intensity file
          output_data  (output) output intensity file (filtered)
          width        number of samples/row
          nlooks       effective number of look of the input data
          bx           filter size in x direction (columns) (1,3,5...)
          by           filter size in y direction (rows) (1,3,5...) (enter - for default: by = bx)


        """

        if self.validate_inputs:
            self._validate_gamma_map(input_data, output_data, width, nlooks, bx, by)

        if self.mock_outputs:
            self._mock_gamma_map_outputs(input_data, output_data, width, nlooks, bx, by)

        ca = self._clean_args(locals(), inspect.signature(self.gamma_map))
        result = self._gamma_call("LAT", "gamma_map", ca)

        assert output_data.exists(), f"{output_data} does not exist"
        assert output_data.stat().st_size > 0, f"{output_data} has zero file size"

        return result

    def _validate_m_chi(
        self, s0: Path, m: Path, s2chi: Path, S_par: Path, c1: Path, c3: Path
    ) -> None:
        """

        Validate the arguments to m_chi.

        """

        assert s0.exists(), f"{s0} does not exist"
        assert s0.stat().st_size > 0, f"{s0} has zero file size"

        assert m.exists(), f"{m} does not exist"
        assert m.stat().st_size > 0, f"{m} has zero file size"

        assert s2chi.exists(), f"{s2chi} does not exist"
        assert s2chi.stat().st_size > 0, f"{s2chi} has zero file size"

        assert S_par.exists(), f"{S_par} does not exist"
        assert S_par.stat().st_size > 0, f"{S_par} has zero file size"

        assert not c1.exists(), f"{c1} should _not_ exist!"

        assert not c3.exists(), f"{c3} should _not_ exist!"

    def _mock_m_chi_outputs(
        self, s0: Path, m: Path, s2chi: Path, S_par: Path, c1: Path, c3: Path
    ) -> None:
        """

        Mock the program m_chi.

        """

        if c1 is not None and str(c1) != "-":
            c1.touch()

        if c3 is not None and str(c3) != "-":
            c3.touch()

    def m_chi(
        self, s0: Path, m: Path, s2chi: Path, S_par: Path, c1: Path, c3: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate m-chi decomposition from Stokes parameters


        input parameters:
          s0     (input) Stokes parameter for the total power in the H and V polarizations <|E_h|**2 + |E_v|**2>
          m      (input) degree of polarization: sqrt(s1**2 + s2**2 + s3**2)/s0 (float)
          s2chi  (input) sin(2*chi) = s3/(m*s0), 2*chi: latitude of the Stokes vector on the Poincare sphere
                    sin(2*chi) > 0  measured field is LCP
                    sin(2*chi) < 0  measured field is RCP
          S_par  (input) MLI image parameter file associated with the Stokes parameter data files
          c1     (output) s0 * m * (1 + sin(2*chi))/2 (float)
          c2     (output) s0 * (1.0-m) depolarized component (float)
          c3     (output) s0 * m * (1 - sin(2*chi))/2 (float)

        """

        if self.validate_inputs:
            self._validate_m_chi(s0, m, s2chi, S_par, c1, c3)

        if self.mock_outputs:
            self._mock_m_chi_outputs(s0, m, s2chi, S_par, c1, c3)

        ca = self._clean_args(locals(), inspect.signature(self.m_chi))
        result = self._gamma_call("LAT", "m-chi", ca)

        assert c1.exists(), f"{c1} does not exist"
        assert c1.stat().st_size > 0, f"{c1} has zero file size"

        assert c3.exists(), f"{c3} does not exist"
        assert c3.stat().st_size > 0, f"{c3} has zero file size"

        return result

    def _validate_reallks(
        self,
        image: Path,
        ML_image: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        r_start: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to reallks.

        """

        assert image.exists(), f"{image} does not exist"
        assert image.stat().st_size > 0, f"{image} has zero file size"

        assert not ML_image.exists(), f"{ML_image} should _not_ exist!"

    def _mock_reallks_outputs(
        self,
        image: Path,
        ML_image: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        r_start: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        """

        Mock the program reallks.

        """

        if ML_image is not None and str(ML_image) != "-":
            ML_image.touch()

    def reallks(
        self,
        image: Path,
        ML_image: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        r_start: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/reallks.c

        Multilooking for real valued image data


        input parameters:
          image     (input) 4-byte/value float input file
          ML_image  (output) 4-byte/value float output file
          width     width of image
          rlks      number of range looks (default=1)
          azlks     number of azimuth looks (default=1)
          start     starting line (default=1)
          nlines    number of lines (default=entire file, 0 for entire file)
          r_start   starting range (default=1)
          nsamp     number of range samples to extract (default = to end of line)


        """

        if self.validate_inputs:
            self._validate_reallks(
                image, ML_image, width, rlks, azlks, start, nlines, r_start, nsamp
            )

        if self.mock_outputs:
            self._mock_reallks_outputs(
                image, ML_image, width, rlks, azlks, start, nlines, r_start, nsamp
            )

        ca = self._clean_args(locals(), inspect.signature(self.reallks))
        result = self._gamma_call("LAT", "reallks", ca)

        assert ML_image.exists(), f"{ML_image} does not exist"
        assert ML_image.stat().st_size > 0, f"{ML_image} has zero file size"

        return result

    def _validate_frost(
        self,
        pwr1: Path,
        pwr1_frost: Path,
        width: int,
        fx: Optional[int] = None,
        sx: Optional[int] = None,
        power: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to frost.

        """

        assert pwr1.exists(), f"{pwr1} does not exist"
        assert pwr1.stat().st_size > 0, f"{pwr1} has zero file size"

        assert not pwr1_frost.exists(), f"{pwr1_frost} should _not_ exist!"

    def _mock_frost_outputs(
        self,
        pwr1: Path,
        pwr1_frost: Path,
        width: int,
        fx: Optional[int] = None,
        sx: Optional[int] = None,
        power: Optional[int] = None,
    ) -> None:
        """

        Mock the program frost.

        """

        if pwr1_frost is not None and str(pwr1_frost) != "-":
            pwr1_frost.touch()

    def frost(
        self,
        pwr1: Path,
        pwr1_frost: Path,
        width: int,
        fx: Optional[int] = None,
        sx: Optional[int] = None,
        power: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT frost: Minimum mean square error filter (similar to Frost et al., 1982)


        input parameters:
          pwr1        (input) intensity image (float)
          pwr1_frost  (output) filtered intensity image (float)
          width       number of samples/row
          fx          filter size (enter - for default: 5)
          sx          window size used for statistics (enter - for default: 5)
          power       exponent applied to window size parameter alpha (enter - for default: 1.0 for model by Frost et al., 1982)


        """

        if self.validate_inputs:
            self._validate_frost(pwr1, pwr1_frost, width, fx, sx, power)

        if self.mock_outputs:
            self._mock_frost_outputs(pwr1, pwr1_frost, width, fx, sx, power)

        ca = self._clean_args(locals(), inspect.signature(self.frost))
        result = self._gamma_call("LAT", "frost", ca)

        assert pwr1_frost.exists(), f"{pwr1_frost} does not exist"
        assert pwr1_frost.stat().st_size > 0, f"{pwr1_frost} has zero file size"

        return result

    def _validate_mt_lee_filt(
        self,
        im_list: Optional[Path],
        ref_image: Path,
        width: int,
        winsz: int,
        L_ref: int,
        L: int,
        cthres: Optional[int] = None,
        out_list: Optional[Path] = None,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to mt_lee_filt.

        """

        if im_list is not None:
            assert im_list.exists(), f"{im_list} does not exist"
            assert im_list.stat().st_size > 0, f"{im_list} has zero file size"

        assert ref_image.exists(), f"{ref_image} does not exist"
        assert ref_image.stat().st_size > 0, f"{ref_image} has zero file size"

        if out_list is not None:
            assert out_list.exists(), f"{out_list} does not exist"
            assert out_list.stat().st_size > 0, f"{out_list} has zero file size"

        if ref_out is not None:
            assert not ref_out.exists(), f"{ref_out} should _not_ exist!"

        if b_coeff is not None:
            assert not b_coeff.exists(), f"{b_coeff} should _not_ exist!"

        if filt_num is not None:
            assert not filt_num.exists(), f"{filt_num} should _not_ exist!"

        if msr is not None:
            assert not msr.exists(), f"{msr} should _not_ exist!"

        if ctr is not None:
            assert not ctr.exists(), f"{ctr} should _not_ exist!"

    def _mock_mt_lee_filt_outputs(
        self,
        im_list: Optional[Path],
        ref_image: Path,
        width: int,
        winsz: int,
        L_ref: int,
        L: int,
        cthres: Optional[int] = None,
        out_list: Optional[Path] = None,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> None:
        """

        Mock the program mt_lee_filt.

        """

        if ref_out is not None and str(ref_out) != "-":
            ref_out.touch()

        if b_coeff is not None and str(b_coeff) != "-":
            b_coeff.touch()

        if filt_num is not None and str(filt_num) != "-":
            filt_num.touch()

        if msr is not None and str(msr) != "-":
            msr.touch()

        if ctr is not None and str(ctr) != "-":
            ctr.touch()

    def mt_lee_filt(
        self,
        im_list: Optional[Path],
        ref_image: Path,
        width: int,
        winsz: int,
        L_ref: int,
        L: int,
        cthres: Optional[int] = None,
        out_list: Optional[Path] = None,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/mt_lee_filt
        Multi-temporal direction Lee adaptive filter


        input parameters:
          im_list    (input) text file with names of co-registered FLOAT images including path (enter - for none)
          ref_image  (input) reference image used to generate the filter weights (FLOAT)
                     NOTE: the reference scene should have the same dimensions as the data files in the im_list
          width      number of samples/line
          winsz      size of the Lee filter window (valid values: 7, 13, 19)
          L_ref      effective number of looks (ENL) in the reference image (FLOAT)
          L          ENL of the images in the im_list used for local determination of the MMSE weight for each image in the im_list (FLOAT)
                     NOTE: enter - to use the MMSE filter weight derived from the reference image for all images in the im_list
          cthres     directional contrast threshold to determine if the directional filter should be applied (0->4) (enter - for default: 1.500)
                     NOTE: setting cthres=0.0, forces the directional filter to be used at all times, setting cthres=4.0 blocks all directional filtering
          out_list   (input) list of filtered output data files, number of entries in the im_list and out_list must match (enter - for none)
          ref_out    (output) filtered reference image (FLOAT) (enter - for none)
          b_coeff    (output) MMSE weighting coefficient calculated from the mean to sigma ratio and L for each sample (FLOAT) (enter - for none)
          filt_num   (output) selected structural filter number (0-->7) (BYTE) (enter - for none)
          msr        (output) mean/sigma ratio where the mean is the local mean and sigma the local standard deviation of the intensity image in the filter window (enter - for none)
          ctr        (output) directional contrast estimate used to determine if the directional filter is applied (enter - for none)


        """

        if self.validate_inputs:
            self._validate_mt_lee_filt(
                im_list,
                ref_image,
                width,
                winsz,
                L_ref,
                L,
                cthres,
                out_list,
                ref_out,
                b_coeff,
                filt_num,
                msr,
                ctr,
            )

        if self.mock_outputs:
            self._mock_mt_lee_filt_outputs(
                im_list,
                ref_image,
                width,
                winsz,
                L_ref,
                L,
                cthres,
                out_list,
                ref_out,
                b_coeff,
                filt_num,
                msr,
                ctr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.mt_lee_filt))
        result = self._gamma_call("LAT", "mt_lee_filt", ca)

        if ref_out is not None:
            assert ref_out.exists(), f"{ref_out} does not exist"
            assert ref_out.stat().st_size > 0, f"{ref_out} has zero file size"

        if b_coeff is not None:
            assert b_coeff.exists(), f"{b_coeff} does not exist"
            assert b_coeff.stat().st_size > 0, f"{b_coeff} has zero file size"

        if filt_num is not None:
            assert filt_num.exists(), f"{filt_num} does not exist"
            assert filt_num.stat().st_size > 0, f"{filt_num} has zero file size"

        if msr is not None:
            assert msr.exists(), f"{msr} does not exist"
            assert msr.stat().st_size > 0, f"{msr} has zero file size"

        if ctr is not None:
            assert ctr.exists(), f"{ctr} does not exist"
            assert ctr.stat().st_size > 0, f"{ctr} has zero file size"

        return result

    def _validate_multi_stat(
        self,
        im_list: Path,
        width: int,
        im_out: Path,
        mode: int,
        rank: int,
        nmin: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to multi_stat.

        """

        assert im_list.exists(), f"{im_list} does not exist"
        assert im_list.stat().st_size > 0, f"{im_list} has zero file size"

        assert not im_out.exists(), f"{im_out} should _not_ exist!"

    def _mock_multi_stat_outputs(
        self,
        im_list: Path,
        width: int,
        im_out: Path,
        mode: int,
        rank: int,
        nmin: Optional[int] = None,
    ) -> None:
        """

        Mock the program multi_stat.

        """

        if im_out is not None and str(im_out) != "-":
            im_out.touch()

    def multi_stat(
        self,
        im_list: Path,
        width: int,
        im_out: Path,
        mode: int,
        rank: int,
        nmin: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/multi_stat
        Sort MLI image values in a stack and specify the rank of the output image


        input parameters:
          im_list  (input) text file with names of co-registered FLOAT images including path
          width    number of samples/line
          im_out   (output) output filtered image (FLOAT)
          mode     data selection mode:
                     0: average
                     1: median
                     2: rank relative to minimum, rank=1 for minimum
                     3: rank relative to maximum, rank=1 for maximum
                     4: percentile, 0 (minimum) --> 100 (maximum)
          rank     rank value in modes 2 and 3, percentile in mode 4 (0-->100), ignored for average or median
          nmin     minimum number of valid image values required to sort (enter - for default: nfiles/2)


        """

        if self.validate_inputs:
            self._validate_multi_stat(im_list, width, im_out, mode, rank, nmin)

        if self.mock_outputs:
            self._mock_multi_stat_outputs(im_list, width, im_out, mode, rank, nmin)

        ca = self._clean_args(locals(), inspect.signature(self.multi_stat))
        result = self._gamma_call("LAT", "multi_stat", ca)

        assert im_out.exists(), f"{im_out} does not exist"
        assert im_out.stat().st_size > 0, f"{im_out} has zero file size"

        return result

    def _validate_trigo(self, data1: Path, func: int, data2: Path, width: int) -> None:
        """

        Validate the arguments to trigo.

        """

        assert data1.exists(), f"{data1} does not exist"
        assert data1.stat().st_size > 0, f"{data1} has zero file size"

        assert not data2.exists(), f"{data2} should _not_ exist!"

    def _mock_trigo_outputs(
        self, data1: Path, func: int, data2: Path, width: int
    ) -> None:
        """

        Mock the program trigo.

        """

        if data2 is not None and str(data2) != "-":
            data2.touch()

    def trigo(
        self, data1: Path, func: int, data2: Path, width: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/trigo.c

        Compute trigonometric functions of an input file


        input parameters:
          data1  (input) angle data in radians (float)
          func   1: sin, 2: cos, 3: tan, 4: asin, 5: acos, 6:atan
          data2  (output) data calculated as func(data1) (float)
          width  number of samples/line


        """

        if self.validate_inputs:
            self._validate_trigo(data1, func, data2, width)

        if self.mock_outputs:
            self._mock_trigo_outputs(data1, func, data2, width)

        ca = self._clean_args(locals(), inspect.signature(self.trigo))
        result = self._gamma_call("LAT", "trigo", ca)

        assert data2.exists(), f"{data2} does not exist"
        assert data2.stat().st_size > 0, f"{data2} has zero file size"

        return result

    def _validate_temp_filt(
        self,
        data_tab: Path,
        width: int,
        wy: Optional[int] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to temp_filt.

        """

        assert data_tab.exists(), f"{data_tab} does not exist"
        assert data_tab.stat().st_size > 0, f"{data_tab} has zero file size"

        self._check_tab_file(data_tab, "data_tab")

    def _mock_temp_filt_outputs(
        self,
        data_tab: Path,
        width: int,
        wy: Optional[int] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program temp_filt.

        """
        pass

    def temp_filt(
        self,
        data_tab: Path,
        width: int,
        wy: Optional[int] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/temp_filt
        Multi-temporal filtering of registered data sets of FLOAT format data

        input parameters:
          data_tab   (input) two column list of the names of input and output data files (FLOAT)
                       input file 1   output file 1
                       input file 2   output file 2
                        ...            ...
          width      number of samples/row
          wy         spatial averaging filter height (enter - for default:  5.00)
          wx         spatial averaging filter width (enter - for default:  5.00)
          wt_flag    weighting function flag (enter - for default)
                       0: uniform (default)
                       1: linear
                       2: Gaussian
          zflag      zero data flag (enter - for default)
                       0: 0.0 interpreted as missing value (default)
                       1: 0.0 interpreted as valid data value
          loff       number of lines offset to starting line (enter - for default: 0)
          nlines     number of lines to process (enter - or 0 for default: entire file)


        """

        if self.validate_inputs:
            self._validate_temp_filt(
                data_tab, width, wy, wx, wt_flag, zflag, loff, nlines
            )

        if self.mock_outputs:
            self._mock_temp_filt_outputs(
                data_tab, width, wy, wx, wt_flag, zflag, loff, nlines
            )

        ca = self._clean_args(locals(), inspect.signature(self.temp_filt))
        result = self._gamma_call("LAT", "temp_filt", ca)
        return result

    def _validate_cpxlks(
        self,
        CMPLX: Path,
        ML_CMPLX: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        r_start: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to cpxlks.

        """

        assert CMPLX.exists(), f"{CMPLX} does not exist"
        assert CMPLX.stat().st_size > 0, f"{CMPLX} has zero file size"

        assert not ML_CMPLX.exists(), f"{ML_CMPLX} should _not_ exist!"

    def _mock_cpxlks_outputs(
        self,
        CMPLX: Path,
        ML_CMPLX: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        r_start: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        """

        Mock the program cpxlks.

        """

        if ML_CMPLX is not None and str(ML_CMPLX) != "-":
            ML_CMPLX.touch()

    def cpxlks(
        self,
        CMPLX: Path,
        ML_CMPLX: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        r_start: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT cpxlks: Multilooking of complex valued image


        input parameters:
          CMPLX     (input) fcomplex image file
          ML_CMPLX  (output) output multilook fcomplex image file
          width     width of complex image
          rlks      number of range looks (default=1)
          azlks     number azimuth looks (default=1)
          start     starting line (default=1)
          nlines    number of lines (default=entire file, 0 for entire file)
          r_start   starting range (default=1)
          nsamp     number of range samples to extract (default = to end of line)


        """

        if self.validate_inputs:
            self._validate_cpxlks(
                CMPLX, ML_CMPLX, width, rlks, azlks, start, nlines, r_start, nsamp
            )

        if self.mock_outputs:
            self._mock_cpxlks_outputs(
                CMPLX, ML_CMPLX, width, rlks, azlks, start, nlines, r_start, nsamp
            )

        ca = self._clean_args(locals(), inspect.signature(self.cpxlks))
        result = self._gamma_call("LAT", "cpxlks", ca)

        assert ML_CMPLX.exists(), f"{ML_CMPLX} does not exist"
        assert ML_CMPLX.stat().st_size > 0, f"{ML_CMPLX} has zero file size"

        return result

    def _validate_ras_to_rgb(
        self, ras_out: Path, LR: Optional[int] = None, null_flag: Optional[int] = None
    ) -> None:
        """

        Validate the arguments to ras_to_rgb.

        """

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

        pass

    def _mock_ras_to_rgb_outputs(
        self, ras_out: Path, LR: Optional[int] = None, null_flag: Optional[int] = None
    ) -> None:
        """

        Mock the program ras_to_rgb.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_to_rgb(
        self, ras_out: Path, LR: Optional[int] = None, null_flag: Optional[int] = None
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program ras_to_rgb.c
        Combine 3 raster images (SUN, BMP, or TIFF format)  into a composite 24-bit RGB (red/green/blue) image


        input parameters:
          red channel     (input) red channel 8-bit raster image (SUN, BMP, or TIFF format)
          green channel   (input) green channel 8-bit raster image (SUN, BMP, or TIFF format)
          blue channel    (input) blue channel 8-bit raster image (SUN, BMP, or TIFF format)
          ras_out         (output) RGB 24-bit composite raster image (SUN, BMP, or TIFF format)
          LR              image mirror flag (enter - for default)
                            1: normal (default)
                           -1: mirror image
          null_flag       zero value flag (enter - for default)
                            0: same as other data (default)
                            1: if one channel is 0, set to (0,0,0)


        """

        if self.validate_inputs:
            self._validate_ras_to_rgb(ras_out, LR, null_flag)

        if self.mock_outputs:
            self._mock_ras_to_rgb_outputs(ras_out, LR, null_flag)

        ca = self._clean_args(locals(), inspect.signature(self.ras_to_rgb))
        result = self._gamma_call("LAT", "ras_to_rgb", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_ave2pwr(
        self,
        pwr1: Path,
        pwr2: Path,
        pwr_out: Path,
        width: int,
        scale_factor: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ave2pwr.

        """

        assert pwr1.exists(), f"{pwr1} does not exist"
        assert pwr1.stat().st_size > 0, f"{pwr1} has zero file size"

        assert pwr2.exists(), f"{pwr2} does not exist"
        assert pwr2.stat().st_size > 0, f"{pwr2} has zero file size"

        assert not pwr_out.exists(), f"{pwr_out} should _not_ exist!"

    def _mock_ave2pwr_outputs(
        self,
        pwr1: Path,
        pwr2: Path,
        pwr_out: Path,
        width: int,
        scale_factor: Optional[int] = None,
    ) -> None:
        """

        Mock the program ave2pwr.

        """

        if pwr_out is not None and str(pwr_out) != "-":
            pwr_out.touch()

    def ave2pwr(
        self,
        pwr1: Path,
        pwr2: Path,
        pwr_out: Path,
        width: int,
        scale_factor: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT ave2pwr: Averaging of two co-registered intensity images


        input parameters:
          pwr1          (input) intensity image 1 (float)
          pwr2          (input) intensity image 2 (float)
          pwr_out       (output) output file: (pwr1 + scale_factor*pwr2)/2.
          width         number of samples/row for the input files
          scale_factor  scale factor for image 2 (absolute value, not dB) (default: 1.0)


        """

        if self.validate_inputs:
            self._validate_ave2pwr(pwr1, pwr2, pwr_out, width, scale_factor)

        if self.mock_outputs:
            self._mock_ave2pwr_outputs(pwr1, pwr2, pwr_out, width, scale_factor)

        ca = self._clean_args(locals(), inspect.signature(self.ave2pwr))
        result = self._gamma_call("LAT", "ave2pwr", ca)

        assert pwr_out.exists(), f"{pwr_out} does not exist"
        assert pwr_out.stat().st_size > 0, f"{pwr_out} has zero file size"

        return result

    def _validate_ras_m_chi(
        self,
        s1: Path,
        c1: Path,
        c2: Path,
        c3: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to ras_m_chi.

        """

        assert s1.exists(), f"{s1} does not exist"
        assert s1.stat().st_size > 0, f"{s1} has zero file size"

        assert c1.exists(), f"{c1} does not exist"
        assert c1.stat().st_size > 0, f"{c1} has zero file size"

        assert c2.exists(), f"{c2} does not exist"
        assert c2.stat().st_size > 0, f"{c2} has zero file size"

        assert c3.exists(), f"{c3} does not exist"
        assert c3.stat().st_size > 0, f"{c3} has zero file size"

        if rasf is not None:
            assert not rasf.exists(), f"{rasf} should _not_ exist!"

    def _mock_ras_m_chi_outputs(
        self,
        s1: Path,
        c1: Path,
        c2: Path,
        c3: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        """

        Mock the program ras_m_chi.

        """

        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras_m_chi(
        self,
        s1: Path,
        c1: Path,
        c2: Path,
        c3: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        scale: Optional[float] = None,
        exp: Optional[float] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/ras_m-chi
        Generate 24-bit RGB raster image of the polarimetric m-chi decomposition


        input parameters:
          s1       (input) Stokes parameter for the total power in the H and V polarizations <|E_h|**2 + |E_v|**2>
          c1       (input) CRTLR double-bounce scattering fraction component: m*(1+sin(2*chi))/2) (red channel)
          c2       (input) random polarized fraction component: (1.0-m) (green channel)
          c3       (input) CRTLR single-bounce scattering fraction component: m*(1-sin(2*chi))/2 (blue channel)
          width    number of samples/row in the input data files
          start    starting line (enter - for default: 1
          nlines   number of lines (enter - for default: to end of file)
          pixavr   number of pixels to average in range (default: 1)
          pixavaz  number of pixels to average in azimuth (default: 1)
          scale    pwr display scale factor (default: 1.)
          exp      pwr display exponent (default: 0.5)
          rasf     (output) image filename, enter - for default, extension determines format:
                     *.ras Sun raster format
                     *.bmp BMP format
                     *.tif TIFF format


        """

        if self.validate_inputs:
            self._validate_ras_m_chi(
                s1, c1, c2, c3, width, start, nlines, pixavr, pixavaz, scale, exp, rasf
            )

        if self.mock_outputs:
            self._mock_ras_m_chi_outputs(
                s1, c1, c2, c3, width, start, nlines, pixavr, pixavaz, scale, exp, rasf
            )

        ca = self._clean_args(locals(), inspect.signature(self.ras_m_chi))
        result = self._gamma_call("LAT", "ras_m-chi", ca)

        if rasf is not None:
            assert rasf.exists(), f"{rasf} does not exist"
            assert rasf.stat().st_size > 0, f"{rasf} has zero file size"

        return result

    def _validate_sigma2gamma(
        self, sigma0: Path, inc: Path, gamma0: Path, width: int
    ) -> None:
        """

        Validate the arguments to sigma2gamma.

        """

        assert sigma0.exists(), f"{sigma0} does not exist"
        assert sigma0.stat().st_size > 0, f"{sigma0} has zero file size"

        assert inc.exists(), f"{inc} does not exist"
        assert inc.stat().st_size > 0, f"{inc} has zero file size"

        assert not gamma0.exists(), f"{gamma0} should _not_ exist!"

    def _mock_sigma2gamma_outputs(
        self, sigma0: Path, inc: Path, gamma0: Path, width: int
    ) -> None:
        """

        Mock the program sigma2gamma.

        """

        if gamma0 is not None and str(gamma0) != "-":
            gamma0.touch()

    def sigma2gamma(
        self, sigma0: Path, inc: Path, gamma0: Path, width: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/sigma2gamma.c

        Compute backscatter coefficient gamma0 (sigma0)/cos(inc)


        input parameters:
          sigma0  (input)  normalized radar cross-section sigma0
          inc     (input)  local incidence angles (radians)
          gamma0  (output) normalized radar cross-section gamma0 = sigma0 / cos(inc)
          width   number of samples/line

        """

        if self.validate_inputs:
            self._validate_sigma2gamma(sigma0, inc, gamma0, width)

        if self.mock_outputs:
            self._mock_sigma2gamma_outputs(sigma0, inc, gamma0, width)

        ca = self._clean_args(locals(), inspect.signature(self.sigma2gamma))
        result = self._gamma_call("LAT", "sigma2gamma", ca)

        assert gamma0.exists(), f"{gamma0} does not exist"
        assert gamma0.stat().st_size > 0, f"{gamma0} has zero file size"

        return result

    def _validate_hsi_color_scale(
        self,
        file_out: Path,
        nval: Optional[int] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        height: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to hsi_color_scale.

        """

        assert not file_out.exists(), f"{file_out} should _not_ exist!"

        pass

    def _mock_hsi_color_scale_outputs(
        self,
        file_out: Path,
        nval: Optional[int] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        height: Optional[int] = None,
    ) -> None:
        """

        Mock the program hsi_color_scale.

        """

        if file_out is not None and str(file_out) != "-":
            file_out.touch()

    def hsi_color_scale(
        self,
        file_out: Path,
        nval: Optional[int] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        height: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program hsi_color_scale.c
        Generate color scale for hue/saturation/intensity (HSI) images


        input parameters:
          file_out     (output) (24-bit) SUN/BMP/TIFF format raster image
          nval         number of discrete color values to display (enter - for default)
                         0: continuous color wheel (default)
          chip_width   width of color chips (enter - for default: 16)
          gap          number of pixels between color chips (enter - for default: 2)
          height       height of color scale (enter - for default: chip_width)


        """

        if self.validate_inputs:
            self._validate_hsi_color_scale(file_out, nval, chip_width, gap, height)

        if self.mock_outputs:
            self._mock_hsi_color_scale_outputs(file_out, nval, chip_width, gap, height)

        ca = self._clean_args(locals(), inspect.signature(self.hsi_color_scale))
        result = self._gamma_call("LAT", "hsi_color_scale", ca)

        assert file_out.exists(), f"{file_out} does not exist"
        assert file_out.stat().st_size > 0, f"{file_out} has zero file size"

        return result

    def _validate_unw_to_cpx(self, unw: Path, cpx: Path, width: int) -> None:
        """

        Validate the arguments to unw_to_cpx.

        """

        assert unw.exists(), f"{unw} does not exist"
        assert unw.stat().st_size > 0, f"{unw} has zero file size"

        assert not cpx.exists(), f"{cpx} should _not_ exist!"

    def _mock_unw_to_cpx_outputs(self, unw: Path, cpx: Path, width: int) -> None:
        """

        Mock the program unw_to_cpx.

        """

        if cpx is not None and str(cpx) != "-":
            cpx.touch()

    def unw_to_cpx(
        self, unw: Path, cpx: Path, width: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/unw_to_cpx.c
        convert unwrapped phase to an fcomplex interferogram


        input parameters:
          unw    (input) unwrapped phase (float)
          cpx    (output) interferogram file (fcomplex)
          width  samples per row

        """

        if self.validate_inputs:
            self._validate_unw_to_cpx(unw, cpx, width)

        if self.mock_outputs:
            self._mock_unw_to_cpx_outputs(unw, cpx, width)

        ca = self._clean_args(locals(), inspect.signature(self.unw_to_cpx))
        result = self._gamma_call("LAT", "unw_to_cpx", ca)

        assert cpx.exists(), f"{cpx} does not exist"
        assert cpx.stat().st_size > 0, f"{cpx} has zero file size"

        return result

    def _validate_polyx(
        self,
    ) -> None:
        """

        Validate the arguments to polyx.

        """

        pass

    def _mock_polyx_outputs(
        self,
    ) -> None:
        """

        Mock the program polyx.

        """
        pass

    def polyx(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/polyx
        Calculate statistics of data within polygonal regions


          input parameters:
          data    (input) data file (float)
          width   image width in range pixels
          poly    (input) polygon description file
          report  (output) report on region statistics (text format)
          mode    report print mode
                     0: i, mean, stdev (linear scale) (default)
                     1: i, mean, stdev (dB scale)
                     2: i, mean (linear scale)
                     3: i, mean (dB scale)
                     4: mean    (linear scale)
                     5: mean    (dB scale)
                     6: stdev   (linear scale)
                     7: stdev   (dB scale)
                     8: i, mean, stdev (linear scale, with exponent)

        """

        if self.validate_inputs:
            self._validate_polyx()

        if self.mock_outputs:
            self._mock_polyx_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.polyx))
        result = self._gamma_call("LAT", "polyx", ca)
        return result

    def _validate_pauli(
        self,
        SLC_HH: Path,
        SLC_VV: Path,
        SLC_HV: Path,
        SLC_HH_par: Path,
        SLC_VV_par: Path,
        SLC_HV_par: Path,
        P: Path,
    ) -> None:
        """

        Validate the arguments to pauli.

        """

        assert SLC_HH.exists(), f"{SLC_HH} does not exist"
        assert SLC_HH.stat().st_size > 0, f"{SLC_HH} has zero file size"

        assert SLC_VV.exists(), f"{SLC_VV} does not exist"
        assert SLC_VV.stat().st_size > 0, f"{SLC_VV} has zero file size"

        assert SLC_HV.exists(), f"{SLC_HV} does not exist"
        assert SLC_HV.stat().st_size > 0, f"{SLC_HV} has zero file size"

        assert SLC_HH_par.exists(), f"{SLC_HH_par} does not exist"
        assert SLC_HH_par.stat().st_size > 0, f"{SLC_HH_par} has zero file size"

        assert SLC_VV_par.exists(), f"{SLC_VV_par} does not exist"
        assert SLC_VV_par.stat().st_size > 0, f"{SLC_VV_par} has zero file size"

        assert SLC_HV_par.exists(), f"{SLC_HV_par} does not exist"
        assert SLC_HV_par.stat().st_size > 0, f"{SLC_HV_par} has zero file size"

        assert not P.exists(), f"{P} should _not_ exist!"

    def _mock_pauli_outputs(
        self,
        SLC_HH: Path,
        SLC_VV: Path,
        SLC_HV: Path,
        SLC_HH_par: Path,
        SLC_VV_par: Path,
        SLC_HV_par: Path,
        P: Path,
    ) -> None:
        """

        Mock the program pauli.

        """

        if P is not None and str(P) != "-":
            P.touch()

    def pauli(
        self,
        SLC_HH: Path,
        SLC_VV: Path,
        SLC_HV: Path,
        SLC_HH_par: Path,
        SLC_VV_par: Path,
        SLC_HV_par: Path,
        P: Path,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate Pauli polarimetric decomposition from HH, VV, and HV SLC images


        input parameters:
          SLC_HH      (input) HH single-look complex image (scomplex or fcomplex format)
          SLC_VV      (input) VV single-look complex image coregistered with SLC_HH (scomplex or fcomplex format)
          SLC_HV      (input) HV single-look complex image coregistered with SLC_HH (scomplex or fcomplex format)
          SLC_HH_par  (input) SLC_HH image parameter file
          SLC_VV_par  (input) SLC_VV image parameter file
          SLC_HV_par  (input) SLC_HV image parameter file
          P           (output) root file name of Pauli decomposition images: P_alpha.slc, P_beta.slc, P_gamma.slc (fcomplex format)
                        alpha: (S_HH + S_VV)/sqrt(2.0)
                        beta:  (S_HH - S_VV)/sqrt(2.0)
                        gamma: sqrt(2.0)*S_HV
          Note: SLC image parameter files are generated: P_alpha.slc.par, P_beta.slc.par, P_gamma.slc.par

        """

        if self.validate_inputs:
            self._validate_pauli(
                SLC_HH, SLC_VV, SLC_HV, SLC_HH_par, SLC_VV_par, SLC_HV_par, P
            )

        if self.mock_outputs:
            self._mock_pauli_outputs(
                SLC_HH, SLC_VV, SLC_HV, SLC_HH_par, SLC_VV_par, SLC_HV_par, P
            )

        ca = self._clean_args(locals(), inspect.signature(self.pauli))
        result = self._gamma_call("LAT", "pauli", ca)

        assert P.exists(), f"{P} does not exist"
        assert P.stat().st_size > 0, f"{P} has zero file size"

        return result

    def _validate_m_alpha(
        self, s0: Path, m: Path, alpha: Path, S_par: Path, c1: Path, c3: Path
    ) -> None:
        """

        Validate the arguments to m_alpha.

        """

        assert s0.exists(), f"{s0} does not exist"
        assert s0.stat().st_size > 0, f"{s0} has zero file size"

        assert m.exists(), f"{m} does not exist"
        assert m.stat().st_size > 0, f"{m} has zero file size"

        assert alpha.exists(), f"{alpha} does not exist"
        assert alpha.stat().st_size > 0, f"{alpha} has zero file size"

        assert S_par.exists(), f"{S_par} does not exist"
        assert S_par.stat().st_size > 0, f"{S_par} has zero file size"

        assert not c1.exists(), f"{c1} should _not_ exist!"

        assert not c3.exists(), f"{c3} should _not_ exist!"

    def _mock_m_alpha_outputs(
        self, s0: Path, m: Path, alpha: Path, S_par: Path, c1: Path, c3: Path
    ) -> None:
        """

        Mock the program m_alpha.

        """

        if c1 is not None and str(c1) != "-":
            c1.touch()

        if c3 is not None and str(c3) != "-":
            c3.touch()

    def m_alpha(
        self, s0: Path, m: Path, alpha: Path, S_par: Path, c1: Path, c3: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate m-alpha decomposition from Stokes parameters


        input parameters:
          s0     (input) Stokes parameter for the total power in the H and V polarizations <|E_h|**2 + |E_v|**2>
          m      (input) degree of polarization: sqrt(s1**2 + s2**2 + s3**2)/s0 (float)
          alpha  (input) 0.5*atan(sqrt(s1**2 + s2**2)/s3):
                    0.0  < alpha < PI/4 LCP
                    PI/4 < alpha < PI/2 RCP
          S_par  (input) MLI image parameter file associated with the Stokes parameter data files
          c1     (output) s0 * m * (1 + cos(2*alpha))/2 (float)
          c2     (output) s0 * (1.0-m) depolarized component (float)
          c3     (output) s0 * m * (1 - cos(2*alpha))/2 (float)

        """

        if self.validate_inputs:
            self._validate_m_alpha(s0, m, alpha, S_par, c1, c3)

        if self.mock_outputs:
            self._mock_m_alpha_outputs(s0, m, alpha, S_par, c1, c3)

        ca = self._clean_args(locals(), inspect.signature(self.m_alpha))
        result = self._gamma_call("LAT", "m-alpha", ca)

        assert c1.exists(), f"{c1} does not exist"
        assert c1.stat().st_size > 0, f"{c1} has zero file size"

        assert c3.exists(), f"{c3} does not exist"
        assert c3.stat().st_size > 0, f"{c3} has zero file size"

        return result

    def _validate_stokes(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        S: Path,
        S_par: Optional[Path],
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to stokes.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert not S.exists(), f"{S} should _not_ exist!"

        if S_par is not None:
            assert not S_par.exists(), f"{S_par} should _not_ exist!"

    def _mock_stokes_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        S: Path,
        S_par: Optional[Path],
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program stokes.

        """

        if S is not None and str(S) != "-":
            S.touch()

        if S_par is not None and str(S_par) != "-":
            S_par.touch()

    def stokes(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        S: Path,
        S_par: Optional[Path],
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate Stokes parameters from SLC images with H and V receive polarization and same transmit polarization


        input parameters:
          SLC-1     (input) HH, VV, RH, LH single-look complex image (SCOMPLEX or FCOMPLEX format)
          SLC-2     (input) HV, VH, RV, LV single-look complex image coregistered with SLC-1 (SCOMPLEX or FCOMPLEX format)
                    NOTE: 1. SLC images must be a co-pol and cross-pol pair with the same transmit polarization
                             and linear receive polarization (HH, HV), (VV, VH), (RH, RV), or (LH, LV)
                          2. SCOMPLEX SLC data are scaled according to the calibration gains indicated in the SLC parameter files
          SLC1_par  (input) SLC image parameter file of SLC-1
          SLC2_par  (input) SLC image parameter file of SLC-2 coregistered with SLC-1
          S         (output) root file name of 4 Stokes parameter files with extensions .s0, .s1, .s2, .s3 (FLOAT)
                    NOTE: expressed in the H,V polarization basis, BSA convention, the Stokes parameters are given by:
                       s0: <|E_H|**2 + |E_V|**2>
                       s1: <|E_H|**2 - |E_V|**2>
                       s2: 2Re<E_H E_V*>
                       s3: 2Im<E_H E_V*>
          S_par     (output) MLI image parameter file associated with the Stokes parameter data files (enter - for none)
          rlks      number of range looks used to calculate Stokes parameters
          azlks     number of azimuth looks used to calculate Stokes parameters
          loff      offset to starting line (enter - for default: 0)
          nlines    number of SLC lines to process (enter - for default: entire file)


        """

        if self.validate_inputs:
            self._validate_stokes(
                SLC_1, SLC_2, SLC1_par, SLC2_par, S, S_par, rlks, azlks, loff, nlines
            )

        if self.mock_outputs:
            self._mock_stokes_outputs(
                SLC_1, SLC_2, SLC1_par, SLC2_par, S, S_par, rlks, azlks, loff, nlines
            )

        ca = self._clean_args(locals(), inspect.signature(self.stokes))
        result = self._gamma_call("LAT", "stokes", ca)

        assert S.exists(), f"{S} does not exist"
        assert S.stat().st_size > 0, f"{S} has zero file size"

        if S_par is not None:
            assert S_par.exists(), f"{S_par} does not exist"
            assert S_par.stat().st_size > 0, f"{S_par} has zero file size"

        return result

    def _validate_histogram_ras(
        self,
        ras_in: Path,
        polygon: int,
        histograms: int,
        percent: int,
        lr_flag: Optional[int] = None,
        start: Optional[int] = None,
        stop: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to histogram_ras.

        """

        assert ras_in.exists(), f"{ras_in} does not exist"
        assert ras_in.stat().st_size > 0, f"{ras_in} has zero file size"

    def _mock_histogram_ras_outputs(
        self,
        ras_in: Path,
        polygon: int,
        histograms: int,
        percent: int,
        lr_flag: Optional[int] = None,
        start: Optional[int] = None,
        stop: Optional[int] = None,
    ) -> None:
        """

        Mock the program histogram_ras.

        """
        pass

    def histogram_ras(
        self,
        ras_in: Path,
        polygon: int,
        histograms: int,
        percent: int,
        lr_flag: Optional[int] = None,
        start: Optional[int] = None,
        stop: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/histogram_ras.c
        Calculation of histograms for polygon regions for a SUN raster or BMP format image


        input parameters:
          ras_in        (input) raster image, SUN raster *.ras, BMP *.bmp, or TIFF *.tif format, 8 bits/pixel
          polygon       polygon data file
          histograms    calculated histograms (output)
          mean/stdev    calculated mean/stdev (output)
          percent       histogram in terms of percent of total pixels (output)
          lr_flag       input left/right flipped (default=1: flipped; -1: not flipped)
          start         first histogram class (default=0)
          stop          last histogram class (default=all values)


        """

        if self.validate_inputs:
            self._validate_histogram_ras(
                ras_in, polygon, histograms, percent, lr_flag, start, stop
            )

        if self.mock_outputs:
            self._mock_histogram_ras_outputs(
                ras_in, polygon, histograms, percent, lr_flag, start, stop
            )

        ca = self._clean_args(locals(), inspect.signature(self.histogram_ras))
        result = self._gamma_call("LAT", "histogram_ras", ca)
        return result

    def _validate_product(
        self,
        data_1: Path,
        data_2: Path,
        product: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to product.

        """

        assert data_1.exists(), f"{data_1} does not exist"
        assert data_1.stat().st_size > 0, f"{data_1} has zero file size"

        assert data_2.exists(), f"{data_2} does not exist"
        assert data_2.stat().st_size > 0, f"{data_2} has zero file size"

        assert not product.exists(), f"{product} should _not_ exist!"

    def _mock_product_outputs(
        self,
        data_1: Path,
        data_2: Path,
        product: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
    ) -> None:
        """

        Mock the program product.

        """

        if product is not None and str(product) != "-":
            product.touch()

    def product(
        self,
        data_1: Path,
        data_2: Path,
        product: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/product
        Calculate product of two images: (image 1)*(image 2)


        input parameters:
          data_1   (input) data file 1 (float)
          data_2   (input) data file 2 (float)
          product  (output) product data_1 * data_2 (float)
          width    number of samples/row
          bx       box size in range for averaging (before multiplication, default = 5)
          by       box size in azimuth for averaging (before multiplication, default = bx
          wgt_flg  weighting mode
                     0: no weighting (default)
                     1: linear weighting
                     2: gaussian weighting


        """

        if self.validate_inputs:
            self._validate_product(data_1, data_2, product, width, bx, by)

        if self.mock_outputs:
            self._mock_product_outputs(data_1, data_2, product, width, bx, by)

        ca = self._clean_args(locals(), inspect.signature(self.product))
        result = self._gamma_call("LAT", "product", ca)

        assert product.exists(), f"{product} does not exist"
        assert product.stat().st_size > 0, f"{product} has zero file size"

        return result

    def _validate_mt_lee_filt_cpx(
        self,
        cpx_list: Optional[Path],
        ref_image: Path,
        width: int,
        winsz: int,
        L_ref: int,
        cthres: Optional[int] = None,
        out_list: Optional[Path] = None,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to mt_lee_filt_cpx.

        """

        if cpx_list is not None:
            assert cpx_list.exists(), f"{cpx_list} does not exist"
            assert cpx_list.stat().st_size > 0, f"{cpx_list} has zero file size"

        assert ref_image.exists(), f"{ref_image} does not exist"
        assert ref_image.stat().st_size > 0, f"{ref_image} has zero file size"

        if out_list is not None:
            assert out_list.exists(), f"{out_list} does not exist"
            assert out_list.stat().st_size > 0, f"{out_list} has zero file size"

        if ref_out is not None:
            assert not ref_out.exists(), f"{ref_out} should _not_ exist!"

        if b_coeff is not None:
            assert not b_coeff.exists(), f"{b_coeff} should _not_ exist!"

        if filt_num is not None:
            assert not filt_num.exists(), f"{filt_num} should _not_ exist!"

        if msr is not None:
            assert not msr.exists(), f"{msr} should _not_ exist!"

        if ctr is not None:
            assert not ctr.exists(), f"{ctr} should _not_ exist!"

    def _mock_mt_lee_filt_cpx_outputs(
        self,
        cpx_list: Optional[Path],
        ref_image: Path,
        width: int,
        winsz: int,
        L_ref: int,
        cthres: Optional[int] = None,
        out_list: Optional[Path] = None,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> None:
        """

        Mock the program mt_lee_filt_cpx.

        """

        if ref_out is not None and str(ref_out) != "-":
            ref_out.touch()

        if b_coeff is not None and str(b_coeff) != "-":
            b_coeff.touch()

        if filt_num is not None and str(filt_num) != "-":
            filt_num.touch()

        if msr is not None and str(msr) != "-":
            msr.touch()

        if ctr is not None and str(ctr) != "-":
            ctr.touch()

    def mt_lee_filt_cpx(
        self,
        cpx_list: Optional[Path],
        ref_image: Path,
        width: int,
        winsz: int,
        L_ref: int,
        cthres: Optional[int] = None,
        out_list: Optional[Path] = None,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/mt_lee_filt_cpx
        Multi-temporal Lee directional adaptive filter for complex data


        input parameters:
          cpx_list   (input) text file with names of co-registered FCOMPLEX data files including path (enter - for none)
          ref_image  (input) reference intensity image used to generate the filter weights (FLOAT)
                     NOTE: the reference scene should have the same dimensions as the data files in the cpx_list
          width      number of samples/line
          winsz      size of the Lee filter window (valid values: 7, 13, 19)
          L_ref      effective number of looks in the reference image (FLOAT)
          cthres     directional contrast threshold to determine if the directional filter should be applied (0->4)(enter - for default: 1.500)
                     NOTE: setting cthres=0.0, forces the directional filter to be used at all times, setting cthres=4.0 blocks all directional filtering
          out_list   (input) list of filtered output data files, number of entries in the cpx_list and out_list must match (enter - for none)
          ref_out    (output) filtered reference image (FLOAT) (enter - for none)
          b_coeff    (output) MMSE weighting coefficient calculated from the mean to sigma ratio and L for each sample in the reference image (FLOAT) (enter - for none)
          filt_num   (output) selected structural filter number (0-->7) (BYTE) (enter - for none)
          msr        (output) mean/sigma ratio where the mean is the local mean and sigma the local standard deviation of the intensity image in the filter window (enter - for none)
          ctr        (output) directional contrast estimate used to determine if the directional filter is applied (enter - for none)


        """

        if self.validate_inputs:
            self._validate_mt_lee_filt_cpx(
                cpx_list,
                ref_image,
                width,
                winsz,
                L_ref,
                cthres,
                out_list,
                ref_out,
                b_coeff,
                filt_num,
                msr,
                ctr,
            )

        if self.mock_outputs:
            self._mock_mt_lee_filt_cpx_outputs(
                cpx_list,
                ref_image,
                width,
                winsz,
                L_ref,
                cthres,
                out_list,
                ref_out,
                b_coeff,
                filt_num,
                msr,
                ctr,
            )

        ca = self._clean_args(locals(), inspect.signature(self.mt_lee_filt_cpx))
        result = self._gamma_call("LAT", "mt_lee_filt_cpx", ca)

        if ref_out is not None:
            assert ref_out.exists(), f"{ref_out} does not exist"
            assert ref_out.stat().st_size > 0, f"{ref_out} has zero file size"

        if b_coeff is not None:
            assert b_coeff.exists(), f"{b_coeff} does not exist"
            assert b_coeff.stat().st_size > 0, f"{b_coeff} has zero file size"

        if filt_num is not None:
            assert filt_num.exists(), f"{filt_num} does not exist"
            assert filt_num.stat().st_size > 0, f"{filt_num} has zero file size"

        if msr is not None:
            assert msr.exists(), f"{msr} does not exist"
            assert msr.stat().st_size > 0, f"{msr} has zero file size"

        if ctr is not None:
            assert ctr.exists(), f"{ctr} does not exist"
            assert ctr.stat().st_size > 0, f"{ctr} has zero file size"

        return result

    def _validate_polcovar(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        C: Path,
        C_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to polcovar.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC_3.exists(), f"{SLC_3} does not exist"
        assert SLC_3.stat().st_size > 0, f"{SLC_3} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert SLC3_par.exists(), f"{SLC3_par} does not exist"
        assert SLC3_par.stat().st_size > 0, f"{SLC3_par} has zero file size"

        assert not C.exists(), f"{C} should _not_ exist!"

        assert not C_par.exists(), f"{C_par} should _not_ exist!"

    def _mock_polcovar_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        C: Path,
        C_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program polcovar.

        """

        if C is not None and str(C) != "-":
            C.touch()

        if C_par is not None and str(C_par) != "-":
            C_par.touch()

    def polcovar(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        C: Path,
        C_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate covariance matrix C elements from HH, HV, and VV SLC data


        input parameters:
          SLC-1     (input) HH single-look complex image (scomplex or fcomplex format)
          SLC-2     (input) HV single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC-3     (input) VV single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC1_par  (input) HH SLC image parameter file of SLC-1
          SLC2_par  (input) HV SLC image parameter file of SLC-2 coregistered with SLC-1
          SLC3_par  (input) VV SLC image parameter file of SLC-3 coregistered with SLC-1
          C         (output) root file name of covariance matrix C_3 elements (e.g. scene_id): .c11, .c22, .c33 (float), .c12, .c13, .c23 (fcomplex)
          C_par     (output) MLI image parameter file associated with the covariance matrix element data files
          rlks      number of range looks used to calculate covariances
          azlks     number of azimuth looks used to calculate covariance
          loff      offset to starting line (default: 0)
          nlines    number of SLC lines to process (enter - for default: entire file)


        """

        if self.validate_inputs:
            self._validate_polcovar(
                SLC_1,
                SLC_2,
                SLC_3,
                SLC1_par,
                SLC2_par,
                SLC3_par,
                C,
                C_par,
                rlks,
                azlks,
                loff,
                nlines,
            )

        if self.mock_outputs:
            self._mock_polcovar_outputs(
                SLC_1,
                SLC_2,
                SLC_3,
                SLC1_par,
                SLC2_par,
                SLC3_par,
                C,
                C_par,
                rlks,
                azlks,
                loff,
                nlines,
            )

        ca = self._clean_args(locals(), inspect.signature(self.polcovar))
        result = self._gamma_call("LAT", "polcovar", ca)

        assert C.exists(), f"{C} does not exist"
        assert C.stat().st_size > 0, f"{C} has zero file size"

        assert C_par.exists(), f"{C_par} does not exist"
        assert C_par.stat().st_size > 0, f"{C_par} has zero file size"

        return result

    def _validate_stokes_qm(
        self,
        S: Path,
        S_par: Path,
        m: Optional[Path] = None,
        s2chi: Optional[Path] = None,
        s2psi: Optional[Path] = None,
        m_l: Optional[Path] = None,
        m_c: Optional[Path] = None,
        lp_ratio: Optional[Path] = None,
        cp_ratio: Optional[Path] = None,
        mu: Optional[Path] = None,
        delta: Optional[Path] = None,
        alpha: Optional[Path] = None,
        phi: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to stokes_qm.

        """

        assert S.exists(), f"{S} does not exist"
        assert S.stat().st_size > 0, f"{S} has zero file size"

        assert S_par.exists(), f"{S_par} does not exist"
        assert S_par.stat().st_size > 0, f"{S_par} has zero file size"

        if m is not None:
            assert not m.exists(), f"{m} should _not_ exist!"

        if s2chi is not None:
            assert not s2chi.exists(), f"{s2chi} should _not_ exist!"

        if s2psi is not None:
            assert not s2psi.exists(), f"{s2psi} should _not_ exist!"

        if m_l is not None:
            assert not m_l.exists(), f"{m_l} should _not_ exist!"

        if m_c is not None:
            assert not m_c.exists(), f"{m_c} should _not_ exist!"

        if lp_ratio is not None:
            assert not lp_ratio.exists(), f"{lp_ratio} should _not_ exist!"

        if cp_ratio is not None:
            assert not cp_ratio.exists(), f"{cp_ratio} should _not_ exist!"

        if mu is not None:
            assert not mu.exists(), f"{mu} should _not_ exist!"

        if delta is not None:
            assert not delta.exists(), f"{delta} should _not_ exist!"

        if alpha is not None:
            assert not alpha.exists(), f"{alpha} should _not_ exist!"

        if phi is not None:
            assert not phi.exists(), f"{phi} should _not_ exist!"

    def _mock_stokes_qm_outputs(
        self,
        S: Path,
        S_par: Path,
        m: Optional[Path] = None,
        s2chi: Optional[Path] = None,
        s2psi: Optional[Path] = None,
        m_l: Optional[Path] = None,
        m_c: Optional[Path] = None,
        lp_ratio: Optional[Path] = None,
        cp_ratio: Optional[Path] = None,
        mu: Optional[Path] = None,
        delta: Optional[Path] = None,
        alpha: Optional[Path] = None,
        phi: Optional[Path] = None,
    ) -> None:
        """

        Mock the program stokes_qm.

        """

        if m is not None and str(m) != "-":
            m.touch()

        if s2chi is not None and str(s2chi) != "-":
            s2chi.touch()

        if s2psi is not None and str(s2psi) != "-":
            s2psi.touch()

        if m_l is not None and str(m_l) != "-":
            m_l.touch()

        if m_c is not None and str(m_c) != "-":
            m_c.touch()

        if lp_ratio is not None and str(lp_ratio) != "-":
            lp_ratio.touch()

        if cp_ratio is not None and str(cp_ratio) != "-":
            cp_ratio.touch()

        if mu is not None and str(mu) != "-":
            mu.touch()

        if delta is not None and str(delta) != "-":
            delta.touch()

        if alpha is not None and str(alpha) != "-":
            alpha.touch()

        if phi is not None and str(phi) != "-":
            phi.touch()

    def stokes_qm(
        self,
        S: Path,
        S_par: Path,
        m: Optional[Path] = None,
        s2chi: Optional[Path] = None,
        s2psi: Optional[Path] = None,
        m_l: Optional[Path] = None,
        m_c: Optional[Path] = None,
        lp_ratio: Optional[Path] = None,
        cp_ratio: Optional[Path] = None,
        mu: Optional[Path] = None,
        delta: Optional[Path] = None,
        alpha: Optional[Path] = None,
        phi: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate quantitative measures derived from Stokes parameters (e.g. degree of polarization)


        input parameters:
          S         (input) root file name of 4 Stokes parameter files with extensions .s0, .s1, .s2, .s3 (FLOAT)
          S_par     (input) image parameter file associated with the Stokes parameter data files
          m         (output) degree of polarization: sqrt(s1**2 + s2**2 + s3**2)/s0 (enter - for none) (FLOAT)
          s2chi     (output) sine of the latitude of the Stokes vector on the Poincare sphere: sin(2*chi) = s3/(m*s0)
          s2psi     (output) sine of the longitude of the Stokes vector on the Poincare sphere: sin(2*psi) = s2/sqrt(s1**2 + s2**2))
          m_l       (output) degree of linear polarization: sqrt(s1**2 + s2**2)/s0  (enter - for none) (FLOAT)
          m_c       (output) degree of circular polarization: s3/s0 (enter - for none) (FLOAT)
          lp_ratio  (output) linear polarization ratio: (s0 - s1)/(s0 + s1), 0 <= lp_ratio (enter - for none) (FLOAT)
          cp_ratio  (output) circular polarization ratio: (s0 - s3)/(s0 + s3), 0 <= cp_ratio (enter - for none) (FLOAT)
          mu        (output) coherency parameter |mu_xy|: sqrt(s2**2 + s3**2)/sqrt(s0**2 - s1**2) (enter - for none) (FLOAT)
          delta     (output) relative H and V phase difference atan(s3/s2) (enter - for none) (radians, FLOAT)
          alpha     (output) alpha parameter in the compact H/alpha decomposition: 0.5*atan(sqrt(s1**2 + s2**2)/s3) (enter - for none) (radians, FLOAT)
          phi       (output) longitude of Stokes vector 2*psi: atan(s2/s1) (enter - for none) (radians, FLOAT)


        """

        if self.validate_inputs:
            self._validate_stokes_qm(
                S,
                S_par,
                m,
                s2chi,
                s2psi,
                m_l,
                m_c,
                lp_ratio,
                cp_ratio,
                mu,
                delta,
                alpha,
                phi,
            )

        if self.mock_outputs:
            self._mock_stokes_qm_outputs(
                S,
                S_par,
                m,
                s2chi,
                s2psi,
                m_l,
                m_c,
                lp_ratio,
                cp_ratio,
                mu,
                delta,
                alpha,
                phi,
            )

        ca = self._clean_args(locals(), inspect.signature(self.stokes_qm))
        result = self._gamma_call("LAT", "stokes_qm", ca)

        if m is not None:
            assert m.exists(), f"{m} does not exist"
            assert m.stat().st_size > 0, f"{m} has zero file size"

        if s2chi is not None:
            assert s2chi.exists(), f"{s2chi} does not exist"
            assert s2chi.stat().st_size > 0, f"{s2chi} has zero file size"

        if s2psi is not None:
            assert s2psi.exists(), f"{s2psi} does not exist"
            assert s2psi.stat().st_size > 0, f"{s2psi} has zero file size"

        if m_l is not None:
            assert m_l.exists(), f"{m_l} does not exist"
            assert m_l.stat().st_size > 0, f"{m_l} has zero file size"

        if m_c is not None:
            assert m_c.exists(), f"{m_c} does not exist"
            assert m_c.stat().st_size > 0, f"{m_c} has zero file size"

        if lp_ratio is not None:
            assert lp_ratio.exists(), f"{lp_ratio} does not exist"
            assert lp_ratio.stat().st_size > 0, f"{lp_ratio} has zero file size"

        if cp_ratio is not None:
            assert cp_ratio.exists(), f"{cp_ratio} does not exist"
            assert cp_ratio.stat().st_size > 0, f"{cp_ratio} has zero file size"

        if mu is not None:
            assert mu.exists(), f"{mu} does not exist"
            assert mu.stat().st_size > 0, f"{mu} has zero file size"

        if delta is not None:
            assert delta.exists(), f"{delta} does not exist"
            assert delta.stat().st_size > 0, f"{delta} has zero file size"

        if alpha is not None:
            assert alpha.exists(), f"{alpha} does not exist"
            assert alpha.stat().st_size > 0, f"{alpha} has zero file size"

        if phi is not None:
            assert phi.exists(), f"{phi} does not exist"
            assert phi.stat().st_size > 0, f"{phi} has zero file size"

        return result

    def _validate_frame(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: int,
        dx1: int,
        dx2: int,
        dy1: int,
        dy2: int,
        null_flag: Optional[int] = None,
        all_flag: Optional[Path] = None,
        null_value: Optional[int] = None,
        frame_value: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to frame.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_frame_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: int,
        dx1: int,
        dx2: int,
        dy1: int,
        dy2: int,
        null_flag: Optional[int] = None,
        all_flag: Optional[Path] = None,
        null_value: Optional[int] = None,
        frame_value: Optional[int] = None,
    ) -> None:
        """

        Mock the program frame.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def frame(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: int,
        dx1: int,
        dx2: int,
        dy1: int,
        dy2: int,
        null_flag: Optional[int] = None,
        all_flag: Optional[Path] = None,
        null_value: Optional[int] = None,
        frame_value: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT frame: Replace values near the image edges with a user-defined value


        input parameters:
          data_in      (input) image data file
          data_out     (output) image data file
          width        width of input data (samples/line)
          dtype        data type:
                         0: FLOAT    (REAL*4)
                         1: FCOMPLEX (REAL*4, REAL*4)
                         2: INTEGER  (INTEGER*4)
                         3: SHORT    (INTEGER*2)
                         4: BYTE     (UNSIGNED CHAR)
                         5: SUN/BMP/TIFF format raster image (8 or 24 bits/pixel)
          dx1          left side frame width (samples)
          dx2          right side frame width (samples)
          dy1          top side frame width (lines)
          dy2          bottom side frame width (lines)
          null_flag    specify how a new fame is added to the existing border around the image (enter - for default)
                         0: absolute border does not depend on the existing image pixel values (default)
                         1: border is added to the existing image border
          all_flag     specify classification of null values in SUN raster and BMP format files (enter - for default)
                         0: require only one component of the pixel RGB value to be NULL in order to belong to the NULL class (default)
                         1: require that all components of the pixel RGB value to be NULL in order to belong to the NULL class
          null_value   NULL value:
                         FLOAT, INTEGER, SHORT, BYTE default: 0.0
                         FCOMPLEX default: 0.0, 0.0
                         SUN/BMP/TIFF raster image default (RGB): 0 0 0
          frame_value  FRAME value:
                         FLOAT, INTEGER, SHORT, BYTE default: 0.0
                         FCOMPLEX default: 0.0 0.0
                         SUN/BMP/TIFF raster image default (RGB): 0 0 0


        """

        if self.validate_inputs:
            self._validate_frame(
                data_in,
                data_out,
                width,
                dtype,
                dx1,
                dx2,
                dy1,
                dy2,
                null_flag,
                all_flag,
                null_value,
                frame_value,
            )

        if self.mock_outputs:
            self._mock_frame_outputs(
                data_in,
                data_out,
                width,
                dtype,
                dx1,
                dx2,
                dy1,
                dy2,
                null_flag,
                all_flag,
                null_value,
                frame_value,
            )

        ca = self._clean_args(locals(), inspect.signature(self.frame))
        result = self._gamma_call("LAT", "frame", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_looks(
        self,
    ) -> None:
        """

        Validate the arguments to looks.

        """

        pass

    def _mock_looks_outputs(
        self,
    ) -> None:
        """

        Mock the program looks.

        """
        pass

    def looks(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/looks.c
        Equivalent number of looks (ENL) estimation for test areas (polygon regions)


          input parameters:
          pwr      (input) input intensity image file (floating point)
          width    image width in range pixels
          polygon  polygon data file

        """

        if self.validate_inputs:
            self._validate_looks()

        if self.mock_outputs:
            self._mock_looks_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.looks))
        result = self._gamma_call("LAT", "looks", ca)
        return result

    def _validate_polcoh(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        T: Path,
        T_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to polcoh.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC_3.exists(), f"{SLC_3} does not exist"
        assert SLC_3.stat().st_size > 0, f"{SLC_3} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert SLC3_par.exists(), f"{SLC3_par} does not exist"
        assert SLC3_par.stat().st_size > 0, f"{SLC3_par} has zero file size"

        assert not T.exists(), f"{T} should _not_ exist!"

        assert not T_par.exists(), f"{T_par} should _not_ exist!"

    def _mock_polcoh_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        T: Path,
        T_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program polcoh.

        """

        if T is not None and str(T) != "-":
            T.touch()

        if T_par is not None and str(T_par) != "-":
            T_par.touch()

    def polcoh(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        T: Path,
        T_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate coherence matrix T elements from Pauli decomposition alpha, beta, gamma


        input parameters:
          SLC-1     (input) alpha single-look complex image (scomplex or fcomplex format)
          SLC-2     (input) beta single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC-3     (input) gamma single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC1_par  (input) SLC image parameter file of SLC-1
          SLC2_par  (input) SLC image parameter file of SLC-2 coregistered with SLC-1
          SLC3_par  (input) SLC image parameter file of SLC-3 coregistered with SLC-1
          T         (output) root file name of coherence matrix elements (e.g. scene_id): .t11, .t22, .t33 (float), .t12, .t13, .t23 (fcomplex)
          T_par     (output) MLI image parameter file associated with the coherence matrix element data files
          rlks      number of range looks used to calculate coherences
          azlks     number of azimuth looks used to calculate coherence
          loff      offset to starting line (default: 0)
          nlines    number of SLC lines to process (enter - for default: entire file)


        """

        if self.validate_inputs:
            self._validate_polcoh(
                SLC_1,
                SLC_2,
                SLC_3,
                SLC1_par,
                SLC2_par,
                SLC3_par,
                T,
                T_par,
                rlks,
                azlks,
                loff,
                nlines,
            )

        if self.mock_outputs:
            self._mock_polcoh_outputs(
                SLC_1,
                SLC_2,
                SLC_3,
                SLC1_par,
                SLC2_par,
                SLC3_par,
                T,
                T_par,
                rlks,
                azlks,
                loff,
                nlines,
            )

        ca = self._clean_args(locals(), inspect.signature(self.polcoh))
        result = self._gamma_call("LAT", "polcoh", ca)

        assert T.exists(), f"{T} does not exist"
        assert T.stat().st_size > 0, f"{T} has zero file size"

        assert T_par.exists(), f"{T_par} does not exist"
        assert T_par.stat().st_size > 0, f"{T_par} has zero file size"

        return result

    def _validate_lin_comb(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant: int,
        factor1: int,
        factor2: int,
        f_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to lin_comb.

        """

        assert f1.exists(), f"{f1} does not exist"
        assert f1.stat().st_size > 0, f"{f1} has zero file size"

        assert f2.exists(), f"{f2} does not exist"
        assert f2.stat().st_size > 0, f"{f2} has zero file size"

        assert not f_out.exists(), f"{f_out} should _not_ exist!"

    def _mock_lin_comb_outputs(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant: int,
        factor1: int,
        factor2: int,
        f_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program lin_comb.

        """

        if f_out is not None and str(f_out) != "-":
            f_out.touch()

    def lin_comb(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant: int,
        factor1: int,
        factor2: int,
        f_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/lin_comb.c
        Calculate linear combination of float data files


        input parameters:
          nfiles     number of input data files
          f1         (input) 1. input data file (float)
          f2         (input) 2. input data file (float)
          ...        (input) further input files
          constant   constant value to add to output
          factor1    factor1 to multiply with f1
          factor2    factor2 to multiply with f2
          ...        factors for further input files
          f_out      (output) output file (float)
          width      number of samples/row
          start      starting line (default: 1)
          nlines     number of lines to display (default 0: entire file)
          pixav_x    number of pixels to average in width (default: 1)
          pixav_y    number of pixels to average in height (default: 1)
          zero_flag  interpretation of 0.0 values:
                       0: interpreted as missing value (default)
                       1: 0.0 is valid data value


        """

        if self.validate_inputs:
            self._validate_lin_comb(
                nfiles,
                f1,
                f2,
                constant,
                factor1,
                factor2,
                f_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                zero_flag,
            )

        if self.mock_outputs:
            self._mock_lin_comb_outputs(
                nfiles,
                f1,
                f2,
                constant,
                factor1,
                factor2,
                f_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                zero_flag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.lin_comb))
        result = self._gamma_call("LAT", "lin_comb", ca)

        assert f_out.exists(), f"{f_out} does not exist"
        assert f_out.stat().st_size > 0, f"{f_out} has zero file size"

        return result

    def _validate_multi_class_mapping(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        fn: Path,
        classf: Path,
        ras_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[int] = None,
        color_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to multi_class_mapping.

        """

        assert f1.exists(), f"{f1} does not exist"
        assert f1.stat().st_size > 0, f"{f1} has zero file size"

        assert f2.exists(), f"{f2} does not exist"
        assert f2.stat().st_size > 0, f"{f2} has zero file size"

        assert fn.exists(), f"{fn} does not exist"
        assert fn.stat().st_size > 0, f"{fn} has zero file size"

        assert classf.exists(), f"{classf} does not exist"
        assert classf.stat().st_size > 0, f"{classf} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

    def _mock_multi_class_mapping_outputs(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        fn: Path,
        classf: Path,
        ras_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[int] = None,
        color_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program multi_class_mapping.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def multi_class_mapping(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        fn: Path,
        classf: Path,
        ras_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[int] = None,
        color_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program multi_class_mapping.c
        Classification based on multiple input files using threshold table


        input parameters:
          nfiles      number of input data files
          f1          (input) 1. input data file (float)
          f2          (input) 2. input data file (float)
          ...         (input) further input files
          fn          (input) last input data file (float)
          classf      (input) decision thresholds (text format)
                      each line contains thresholds for a single class for each input file lower and upper thresholds are requested
          ras_out     (output) 8-bit raster image file (SUN raster: *.ras,  BMP: *.bmp, TIFF: *.tif)
          width       number of samples/row
          start       starting line (enter - for default: 1)
          nlines      number of lines to display (enter - for default: 0=entire file)
          pixav_x     number of pixels to average in width (enter - for default: 1)
          pixav_y     number of pixels to average in height (enter - for default: 1)
          LR          left/right mirror image flag (enter - for default: 1: normal (default), -1: mirror image)
          color_flag  flag indicating if a color table is defined in file classf (enter - for default)
                        0: no color table defined (default)
                        1: color table defined


        """

        if self.validate_inputs:
            self._validate_multi_class_mapping(
                nfiles,
                f1,
                f2,
                fn,
                classf,
                ras_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                LR,
                color_flag,
            )

        if self.mock_outputs:
            self._mock_multi_class_mapping_outputs(
                nfiles,
                f1,
                f2,
                fn,
                classf,
                ras_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                LR,
                color_flag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.multi_class_mapping))
        result = self._gamma_call("LAT", "multi_class_mapping", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_takecut(
        self,
        data_in: Path,
        width: int,
        report: Path,
        mode: Optional[int],
        pos: int,
        pr_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to takecut.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not report.exists(), f"{report} should _not_ exist!"

    def _mock_takecut_outputs(
        self,
        data_in: Path,
        width: int,
        report: Path,
        mode: Optional[int],
        pos: int,
        pr_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program takecut.

        """

        if report is not None and str(report) != "-":
            report.touch()

    def takecut(
        self,
        data_in: Path,
        width: int,
        report: Path,
        mode: Optional[int],
        pos: int,
        pr_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/takecut
        Extract data values along a line or vertical cut of a float data file


        input parameters:
          data_in  (input) input data file (float)
          width    samples per row of data_in
          report   (output) text file containing extracted values
          mode     data extraction mode (enter - for default)
                     0: extract values along a line (default)
                     1: extract values along a vertical cut
          pos      line or across-track sample number (starting with 0)
          pr_flag  print option (enter - for default)
                     0: print values at all positions (default)
                     1: print only positions with valid data (data != 0.0)


        """

        if self.validate_inputs:
            self._validate_takecut(data_in, width, report, mode, pos, pr_flag)

        if self.mock_outputs:
            self._mock_takecut_outputs(data_in, width, report, mode, pos, pr_flag)

        ca = self._clean_args(locals(), inspect.signature(self.takecut))
        result = self._gamma_call("LAT", "takecut", ca)

        assert report.exists(), f"{report} does not exist"
        assert report.stat().st_size > 0, f"{report} has zero file size"

        return result

    def _validate_polyx_phase(
        self, data: Path, width: int, polygon: Path, report: Path
    ) -> None:
        """

        Validate the arguments to polyx_phase.

        """

        assert data.exists(), f"{data} does not exist"
        assert data.stat().st_size > 0, f"{data} has zero file size"

        assert polygon.exists(), f"{polygon} does not exist"
        assert polygon.stat().st_size > 0, f"{polygon} has zero file size"

        assert not report.exists(), f"{report} should _not_ exist!"

    def _mock_polyx_phase_outputs(
        self, data: Path, width: int, polygon: Path, report: Path
    ) -> None:
        """

        Mock the program polyx_phase.

        """

        if report is not None and str(report) != "-":
            report.touch()

    def polyx_phase(
        self, data: Path, width: int, polygon: Path, report: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/polyx_phase
        Extraction of phase for polygon regions of complex valued image


        input parameters:
          data     (input) input data file (fcomplex)
          width    width in pixels
          polygon  (input) polygon data file
          report   (output) report on region statistics (text format)


        """

        if self.validate_inputs:
            self._validate_polyx_phase(data, width, polygon, report)

        if self.mock_outputs:
            self._mock_polyx_phase_outputs(data, width, polygon, report)

        ca = self._clean_args(locals(), inspect.signature(self.polyx_phase))
        result = self._gamma_call("LAT", "polyx_phase", ca)

        assert report.exists(), f"{report} does not exist"
        assert report.stat().st_size > 0, f"{report} has zero file size"

        return result

    def _validate_temp_lin_var(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[int] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        norm_pow: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to temp_lin_var.

        """

        assert data_tab.exists(), f"{data_tab} does not exist"
        assert data_tab.stat().st_size > 0, f"{data_tab} has zero file size"

        self._check_tab_file(data_tab, "data_tab")

        assert not mean.exists(), f"{mean} should _not_ exist!"

        assert not stdev.exists(), f"{stdev} should _not_ exist!"

    def _mock_temp_lin_var_outputs(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[int] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        norm_pow: Optional[int] = None,
    ) -> None:
        """

        Mock the program temp_lin_var.

        """

        if mean is not None and str(mean) != "-":
            mean.touch()

        if stdev is not None and str(stdev) != "-":
            stdev.touch()

    def temp_lin_var(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[int] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        norm_pow: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/temp_lin_var

        Calculation of temporal mean and variability (defined as stdev/pow(mean, norm_pow) of multiple data sets


        input parameters:
          data_tab   (input) single column list of the names of input data files (FLOAT)
          mean       (output) temporal mean (linear scale) (FLOAT)
          stdev      (output) temporal variability (stdev/pow(mean,norm_pow))(FLOAT)
          width      number of samples/row
          wy         spatial averaging filter height (enter - for default: 1.0)
          wx         spatial averaging filter width (enter - for default: 1.0)
          wt_flag    weighting function (enter - for default)
                       0: uniform (default)
                       1: linear
                       2: Gaussian
          zflag      zero data flag (enter - for default)
                       0: 0.0 interpreted as missing value (default)
                       1: 0.0 interpreted as valid data value
          loff       offset to starting line (enter - for default: 0)
          nlines     number of lines to process (enter - or 0 for default: entire file)
          norm_pow   temporal stdev is normalized with POW(mean,norm_pow) (enter - for default)
                       0.0: normalized with 1.0
                       1.0: normalized with backscatter intensity (default)


        """

        if self.validate_inputs:
            self._validate_temp_lin_var(
                data_tab,
                mean,
                stdev,
                width,
                wy,
                wx,
                wt_flag,
                zflag,
                loff,
                nlines,
                norm_pow,
            )

        if self.mock_outputs:
            self._mock_temp_lin_var_outputs(
                data_tab,
                mean,
                stdev,
                width,
                wy,
                wx,
                wt_flag,
                zflag,
                loff,
                nlines,
                norm_pow,
            )

        ca = self._clean_args(locals(), inspect.signature(self.temp_lin_var))
        result = self._gamma_call("LAT", "temp_lin_var", ca)

        assert mean.exists(), f"{mean} does not exist"
        assert mean.stat().st_size > 0, f"{mean} has zero file size"

        assert stdev.exists(), f"{stdev} does not exist"
        assert stdev.stat().st_size > 0, f"{stdev} has zero file size"

        return result

    def _validate_mask_op(
        self, mask_1: Path, mask_2: Path, mask_out: Path, mode: int
    ) -> None:
        """

        Validate the arguments to mask_op.

        """

        assert mask_1.exists(), f"{mask_1} does not exist"
        assert mask_1.stat().st_size > 0, f"{mask_1} has zero file size"

        assert mask_2.exists(), f"{mask_2} does not exist"
        assert mask_2.stat().st_size > 0, f"{mask_2} has zero file size"

        assert not mask_out.exists(), f"{mask_out} should _not_ exist!"

    def _mock_mask_op_outputs(
        self, mask_1: Path, mask_2: Path, mask_out: Path, mode: int
    ) -> None:
        """

        Mock the program mask_op.

        """

        if mask_out is not None and str(mask_out) != "-":
            mask_out.touch()

    def mask_op(
        self, mask_1: Path, mask_2: Path, mask_out: Path, mode: int
    ) -> Tuple[int, List[str], List[str]]:
        """

        Pixel based logical mask operations on a pixel by pixel basis


        input parameters:
          mask-1    (input) mask 1 raster file SUN raster *.ras, BMP *.bmp, or TIFF *.tif 8-bits/pixel
          mask-2    (input) mask 2 raster file SUN raster *.ras, BMP *.bmp, or TIFF *.tif 8-bits/pixel
          mask_out  (output) output mask SUN raster *.ras, BMP *.bmp, or TIFF *.tif format
          mode      logical operations on a pixel by pixel basis:
                      0: if mask-1 > 0 AND mask-2 > 0 then mask_out = mask-1
                      1: if mask-1 > 0 then mask_out = mask-1, OR if mask-2 > 0 then mask_out = mask-2, otherwise mask_out = 0
                      2: if mask-1 > 0 then mask_out = 0, and if mask-1 == 0 then mask_out = 255


        """

        if self.validate_inputs:
            self._validate_mask_op(mask_1, mask_2, mask_out, mode)

        if self.mock_outputs:
            self._mock_mask_op_outputs(mask_1, mask_2, mask_out, mode)

        ca = self._clean_args(locals(), inspect.signature(self.mask_op))
        result = self._gamma_call("LAT", "mask_op", ca)

        assert mask_out.exists(), f"{mask_out} does not exist"
        assert mask_out.stat().st_size > 0, f"{mask_out} has zero file size"

        return result

    def _validate_quad2cp(
        self,
        SLC_HH: Path,
        SLC_HV: Path,
        SLC_VH: Path,
        SLC_VV: Path,
        SLC_HH_par: Path,
        SLC_HV_par: Path,
        SLC_VH_par: Path,
        SLC_VV_par: Path,
        CP: Path,
        TX_pol: int,
    ) -> None:
        """

        Validate the arguments to quad2cp.

        """

        assert SLC_HH.exists(), f"{SLC_HH} does not exist"
        assert SLC_HH.stat().st_size > 0, f"{SLC_HH} has zero file size"

        assert SLC_HV.exists(), f"{SLC_HV} does not exist"
        assert SLC_HV.stat().st_size > 0, f"{SLC_HV} has zero file size"

        assert SLC_VH.exists(), f"{SLC_VH} does not exist"
        assert SLC_VH.stat().st_size > 0, f"{SLC_VH} has zero file size"

        assert SLC_VV.exists(), f"{SLC_VV} does not exist"
        assert SLC_VV.stat().st_size > 0, f"{SLC_VV} has zero file size"

        assert SLC_HH_par.exists(), f"{SLC_HH_par} does not exist"
        assert SLC_HH_par.stat().st_size > 0, f"{SLC_HH_par} has zero file size"

        assert SLC_HV_par.exists(), f"{SLC_HV_par} does not exist"
        assert SLC_HV_par.stat().st_size > 0, f"{SLC_HV_par} has zero file size"

        assert SLC_VH_par.exists(), f"{SLC_VH_par} does not exist"
        assert SLC_VH_par.stat().st_size > 0, f"{SLC_VH_par} has zero file size"

        assert SLC_VV_par.exists(), f"{SLC_VV_par} does not exist"
        assert SLC_VV_par.stat().st_size > 0, f"{SLC_VV_par} has zero file size"

        assert not CP.exists(), f"{CP} should _not_ exist!"

    def _mock_quad2cp_outputs(
        self,
        SLC_HH: Path,
        SLC_HV: Path,
        SLC_VH: Path,
        SLC_VV: Path,
        SLC_HH_par: Path,
        SLC_HV_par: Path,
        SLC_VH_par: Path,
        SLC_VV_par: Path,
        CP: Path,
        TX_pol: int,
    ) -> None:
        """

        Mock the program quad2cp.

        """

        if CP is not None and str(CP) != "-":
            CP.touch()

    def quad2cp(
        self,
        SLC_HH: Path,
        SLC_HV: Path,
        SLC_VH: Path,
        SLC_VV: Path,
        SLC_HH_par: Path,
        SLC_HV_par: Path,
        SLC_VH_par: Path,
        SLC_VV_par: Path,
        CP: Path,
        TX_pol: int,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Synthesize Compact Polarization Data from quad-pol HH, VV, HV, VH SLC data
        Transmit polarization: RCP or LCP, receive polarization: H and V linear


        input parameters:
          SLC_HH      (input) HH single-look complex image (scomplex or fcomplex format)
          SLC_HV      (input) HV single-look complex image (coregistered with SLC_HH)(scomplex or fcomplex format)
          SLC_VH      (input) VH single-look complex image (coregistered with SLC_HH)(scomplex or fcomplex format)
          SLC_VV      (input) VV single-look complex image (coregistered with SLC_HH)(scomplex or fcomplex format)
          SLC_HH_par  (input) SLC_HH image parameter file
          SLC_HV_par  (input) SLC_HV image parameter file
          SLC_VH_par  (input) SLC_VH image parameter file
          SLC_VV_par  (input) SLC_VV image parameter file
          CP          (output) root file name of the 2 linearly polarized images (H,V): (fcomplex format)
                      RCP transmit: *_RH: 1/(sqrt(2) (S_HH - iS_HV)
                                    *_RV: 1/(sqrt(2) (S_VH - iS_VV)
                      LCP transmit: *_LH: 1/(sqrt(2) (S_HH + iS_HV)
                                    *_LV: 1/(sqrt(2) (S_VH + iS_VV)
          Note: SLC parameter files are created from the CP SLC name + .par
          TX_pol      transmit polarization of synthesized compact mode data:
                        0: RCP Right Circular Polarziation
                        1: LCP Left  Circular Polarziation


        """

        if self.validate_inputs:
            self._validate_quad2cp(
                SLC_HH,
                SLC_HV,
                SLC_VH,
                SLC_VV,
                SLC_HH_par,
                SLC_HV_par,
                SLC_VH_par,
                SLC_VV_par,
                CP,
                TX_pol,
            )

        if self.mock_outputs:
            self._mock_quad2cp_outputs(
                SLC_HH,
                SLC_HV,
                SLC_VH,
                SLC_VV,
                SLC_HH_par,
                SLC_HV_par,
                SLC_VH_par,
                SLC_VV_par,
                CP,
                TX_pol,
            )

        ca = self._clean_args(locals(), inspect.signature(self.quad2cp))
        result = self._gamma_call("LAT", "quad2cp", ca)

        assert CP.exists(), f"{CP} does not exist"
        assert CP.stat().st_size > 0, f"{CP} has zero file size"

        return result

    def _validate_poly_math(
        self,
    ) -> None:
        """

        Validate the arguments to poly_math.

        """

        pass

    def _mock_poly_math_outputs(
        self,
    ) -> None:
        """

        Mock the program poly_math.

        """
        pass

    def poly_math(
        self,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/poly_math
        Mathematical operations on polygonal regions (float data)


          input parameters:
          data_in       (input) input data file (float)
          data_out      (output) output data file (float)
          width         number of samples/line
          polygon       text file containing polygon vertices
          offset_scale  text file containing offset and scale factors for data in each polygon
                        enter - to read offset and scale from the command line
          mode          data masking mode:
                          0: copy all data
                          1: copy data only within polygons, set the background to 0.0
          offset        constant offset applied for all data within polygons, (default: 0.0)
          scale         scale factor for all output polygon (default: 1.0)


        """

        if self.validate_inputs:
            self._validate_poly_math()

        if self.mock_outputs:
            self._mock_poly_math_outputs()

        ca = self._clean_args(locals(), inspect.signature(self.poly_math))
        result = self._gamma_call("LAT", "poly_math", ca)
        return result

    def _validate_single_class_mapping(
        self,
        nfiles: int,
        f1: Path,
        lt1: int,
        fn: Path,
        ltn: int,
        utn: int,
        ras_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to single_class_mapping.

        """

        assert f1.exists(), f"{f1} does not exist"
        assert f1.stat().st_size > 0, f"{f1} has zero file size"

        assert fn.exists(), f"{fn} does not exist"
        assert fn.stat().st_size > 0, f"{fn} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

    def _mock_single_class_mapping_outputs(
        self,
        nfiles: int,
        f1: Path,
        lt1: int,
        fn: Path,
        ltn: int,
        utn: int,
        ras_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[int] = None,
    ) -> None:
        """

        Mock the program single_class_mapping.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def single_class_mapping(
        self,
        nfiles: int,
        f1: Path,
        lt1: int,
        fn: Path,
        ltn: int,
        utn: int,
        ras_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program single_class_mapping.c
        Classification based on multiple input files with thresholds defined on the command line


        input parameters:
          nfiles    number of input data files
          f1        (input) 1. input data file (float)
          lt1       lower threshold for file 1
          ut1       upper threshold for file 1
          ...       (input) further input files
          fn        (input) last input data file (float)
          ltn       lower threshold for last file
          utn       upper threshold for last file
          ras_out   (output) 8-bit raster image file (SUN raster: *.ras,  BMP: *.bmp, TIFF: *.tif)
          width     number of samples/row
          start     starting line (enter - for default: 1)
          nlines    number of lines to display (enter - for default: 0=entire file)
          pixav_x   number of pixels to average in width (enter - for default: 1)
          pixav_y   number of pixels to average in height (enter - for default: 1)
          LR        left/right mirror image flag (enter - for default: 1: normal (default), -1: mirror image)


        """

        if self.validate_inputs:
            self._validate_single_class_mapping(
                nfiles,
                f1,
                lt1,
                fn,
                ltn,
                utn,
                ras_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                LR,
            )

        if self.mock_outputs:
            self._mock_single_class_mapping_outputs(
                nfiles,
                f1,
                lt1,
                fn,
                ltn,
                utn,
                ras_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                LR,
            )

        ca = self._clean_args(locals(), inspect.signature(self.single_class_mapping))
        result = self._gamma_call("LAT", "single_class_mapping", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_drawthat(
        self,
        ras_in: Path,
        ras_out: Path,
        pt_list: Path,
        mode: Optional[int] = None,
        r: Optional[int] = None,
        g: Optional[int] = None,
        b: Optional[int] = None,
        xs: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to drawthat.

        """

        assert ras_in.exists(), f"{ras_in} does not exist"
        assert ras_in.stat().st_size > 0, f"{ras_in} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

        assert pt_list.exists(), f"{pt_list} does not exist"
        assert pt_list.stat().st_size > 0, f"{pt_list} has zero file size"

    def _mock_drawthat_outputs(
        self,
        ras_in: Path,
        ras_out: Path,
        pt_list: Path,
        mode: Optional[int] = None,
        r: Optional[int] = None,
        g: Optional[int] = None,
        b: Optional[int] = None,
        xs: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program drawthat.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def drawthat(
        self,
        ras_in: Path,
        ras_out: Path,
        pt_list: Path,
        mode: Optional[int] = None,
        r: Optional[int] = None,
        g: Optional[int] = None,
        b: Optional[int] = None,
        xs: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT drawthat: Draw an arc, polygon, cross, or point on a SUN/BMP/TIFF raster image


        input parameters:
          ras_in   (input) raster image (SUN, BMP, or TIFF format)
          ras_out  (output) raster image with features drawn at points (SUN, BMP, or TIFF format)
          pt_list  (input) point list (text)
          mode     drawing mode (enter - for default)
                     0: draw an arc connecting points (default)
                     1: draw a filled polygon specified by the points
                     2: draw cross
          r        line color value red   (0 --> 255) (enter - for default: 255)
          g        line color value green (0 --> 255) (enter - for default: 255)
          b        line color value blue  (0 --> 255) (enter - for default: 0)
          xs       size of cross in pixels, set to 1 for single points (enter - for default: 1)
          zflg     zero image flag (enter - for default)
                     0: retain image values (default)
                     1: set all image values to 0 except points


        """

        if self.validate_inputs:
            self._validate_drawthat(ras_in, ras_out, pt_list, mode, r, g, b, xs, zflg)

        if self.mock_outputs:
            self._mock_drawthat_outputs(ras_in, ras_out, pt_list, mode, r, g, b, xs, zflg)

        ca = self._clean_args(locals(), inspect.signature(self.drawthat))
        result = self._gamma_call("LAT", "drawthat", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_m_delta(
        self, s0: Path, m: Path, delta: Path, S_par: Path, c1: Path, c3: Path
    ) -> None:
        """

        Validate the arguments to m_delta.

        """

        assert s0.exists(), f"{s0} does not exist"
        assert s0.stat().st_size > 0, f"{s0} has zero file size"

        assert m.exists(), f"{m} does not exist"
        assert m.stat().st_size > 0, f"{m} has zero file size"

        assert delta.exists(), f"{delta} does not exist"
        assert delta.stat().st_size > 0, f"{delta} has zero file size"

        assert S_par.exists(), f"{S_par} does not exist"
        assert S_par.stat().st_size > 0, f"{S_par} has zero file size"

        assert not c1.exists(), f"{c1} should _not_ exist!"

        assert not c3.exists(), f"{c3} should _not_ exist!"

    def _mock_m_delta_outputs(
        self, s0: Path, m: Path, delta: Path, S_par: Path, c1: Path, c3: Path
    ) -> None:
        """

        Mock the program m_delta.

        """

        if c1 is not None and str(c1) != "-":
            c1.touch()

        if c3 is not None and str(c3) != "-":
            c3.touch()

    def m_delta(
        self, s0: Path, m: Path, delta: Path, S_par: Path, c1: Path, c3: Path
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate m-delta decomposition from Stokes parameters


        input parameters:
          s0     (input) Stokes parameter for the total power in the H and V polarizations <|E_h|**2 + |E_v|**2>
          m      (input) degree of polarization: sqrt(s1**2 + s2**2 + s3**2)/s0 (float)
          delta  (input) relative H-V phase: atan(s3/s2):
          S_par  (input) MLI image parameter file associated with the Stokes parameter data files
          c1     (output) s0 * m * (1 + sin(delta))/2 (float)
          c2     (output) s0 * (1.0-m) depolarized component (float)
          c3     (output) s0 * m * (1 - sin(delta))/2 (float)

        """

        if self.validate_inputs:
            self._validate_m_delta(s0, m, delta, S_par, c1, c3)

        if self.mock_outputs:
            self._mock_m_delta_outputs(s0, m, delta, S_par, c1, c3)

        ca = self._clean_args(locals(), inspect.signature(self.m_delta))
        result = self._gamma_call("LAT", "m-delta", ca)

        assert c1.exists(), f"{c1} does not exist"
        assert c1.stat().st_size > 0, f"{c1} has zero file size"

        assert c3.exists(), f"{c3} does not exist"
        assert c3.stat().st_size > 0, f"{c3} has zero file size"

        return result

    def _validate_temp_filt_ad(
        self,
        data_tab: Path,
        width: int,
        zflag: Optional[int] = None,
        loffset: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to temp_filt_ad.

        """

        assert data_tab.exists(), f"{data_tab} does not exist"
        assert data_tab.stat().st_size > 0, f"{data_tab} has zero file size"

        self._check_tab_file(data_tab, "data_tab")

    def _mock_temp_filt_ad_outputs(
        self,
        data_tab: Path,
        width: int,
        zflag: Optional[int] = None,
        loffset: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program temp_filt_ad.

        """
        pass

    def temp_filt_ad(
        self,
        data_tab: Path,
        width: int,
        zflag: Optional[int] = None,
        loffset: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/temp_filt_ad
        Multi-temporal filtering of registered data sets using adaptive spatial mean estimate


        input parameters:
          data_tab   (input) three column list of the names of input and output data files (FLOAT)
                       input file 1  spatially filtered file 1  output file 1
                       input file 2  spatially filtered file 2  output file 2
                        ...              ...                   ...
          width      number of samples/row
          zflag      zero data flag (enter - for default)
                       0: 0.0 interpreted as missing value (default)
                       1: 0.0 interpreted as valid data value
          loffset    number of lines offset to starting line (enter - for default: 0)
          nlines     number of lines to process (enter - or 0 for default: entire file)


        """

        if self.validate_inputs:
            self._validate_temp_filt_ad(data_tab, width, zflag, loffset, nlines)

        if self.mock_outputs:
            self._mock_temp_filt_ad_outputs(data_tab, width, zflag, loffset, nlines)

        ca = self._clean_args(locals(), inspect.signature(self.temp_filt_ad))
        result = self._gamma_call("LAT", "temp_filt_ad", ca)
        return result

    def _validate_bm3d(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        profile: Optional[int] = None,
        looks: Optional[int] = None,
        sigma: Optional[int] = None,
        block_size: Optional[int] = None,
        s_dist: Optional[int] = None,
        step: Optional[int] = None,
        d_max: Optional[int] = None,
        t1d: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to bm3d.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_bm3d_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        profile: Optional[int] = None,
        looks: Optional[int] = None,
        sigma: Optional[int] = None,
        block_size: Optional[int] = None,
        s_dist: Optional[int] = None,
        step: Optional[int] = None,
        d_max: Optional[int] = None,
        t1d: Optional[int] = None,
    ) -> None:
        """

        Mock the program bm3d.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def bm3d(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        profile: Optional[int] = None,
        looks: Optional[int] = None,
        sigma: Optional[int] = None,
        block_size: Optional[int] = None,
        s_dist: Optional[int] = None,
        step: Optional[int] = None,
        d_max: Optional[int] = None,
        t1d: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Denoising using Block-Matching and 3D filtering (BM3D)


        input parameters:
          data_in     (input) input data file
          width       width of input data
          data_out    (output) output data file (same type as input)
          dtype       input and output data type (enter - for default)
                        0: FLOAT (default)
                        1: FCOMPLEX (profiles 2 and 6 only)
                        2: SUN/BMP/TIFF 8 or 24-bit raster image
          profile     profile types (enter - for default)
                        0: SAR-BM3D (fast), filtering on data (default)
                        1: SAR-BM3D (fine), filtering on data
                        2: BM3D, direct filtering on data (default for FCOMPLEX)
                        3: BM3D, filtering on sqrt(data)
                        4: BM3D, filtering on log(data)
                        5: C-BM3D, filtering color images (SUN/BMP/TIFF raster images only)
                        6: InSAR-BM3D, filtering on wrapped interferogram (FCOMPLEX only)
          looks       equivalent number of looks (necessary for SAR-BM3D and InSAR-BM3D, enter - for default: 10)
          sigma       estimated noise parameter (enter - or 0 for default: automatic estimation)
                      NOTE: for InSAR-BM3D, sigma is a factor multiplying the estimated standard deviation
          block_size  block size (enter - for default: 8)
          s_dist      maximum search distance (enter - for default: 16)
          step        step between reference blocks (enter - for default: 3)
          d_max       maximum pixel value distance in block matching (not available for SAR-BM3D and INSAR-BM3D, enter - for default)
                        0: estimated from data (default)
                        1: infinite
          t1d         type of transform in the third dimension (enter - for default)
                        0: Haar (default)
                        1: DCT


        """

        if self.validate_inputs:
            self._validate_bm3d(
                data_in,
                width,
                data_out,
                dtype,
                profile,
                looks,
                sigma,
                block_size,
                s_dist,
                step,
                d_max,
                t1d,
            )

        if self.mock_outputs:
            self._mock_bm3d_outputs(
                data_in,
                width,
                data_out,
                dtype,
                profile,
                looks,
                sigma,
                block_size,
                s_dist,
                step,
                d_max,
                t1d,
            )

        ca = self._clean_args(locals(), inspect.signature(self.bm3d))
        result = self._gamma_call("LAT", "bm3d", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_restore_float(self, width: int) -> None:
        """

        Validate the arguments to restore_float.

        """

        pass

    def _mock_restore_float_outputs(self, width: int) -> None:
        """

        Mock the program restore_float.

        """
        pass

    def restore_float(self, width: int) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/restore_float.c

        Interpolator to fill NULL values by interpolation


        input parameters:
          input file    (input) data containing 0.0 values (float)
          output file   (output) data with 0.0 values replaced (float)
          width         line width (samples)
          interp_limit  max. gap that is interpolated (default:10 samples)


        """

        if self.validate_inputs:
            self._validate_restore_float(width)

        if self.mock_outputs:
            self._mock_restore_float_outputs(width)

        ca = self._clean_args(locals(), inspect.signature(self.restore_float))
        result = self._gamma_call("LAT", "restore_float", ca)
        return result

    def _validate_haalpha(
        self,
        alpha: Optional[Path],
        beta: Path,
        gamma: Path,
        SLC_par: Path,
        anisotropy: Optional[Path],
        entropy: Optional[Path],
        lambda1: Optional[Path],
        lambda2: Optional[Path],
        lambda3: Optional[Path],
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to haalpha.

        """

        if alpha is not None:
            assert not alpha.exists(), f"{alpha} should _not_ exist!"

        assert beta.exists(), f"{beta} does not exist"
        assert beta.stat().st_size > 0, f"{beta} has zero file size"

        assert gamma.exists(), f"{gamma} does not exist"
        assert gamma.stat().st_size > 0, f"{gamma} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        if anisotropy is not None:
            assert not anisotropy.exists(), f"{anisotropy} should _not_ exist!"

        if entropy is not None:
            assert not entropy.exists(), f"{entropy} should _not_ exist!"

        if lambda1 is not None:
            assert not lambda1.exists(), f"{lambda1} should _not_ exist!"

        if lambda2 is not None:
            assert not lambda2.exists(), f"{lambda2} should _not_ exist!"

        if lambda3 is not None:
            assert not lambda3.exists(), f"{lambda3} should _not_ exist!"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

    def _mock_haalpha_outputs(
        self,
        alpha: Optional[Path],
        beta: Path,
        gamma: Path,
        SLC_par: Path,
        anisotropy: Optional[Path],
        entropy: Optional[Path],
        lambda1: Optional[Path],
        lambda2: Optional[Path],
        lambda3: Optional[Path],
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program haalpha.

        """

        if alpha is not None and str(alpha) != "-":
            alpha.touch()

        if anisotropy is not None and str(anisotropy) != "-":
            anisotropy.touch()

        if entropy is not None and str(entropy) != "-":
            entropy.touch()

        if lambda1 is not None and str(lambda1) != "-":
            lambda1.touch()

        if lambda2 is not None and str(lambda2) != "-":
            lambda2.touch()

        if lambda3 is not None and str(lambda3) != "-":
            lambda3.touch()

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def haalpha(
        self,
        alpha: Optional[Path],
        beta: Path,
        gamma: Path,
        SLC_par: Path,
        anisotropy: Optional[Path],
        entropy: Optional[Path],
        lambda1: Optional[Path],
        lambda2: Optional[Path],
        lambda3: Optional[Path],
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/haalpha
        Calculate H/A/alpha (Entropy, Anisotropy, and alpha) decomposition from the 3D Pauli feature vector


        input parameters:
          alpha       (input) Pauli decomposition alpha component: (S_HH + S_VV)/sqrt(2) (fcomplex format)
          beta        (input) Pauli decomposition beta component:  (S_HH - S_VV)/sqrt(2) (fcomplex format)
          gamma       (input) Pauli decomposition gamma component: sqrt(2) * S_HV        (fcomplex format)
          SLC_par     (input) Pauli data SLC image parameter file
          anisotropy  (output) multi-look anisotropy component (enter - for none)
          alpha       (output) multi-look alpha component (enter - for none)
          entropy     (output) multi-look entropy component (enter - for none)
          lambda1     (output) multi-look lambda1 eigenvalue (enter - for none)
          lambda2     (output) multi-look lambda2 eigenvalue (enter - for none)
          lambda3     (output) multi-look lambda3 eigenvalue (enter - for none)
          MLI_par     (output) MLI ISP image parameter file
          rlks        number of range looks (default: 1)
          azlks       number of azimuth looks (default: 1)
          loff        offset to starting line (default: 0)
          nlines      number of SLC lines to process (default: entire file)

        """

        if self.validate_inputs:
            self._validate_haalpha(
                alpha,
                beta,
                gamma,
                SLC_par,
                anisotropy,
                entropy,
                lambda1,
                lambda2,
                lambda3,
                MLI_par,
                rlks,
                azlks,
                loff,
                nlines,
            )

        if self.mock_outputs:
            self._mock_haalpha_outputs(
                alpha,
                beta,
                gamma,
                SLC_par,
                anisotropy,
                entropy,
                lambda1,
                lambda2,
                lambda3,
                MLI_par,
                rlks,
                azlks,
                loff,
                nlines,
            )

        ca = self._clean_args(locals(), inspect.signature(self.haalpha))
        result = self._gamma_call("LAT", "haalpha", ca)

        if alpha is not None:
            assert alpha.exists(), f"{alpha} does not exist"
            assert alpha.stat().st_size > 0, f"{alpha} has zero file size"

        if anisotropy is not None:
            assert anisotropy.exists(), f"{anisotropy} does not exist"
            assert anisotropy.stat().st_size > 0, f"{anisotropy} has zero file size"

        if entropy is not None:
            assert entropy.exists(), f"{entropy} does not exist"
            assert entropy.stat().st_size > 0, f"{entropy} has zero file size"

        if lambda1 is not None:
            assert lambda1.exists(), f"{lambda1} does not exist"
            assert lambda1.stat().st_size > 0, f"{lambda1} has zero file size"

        if lambda2 is not None:
            assert lambda2.exists(), f"{lambda2} does not exist"
            assert lambda2.stat().st_size > 0, f"{lambda2} has zero file size"

        if lambda3 is not None:
            assert lambda3.exists(), f"{lambda3} does not exist"
            assert lambda3.stat().st_size > 0, f"{lambda3} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        return result

    def _validate_wolf(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        J: Path,
        J_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to wolf.

        """

        assert SLC_1.exists(), f"{SLC_1} does not exist"
        assert SLC_1.stat().st_size > 0, f"{SLC_1} has zero file size"

        assert SLC_2.exists(), f"{SLC_2} does not exist"
        assert SLC_2.stat().st_size > 0, f"{SLC_2} has zero file size"

        assert SLC1_par.exists(), f"{SLC1_par} does not exist"
        assert SLC1_par.stat().st_size > 0, f"{SLC1_par} has zero file size"

        assert SLC2_par.exists(), f"{SLC2_par} does not exist"
        assert SLC2_par.stat().st_size > 0, f"{SLC2_par} has zero file size"

        assert not J.exists(), f"{J} should _not_ exist!"

        assert not J_par.exists(), f"{J_par} should _not_ exist!"

    def _mock_wolf_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        J: Path,
        J_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program wolf.

        """

        if J is not None and str(J) != "-":
            J.touch()

        if J_par is not None and str(J_par) != "-":
            J_par.touch()

    def wolf(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        J: Path,
        J_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Calculate Wolf coherence matrix from H and V polarized SLC images


        input parameters:
          SLC-1     (input) H polarized (HH or VH) single-look complex image (scomplex or fcomplex format)
          SLC-2     (input) V polarized (VV or HV) single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC1_par  (input) SLC image parameter file of SLC-1
          SLC2_par  (input) SLC image parameter file of SLC-2 coregistered with SLC-1
          J         (output) root file name of Wolf coherence matrix elements (e.g. scene_id): .j11, .j22, (float), .j12 (fcomplex)
          J_par     (output) MLI image parameter file associated with the Wolf coherence matrix element data files
          rlks      number of range looks used to calculate coherence
          azlks     number of azimuth looks used to calculate coherence
          loff      offset to starting line (default: 0)
          nlines    number of SLC lines to process (enter - for default: entire file)


        """

        if self.validate_inputs:
            self._validate_wolf(
                SLC_1, SLC_2, SLC1_par, SLC2_par, J, J_par, rlks, azlks, loff, nlines
            )

        if self.mock_outputs:
            self._mock_wolf_outputs(
                SLC_1, SLC_2, SLC1_par, SLC2_par, J, J_par, rlks, azlks, loff, nlines
            )

        ca = self._clean_args(locals(), inspect.signature(self.wolf))
        result = self._gamma_call("LAT", "wolf", ca)

        assert J.exists(), f"{J} does not exist"
        assert J.stat().st_size > 0, f"{J} has zero file size"

        assert J_par.exists(), f"{J_par} does not exist"
        assert J_par.stat().st_size > 0, f"{J_par} has zero file size"

        return result

    def _validate_poly_mask(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        polygon: int,
        mode: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to poly_mask.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

    def _mock_poly_mask_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        polygon: int,
        mode: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        """

        Mock the program poly_mask.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def poly_mask(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        polygon: int,
        mode: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/poly_mask
        Mask data using polygonal image regions


        input parameters:
          data_in       (input) input data file
          data_out      (output) output data file
          width         number of samples/line
          polygon       text file containing polygon vertices
          mode          data masking mode (enter - for default)
                          0: copy data within polygons, set areas outside polygons to 0 (default)
                          1: copy data outside polygons, set areas within polygons to 0
          dtype         input and output data type (enter - for default)
                          0: FLOAT (default)
                          1: FCOMPLEX
                          2: Sun/BMP/TIFF 8 or 24-bit raster image
                          3: UNSIGNED CHAR
                          4: SHORT
                          5: SCOMPLEX
                          6: DOUBLE
                          7: INTEGER


        """

        if self.validate_inputs:
            self._validate_poly_mask(data_in, data_out, width, polygon, mode, dtype)

        if self.mock_outputs:
            self._mock_poly_mask_outputs(data_in, data_out, width, polygon, mode, dtype)

        ca = self._clean_args(locals(), inspect.signature(self.poly_mask))
        result = self._gamma_call("LAT", "poly_mask", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        return result

    def _validate_lee(
        self,
        input_data: Path,
        output_data: Path,
        width: int,
        nlooks: int,
        bx: int,
        by: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to lee.

        """

        assert input_data.exists(), f"{input_data} does not exist"
        assert input_data.stat().st_size > 0, f"{input_data} has zero file size"

        assert not output_data.exists(), f"{output_data} should _not_ exist!"

    def _mock_lee_outputs(
        self,
        input_data: Path,
        output_data: Path,
        width: int,
        nlooks: int,
        bx: int,
        by: Optional[int] = None,
    ) -> None:
        """

        Mock the program lee.

        """

        if output_data is not None and str(output_data) != "-":
            output_data.touch()

    def lee(
        self,
        input_data: Path,
        output_data: Path,
        width: int,
        nlooks: int,
        bx: int,
        by: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program lee.c
        Lee Filter (Lee, 1980)


        input parameters:
          input_data   (input) input intensity file
          output_data  (output) output intensity file (filtered)
          width        number of samples/row
          nlooks       number of looks
          bx           filter size in x direction (number of cols)
          by           filter size in y direction (number of rows) (enter - for default: by = bx)


        """

        if self.validate_inputs:
            self._validate_lee(input_data, output_data, width, nlooks, bx, by)

        if self.mock_outputs:
            self._mock_lee_outputs(input_data, output_data, width, nlooks, bx, by)

        ca = self._clean_args(locals(), inspect.signature(self.lee))
        result = self._gamma_call("LAT", "lee", ca)

        assert output_data.exists(), f"{output_data} does not exist"
        assert output_data.stat().st_size > 0, f"{output_data} has zero file size"

        return result

    def _validate_enh_lee(
        self,
        input_data: Path,
        output_data: Path,
        width: int,
        nlooks: int,
        damp: int,
        bx: int,
        by: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to enh_lee.

        """

        assert input_data.exists(), f"{input_data} does not exist"
        assert input_data.stat().st_size > 0, f"{input_data} has zero file size"

        assert not output_data.exists(), f"{output_data} should _not_ exist!"

    def _mock_enh_lee_outputs(
        self,
        input_data: Path,
        output_data: Path,
        width: int,
        nlooks: int,
        damp: int,
        bx: int,
        by: Optional[int] = None,
    ) -> None:
        """

        Mock the program enh_lee.

        """

        if output_data is not None and str(output_data) != "-":
            output_data.touch()

    def enh_lee(
        self,
        input_data: Path,
        output_data: Path,
        width: int,
        nlooks: int,
        damp: int,
        bx: int,
        by: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT enh_lee: Enhanced Lee Filter (Lopes et al., 1990)


        input parameters:
          input_data   (input) input intensity file
          output_data  (output) output intensity file (filtered)
          width        number of samples/row
          nlooks       number of looks
          damp         damping constant of filter
          bx           filter size in x direction (number of cols)
          by           filter size in y direction (number of rows) (enter - for default: by = bx)


        """

        if self.validate_inputs:
            self._validate_enh_lee(input_data, output_data, width, nlooks, damp, bx, by)

        if self.mock_outputs:
            self._mock_enh_lee_outputs(
                input_data, output_data, width, nlooks, damp, bx, by
            )

        ca = self._clean_args(locals(), inspect.signature(self.enh_lee))
        result = self._gamma_call("LAT", "enh_lee", ca)

        assert output_data.exists(), f"{output_data} does not exist"
        assert output_data.stat().st_size > 0, f"{output_data} has zero file size"

        return result

    def _validate_ratio(
        self,
        d1: Path,
        d2: Path,
        ratio: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ratio.

        """

        assert d1.exists(), f"{d1} does not exist"
        assert d1.stat().st_size > 0, f"{d1} has zero file size"

        assert d2.exists(), f"{d2} does not exist"
        assert d2.stat().st_size > 0, f"{d2} has zero file size"

        assert not ratio.exists(), f"{ratio} should _not_ exist!"

    def _mock_ratio_outputs(
        self,
        d1: Path,
        d2: Path,
        ratio: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
    ) -> None:
        """

        Mock the program ratio.

        """

        if ratio is not None and str(ratio) != "-":
            ratio.touch()

    def ratio(
        self,
        d1: Path,
        d2: Path,
        ratio: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT ratio: Estimate ratio of image data values: d1/d2 (float data)


        input parameters:
          d1       (input) data file 1 (float)
          d2       (input) data file 2 (float)
          ratio    (output) ratio: d1/d2  (float)
          width    number of samples/row of the input image
          bx       number of range samples to average before evaluating ratio (odd number, enter - for default: 5)
          by       number of azimuth lines to average before evaluating ratio (odd number, enter - for default: bx)
          wgt_flg  weighting flag (enter - for default)
                     0: no weighting function applied (default)
                     1: linear weighting function
                     2: Gaussian weighting function


        """

        if self.validate_inputs:
            self._validate_ratio(d1, d2, ratio, width, bx, by)

        if self.mock_outputs:
            self._mock_ratio_outputs(d1, d2, ratio, width, bx, by)

        ca = self._clean_args(locals(), inspect.signature(self.ratio))
        result = self._gamma_call("LAT", "ratio", ca)

        assert ratio.exists(), f"{ratio} does not exist"
        assert ratio.stat().st_size > 0, f"{ratio} has zero file size"

        return result

    def _validate_cc_ad(
        self,
        interf: Path,
        pwr1: Optional[Path],
        pwr2: Optional[Path],
        slope: Optional[Path],
        texture: Optional[Path],
        cc_ad: Path,
        width: int,
        box_min: Optional[int] = None,
        box_max: Optional[int] = None,
        wgt_flag: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to cc_ad.

        """

        assert interf.exists(), f"{interf} does not exist"
        assert interf.stat().st_size > 0, f"{interf} has zero file size"

        if pwr1 is not None:
            assert pwr1.exists(), f"{pwr1} does not exist"
            assert pwr1.stat().st_size > 0, f"{pwr1} has zero file size"

        if pwr2 is not None:
            assert pwr2.exists(), f"{pwr2} does not exist"
            assert pwr2.stat().st_size > 0, f"{pwr2} has zero file size"

        if slope is not None:
            assert slope.exists(), f"{slope} does not exist"
            assert slope.stat().st_size > 0, f"{slope} has zero file size"

        if texture is not None:
            assert texture.exists(), f"{texture} does not exist"
            assert texture.stat().st_size > 0, f"{texture} has zero file size"

        assert not cc_ad.exists(), f"{cc_ad} should _not_ exist!"

    def _mock_cc_ad_outputs(
        self,
        interf: Path,
        pwr1: Optional[Path],
        pwr2: Optional[Path],
        slope: Optional[Path],
        texture: Optional[Path],
        cc_ad: Path,
        width: int,
        box_min: Optional[int] = None,
        box_max: Optional[int] = None,
        wgt_flag: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        """

        Mock the program cc_ad.

        """

        if cc_ad is not None and str(cc_ad) != "-":
            cc_ad.touch()

    def cc_ad(
        self,
        interf: Path,
        pwr1: Optional[Path],
        pwr2: Optional[Path],
        slope: Optional[Path],
        texture: Optional[Path],
        cc_ad: Path,
        width: int,
        box_min: Optional[int] = None,
        box_max: Optional[int] = None,
        wgt_flag: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT cc_ad: Adaptive coherence estimation with consideration of phase slope and texture


        input parameters:
          interf    (input) complex interferogram
          pwr1      (input) intensity image of first scene (enter - for none)
          pwr2      (input) intensity image of second scene (enter - for none)
          slope     (input) phase slope data (enter - for none)
          texture   (input) backscatter texture data (enter - for none)
          cc_ad     (output) adaptive coherence estimate
          width     number of samples/row
          box_min   smallest correlation average box size (enter - for default: 3.0)
          box_max   largest correlation average box size  (enter - for default: 9.0)
          wgt_flag  weighting function (enter - for default)
                      0: constant (default)
                      1: gaussian
          loff      offset in lines to starting line (enter - for default: 0)
          nl        number of lines to process (enter - for default: 0, to end of file)


        """

        if self.validate_inputs:
            self._validate_cc_ad(
                interf,
                pwr1,
                pwr2,
                slope,
                texture,
                cc_ad,
                width,
                box_min,
                box_max,
                wgt_flag,
                loff,
                nl,
            )

        if self.mock_outputs:
            self._mock_cc_ad_outputs(
                interf,
                pwr1,
                pwr2,
                slope,
                texture,
                cc_ad,
                width,
                box_min,
                box_max,
                wgt_flag,
                loff,
                nl,
            )

        ca = self._clean_args(locals(), inspect.signature(self.cc_ad))
        result = self._gamma_call("LAT", "cc_ad", ca)

        assert cc_ad.exists(), f"{cc_ad} does not exist"
        assert cc_ad.stat().st_size > 0, f"{cc_ad} has zero file size"

        return result

    def _validate_lin_comb_cpx(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant_r: int,
        constant_i: int,
        factor1_r: int,
        factor1_i: int,
        factor2_r: int,
        factor2_i: int,
        f_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to lin_comb_cpx.

        """

        assert f1.exists(), f"{f1} does not exist"
        assert f1.stat().st_size > 0, f"{f1} has zero file size"

        assert f2.exists(), f"{f2} does not exist"
        assert f2.stat().st_size > 0, f"{f2} has zero file size"

        assert not f_out.exists(), f"{f_out} should _not_ exist!"

    def _mock_lin_comb_cpx_outputs(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant_r: int,
        constant_i: int,
        factor1_r: int,
        factor1_i: int,
        factor2_r: int,
        factor2_i: int,
        f_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> None:
        """

        Mock the program lin_comb_cpx.

        """

        if f_out is not None and str(f_out) != "-":
            f_out.touch()

    def lin_comb_cpx(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant_r: int,
        constant_i: int,
        factor1_r: int,
        factor1_i: int,
        factor2_r: int,
        factor2_i: int,
        f_out: Path,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/lin_comb_cpx.c
        Calculate linear combination of fcomplex data files


        input parameters:
          nfiles      number of input data files
          f1          (input) 1. input data file (fcomplex)
          f2          (input) 2. input data file (fcomplex)
          ...         (input) further input files
          constant_r  constant value (real part) to add to output
          constant_i  constant value (imaginary part) to add to output
          factor1_r   factor1 (real part) to multiply with f1
          factor1_i   factor1 (imaginary part) to multiply with f1
          factor2_r   factor2 (real part) to multiply with f2
          factor2_i   factor2 (imaginary part) to multiply with f2
          ...         factors for further input files
          f_out       (output) output file (fcomplex)
          width       number of samples/row
          start       starting line (default=1)
          nlines      number of lines to display (default: 0=entire file)
          pixav_x     number of pixels to average in width (default=1)
          pixav_y     number of pixels to average in height (default=1)
          zero_flag   interpretation of 0.0 values:
                        0: interpreted as missing value (default)
                        1: 0.0 is valid data value


        """

        if self.validate_inputs:
            self._validate_lin_comb_cpx(
                nfiles,
                f1,
                f2,
                constant_r,
                constant_i,
                factor1_r,
                factor1_i,
                factor2_r,
                factor2_i,
                f_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                zero_flag,
            )

        if self.mock_outputs:
            self._mock_lin_comb_cpx_outputs(
                nfiles,
                f1,
                f2,
                constant_r,
                constant_i,
                factor1_r,
                factor1_i,
                factor2_r,
                factor2_i,
                f_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                zero_flag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.lin_comb_cpx))
        result = self._gamma_call("LAT", "lin_comb_cpx", ca)

        assert f_out.exists(), f"{f_out} does not exist"
        assert f_out.stat().st_size > 0, f"{f_out} has zero file size"

        return result

    def _validate_median_filter(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[int] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to median_filter.

        """

        assert din.exists(), f"{din} does not exist"
        assert din.stat().st_size > 0, f"{din} has zero file size"

        assert not dout.exists(), f"{dout} should _not_ exist!"

    def _mock_median_filter_outputs(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[int] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program median_filter.

        """

        if dout is not None and str(dout) != "-":
            dout.touch()

    def median_filter(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[int] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program median_filter.c
        Median filter (float data)


        input parameters:
          din     (input) input data file
          dout    (output) output data file (filtered)
          width   number of samples/row
          bx      filter window width (columns): 1,3,5,7...
          by      filter window height (rows): 1,3,5,7.., (enter - for default: bx)
          min_pt  minimum number of points required in the filter window to evaluate the median value (enter - for default: (bx*by)/4)
          zflg    zero value flag (enter - for default)
                    0: data values that are equal to 0.0 (no data) are not changed (default)
                    1: data gaps can be filled with median values


        """

        if self.validate_inputs:
            self._validate_median_filter(din, dout, width, bx, by, min_pt, zflg)

        if self.mock_outputs:
            self._mock_median_filter_outputs(din, dout, width, bx, by, min_pt, zflg)

        ca = self._clean_args(locals(), inspect.signature(self.median_filter))
        result = self._gamma_call("LAT", "median_filter", ca)

        assert dout.exists(), f"{dout} does not exist"
        assert dout.stat().st_size > 0, f"{dout} has zero file size"

        return result

    def _validate_cc_monitoring(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        ras_out: Path,
        width: int,
        cc_thresh: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to cc_monitoring.

        """

        assert f1.exists(), f"{f1} does not exist"
        assert f1.stat().st_size > 0, f"{f1} has zero file size"

        assert f2.exists(), f"{f2} does not exist"
        assert f2.stat().st_size > 0, f"{f2} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

    def _mock_cc_monitoring_outputs(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        ras_out: Path,
        width: int,
        cc_thresh: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[int] = None,
    ) -> None:
        """

        Mock the program cc_monitoring.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def cc_monitoring(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        ras_out: Path,
        width: int,
        cc_thresh: Optional[int] = None,
        start: Optional[int] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT cc_monitoring: Classification based on multiple input files using single threshold


        input parameters:
          nfiles     number of input data files
          f1         (input) 1. input data file (float)
          f2         (input) 2. input data file (float)
          ...        (input) further input files
          ras_out    (output) output 8-bit image file (SUN: *.ras, BMP: *.bmp, TIFF: *.tif)
          width      number of samples/row
          cc_thresh  classification threshold (enter - for default: 0.5)
          start      starting line (enter - for default: 1)
          nlines     number of lines to display (enter - for default: 0=entire file)
          pixav_x    number of pixels to average in width (enter - for default: 1)
          pixav_y    number of pixels to average in height (enter - for default: 1)
          LR         flip image left/right (1: normal (default), -1: mirror image) (enter - for default)


        """

        if self.validate_inputs:
            self._validate_cc_monitoring(
                nfiles,
                f1,
                f2,
                ras_out,
                width,
                cc_thresh,
                start,
                nlines,
                pixav_x,
                pixav_y,
                LR,
            )

        if self.mock_outputs:
            self._mock_cc_monitoring_outputs(
                nfiles,
                f1,
                f2,
                ras_out,
                width,
                cc_thresh,
                start,
                nlines,
                pixav_x,
                pixav_y,
                LR,
            )

        ca = self._clean_args(locals(), inspect.signature(self.cc_monitoring))
        result = self._gamma_call("LAT", "cc_monitoring", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_temp_log_var(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[int] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to temp_log_var.

        """

        assert data_tab.exists(), f"{data_tab} does not exist"
        assert data_tab.stat().st_size > 0, f"{data_tab} has zero file size"

        self._check_tab_file(data_tab, "data_tab")

        assert not mean.exists(), f"{mean} should _not_ exist!"

        assert not stdev.exists(), f"{stdev} should _not_ exist!"

    def _mock_temp_log_var_outputs(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[int] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        """

        Mock the program temp_log_var.

        """

        if mean is not None and str(mean) != "-":
            mean.touch()

        if stdev is not None and str(stdev) != "-":
            stdev.touch()

    def temp_log_var(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[int] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/temp_log_var

        Calculation of log-mean and log-stdev (temporal variability) of multiple data sets


        input parameters:
          data_tab   (input) single column list of the names of input data files (FLOAT)
          mean       (output) temporal mean in dB (FLOAT)
          stdev      (output) temporal variability, standard deviation in dB (FLOAT)
          width      number of samples/row
          wy         spatial averaging filter height (enter - for default: 1.0)
          wx         spatial averaging filter width (enter - for default: 1.0)
          wt_flag    weighting function (enter - for default)
                       0: uniform (default)
                       1: linear
                       2: Gaussian
          zflag      zero data flag (enter - for default)
                       0: 0.0 interpreted as missing value (default)
                       1: 0.0 interpreted as valid data value
          loff       offset to starting line (enter - for default: 0)
          nlines     number of lines to process (enter - or 0 for default: entire file)


        """

        if self.validate_inputs:
            self._validate_temp_log_var(
                data_tab, mean, stdev, width, wy, wx, wt_flag, zflag, loff, nlines
            )

        if self.mock_outputs:
            self._mock_temp_log_var_outputs(
                data_tab, mean, stdev, width, wy, wx, wt_flag, zflag, loff, nlines
            )

        ca = self._clean_args(locals(), inspect.signature(self.temp_log_var))
        result = self._gamma_call("LAT", "temp_log_var", ca)

        assert mean.exists(), f"{mean} does not exist"
        assert mean.stat().st_size > 0, f"{mean} has zero file size"

        assert stdev.exists(), f"{stdev} does not exist"
        assert stdev.stat().st_size > 0, f"{stdev} has zero file size"

        return result

    def _validate_ras_to_hsi(
        self,
        HUE: Path,
        SATURATION: Path,
        INTENSITY: Path,
        ras_out: Path,
        LR: Optional[int] = None,
        cflg: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to ras_to_hsi.

        """

        assert HUE.exists(), f"{HUE} does not exist"
        assert HUE.stat().st_size > 0, f"{HUE} has zero file size"

        assert SATURATION.exists(), f"{SATURATION} does not exist"
        assert SATURATION.stat().st_size > 0, f"{SATURATION} has zero file size"

        assert INTENSITY.exists(), f"{INTENSITY} does not exist"
        assert INTENSITY.stat().st_size > 0, f"{INTENSITY} has zero file size"

        assert not ras_out.exists(), f"{ras_out} should _not_ exist!"

    def _mock_ras_to_hsi_outputs(
        self,
        HUE: Path,
        SATURATION: Path,
        INTENSITY: Path,
        ras_out: Path,
        LR: Optional[int] = None,
        cflg: Optional[int] = None,
    ) -> None:
        """

        Mock the program ras_to_hsi.

        """

        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_to_hsi(
        self,
        HUE: Path,
        SATURATION: Path,
        INTENSITY: Path,
        ras_out: Path,
        LR: Optional[int] = None,
        cflg: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program ras_to_hsi.c
        Combine 3 raster images (SUN, BMP, or TIFF format) into a HSI (hue/saturation/intensity) 24-bit raster image

        input parameters:
          HUE         (input) HUE channel 8-bit raster image (SUN, BMP, or TIFF format)
          SATURATION  (input) SATURATION channel 8-bit raster image (SUN, BMP, or TIFF format)
          INTENSITY   (input) INTENSITY channel 8-bit raster image (SUN, BMP, or TIFF format)
          ras_out     (output) HUE/SATURATION/INTENSITY 24-bit composite raster image (SUN, BMP, or TIFF format)
          LR          image mirror flag (enter - for default)
                        1: normal (default)
                       -1: mirror image
          cflg        color table flag (enter - for default)
                        0: use (red+green+blue)/3 as value (default)
                        1: scale input values linearly to 255


        """

        if self.validate_inputs:
            self._validate_ras_to_hsi(HUE, SATURATION, INTENSITY, ras_out, LR, cflg)

        if self.mock_outputs:
            self._mock_ras_to_hsi_outputs(HUE, SATURATION, INTENSITY, ras_out, LR, cflg)

        ca = self._clean_args(locals(), inspect.signature(self.ras_to_hsi))
        result = self._gamma_call("LAT", "ras_to_hsi", ca)

        assert ras_out.exists(), f"{ras_out} does not exist"
        assert ras_out.stat().st_size > 0, f"{ras_out} has zero file size"

        return result

    def _validate_edge_detection(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        op_flg: Optional[int] = None,
        sigma_x: Optional[int] = None,
        sigma_y: Optional[int] = None,
        T1: Optional[int] = None,
        T2: Optional[int] = None,
        min_seg_size: Optional[int] = None,
        max_reg_len: Optional[int] = None,
        max_reg_std: Optional[int] = None,
        max_reg_dist: Optional[int] = None,
        seg_out: Optional[Path] = None,
        line_filt: Optional[int] = None,
        max_line_std: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to edge_detection.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not data_out.exists(), f"{data_out} should _not_ exist!"

        if seg_out is not None:
            assert not seg_out.exists(), f"{seg_out} should _not_ exist!"

    def _mock_edge_detection_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        op_flg: Optional[int] = None,
        sigma_x: Optional[int] = None,
        sigma_y: Optional[int] = None,
        T1: Optional[int] = None,
        T2: Optional[int] = None,
        min_seg_size: Optional[int] = None,
        max_reg_len: Optional[int] = None,
        max_reg_std: Optional[int] = None,
        max_reg_dist: Optional[int] = None,
        seg_out: Optional[Path] = None,
        line_filt: Optional[int] = None,
        max_line_std: Optional[int] = None,
    ) -> None:
        """

        Mock the program edge_detection.

        """

        if data_out is not None and str(data_out) != "-":
            data_out.touch()

        if seg_out is not None and str(seg_out) != "-":
            seg_out.touch()

    def edge_detection(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        op_flg: Optional[int] = None,
        sigma_x: Optional[int] = None,
        sigma_y: Optional[int] = None,
        T1: Optional[int] = None,
        T2: Optional[int] = None,
        min_seg_size: Optional[int] = None,
        max_reg_len: Optional[int] = None,
        max_reg_std: Optional[int] = None,
        max_reg_dist: Optional[int] = None,
        seg_out: Optional[Path] = None,
        line_filt: Optional[int] = None,
        max_line_std: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Detection of edges in an image using a Canny edge detector - extraction of line segments


        input parameters:
          data_in       (input) input data file
          width         width of input data
          data_out      (output) output data file (FLOAT type)
          dtype         input data type (enter - for default)
                          0: FLOAT (default)
                          1: SUN/BMP/TIFF 8 or 24-bit raster image
          op_flg        operation before computing edges (enter - for default)
                          0: none (default)
                          1: sqrt
                          2: log
          sigma_x       Gaussian filter sigma parameter in horizontal direction (enter - for default: 1.00)
          sigma_y       Gaussian filter sigma parameter in vertical direction (enter - for default: same as sigma_x)
          T1            low gradient value for hysteresis thresholding relative to maximum gradient (0 < T1 < 1, enter - for default: 0.01)
          T2            high gradient value for hysteresis thresholding relative to maximum gradient (T1 < T2 < 1, enter - for default: 0.10)
          min_seg_size  minimum segment size (enter - for default: 0)
                        NOTE: only segments with a limited curvature will be kept if [min_seg_size] > 1,
                              the curvature is defined by [max_reg_len] [max_reg_std] and [max_reg_dist] values
          max_reg_len   maximum linear regression length (must be >= 3, enter - for default: 9)
          max_reg_std   maximum standard deviation of segment linear regression (enter - for default: 1.00)
          max_reg_dist  maximum distance between candidate pixel and linear regression (enter - for default: 2.00)
          seg_out       (output) output text file containing the detected line segments (requires [min_seg_size] > 1, enter - for none)
          line_filt     flag for filtering out non-straight lines (enter - for default)
                          0: no filter (default)
                          1: keep only straight lines (requires [min_seg_size] > 1)
          max_line_std  maximum standard deviation of line linear regression (enter - for default: 1.00)


        """

        if self.validate_inputs:
            self._validate_edge_detection(
                data_in,
                width,
                data_out,
                dtype,
                op_flg,
                sigma_x,
                sigma_y,
                T1,
                T2,
                min_seg_size,
                max_reg_len,
                max_reg_std,
                max_reg_dist,
                seg_out,
                line_filt,
                max_line_std,
            )

        if self.mock_outputs:
            self._mock_edge_detection_outputs(
                data_in,
                width,
                data_out,
                dtype,
                op_flg,
                sigma_x,
                sigma_y,
                T1,
                T2,
                min_seg_size,
                max_reg_len,
                max_reg_std,
                max_reg_dist,
                seg_out,
                line_filt,
                max_line_std,
            )

        ca = self._clean_args(locals(), inspect.signature(self.edge_detection))
        result = self._gamma_call("LAT", "edge_detection", ca)

        assert data_out.exists(), f"{data_out} does not exist"
        assert data_out.stat().st_size > 0, f"{data_out} has zero file size"

        if seg_out is not None:
            assert seg_out.exists(), f"{seg_out} does not exist"
            assert seg_out.stat().st_size > 0, f"{seg_out} has zero file size"

        return result

    def _validate_texture(
        self,
        data_in: Path,
        format_flag: int,
        texture: Path,
        width: int,
        type: Optional[int] = None,
        bx: Optional[int] = None,
        by: Optional[int] = None,
        r_looks: Optional[int] = None,
        az_looks: Optional[int] = None,
        data_in_mean: Optional[Path] = None,
    ) -> None:
        """

        Validate the arguments to texture.

        """

        assert data_in.exists(), f"{data_in} does not exist"
        assert data_in.stat().st_size > 0, f"{data_in} has zero file size"

        assert not texture.exists(), f"{texture} should _not_ exist!"

        if data_in_mean is not None:
            assert data_in_mean.exists(), f"{data_in_mean} does not exist"
            assert data_in_mean.stat().st_size > 0, f"{data_in_mean} has zero file size"

    def _mock_texture_outputs(
        self,
        data_in: Path,
        format_flag: int,
        texture: Path,
        width: int,
        type: Optional[int] = None,
        bx: Optional[int] = None,
        by: Optional[int] = None,
        r_looks: Optional[int] = None,
        az_looks: Optional[int] = None,
        data_in_mean: Optional[Path] = None,
    ) -> None:
        """

        Mock the program texture.

        """

        if texture is not None and str(texture) != "-":
            texture.touch()

    def texture(
        self,
        data_in: Path,
        format_flag: int,
        texture: Path,
        width: int,
        type: Optional[int] = None,
        bx: Optional[int] = None,
        by: Optional[int] = None,
        r_looks: Optional[int] = None,
        az_looks: Optional[int] = None,
        data_in_mean: Optional[Path] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: Program texture.c
        Estimation of image texture defined as stdev/mean or log<I>-<logI>


        input parameters:
          data_in      (input) data file (float, fcomplex, or scomplex)
          format_flag  format of data_in: 0: float, 1: fcomplex, 2: scomplex)
          texture      (output) image texture (float) defined as normalized second moment
          width        number of samples/row
          type         texture measure flag (enter - for default)
                         0: texture defined as stdev/mean (default)
                         1: log<I>-<logI>
          bx           estimation window size in input image range pixels (enter - for default: 15)
          by           estimation window size in input image azimuth pixels (default - for default: bx)
          r_looks      range multilooking (in range pixels) (enter - for default: 1)
          az_looks     azimuth multilooking (in azimuth pixels) (enter - for default: 1)
          wgt_flag     weighting function: (enter - for default)
                         0: no weighting function applied (default)
                         1: linear weighting function
                         2: Gaussian weighting function
          data_in_mean (input) first moment of input data file (float) (enter - for none)


        """

        if self.validate_inputs:
            self._validate_texture(
                data_in,
                format_flag,
                texture,
                width,
                type,
                bx,
                by,
                r_looks,
                az_looks,
                data_in_mean,
            )

        if self.mock_outputs:
            self._mock_texture_outputs(
                data_in,
                format_flag,
                texture,
                width,
                type,
                bx,
                by,
                r_looks,
                az_looks,
                data_in_mean,
            )

        ca = self._clean_args(locals(), inspect.signature(self.texture))
        result = self._gamma_call("LAT", "texture", ca)

        assert texture.exists(), f"{texture} does not exist"
        assert texture.stat().st_size > 0, f"{texture} has zero file size"

        return result

    def _validate_diplane_helix(
        self,
        LL: Path,
        RR: Path,
        SLC_par: Path,
        diplane: Path,
        helix: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
    ) -> None:
        """

        Validate the arguments to diplane_helix.

        """

        assert LL.exists(), f"{LL} does not exist"
        assert LL.stat().st_size > 0, f"{LL} has zero file size"

        assert RR.exists(), f"{RR} does not exist"
        assert RR.stat().st_size > 0, f"{RR} has zero file size"

        assert SLC_par.exists(), f"{SLC_par} does not exist"
        assert SLC_par.stat().st_size > 0, f"{SLC_par} has zero file size"

        assert not diplane.exists(), f"{diplane} should _not_ exist!"

        assert not helix.exists(), f"{helix} should _not_ exist!"

        assert not MLI_par.exists(), f"{MLI_par} should _not_ exist!"

    def _mock_diplane_helix_outputs(
        self,
        LL: Path,
        RR: Path,
        SLC_par: Path,
        diplane: Path,
        helix: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
    ) -> None:
        """

        Mock the program diplane_helix.

        """

        if diplane is not None and str(diplane) != "-":
            diplane.touch()

        if helix is not None and str(helix) != "-":
            helix.touch()

        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def diplane_helix(
        self,
        LL: Path,
        RR: Path,
        SLC_par: Path,
        diplane: Path,
        helix: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[float] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        LAT diplane_helix: Calculate Helix and Diplane composition from RR and LL circular components


        input parameters:
          LL          (input) single-look complex image with LL circular component
          RR          (input) single-look complex image with RR circular component
          SLC_par     (input) SLC ISP image parameter file
          diplane     (output) multi-look intensity image with diplane component
          helix       (output) multi-look intensity image with helix component
          MLI_par     (output) MLI ISP image parameter file
          rlks        number of range looks
          azlks       number of azimuth looks
          loff        offset to starting line (default: 0)
          nlines      number of SLC lines to process (default: entire file)
          scale       scale factor for output MLI (default: 1.0)


        """

        if self.validate_inputs:
            self._validate_diplane_helix(
                LL, RR, SLC_par, diplane, helix, MLI_par, rlks, azlks, loff, nlines, scale
            )

        if self.mock_outputs:
            self._mock_diplane_helix_outputs(
                LL, RR, SLC_par, diplane, helix, MLI_par, rlks, azlks, loff, nlines, scale
            )

        ca = self._clean_args(locals(), inspect.signature(self.diplane_helix))
        result = self._gamma_call("LAT", "diplane_helix", ca)

        assert diplane.exists(), f"{diplane} does not exist"
        assert diplane.stat().st_size > 0, f"{diplane} has zero file size"

        assert helix.exists(), f"{helix} does not exist"
        assert helix.stat().st_size > 0, f"{helix} has zero file size"

        assert MLI_par.exists(), f"{MLI_par} does not exist"
        assert MLI_par.stat().st_size > 0, f"{MLI_par} has zero file size"

        return result

    def _validate_lin_comb_ref(
        self,
        f1: Path,
        f2: Path,
        constant: int,
        factor1: int,
        factor2: int,
        f_out: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        """

        Validate the arguments to lin_comb_ref.

        """

        assert f1.exists(), f"{f1} does not exist"
        assert f1.stat().st_size > 0, f"{f1} has zero file size"

        assert f2.exists(), f"{f2} does not exist"
        assert f2.stat().st_size > 0, f"{f2} has zero file size"

        assert not f_out.exists(), f"{f_out} should _not_ exist!"

    def _mock_lin_comb_ref_outputs(
        self,
        f1: Path,
        f2: Path,
        constant: int,
        factor1: int,
        factor2: int,
        f_out: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        """

        Mock the program lin_comb_ref.

        """

        if f_out is not None and str(f_out) != "-":
            f_out.touch()

    def lin_comb_ref(
        self,
        f1: Path,
        f2: Path,
        constant: int,
        factor1: int,
        factor2: int,
        f_out: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> Tuple[int, List[str], List[str]]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/lin_comb_ref.c
        Calculate linear combination of 2 images (float) with option to add or subtract the scaled average of a specified reference region


        input parameters:
          f1         (input) input data file 1 (float)
          f2         (input) input data file 2,  reference scene if this mode selected by selecting a region with roff and loff (float)
          constant   constant value to add to output
          factor1    factor1 to multiply with f1
          factor2    factor2 to multiply with f2, or reference region average, set to -1.0 to subtract reference region value
          f_out      (output) output file (float)
          width      number of samples/row
          roff       range pixel offset to center of the reference region in f2, (default: -1, otherwise center of reference region)
          loff       line offset to center of the reference region
          nr         number of range pixels to average in the reference region (enter - for default = 16)
          nl         number of lines average in the reference region (enter - for default= 16)
          zflag      interpretation of 0.0 data values:
                       0: interpreted as missing value (default)
                       1: 0.0 is valid data value


        """

        if self.validate_inputs:
            self._validate_lin_comb_ref(
                f1,
                f2,
                constant,
                factor1,
                factor2,
                f_out,
                width,
                roff,
                loff,
                nr,
                nl,
                zflag,
            )

        if self.mock_outputs:
            self._mock_lin_comb_ref_outputs(
                f1,
                f2,
                constant,
                factor1,
                factor2,
                f_out,
                width,
                roff,
                loff,
                nr,
                nl,
                zflag,
            )

        ca = self._clean_args(locals(), inspect.signature(self.lin_comb_ref))
        result = self._gamma_call("LAT", "lin_comb_ref", ca)

        assert f_out.exists(), f"{f_out} does not exist"
        assert f_out.stat().st_size > 0, f"{f_out} has zero file size"

        return result

    def rashgt(self, *args, **kwargs):
        if not self.mock_outputs:
            raise NotImplementedError()

    def rascc(self, *args, **kwargs):
        if not self.mock_outputs:
            raise NotImplementedError()

    def rasrmg(self, *args, **kwargs):
        if not self.mock_outputs:
            raise NotImplementedError()
