from pathlib import Path
from typing import Sequence, NamedTuple, Dict, Optional
from collections import Counter
from copy import copy
import inspect

from insar.logs import STATUS_LOGGER as LOG

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# WARNING: This file is automatically generated!
# See utils/gamma_usage2py.py
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

PyGammaCall = NamedTuple("PyGammaCall", [("module", str), ("program", str), ("parameters", Dict[str, object]), ("status", int)])


class SimpleParFile(object):
    values = {}

    def __init__(self, path):
        with open(path, 'r') as file:
            lines = file.read().splitlines()[1:]  # Skip header lines

            for line in lines:
                value_id = line.split(':')[0]
                if len(value_id.strip()) == 0:
                    continue

                value_data = line[len(value_id)+2:].strip()

                self.values[value_id] = value_data

    def get_value(self, value_id: str, dtype=str, index: Optional[int] = None):
        def attempt_convert(val):
            try:
                return dtype(val)
            except:
                return val

        if index is not None:
            return attempt_convert(self.values[value_id].split()[index])
        else:
            return [attempt_convert(i) for i in self.values[value_id].split()]


class PyGammaProxy(object):
    ParFile = SimpleParFile

    validate_inputs: bool = True
    mock_outputs: bool = False

    call_sequence: Sequence[PyGammaCall]
    call_count: Counter
    error_count: int

    _exception_type: type
    _wraps: object
    _fail_reason: str

    def __init__(self, exception_type=None, wraps=None):
        self.reset_proxy()
        self._exception_type = exception_type
        self._wraps = wraps

    def reset_proxy(self):
        self.call_sequence = []
        self.call_count = Counter()
        self.error_count = 0
        self._fail_reason = None

    def _validate(self, cmd, is_valid, fail_reason):
        if not is_valid:
            stat = -1
            self._fail_reason = fail_reason
            raise ValueError(f"Invaid pg.{cmd} parameters ({self._fail_reason})")

    def _on_error(self, cmd, params, status):
        if status is None or status == 0:
            return

        if self._exception_type is None:
            return

        raise self._exception_type(f"failed to execute pg.{cmd} ({self._fail_reason})")

    def _gamma_call(self, gamma_module: str, gamma_program: str, program_args):
        result = (0, "", "")

        if self._wraps is not None:
            result = getattr(self._wraps, gamma_program)(*program_args)

        self.call_count[gamma_program] += 1
        self.call_sequence.append(PyGammaCall(gamma_module, gamma_program, program_args, result[0]))
        self._on_error(gamma_program, program_args, result[0])

        return result

#    def _clean_call_args(self, values, sig: inspect.Signature):
#        # Subset argnames to just those the user provided
#        # (eg: ignore the default-value params they didn't provide)
#        del values["self"]
#        argnames = list(sig.parameters.keys())[:len(values)]
#
#        # And then also remove the trailing default args w/ no value
#        for name in reversed(argnames.copy()):
#            param = sig.parameters[name]
#
#            # Stop once we hit non-default values
#            if param.default == inspect.Parameter.empty:
#                break
#
#            # And also stop once we hit values the call is being passed
#            val = values[argnames[-1]]
#            if val and val != "-":
#                break
#
#            argnames.pop()
#
#        return [values[i] for i in argnames]

    def _clean_call_args(self, values, sig: inspect.Signature):
        cleaned = []
        for arg in sig.parameters.keys():
            value = copy(values[arg])
            if value is None:
                cleaned.append('-')
            else:
                cleaned.append(value)
        while cleaned[-1] == '-':
            cleaned.pop()
        return cleaned

    def _validate_gc_map_fine(self, gc_in: str, width, DIFF_par, gc_out: str, ref_flg = None):
        if gc_in is not None:
            self._validate("gc_map_fine", gc_in == "-" or Path(gc_in).exists(), f"gc_in path does not exist ({gc_in})")
        valid_values = [0, 1] + [None]
        self._validate("gc_map_fine", ref_flg == "-" or ref_flg in valid_values, f"ref_flg is not a valid value (expects: {valid_values}, got: {ref_flg})")

    def _mock_gc_map_fine_outputs(self, gc_in: str, width, DIFF_par, gc_out: str, ref_flg = None):
        if gc_out is not None and gc_out != "-":
            Path(gc_out).touch()

    def gc_map_fine(self, gc_in: str, width, DIFF_par, gc_out: str, ref_flg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map_fine))

        if self.validate_inputs:
            self._validate_gc_map_fine(*supplied_args)

        if self.mock_outputs:
            self._mock_gc_map_fine_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gc_map_fine", supplied_args)


    def _validate_diff_ls_fit(self, unw_1: str, unw_2: str, DIFF_par: str, nr = None, naz = None, mask = None, plot_data: str = None):
        if unw_1 is not None:
            self._validate("diff_ls_fit", unw_1 == "-" or Path(unw_1).exists(), f"unw_1 path does not exist ({unw_1})")
        if unw_2 is not None:
            self._validate("diff_ls_fit", unw_2 == "-" or Path(unw_2).exists(), f"unw_2 path does not exist ({unw_2})")
        if DIFF_par is not None:
            self._validate("diff_ls_fit", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_diff_ls_fit_outputs(self, unw_1: str, unw_2: str, DIFF_par: str, nr = None, naz = None, mask = None, plot_data: str = None):
        if plot_data is not None and plot_data != "-":
            Path(plot_data).touch()

    def diff_ls_fit(self, unw_1: str, unw_2: str, DIFF_par: str, nr = None, naz = None, mask = None, plot_data: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.diff_ls_fit))

        if self.validate_inputs:
            self._validate_diff_ls_fit(*supplied_args)

        if self.mock_outputs:
            self._mock_diff_ls_fit_outputs(*supplied_args)

        return self._gamma_call("DIFF", "diff_ls_fit", supplied_args)


    def _validate_WSS_mosaic(self, WSS_tab: str, MLI_par: str, WSS_data: str, type):
        if WSS_tab is not None:
            self._validate("WSS_mosaic", WSS_tab == "-" or Path(WSS_tab).exists(), f"WSS_tab path does not exist ({WSS_tab})")
        valid_values = [0, 1]
        self._validate("WSS_mosaic", type == "-" or type in valid_values, f"type is not a valid value (expects: {valid_values}, got: {type})")

    def _mock_WSS_mosaic_outputs(self, WSS_tab: str, MLI_par: str, WSS_data: str, type):
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if WSS_data is not None and WSS_data != "-":
            Path(WSS_data).touch()

    def WSS_mosaic(self, WSS_tab: str, MLI_par: str, WSS_data: str, type):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.WSS_mosaic))

        if self.validate_inputs:
            self._validate_WSS_mosaic(*supplied_args)

        if self.mock_outputs:
            self._mock_WSS_mosaic_outputs(*supplied_args)

        return self._gamma_call("DIFF", "WSS_mosaic", supplied_args)


    def _validate_dispmap_vec_offset(self, DEM_par: str, DEM: str, dispmap_r, dispmap_az, lv_theta, lv_phi, dv_norm: str, dv_theta: str = None, dv_phi: str = None, dv_x: str = None, dv_y: str = None, dv_z: str = None, mask_angle = None, mode = None, ax_north = None, ax_east = None):
        if DEM_par is not None:
            self._validate("dispmap_vec_offset", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("dispmap_vec_offset", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        valid_values = [0, 1] + [None]
        self._validate("dispmap_vec_offset", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_dispmap_vec_offset_outputs(self, DEM_par: str, DEM: str, dispmap_r, dispmap_az, lv_theta, lv_phi, dv_norm: str, dv_theta: str = None, dv_phi: str = None, dv_x: str = None, dv_y: str = None, dv_z: str = None, mask_angle = None, mode = None, ax_north = None, ax_east = None):
        if dv_norm is not None and dv_norm != "-":
            Path(dv_norm).touch()
        if dv_theta is not None and dv_theta != "-":
            Path(dv_theta).touch()
        if dv_phi is not None and dv_phi != "-":
            Path(dv_phi).touch()
        if dv_x is not None and dv_x != "-":
            Path(dv_x).touch()
        if dv_y is not None and dv_y != "-":
            Path(dv_y).touch()
        if dv_z is not None and dv_z != "-":
            Path(dv_z).touch()

    def dispmap_vec_offset(self, DEM_par: str, DEM: str, dispmap_r, dispmap_az, lv_theta, lv_phi, dv_norm: str, dv_theta: str = None, dv_phi: str = None, dv_x: str = None, dv_y: str = None, dv_z: str = None, mask_angle = None, mode = None, ax_north = None, ax_east = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_vec_offset))

        if self.validate_inputs:
            self._validate_dispmap_vec_offset(*supplied_args)

        if self.mock_outputs:
            self._mock_dispmap_vec_offset_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dispmap_vec_offset", supplied_args)


    def _validate_create_diff_par(self, PAR_1: str, PAR_2: str, DIFF_par: str, PAR_type = None, iflg = None):
        if PAR_1 is not None:
            self._validate("create_diff_par", PAR_1 == "-" or Path(PAR_1).exists(), f"PAR_1 path does not exist ({PAR_1})")
        if PAR_2 is not None:
            self._validate("create_diff_par", PAR_2 == "-" or Path(PAR_2).exists(), f"PAR_2 path does not exist ({PAR_2})")
        valid_values = [0, 1, 2] + [None]
        self._validate("create_diff_par", PAR_type == "-" or PAR_type in valid_values, f"PAR_type is not a valid value (expects: {valid_values}, got: {PAR_type})")
        valid_values = [0, 1] + [None]
        self._validate("create_diff_par", iflg == "-" or iflg in valid_values, f"iflg is not a valid value (expects: {valid_values}, got: {iflg})")

    def _mock_create_diff_par_outputs(self, PAR_1: str, PAR_2: str, DIFF_par: str, PAR_type = None, iflg = None):
        if DIFF_par is not None and DIFF_par != "-" and not Path(DIFF_par).exists():
            Path(DIFF_par).touch()

    def create_diff_par(self, PAR_1: str, PAR_2: str, DIFF_par: str, PAR_type = None, iflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_diff_par))

        if self.validate_inputs:
            self._validate_create_diff_par(*supplied_args)

        if self.mock_outputs:
            self._mock_create_diff_par_outputs(*supplied_args)

        return self._gamma_call("DIFF", "create_diff_par", supplied_args)


    def _validate_gc_map_grd(self, MLI_par: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None, ls_mode = None, r_ovr = None):
        if MLI_par is not None:
            self._validate("gc_map_grd", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if DEM_par is not None:
            self._validate("gc_map_grd", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("gc_map_grd", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("gc_map_grd", ls_mode == "-" or ls_mode in valid_values, f"ls_mode is not a valid value (expects: {valid_values}, got: {ls_mode})")

    def _mock_gc_map_grd_outputs(self, MLI_par: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None, ls_mode = None, r_ovr = None):
        if DEM_seg_par is not None and DEM_seg_par != "-" and not Path(DEM_seg_par).exists():
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()

    def gc_map_grd(self, MLI_par: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None, ls_mode = None, r_ovr = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map_grd))

        if self.validate_inputs:
            self._validate_gc_map_grd(*supplied_args)

        if self.mock_outputs:
            self._mock_gc_map_grd_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gc_map_grd", supplied_args)


    def _validate_multi_mosaic(self, data_tab: str, data_out: str, DEM_par_out: str, mode, format_flag):
        if data_tab is not None:
            self._validate("multi_mosaic", data_tab == "-" or Path(data_tab).exists(), f"data_tab path does not exist ({data_tab})")
        valid_values = [0, 1]
        self._validate("multi_mosaic", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")
        valid_values = [0, 1, 2, 3, 4, 5]
        self._validate("multi_mosaic", format_flag == "-" or format_flag in valid_values, f"format_flag is not a valid value (expects: {valid_values}, got: {format_flag})")

    def _mock_multi_mosaic_outputs(self, data_tab: str, data_out: str, DEM_par_out: str, mode, format_flag):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if DEM_par_out is not None and DEM_par_out != "-":
            Path(DEM_par_out).touch()

    def multi_mosaic(self, data_tab: str, data_out: str, DEM_par_out: str, mode, format_flag):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_mosaic))

        if self.validate_inputs:
            self._validate_multi_mosaic(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_mosaic_outputs(*supplied_args)

        return self._gamma_call("DIFF", "multi_mosaic", supplied_args)


    def _validate_gc_map1(self, MLI_par: str, OFF_par: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None, ls_mode = None, r_ovr = None):
        if MLI_par is not None:
            self._validate("gc_map1", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if OFF_par is not None:
            self._validate("gc_map1", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if DEM_par is not None:
            self._validate("gc_map1", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("gc_map1", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("gc_map1", ls_mode == "-" or ls_mode in valid_values, f"ls_mode is not a valid value (expects: {valid_values}, got: {ls_mode})")

    def _mock_gc_map1_outputs(self, MLI_par: str, OFF_par: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None, ls_mode = None, r_ovr = None):
        if DEM_seg_par is not None and DEM_seg_par != "-" and not Path(DEM_seg_par).exists():
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()

    def gc_map1(self, MLI_par: str, OFF_par: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None, ls_mode = None, r_ovr = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map1))

        if self.validate_inputs:
            self._validate_gc_map1(*supplied_args)

        if self.mock_outputs:
            self._mock_gc_map1_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gc_map1", supplied_args)


    def _validate_SLC_diff_intf(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, OFF_par: str, sim_unw, diff_int: str, rlks, azlks, sps_flg = None, azf_flg = None, rbw_min = None, rp1_flg = None, rp2_flg = None):
        if SLC_1 is not None:
            self._validate("SLC_diff_intf", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2R is not None:
            self._validate("SLC_diff_intf", SLC_2R == "-" or Path(SLC_2R).exists(), f"SLC_2R path does not exist ({SLC_2R})")
        if SLC1_par is not None:
            self._validate("SLC_diff_intf", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2R_par is not None:
            self._validate("SLC_diff_intf", SLC2R_par == "-" or Path(SLC2R_par).exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        if OFF_par is not None:
            self._validate("SLC_diff_intf", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [1, 0] + [None]
        self._validate("SLC_diff_intf", sps_flg == "-" or sps_flg in valid_values, f"sps_flg is not a valid value (expects: {valid_values}, got: {sps_flg})")
        valid_values = [1, 0] + [None]
        self._validate("SLC_diff_intf", azf_flg == "-" or azf_flg in valid_values, f"azf_flg is not a valid value (expects: {valid_values}, got: {azf_flg})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_diff_intf", rp1_flg == "-" or rp1_flg in valid_values, f"rp1_flg is not a valid value (expects: {valid_values}, got: {rp1_flg})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_diff_intf", rp2_flg == "-" or rp2_flg in valid_values, f"rp2_flg is not a valid value (expects: {valid_values}, got: {rp2_flg})")

    def _mock_SLC_diff_intf_outputs(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, OFF_par: str, sim_unw, diff_int: str, rlks, azlks, sps_flg = None, azf_flg = None, rbw_min = None, rp1_flg = None, rp2_flg = None):
        if diff_int is not None and diff_int != "-":
            Path(diff_int).touch()

    def SLC_diff_intf(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, OFF_par: str, sim_unw, diff_int: str, rlks, azlks, sps_flg = None, azf_flg = None, rbw_min = None, rp1_flg = None, rp2_flg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_diff_intf))

        if self.validate_inputs:
            self._validate_SLC_diff_intf(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_diff_intf_outputs(*supplied_args)

        return self._gamma_call("DIFF", "SLC_diff_intf", supplied_args)


    def _validate_pixel_area(self, MLI_par: str, DEM_par: str, DEM: str, lookup_table: str, ls_map: str, inc_map: str, pix_sigma0: str, pix_gamma0: str = None, nstep = None, area_fact = None, sigma0_ratio: str = None, gamma0_ratio: str = None):
        if MLI_par is not None:
            self._validate("pixel_area", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if DEM_par is not None:
            self._validate("pixel_area", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("pixel_area", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        if lookup_table is not None:
            self._validate("pixel_area", lookup_table == "-" or Path(lookup_table).exists(), f"lookup_table path does not exist ({lookup_table})")
        if ls_map is not None:
            self._validate("pixel_area", ls_map == "-" or Path(ls_map).exists(), f"ls_map path does not exist ({ls_map})")
        if inc_map is not None:
            self._validate("pixel_area", inc_map == "-" or Path(inc_map).exists(), f"inc_map path does not exist ({inc_map})")

    def _mock_pixel_area_outputs(self, MLI_par: str, DEM_par: str, DEM: str, lookup_table: str, ls_map: str, inc_map: str, pix_sigma0: str, pix_gamma0: str = None, nstep = None, area_fact = None, sigma0_ratio: str = None, gamma0_ratio: str = None):
        if pix_sigma0 is not None and pix_sigma0 != "-":
            Path(pix_sigma0).touch()
        if pix_gamma0 is not None and pix_gamma0 != "-":
            Path(pix_gamma0).touch()
        if sigma0_ratio is not None and sigma0_ratio != "-":
            Path(sigma0_ratio).touch()
        if gamma0_ratio is not None and gamma0_ratio != "-":
            Path(gamma0_ratio).touch()

    def pixel_area(self, MLI_par: str, DEM_par: str, DEM: str, lookup_table: str, ls_map: str, inc_map: str, pix_sigma0: str, pix_gamma0: str = None, nstep = None, area_fact = None, sigma0_ratio: str = None, gamma0_ratio: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pixel_area))

        if self.validate_inputs:
            self._validate_pixel_area(*supplied_args)

        if self.mock_outputs:
            self._mock_pixel_area_outputs(*supplied_args)

        return self._gamma_call("DIFF", "pixel_area", supplied_args)


    def _validate_extract_gcp(self, DEM_rdc: str, OFF_par: str, GCP: str, nr, naz, mask: str = None):
        if DEM_rdc is not None:
            self._validate("extract_gcp", DEM_rdc == "-" or Path(DEM_rdc).exists(), f"DEM_rdc path does not exist ({DEM_rdc})")
        if OFF_par is not None:
            self._validate("extract_gcp", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if mask is not None:
            self._validate("extract_gcp", mask == "-" or Path(mask).exists(), f"mask path does not exist ({mask})")

    def _mock_extract_gcp_outputs(self, DEM_rdc: str, OFF_par: str, GCP: str, nr, naz, mask: str = None):
        if GCP is not None and GCP != "-":
            Path(GCP).touch()

    def extract_gcp(self, DEM_rdc: str, OFF_par: str, GCP: str, nr, naz, mask: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.extract_gcp))

        if self.validate_inputs:
            self._validate_extract_gcp(*supplied_args)

        if self.mock_outputs:
            self._mock_extract_gcp_outputs(*supplied_args)

        return self._gamma_call("DIFF", "extract_gcp", supplied_args)


    def _validate_gc_map2(self, MLI_par: str, DEM_par: str, DEM: str, DEM_seg_par: str = None, DEM_seg: str = None, lookup_table: str = None, lat_ovr = None, lon_ovr = None, ls_map: str = None, ls_map_rdc: str = None, inc: str = None, res: str = None, offnadir: str = None, sim_sar: str = None, u: str = None, v: str = None, psi: str = None, pix: str = None, r_ovr = None, az_dec = None, mask = None, frame = None, ls_scaling = None, DIFF_par: str = None, ref_flg = None):
        if MLI_par is not None:
            self._validate("gc_map2", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if DEM_par is not None:
            self._validate("gc_map2", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("gc_map2", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("gc_map2", mask == "-" or mask in valid_values, f"mask is not a valid value (expects: {valid_values}, got: {mask})")
        valid_values = [0, 1] + [None]
        self._validate("gc_map2", ls_scaling == "-" or ls_scaling in valid_values, f"ls_scaling is not a valid value (expects: {valid_values}, got: {ls_scaling})")
        if DIFF_par is not None:
            self._validate("gc_map2", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("gc_map2", ref_flg == "-" or ref_flg in valid_values, f"ref_flg is not a valid value (expects: {valid_values}, got: {ref_flg})")

    def _mock_gc_map2_outputs(self, MLI_par: str, DEM_par: str, DEM: str, DEM_seg_par: str = None, DEM_seg: str = None, lookup_table: str = None, lat_ovr = None, lon_ovr = None, ls_map: str = None, ls_map_rdc: str = None, inc: str = None, res: str = None, offnadir: str = None, sim_sar: str = None, u: str = None, v: str = None, psi: str = None, pix: str = None, r_ovr = None, az_dec = None, mask = None, frame = None, ls_scaling = None, DIFF_par: str = None, ref_flg = None):
        if DEM_seg_par is not None and DEM_seg_par != "-":
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()
        if ls_map_rdc is not None and ls_map_rdc != "-":
            Path(ls_map_rdc).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if res is not None and res != "-":
            Path(res).touch()
        if offnadir is not None and offnadir != "-":
            Path(offnadir).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()

    def gc_map2(self, MLI_par: str, DEM_par: str, DEM: str, DEM_seg_par: str = None, DEM_seg: str = None, lookup_table: str = None, lat_ovr = None, lon_ovr = None, ls_map: str = None, ls_map_rdc: str = None, inc: str = None, res: str = None, offnadir: str = None, sim_sar: str = None, u: str = None, v: str = None, psi: str = None, pix: str = None, r_ovr = None, az_dec = None, mask = None, frame = None, ls_scaling = None, DIFF_par: str = None, ref_flg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map2))

        if self.validate_inputs:
            self._validate_gc_map2(*supplied_args)

        if self.mock_outputs:
            self._mock_gc_map2_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gc_map2", supplied_args)


    def _validate_dem_trans(self, DEM1_par: str, DEM1: str, DEM2_par: str, DEM2: str, lat_ovr = None, lon_ovr = None, datum_shift = None, bflg = None, lookup_table: str = None, interp_mode = None, order = None):
        if DEM1_par is not None:
            self._validate("dem_trans", DEM1_par == "-" or Path(DEM1_par).exists(), f"DEM1_par path does not exist ({DEM1_par})")
        if DEM1 is not None:
            self._validate("dem_trans", DEM1 == "-" or Path(DEM1).exists(), f"DEM1 path does not exist ({DEM1})")
        valid_values = [0, 1] + [None]
        self._validate("dem_trans", datum_shift == "-" or datum_shift in valid_values, f"datum_shift is not a valid value (expects: {valid_values}, got: {datum_shift})")
        valid_values = [0, 1] + [None]
        self._validate("dem_trans", bflg == "-" or bflg in valid_values, f"bflg is not a valid value (expects: {valid_values}, got: {bflg})")
        valid_values = [0, 1, 2] + [None]
        self._validate("dem_trans", interp_mode == "-" or interp_mode in valid_values, f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})")

    def _mock_dem_trans_outputs(self, DEM1_par: str, DEM1: str, DEM2_par: str, DEM2: str, lat_ovr = None, lon_ovr = None, datum_shift = None, bflg = None, lookup_table: str = None, interp_mode = None, order = None):
        if DEM2_par is not None and DEM2_par != "-" and not Path(DEM2_par).exists():
            Path(DEM2_par).touch()
        if DEM2 is not None and DEM2 != "-":
            Path(DEM2).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()

    def dem_trans(self, DEM1_par: str, DEM1: str, DEM2_par: str, DEM2: str, lat_ovr = None, lon_ovr = None, datum_shift = None, bflg = None, lookup_table: str = None, interp_mode = None, order = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_trans))

        if self.validate_inputs:
            self._validate_dem_trans(*supplied_args)

        if self.mock_outputs:
            self._mock_dem_trans_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dem_trans", supplied_args)


    def _validate_quad_sub(self, int_1, DIFF_par: str, int_2: str, int_type, mode = None):
        if DIFF_par is not None:
            self._validate("quad_sub", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")
        valid_values = [0, 1]
        self._validate("quad_sub", int_type == "-" or int_type in valid_values, f"int_type is not a valid value (expects: {valid_values}, got: {int_type})")
        valid_values = [0, 1] + [None]
        self._validate("quad_sub", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_quad_sub_outputs(self, int_1, DIFF_par: str, int_2: str, int_type, mode = None):
        if int_2 is not None and int_2 != "-":
            Path(int_2).touch()

    def quad_sub(self, int_1, DIFF_par: str, int_2: str, int_type, mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.quad_sub))

        if self.validate_inputs:
            self._validate_quad_sub(*supplied_args)

        if self.mock_outputs:
            self._mock_quad_sub_outputs(*supplied_args)

        return self._gamma_call("DIFF", "quad_sub", supplied_args)


    def _validate_phase_sum(self, im_list, width, sum: str, start = None, nlines = None, pixav_x = None, pixav_y = None, zflag = None):
        valid_values = [0, 1] + [None]
        self._validate("phase_sum", zflag == "-" or zflag in valid_values, f"zflag is not a valid value (expects: {valid_values}, got: {zflag})")

    def _mock_phase_sum_outputs(self, im_list, width, sum: str, start = None, nlines = None, pixav_x = None, pixav_y = None, zflag = None):
        if sum is not None and sum != "-":
            Path(sum).touch()

    def phase_sum(self, im_list, width, sum: str, start = None, nlines = None, pixav_x = None, pixav_y = None, zflag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.phase_sum))

        if self.validate_inputs:
            self._validate_phase_sum(*supplied_args)

        if self.mock_outputs:
            self._mock_phase_sum_outputs(*supplied_args)

        return self._gamma_call("DIFF", "phase_sum", supplied_args)


    def _validate_base_add(self, base_1: str, base_2: str, base_out: str, mode = None):
        if base_1 is not None:
            self._validate("base_add", base_1 == "-" or Path(base_1).exists(), f"base_1 path does not exist ({base_1})")
        if base_2 is not None:
            self._validate("base_add", base_2 == "-" or Path(base_2).exists(), f"base_2 path does not exist ({base_2})")

    def _mock_base_add_outputs(self, base_1: str, base_2: str, base_out: str, mode = None):
        if base_out is not None and base_out != "-":
            Path(base_out).touch()

    def base_add(self, base_1: str, base_2: str, base_out: str, mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_add))

        if self.validate_inputs:
            self._validate_base_add(*supplied_args)

        if self.mock_outputs:
            self._mock_base_add_outputs(*supplied_args)

        return self._gamma_call("DIFF", "base_add", supplied_args)


    def _validate_gec_map_grd(self, GRD_par: str, DEM_par: str, href: str, DEM_seg_par: str, lookup_table: str, lat_ovr = None, lon_ovr = None):
        if GRD_par is not None:
            self._validate("gec_map_grd", GRD_par == "-" or Path(GRD_par).exists(), f"GRD_par path does not exist ({GRD_par})")
        if DEM_par is not None:
            self._validate("gec_map_grd", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if href is not None:
            self._validate("gec_map_grd", href == "-" or Path(href).exists(), f"href path does not exist ({href})")

    def _mock_gec_map_grd_outputs(self, GRD_par: str, DEM_par: str, href: str, DEM_seg_par: str, lookup_table: str, lat_ovr = None, lon_ovr = None):
        if DEM_seg_par is not None and DEM_seg_par != "-" and not Path(DEM_seg_par).exists():
            Path(DEM_seg_par).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()

    def gec_map_grd(self, GRD_par: str, DEM_par: str, href: str, DEM_seg_par: str, lookup_table: str, lat_ovr = None, lon_ovr = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gec_map_grd))

        if self.validate_inputs:
            self._validate_gec_map_grd(*supplied_args)

        if self.mock_outputs:
            self._mock_gec_map_grd_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gec_map_grd", supplied_args)


    def _validate_sarpix_coord_list(self, SLC_par: str, OFF_par: str, DEM_par: str, SAR_coord: str, MAP_coord: str):
        if SLC_par is not None:
            self._validate("sarpix_coord_list", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("sarpix_coord_list", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if DEM_par is not None:
            self._validate("sarpix_coord_list", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if SAR_coord is not None:
            self._validate("sarpix_coord_list", SAR_coord == "-" or Path(SAR_coord).exists(), f"SAR_coord path does not exist ({SAR_coord})")

    def _mock_sarpix_coord_list_outputs(self, SLC_par: str, OFF_par: str, DEM_par: str, SAR_coord: str, MAP_coord: str):
        if MAP_coord is not None and MAP_coord != "-":
            Path(MAP_coord).touch()

    def sarpix_coord_list(self, SLC_par: str, OFF_par: str, DEM_par: str, SAR_coord: str, MAP_coord: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sarpix_coord_list))

        if self.validate_inputs:
            self._validate_sarpix_coord_list(*supplied_args)

        if self.mock_outputs:
            self._mock_sarpix_coord_list_outputs(*supplied_args)

        return self._gamma_call("DIFF", "sarpix_coord_list", supplied_args)


    def _validate_dispmap_vec(self, DEM_par: str, dispmap, lv_theta: str, lv_phi: str, fv_theta: str, fv_phi: str, dv_norm: str, dv_theta: str = None, dv_phi: str = None, dv_x: str = None, dv_y: str = None, dv_z: str = None, mask_angle = None):
        if DEM_par is not None:
            self._validate("dispmap_vec", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if lv_theta is not None:
            self._validate("dispmap_vec", lv_theta == "-" or Path(lv_theta).exists(), f"lv_theta path does not exist ({lv_theta})")
        if lv_phi is not None:
            self._validate("dispmap_vec", lv_phi == "-" or Path(lv_phi).exists(), f"lv_phi path does not exist ({lv_phi})")
        if fv_theta is not None:
            self._validate("dispmap_vec", fv_theta == "-" or Path(fv_theta).exists(), f"fv_theta path does not exist ({fv_theta})")
        if fv_phi is not None:
            self._validate("dispmap_vec", fv_phi == "-" or Path(fv_phi).exists(), f"fv_phi path does not exist ({fv_phi})")

    def _mock_dispmap_vec_outputs(self, DEM_par: str, dispmap, lv_theta: str, lv_phi: str, fv_theta: str, fv_phi: str, dv_norm: str, dv_theta: str = None, dv_phi: str = None, dv_x: str = None, dv_y: str = None, dv_z: str = None, mask_angle = None):
        if dv_norm is not None and dv_norm != "-":
            Path(dv_norm).touch()
        if dv_theta is not None and dv_theta != "-":
            Path(dv_theta).touch()
        if dv_phi is not None and dv_phi != "-":
            Path(dv_phi).touch()
        if dv_x is not None and dv_x != "-":
            Path(dv_x).touch()
        if dv_y is not None and dv_y != "-":
            Path(dv_y).touch()
        if dv_z is not None and dv_z != "-":
            Path(dv_z).touch()

    def dispmap_vec(self, DEM_par: str, dispmap, lv_theta: str, lv_phi: str, fv_theta: str, fv_phi: str, dv_norm: str, dv_theta: str = None, dv_phi: str = None, dv_x: str = None, dv_y: str = None, dv_z: str = None, mask_angle = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_vec))

        if self.validate_inputs:
            self._validate_dispmap_vec(*supplied_args)

        if self.mock_outputs:
            self._mock_dispmap_vec_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dispmap_vec", supplied_args)


    def _validate_scale_base(self, unw_2: str, scaled_unw_2: str, baseline_1: str, SLC1_par_1: str, OFF_par_1, baseline_2: str, SLC_1_par_2: str, OFF_par_2, int_type):
        if unw_2 is not None:
            self._validate("scale_base", unw_2 == "-" or Path(unw_2).exists(), f"unw_2 path does not exist ({unw_2})")
        if baseline_1 is not None:
            self._validate("scale_base", baseline_1 == "-" or Path(baseline_1).exists(), f"baseline_1 path does not exist ({baseline_1})")
        if SLC1_par_1 is not None:
            self._validate("scale_base", SLC1_par_1 == "-" or Path(SLC1_par_1).exists(), f"SLC1_par_1 path does not exist ({SLC1_par_1})")
        if baseline_2 is not None:
            self._validate("scale_base", baseline_2 == "-" or Path(baseline_2).exists(), f"baseline_2 path does not exist ({baseline_2})")
        if SLC_1_par_2 is not None:
            self._validate("scale_base", SLC_1_par_2 == "-" or Path(SLC_1_par_2).exists(), f"SLC_1_par_2 path does not exist ({SLC_1_par_2})")

    def _mock_scale_base_outputs(self, unw_2: str, scaled_unw_2: str, baseline_1: str, SLC1_par_1: str, OFF_par_1, baseline_2: str, SLC_1_par_2: str, OFF_par_2, int_type):
        if scaled_unw_2 is not None and scaled_unw_2 != "-":
            Path(scaled_unw_2).touch()

    def scale_base(self, unw_2: str, scaled_unw_2: str, baseline_1: str, SLC1_par_1: str, OFF_par_1, baseline_2: str, SLC_1_par_2: str, OFF_par_2, int_type):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.scale_base))

        if self.validate_inputs:
            self._validate_scale_base(*supplied_args)

        if self.mock_outputs:
            self._mock_scale_base_outputs(*supplied_args)

        return self._gamma_call("DIFF", "scale_base", supplied_args)


    def _validate_par_EORC_PALSAR_geo(self, CEOS_leader: str, MLI_par: str, DEM_par: str, CEOS_data: str, MLI: str = None, cal = None):
        if CEOS_leader is not None:
            self._validate("par_EORC_PALSAR_geo", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_data is not None:
            self._validate("par_EORC_PALSAR_geo", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_EORC_PALSAR_geo_outputs(self, CEOS_leader: str, MLI_par: str, DEM_par: str, CEOS_data: str, MLI: str = None, cal = None):
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()

    def par_EORC_PALSAR_geo(self, CEOS_leader: str, MLI_par: str, DEM_par: str, CEOS_data: str, MLI: str = None, cal = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_EORC_PALSAR_geo))

        if self.validate_inputs:
            self._validate_par_EORC_PALSAR_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_par_EORC_PALSAR_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "par_EORC_PALSAR_geo", supplied_args)


    def _validate_SLC_intf_geo(self, SLC_1: str, SLC_2: str, DEM_par: str, interf: str, DEM_par2: str, e_lks, n_lks, MLI_1: str = None, MLI_2: str = None):
        if SLC_1 is not None:
            self._validate("SLC_intf_geo", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("SLC_intf_geo", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if DEM_par is not None:
            self._validate("SLC_intf_geo", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_SLC_intf_geo_outputs(self, SLC_1: str, SLC_2: str, DEM_par: str, interf: str, DEM_par2: str, e_lks, n_lks, MLI_1: str = None, MLI_2: str = None):
        if interf is not None and interf != "-":
            Path(interf).touch()
        if DEM_par2 is not None and DEM_par2 != "-":
            Path(DEM_par2).touch()
        if MLI_1 is not None and MLI_1 != "-":
            Path(MLI_1).touch()
        if MLI_2 is not None and MLI_2 != "-":
            Path(MLI_2).touch()

    def SLC_intf_geo(self, SLC_1: str, SLC_2: str, DEM_par: str, interf: str, DEM_par2: str, e_lks, n_lks, MLI_1: str = None, MLI_2: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_intf_geo))

        if self.validate_inputs:
            self._validate_SLC_intf_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_intf_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "SLC_intf_geo", supplied_args)


    def _validate_map_trans(self, DEM1_par: str, data1: str, DEM2_par: str, data2: str, lat_ovr = None, lon_ovr = None, interp_mode = None, dtype = None, bflg = None, lookup_table: str = None, order = None):
        if DEM1_par is not None:
            self._validate("map_trans", DEM1_par == "-" or Path(DEM1_par).exists(), f"DEM1_par path does not exist ({DEM1_par})")
        if data1 is not None:
            self._validate("map_trans", data1 == "-" or Path(data1).exists(), f"data1 path does not exist ({data1})")
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        self._validate("map_trans", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1] + [None]
        self._validate("map_trans", bflg == "-" or bflg in valid_values, f"bflg is not a valid value (expects: {valid_values}, got: {bflg})")

    def _mock_map_trans_outputs(self, DEM1_par: str, data1: str, DEM2_par: str, data2: str, lat_ovr = None, lon_ovr = None, interp_mode = None, dtype = None, bflg = None, lookup_table: str = None, order = None):
        if DEM2_par is not None and DEM2_par != "-" and not Path(DEM2_par).exists():
            Path(DEM2_par).touch()
        if data2 is not None and data2 != "-":
            Path(data2).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()

    def map_trans(self, DEM1_par: str, data1: str, DEM2_par: str, data2: str, lat_ovr = None, lon_ovr = None, interp_mode = None, dtype = None, bflg = None, lookup_table: str = None, order = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.map_trans))

        if self.validate_inputs:
            self._validate_map_trans(*supplied_args)

        if self.mock_outputs:
            self._mock_map_trans_outputs(*supplied_args)

        return self._gamma_call("DIFF", "map_trans", supplied_args)


    def _validate_gc_map_inversion(self, gc_map, width_in, gc_map_out, width_out, nlines_out = None, interp_mode = None, n_ovr = None, rad_max = None, nintr = None):
        valid_values = [0, 1, 2, 3, 4] + [None]
        self._validate("gc_map_inversion", interp_mode == "-" or interp_mode in valid_values, f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})")

    def _mock_gc_map_inversion_outputs(self, gc_map, width_in, gc_map_out, width_out, nlines_out = None, interp_mode = None, n_ovr = None, rad_max = None, nintr = None):
        pass

    def gc_map_inversion(self, gc_map, width_in, gc_map_out, width_out, nlines_out = None, interp_mode = None, n_ovr = None, rad_max = None, nintr = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map_inversion))

        if self.validate_inputs:
            self._validate_gc_map_inversion(*supplied_args)

        if self.mock_outputs:
            self._mock_gc_map_inversion_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gc_map_inversion", supplied_args)


    def _validate_par_JERS_geo(self, CEOS_leader: str, CEOS_data: str, MLI_par: str, DEM_par: str, GEO: str = None):
        if CEOS_leader is not None:
            self._validate("par_JERS_geo", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_data is not None:
            self._validate("par_JERS_geo", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_JERS_geo_outputs(self, CEOS_leader: str, CEOS_data: str, MLI_par: str, DEM_par: str, GEO: str = None):
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if GEO is not None and GEO != "-":
            Path(GEO).touch()

    def par_JERS_geo(self, CEOS_leader: str, CEOS_data: str, MLI_par: str, DEM_par: str, GEO: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_JERS_geo))

        if self.validate_inputs:
            self._validate_par_JERS_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_par_JERS_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "par_JERS_geo", supplied_args)


    def _validate_interp_data(self, data2: str, DIFF_par: str, data2_out: str, interp_mode = None, dtype = None, order = None):
        if data2 is not None:
            self._validate("interp_data", data2 == "-" or Path(data2).exists(), f"data2 path does not exist ({data2})")
        if DIFF_par is not None:
            self._validate("interp_data", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")
        valid_values = [0, 1, 2, 3, 4, 5, 6] + [None]
        self._validate("interp_data", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_interp_data_outputs(self, data2: str, DIFF_par: str, data2_out: str, interp_mode = None, dtype = None, order = None):
        if data2_out is not None and data2_out != "-":
            Path(data2_out).touch()

    def interp_data(self, data2: str, DIFF_par: str, data2_out: str, interp_mode = None, dtype = None, order = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.interp_data))

        if self.validate_inputs:
            self._validate_interp_data(*supplied_args)

        if self.mock_outputs:
            self._mock_interp_data_outputs(*supplied_args)

        return self._gamma_call("DIFF", "interp_data", supplied_args)


    def _validate_rdc_trans(self, MLI1_par: str, DEM_RDC, MLI2_par: str, lt: str):
        if MLI1_par is not None:
            self._validate("rdc_trans", MLI1_par == "-" or Path(MLI1_par).exists(), f"MLI1_par path does not exist ({MLI1_par})")
        if MLI2_par is not None:
            self._validate("rdc_trans", MLI2_par == "-" or Path(MLI2_par).exists(), f"MLI2_par path does not exist ({MLI2_par})")

    def _mock_rdc_trans_outputs(self, MLI1_par: str, DEM_RDC, MLI2_par: str, lt: str):
        if lt is not None and lt != "-":
            Path(lt).touch()

    def rdc_trans(self, MLI1_par: str, DEM_RDC, MLI2_par: str, lt: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rdc_trans))

        if self.validate_inputs:
            self._validate_rdc_trans(*supplied_args)

        if self.mock_outputs:
            self._mock_rdc_trans_outputs(*supplied_args)

        return self._gamma_call("DIFF", "rdc_trans", supplied_args)


    def _validate_SLC_interp_lt_ScanSAR(self, SLC2_tab: str, SLC2_par: str, SLC1_tab: str, SLC1_par: str, lookup_table: str, MLI1_par: str, MLI2_par: str, OFF_par: str, SLC2R_tab: str, SLC_2R: str = None, SLC2R_par: str = None, mode = None, order = None, SLC2R_dir = None):
        if SLC2_tab is not None:
            self._validate("SLC_interp_lt_ScanSAR", SLC2_tab == "-" or Path(SLC2_tab).exists(), f"SLC2_tab path does not exist ({SLC2_tab})")
        if SLC2_par is not None:
            self._validate("SLC_interp_lt_ScanSAR", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if SLC1_tab is not None:
            self._validate("SLC_interp_lt_ScanSAR", SLC1_tab == "-" or Path(SLC1_tab).exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        if SLC1_par is not None:
            self._validate("SLC_interp_lt_ScanSAR", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if lookup_table is not None:
            self._validate("SLC_interp_lt_ScanSAR", lookup_table == "-" or Path(lookup_table).exists(), f"lookup_table path does not exist ({lookup_table})")
        if MLI1_par is not None:
            self._validate("SLC_interp_lt_ScanSAR", MLI1_par == "-" or Path(MLI1_par).exists(), f"MLI1_par path does not exist ({MLI1_par})")
        if MLI2_par is not None:
            self._validate("SLC_interp_lt_ScanSAR", MLI2_par == "-" or Path(MLI2_par).exists(), f"MLI2_par path does not exist ({MLI2_par})")
        if OFF_par is not None:
            self._validate("SLC_interp_lt_ScanSAR", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_interp_lt_ScanSAR", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_SLC_interp_lt_ScanSAR_outputs(self, SLC2_tab: str, SLC2_par: str, SLC1_tab: str, SLC1_par: str, lookup_table: str, MLI1_par: str, MLI2_par: str, OFF_par: str, SLC2R_tab: str, SLC_2R: str = None, SLC2R_par: str = None, mode = None, order = None, SLC2R_dir = None):
        if SLC2R_tab is not None and SLC2R_tab != "-" and not Path(SLC2R_tab).exists():
            Path(SLC2R_tab).touch()
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()

    def SLC_interp_lt_ScanSAR(self, SLC2_tab: str, SLC2_par: str, SLC1_tab: str, SLC1_par: str, lookup_table: str, MLI1_par: str, MLI2_par: str, OFF_par: str, SLC2R_tab: str, SLC_2R: str = None, SLC2R_par: str = None, mode = None, order = None, SLC2R_dir = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp_lt_ScanSAR))

        if self.validate_inputs:
            self._validate_SLC_interp_lt_ScanSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_interp_lt_ScanSAR_outputs(*supplied_args)

        return self._gamma_call("DIFF", "SLC_interp_lt_ScanSAR", supplied_args)


    def _validate_par_CS_geo(self, HDF5: str, MLI_par: str):
        if HDF5 is not None:
            self._validate("par_CS_geo", HDF5 == "-" or Path(HDF5).exists(), f"HDF5 path does not exist ({HDF5})")
        if MLI_par is not None:
            self._validate("par_CS_geo", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")

    def _mock_par_CS_geo_outputs(self, HDF5: str, MLI_par: str):
        pass

    def par_CS_geo(self, HDF5: str, MLI_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_CS_geo))

        if self.validate_inputs:
            self._validate_par_CS_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_par_CS_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "par_CS_geo", supplied_args)


    def _validate_par_RCM_geo(self, RCM_dir: str, polarization, MLI_par: str, DEM_par: str, GEO: str, dtype = None, ps = None):
        if RCM_dir is not None:
            self._validate("par_RCM_geo", RCM_dir == "-" or Path(RCM_dir).exists(), f"RCM_dir path does not exist ({RCM_dir})")
        valid_values = [0, 1] + [None]
        self._validate("par_RCM_geo", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_par_RCM_geo_outputs(self, RCM_dir: str, polarization, MLI_par: str, DEM_par: str, GEO: str, dtype = None, ps = None):
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if GEO is not None and GEO != "-":
            Path(GEO).touch()

    def par_RCM_geo(self, RCM_dir: str, polarization, MLI_par: str, DEM_par: str, GEO: str, dtype = None, ps = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_geo))

        if self.validate_inputs:
            self._validate_par_RCM_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RCM_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "par_RCM_geo", supplied_args)


    def _validate_offset_pwr_trackingm2(self, MLI_1: str, MLI_2: str, DIFF_par: str, offs: str, ccp: str, DIFF_par2: str = None, offs2: str = None, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, bw_frac = None, pflag = None, pltflg = None, ccs: str = None, std_mean = None):
        if MLI_1 is not None:
            self._validate("offset_pwr_trackingm2", MLI_1 == "-" or Path(MLI_1).exists(), f"MLI_1 path does not exist ({MLI_1})")
        if MLI_2 is not None:
            self._validate("offset_pwr_trackingm2", MLI_2 == "-" or Path(MLI_2).exists(), f"MLI_2 path does not exist ({MLI_2})")
        if DIFF_par is not None:
            self._validate("offset_pwr_trackingm2", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")
        if DIFF_par2 is not None:
            self._validate("offset_pwr_trackingm2", DIFF_par2 == "-" or Path(DIFF_par2).exists(), f"DIFF_par2 path does not exist ({DIFF_par2})")
        if offs2 is not None:
            self._validate("offset_pwr_trackingm2", offs2 == "-" or Path(offs2).exists(), f"offs2 path does not exist ({offs2})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_trackingm2", pflag == "-" or pflag in valid_values, f"pflag is not a valid value (expects: {valid_values}, got: {pflag})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("offset_pwr_trackingm2", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_offset_pwr_trackingm2_outputs(self, MLI_1: str, MLI_2: str, DIFF_par: str, offs: str, ccp: str, DIFF_par2: str = None, offs2: str = None, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, bw_frac = None, pflag = None, pltflg = None, ccs: str = None, std_mean = None):
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        if ccs is not None and ccs != "-":
            Path(ccs).touch()

    def offset_pwr_trackingm2(self, MLI_1: str, MLI_2: str, DIFF_par: str, offs: str, ccp: str, DIFF_par2: str = None, offs2: str = None, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, bw_frac = None, pflag = None, pltflg = None, ccs: str = None, std_mean = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_trackingm2))

        if self.validate_inputs:
            self._validate_offset_pwr_trackingm2(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_pwr_trackingm2_outputs(*supplied_args)

        return self._gamma_call("DIFF", "offset_pwr_trackingm2", supplied_args)


    def _validate_init_offset_orbitm(self, MLI1_par: str, MLI2_par: str, DIFF_par: str, rpos = None, azpos = None, cflag = None):
        if MLI1_par is not None:
            self._validate("init_offset_orbitm", MLI1_par == "-" or Path(MLI1_par).exists(), f"MLI1_par path does not exist ({MLI1_par})")
        if MLI2_par is not None:
            self._validate("init_offset_orbitm", MLI2_par == "-" or Path(MLI2_par).exists(), f"MLI2_par path does not exist ({MLI2_par})")
        valid_values = [0, 1] + [None]
        self._validate("init_offset_orbitm", cflag == "-" or cflag in valid_values, f"cflag is not a valid value (expects: {valid_values}, got: {cflag})")

    def _mock_init_offset_orbitm_outputs(self, MLI1_par: str, MLI2_par: str, DIFF_par: str, rpos = None, azpos = None, cflag = None):
        if DIFF_par is not None and DIFF_par != "-" and not Path(DIFF_par).exists():
            Path(DIFF_par).touch()

    def init_offset_orbitm(self, MLI1_par: str, MLI2_par: str, DIFF_par: str, rpos = None, azpos = None, cflag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.init_offset_orbitm))

        if self.validate_inputs:
            self._validate_init_offset_orbitm(*supplied_args)

        if self.mock_outputs:
            self._mock_init_offset_orbitm_outputs(*supplied_args)

        return self._gamma_call("DIFF", "init_offset_orbitm", supplied_args)


    def _validate_quad_fit(self, unw, DIFF_par, dr = None, daz = None, mask = None, plot_data: str = None, model = None, pmodel: str = None):
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7] + [None]
        self._validate("quad_fit", model == "-" or model in valid_values, f"model is not a valid value (expects: {valid_values}, got: {model})")

    def _mock_quad_fit_outputs(self, unw, DIFF_par, dr = None, daz = None, mask = None, plot_data: str = None, model = None, pmodel: str = None):
        if plot_data is not None and plot_data != "-":
            Path(plot_data).touch()
        if pmodel is not None and pmodel != "-":
            Path(pmodel).touch()

    def quad_fit(self, unw, DIFF_par, dr = None, daz = None, mask = None, plot_data: str = None, model = None, pmodel: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.quad_fit))

        if self.validate_inputs:
            self._validate_quad_fit(*supplied_args)

        if self.mock_outputs:
            self._mock_quad_fit_outputs(*supplied_args)

        return self._gamma_call("DIFF", "quad_fit", supplied_args)


    def _validate_stacking(self, DIFF_tab, width, ph_rate: str, sig_ph_rate: str, sig_ph: str, roff, loff, nr = None, nl = None, np_min = None, tscale = None):
        valid_values = [0, 1] + [None]
        self._validate("stacking", tscale == "-" or tscale in valid_values, f"tscale is not a valid value (expects: {valid_values}, got: {tscale})")

    def _mock_stacking_outputs(self, DIFF_tab, width, ph_rate: str, sig_ph_rate: str, sig_ph: str, roff, loff, nr = None, nl = None, np_min = None, tscale = None):
        if ph_rate is not None and ph_rate != "-":
            Path(ph_rate).touch()
        if sig_ph_rate is not None and sig_ph_rate != "-":
            Path(sig_ph_rate).touch()
        if sig_ph is not None and sig_ph != "-":
            Path(sig_ph).touch()

    def stacking(self, DIFF_tab, width, ph_rate: str, sig_ph_rate: str, sig_ph: str, roff, loff, nr = None, nl = None, np_min = None, tscale = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.stacking))

        if self.validate_inputs:
            self._validate_stacking(*supplied_args)

        if self.mock_outputs:
            self._mock_stacking_outputs(*supplied_args)

        return self._gamma_call("DIFF", "stacking", supplied_args)


    def _validate_atm_mod2(self, diff_unw, hgt: str, MLI_par: str, model: str, dr = None, daz = None, mask: str = None, mode = None, roff = None, loff = None, report: str = None):
        if hgt is not None:
            self._validate("atm_mod2", hgt == "-" or Path(hgt).exists(), f"hgt path does not exist ({hgt})")
        if MLI_par is not None:
            self._validate("atm_mod2", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if mask is not None:
            self._validate("atm_mod2", mask == "-" or Path(mask).exists(), f"mask path does not exist ({mask})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("atm_mod2", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_atm_mod2_outputs(self, diff_unw, hgt: str, MLI_par: str, model: str, dr = None, daz = None, mask: str = None, mode = None, roff = None, loff = None, report: str = None):
        if model is not None and model != "-":
            Path(model).touch()
        if report is not None and report != "-":
            Path(report).touch()

    def atm_mod2(self, diff_unw, hgt: str, MLI_par: str, model: str, dr = None, daz = None, mask: str = None, mode = None, roff = None, loff = None, report: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.atm_mod2))

        if self.validate_inputs:
            self._validate_atm_mod2(*supplied_args)

        if self.mock_outputs:
            self._mock_atm_mod2_outputs(*supplied_args)

        return self._gamma_call("DIFF", "atm_mod2", supplied_args)


    def _validate_par_UAVSAR_geo(self, ann: str, SLC_MLI_par: str, DEM_par: str):
        if ann is not None:
            self._validate("par_UAVSAR_geo", ann == "-" or Path(ann).exists(), f"ann path does not exist ({ann})")

    def _mock_par_UAVSAR_geo_outputs(self, ann: str, SLC_MLI_par: str, DEM_par: str):
        if SLC_MLI_par is not None and SLC_MLI_par != "-":
            Path(SLC_MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()

    def par_UAVSAR_geo(self, ann: str, SLC_MLI_par: str, DEM_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_UAVSAR_geo))

        if self.validate_inputs:
            self._validate_par_UAVSAR_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_par_UAVSAR_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "par_UAVSAR_geo", supplied_args)


    def _validate_dem_import(self, input_DEM: str, DEM: str, DEM_par: str, input_type = None, priority = None, geoid: str = None, geoid_par: str = None, geoid_type = None, latN_shift = None, lonE_shift = None, zflg = None, no_data = None):
        if input_DEM is not None:
            self._validate("dem_import", input_DEM == "-" or Path(input_DEM).exists(), f"input_DEM path does not exist ({input_DEM})")
        valid_values = [0, 1, 2, 3, 4] + [None]
        self._validate("dem_import", input_type == "-" or input_type in valid_values, f"input_type is not a valid value (expects: {valid_values}, got: {input_type})")
        valid_values = [0, 1] + [None]
        self._validate("dem_import", priority == "-" or priority in valid_values, f"priority is not a valid value (expects: {valid_values}, got: {priority})")
        if geoid is not None:
            self._validate("dem_import", geoid == "-" or Path(geoid).exists(), f"geoid path does not exist ({geoid})")
        if geoid_par is not None:
            self._validate("dem_import", geoid_par == "-" or Path(geoid_par).exists(), f"geoid_par path does not exist ({geoid_par})")
        valid_values = [0, 1] + [None]
        self._validate("dem_import", geoid_type == "-" or geoid_type in valid_values, f"geoid_type is not a valid value (expects: {valid_values}, got: {geoid_type})")
        valid_values = [0, 1] + [None]
        self._validate("dem_import", zflg == "-" or zflg in valid_values, f"zflg is not a valid value (expects: {valid_values}, got: {zflg})")

    def _mock_dem_import_outputs(self, input_DEM: str, DEM: str, DEM_par: str, input_type = None, priority = None, geoid: str = None, geoid_par: str = None, geoid_type = None, latN_shift = None, lonE_shift = None, zflg = None, no_data = None):
        if DEM is not None and DEM != "-":
            Path(DEM).touch()
        if DEM_par is not None and DEM_par != "-" and not Path(DEM_par).exists():
            Path(DEM_par).touch()

    def dem_import(self, input_DEM: str, DEM: str, DEM_par: str, input_type = None, priority = None, geoid: str = None, geoid_par: str = None, geoid_type = None, latN_shift = None, lonE_shift = None, zflg = None, no_data = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_import))

        if self.validate_inputs:
            self._validate_dem_import(*supplied_args)

        if self.mock_outputs:
            self._mock_dem_import_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dem_import", supplied_args)


    def _validate_SLC_interp_lt(self, SLC_2: str, SLC1_par: str, SLC2_par: str, lookup_table: str, MLI1_par: str, MLI2_par: str, OFF_par: str, SLC_2R: str, SLC2R_par: str, blk_size = None, mode = None):
        if SLC_2 is not None:
            self._validate("SLC_interp_lt", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("SLC_interp_lt", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("SLC_interp_lt", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if lookup_table is not None:
            self._validate("SLC_interp_lt", lookup_table == "-" or Path(lookup_table).exists(), f"lookup_table path does not exist ({lookup_table})")
        if MLI1_par is not None:
            self._validate("SLC_interp_lt", MLI1_par == "-" or Path(MLI1_par).exists(), f"MLI1_par path does not exist ({MLI1_par})")
        if MLI2_par is not None:
            self._validate("SLC_interp_lt", MLI2_par == "-" or Path(MLI2_par).exists(), f"MLI2_par path does not exist ({MLI2_par})")
        if OFF_par is not None:
            self._validate("SLC_interp_lt", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_interp_lt", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_SLC_interp_lt_outputs(self, SLC_2: str, SLC1_par: str, SLC2_par: str, lookup_table: str, MLI1_par: str, MLI2_par: str, OFF_par: str, SLC_2R: str, SLC2R_par: str, blk_size = None, mode = None):
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()

    def SLC_interp_lt(self, SLC_2: str, SLC1_par: str, SLC2_par: str, lookup_table: str, MLI1_par: str, MLI2_par: str, OFF_par: str, SLC_2R: str, SLC2R_par: str, blk_size = None, mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp_lt))

        if self.validate_inputs:
            self._validate_SLC_interp_lt(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_interp_lt_outputs(*supplied_args)

        return self._gamma_call("DIFF", "SLC_interp_lt", supplied_args)


    def _validate_dispmap(self, unw, hgt, MLI_par: str, OFF_par: str, disp_map: str, mode = None, sflg = None):
        if MLI_par is not None:
            self._validate("dispmap", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if OFF_par is not None:
            self._validate("dispmap", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_dispmap_outputs(self, unw, hgt, MLI_par: str, OFF_par: str, disp_map: str, mode = None, sflg = None):
        if disp_map is not None and disp_map != "-":
            Path(disp_map).touch()

    def dispmap(self, unw, hgt, MLI_par: str, OFF_par: str, disp_map: str, mode = None, sflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap))

        if self.validate_inputs:
            self._validate_dispmap(*supplied_args)

        if self.mock_outputs:
            self._mock_dispmap_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dispmap", supplied_args)


    def _validate_atm_mod(self, diff_unw, hgt: str, DIFF_par, model: str, dr = None, daz = None, mask: str = None, mode = None, roff = None, loff = None):
        if hgt is not None:
            self._validate("atm_mod", hgt == "-" or Path(hgt).exists(), f"hgt path does not exist ({hgt})")
        if mask is not None:
            self._validate("atm_mod", mask == "-" or Path(mask).exists(), f"mask path does not exist ({mask})")
        valid_values = [0, 1] + [None]
        self._validate("atm_mod", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_atm_mod_outputs(self, diff_unw, hgt: str, DIFF_par, model: str, dr = None, daz = None, mask: str = None, mode = None, roff = None, loff = None):
        if model is not None and model != "-":
            Path(model).touch()

    def atm_mod(self, diff_unw, hgt: str, DIFF_par, model: str, dr = None, daz = None, mask: str = None, mode = None, roff = None, loff = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.atm_mod))

        if self.validate_inputs:
            self._validate_atm_mod(*supplied_args)

        if self.mock_outputs:
            self._mock_atm_mod_outputs(*supplied_args)

        return self._gamma_call("DIFF", "atm_mod", supplied_args)


    def _validate_dispmap_LOS(self, unw, width, freq, disp_map: str, sflg = None):
        pass

    def _mock_dispmap_LOS_outputs(self, unw, width, freq, disp_map: str, sflg = None):
        if disp_map is not None and disp_map != "-":
            Path(disp_map).touch()

    def dispmap_LOS(self, unw, width, freq, disp_map: str, sflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_LOS))

        if self.validate_inputs:
            self._validate_dispmap_LOS(*supplied_args)

        if self.mock_outputs:
            self._mock_dispmap_LOS_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dispmap_LOS", supplied_args)


    def _validate_sub_phase(self, int_1: str, unw_2: str, DIFF_par: str, diff_int: str, dtype, mode = None):
        if int_1 is not None:
            self._validate("sub_phase", int_1 == "-" or Path(int_1).exists(), f"int_1 path does not exist ({int_1})")
        if unw_2 is not None:
            self._validate("sub_phase", unw_2 == "-" or Path(unw_2).exists(), f"unw_2 path does not exist ({unw_2})")
        if DIFF_par is not None:
            self._validate("sub_phase", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")
        valid_values = [0, 1, 2]
        self._validate("sub_phase", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1] + [None]
        self._validate("sub_phase", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_sub_phase_outputs(self, int_1: str, unw_2: str, DIFF_par: str, diff_int: str, dtype, mode = None):
        if diff_int is not None and diff_int != "-":
            Path(diff_int).touch()

    def sub_phase(self, int_1: str, unw_2: str, DIFF_par: str, diff_int: str, dtype, mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sub_phase))

        if self.validate_inputs:
            self._validate_sub_phase(*supplied_args)

        if self.mock_outputs:
            self._mock_sub_phase_outputs(*supplied_args)

        return self._gamma_call("DIFF", "sub_phase", supplied_args)


    def _validate_phase_sim(self, SLC1_par: str, OFF_par: str, baseline: str, hgt, sim_unw: str, ph_flag = None, bflag = None, definition = None, delta_t = None, int_mode = None, SLC2R_par: str = None, ph_mode = None):
        if SLC1_par is not None:
            self._validate("phase_sim", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if OFF_par is not None:
            self._validate("phase_sim", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if baseline is not None:
            self._validate("phase_sim", baseline == "-" or Path(baseline).exists(), f"baseline path does not exist ({baseline})")
        valid_values = [0, 1] + [None]
        self._validate("phase_sim", ph_flag == "-" or ph_flag in valid_values, f"ph_flag is not a valid value (expects: {valid_values}, got: {ph_flag})")
        valid_values = [0, 1] + [None]
        self._validate("phase_sim", bflag == "-" or bflag in valid_values, f"bflag is not a valid value (expects: {valid_values}, got: {bflag})")
        valid_values = [0, 1] + [None]
        self._validate("phase_sim", int_mode == "-" or int_mode in valid_values, f"int_mode is not a valid value (expects: {valid_values}, got: {int_mode})")
        if SLC2R_par is not None:
            self._validate("phase_sim", SLC2R_par == "-" or Path(SLC2R_par).exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        valid_values = [0, 1] + [None]
        self._validate("phase_sim", ph_mode == "-" or ph_mode in valid_values, f"ph_mode is not a valid value (expects: {valid_values}, got: {ph_mode})")

    def _mock_phase_sim_outputs(self, SLC1_par: str, OFF_par: str, baseline: str, hgt, sim_unw: str, ph_flag = None, bflag = None, definition = None, delta_t = None, int_mode = None, SLC2R_par: str = None, ph_mode = None):
        if sim_unw is not None and sim_unw != "-":
            Path(sim_unw).touch()

    def phase_sim(self, SLC1_par: str, OFF_par: str, baseline: str, hgt, sim_unw: str, ph_flag = None, bflag = None, definition = None, delta_t = None, int_mode = None, SLC2R_par: str = None, ph_mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.phase_sim))

        if self.validate_inputs:
            self._validate_phase_sim(*supplied_args)

        if self.mock_outputs:
            self._mock_phase_sim_outputs(*supplied_args)

        return self._gamma_call("DIFF", "phase_sim", supplied_args)


    def _validate_par_RISAT_geo(self, annotation_XML: str, GeoTIFF: str, polarization, DEM_par: str, MLI_par: str, MLI: str):
        if annotation_XML is not None:
            self._validate("par_RISAT_geo", annotation_XML == "-" or Path(annotation_XML).exists(), f"annotation_XML path does not exist ({annotation_XML})")
        if GeoTIFF is not None:
            self._validate("par_RISAT_geo", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")

    def _mock_par_RISAT_geo_outputs(self, annotation_XML: str, GeoTIFF: str, polarization, DEM_par: str, MLI_par: str, MLI: str):
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()

    def par_RISAT_geo(self, annotation_XML: str, GeoTIFF: str, polarization, DEM_par: str, MLI_par: str, MLI: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RISAT_geo))

        if self.validate_inputs:
            self._validate_par_RISAT_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RISAT_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "par_RISAT_geo", supplied_args)


    def _validate_MLI_interp_lt(self, MLI_2: str, MLI1_par: str, MLI2_par: str, lookup_table: str, MLI3_par: str, MLI4_par: str, DIFF_par: str, MLI_2R: str, MLI2R_par: str, order = None):
        if MLI_2 is not None:
            self._validate("MLI_interp_lt", MLI_2 == "-" or Path(MLI_2).exists(), f"MLI_2 path does not exist ({MLI_2})")
        if MLI1_par is not None:
            self._validate("MLI_interp_lt", MLI1_par == "-" or Path(MLI1_par).exists(), f"MLI1_par path does not exist ({MLI1_par})")
        if MLI2_par is not None:
            self._validate("MLI_interp_lt", MLI2_par == "-" or Path(MLI2_par).exists(), f"MLI2_par path does not exist ({MLI2_par})")
        if lookup_table is not None:
            self._validate("MLI_interp_lt", lookup_table == "-" or Path(lookup_table).exists(), f"lookup_table path does not exist ({lookup_table})")
        if MLI3_par is not None:
            self._validate("MLI_interp_lt", MLI3_par == "-" or Path(MLI3_par).exists(), f"MLI3_par path does not exist ({MLI3_par})")
        if MLI4_par is not None:
            self._validate("MLI_interp_lt", MLI4_par == "-" or Path(MLI4_par).exists(), f"MLI4_par path does not exist ({MLI4_par})")
        if DIFF_par is not None:
            self._validate("MLI_interp_lt", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_MLI_interp_lt_outputs(self, MLI_2: str, MLI1_par: str, MLI2_par: str, lookup_table: str, MLI3_par: str, MLI4_par: str, DIFF_par: str, MLI_2R: str, MLI2R_par: str, order = None):
        if MLI_2R is not None and MLI_2R != "-":
            Path(MLI_2R).touch()
        if MLI2R_par is not None and MLI2R_par != "-":
            Path(MLI2R_par).touch()

    def MLI_interp_lt(self, MLI_2: str, MLI1_par: str, MLI2_par: str, lookup_table: str, MLI3_par: str, MLI4_par: str, DIFF_par: str, MLI_2R: str, MLI2R_par: str, order = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.MLI_interp_lt))

        if self.validate_inputs:
            self._validate_MLI_interp_lt(*supplied_args)

        if self.mock_outputs:
            self._mock_MLI_interp_lt_outputs(*supplied_args)

        return self._gamma_call("DIFF", "MLI_interp_lt", supplied_args)


    def _validate_lk_vec_lt(self, MLI_par: str, DEM_par: str, DEM: str, lt: str, lv_theta: str, lv_phi: str, lv_ENU: str = None, azv_ENU: str = None):
        if MLI_par is not None:
            self._validate("lk_vec_lt", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if DEM_par is not None:
            self._validate("lk_vec_lt", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("lk_vec_lt", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        if lt is not None:
            self._validate("lk_vec_lt", lt == "-" or Path(lt).exists(), f"lt path does not exist ({lt})")

    def _mock_lk_vec_lt_outputs(self, MLI_par: str, DEM_par: str, DEM: str, lt: str, lv_theta: str, lv_phi: str, lv_ENU: str = None, azv_ENU: str = None):
        if lv_theta is not None and lv_theta != "-":
            Path(lv_theta).touch()
        if lv_phi is not None and lv_phi != "-":
            Path(lv_phi).touch()
        if lv_ENU is not None and lv_ENU != "-":
            Path(lv_ENU).touch()
        if azv_ENU is not None and azv_ENU != "-":
            Path(azv_ENU).touch()

    def lk_vec_lt(self, MLI_par: str, DEM_par: str, DEM: str, lt: str, lv_theta: str, lv_phi: str, lv_ENU: str = None, azv_ENU: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lk_vec_lt))

        if self.validate_inputs:
            self._validate_lk_vec_lt(*supplied_args)

        if self.mock_outputs:
            self._mock_lk_vec_lt_outputs(*supplied_args)

        return self._gamma_call("DIFF", "lk_vec_lt", supplied_args)


    def _validate_coord_to_sarpix(self, SLC_par: str, OFF_par: str, DEM_par: str, north_lat, east_lon, hgt=None, DIFF_par = None):
        if SLC_par is not None:
            self._validate("coord_to_sarpix", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("coord_to_sarpix", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if DEM_par is not None:
            self._validate("coord_to_sarpix", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_coord_to_sarpix_outputs(self, SLC_par: str, OFF_par: str, DEM_par: str, north_lat, east_lon, hgt, DIFF_par = None):
        pass

    def coord_to_sarpix(self, SLC_par: str, OFF_par: str, DEM_par: str, north_lat, east_lon, hgt, DIFF_par = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.coord_to_sarpix))

        if self.validate_inputs:
            self._validate_coord_to_sarpix(*supplied_args)

        if self.mock_outputs:
            self._mock_coord_to_sarpix_outputs(*supplied_args)

        return self._gamma_call("DIFF", "coord_to_sarpix", supplied_args)


    def _validate_WSS_intf(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, OFF_par: str, interf: str, rlks = None, sps_flg = None, azf_flg = None, m_flg = None, boff = None, bstep = None, bmax = None):
        if SLC_1 is not None:
            self._validate("WSS_intf", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2R is not None:
            self._validate("WSS_intf", SLC_2R == "-" or Path(SLC_2R).exists(), f"SLC_2R path does not exist ({SLC_2R})")
        if SLC1_par is not None:
            self._validate("WSS_intf", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2R_par is not None:
            self._validate("WSS_intf", SLC2R_par == "-" or Path(SLC2R_par).exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        valid_values = [1, 0] + [None]
        self._validate("WSS_intf", sps_flg == "-" or sps_flg in valid_values, f"sps_flg is not a valid value (expects: {valid_values}, got: {sps_flg})")
        valid_values = [1, 0] + [None]
        self._validate("WSS_intf", azf_flg == "-" or azf_flg in valid_values, f"azf_flg is not a valid value (expects: {valid_values}, got: {azf_flg})")
        valid_values = [0, 1] + [None]
        self._validate("WSS_intf", m_flg == "-" or m_flg in valid_values, f"m_flg is not a valid value (expects: {valid_values}, got: {m_flg})")

    def _mock_WSS_intf_outputs(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, OFF_par: str, interf: str, rlks = None, sps_flg = None, azf_flg = None, m_flg = None, boff = None, bstep = None, bmax = None):
        if OFF_par is not None and OFF_par != "-":
            Path(OFF_par).touch()
        if interf is not None and interf != "-":
            Path(interf).touch()

    def WSS_intf(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, OFF_par: str, interf: str, rlks = None, sps_flg = None, azf_flg = None, m_flg = None, boff = None, bstep = None, bmax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.WSS_intf))

        if self.validate_inputs:
            self._validate_WSS_intf(*supplied_args)

        if self.mock_outputs:
            self._mock_WSS_intf_outputs(*supplied_args)

        return self._gamma_call("DIFF", "WSS_intf", supplied_args)


    def _validate_map_section(self, DEM_par: str, n1, e1, n2, e2, post_north, post_east, DEM_par2: str, lt: str = None, MLI_par1: str = None, MLI_par2: str = None, cflg = None, lt2: str = None, MLI_coord: str = None):
        if DEM_par is not None:
            self._validate("map_section", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if lt is not None:
            self._validate("map_section", lt == "-" or Path(lt).exists(), f"lt path does not exist ({lt})")
        if MLI_par1 is not None:
            self._validate("map_section", MLI_par1 == "-" or Path(MLI_par1).exists(), f"MLI_par1 path does not exist ({MLI_par1})")
        if MLI_par2 is not None:
            self._validate("map_section", MLI_par2 == "-" or Path(MLI_par2).exists(), f"MLI_par2 path does not exist ({MLI_par2})")

    def _mock_map_section_outputs(self, DEM_par: str, n1, e1, n2, e2, post_north, post_east, DEM_par2: str, lt: str = None, MLI_par1: str = None, MLI_par2: str = None, cflg = None, lt2: str = None, MLI_coord: str = None):
        if DEM_par2 is not None and DEM_par2 != "-":
            Path(DEM_par2).touch()
        if lt2 is not None and lt2 != "-":
            Path(lt2).touch()
        if MLI_coord is not None and MLI_coord != "-":
            Path(MLI_coord).touch()

    def map_section(self, DEM_par: str, n1, e1, n2, e2, post_north, post_east, DEM_par2: str, lt: str = None, MLI_par1: str = None, MLI_par2: str = None, cflg = None, lt2: str = None, MLI_coord: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.map_section))

        if self.validate_inputs:
            self._validate_map_section(*supplied_args)

        if self.mock_outputs:
            self._mock_map_section_outputs(*supplied_args)

        return self._gamma_call("DIFF", "map_section", supplied_args)


    def _validate_offset_list_fitm(self, cp_list: str, DIFF_par: str, DEM_par: str, lookup_table: str = None, lt_type = None, type1 = None, type2 = None, coffsets: str = None, poly_order = None, interact_flag = None, trans_list = None):
        if cp_list is not None:
            self._validate("offset_list_fitm", cp_list == "-" or Path(cp_list).exists(), f"cp_list path does not exist ({cp_list})")
        if DEM_par is not None:
            self._validate("offset_list_fitm", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if lookup_table is not None:
            self._validate("offset_list_fitm", lookup_table == "-" or Path(lookup_table).exists(), f"lookup_table path does not exist ({lookup_table})")
        valid_values = [1, 2] + [None]
        self._validate("offset_list_fitm", lt_type == "-" or lt_type in valid_values, f"lt_type is not a valid value (expects: {valid_values}, got: {lt_type})")
        valid_values = [1, 2, 3] + [None]
        self._validate("offset_list_fitm", type1 == "-" or type1 in valid_values, f"type1 is not a valid value (expects: {valid_values}, got: {type1})")
        valid_values = [1, 2, 3] + [None]
        self._validate("offset_list_fitm", type2 == "-" or type2 in valid_values, f"type2 is not a valid value (expects: {valid_values}, got: {type2})")

    def _mock_offset_list_fitm_outputs(self, cp_list: str, DIFF_par: str, DEM_par: str, lookup_table: str = None, lt_type = None, type1 = None, type2 = None, coffsets: str = None, poly_order = None, interact_flag = None, trans_list = None):
        if DIFF_par is not None and DIFF_par != "-" and not Path(DIFF_par).exists():
            Path(DIFF_par).touch()
        if coffsets is not None and coffsets != "-":
            Path(coffsets).touch()

    def offset_list_fitm(self, cp_list: str, DIFF_par: str, DEM_par: str, lookup_table: str = None, lt_type = None, type1 = None, type2 = None, coffsets: str = None, poly_order = None, interact_flag = None, trans_list = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_list_fitm))

        if self.validate_inputs:
            self._validate_offset_list_fitm(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_list_fitm_outputs(*supplied_args)

        return self._gamma_call("DIFF", "offset_list_fitm", supplied_args)


    def _validate_dem_RDC_list(self, DEM_par1: str, gc_map: str, MLI_par: str, mask: str, clist_RDC: str, clist_MAP: str, DEM_par2: str, s_north, s_east):
        if DEM_par1 is not None:
            self._validate("dem_RDC_list", DEM_par1 == "-" or Path(DEM_par1).exists(), f"DEM_par1 path does not exist ({DEM_par1})")
        if gc_map is not None:
            self._validate("dem_RDC_list", gc_map == "-" or Path(gc_map).exists(), f"gc_map path does not exist ({gc_map})")
        if MLI_par is not None:
            self._validate("dem_RDC_list", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if mask is not None:
            self._validate("dem_RDC_list", mask == "-" or Path(mask).exists(), f"mask path does not exist ({mask})")

    def _mock_dem_RDC_list_outputs(self, DEM_par1: str, gc_map: str, MLI_par: str, mask: str, clist_RDC: str, clist_MAP: str, DEM_par2: str, s_north, s_east):
        if clist_RDC is not None and clist_RDC != "-":
            Path(clist_RDC).touch()
        if clist_MAP is not None and clist_MAP != "-":
            Path(clist_MAP).touch()
        if DEM_par2 is not None and DEM_par2 != "-":
            Path(DEM_par2).touch()

    def dem_RDC_list(self, DEM_par1: str, gc_map: str, MLI_par: str, mask: str, clist_RDC: str, clist_MAP: str, DEM_par2: str, s_north, s_east):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_RDC_list))

        if self.validate_inputs:
            self._validate_dem_RDC_list(*supplied_args)

        if self.mock_outputs:
            self._mock_dem_RDC_list_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dem_RDC_list", supplied_args)


    def _validate_multi_look_geo(self, geo_SLC: str, SLC_DEM_par: str, MLI: str, MLI_DEM_par: str, e_lks, n_lks, dtype = None, scale = None, exp = None):
        if geo_SLC is not None:
            self._validate("multi_look_geo", geo_SLC == "-" or Path(geo_SLC).exists(), f"geo_SLC path does not exist ({geo_SLC})")
        if SLC_DEM_par is not None:
            self._validate("multi_look_geo", SLC_DEM_par == "-" or Path(SLC_DEM_par).exists(), f"SLC_DEM_par path does not exist ({SLC_DEM_par})")
        valid_values = [0, 1] + [None]
        self._validate("multi_look_geo", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_multi_look_geo_outputs(self, geo_SLC: str, SLC_DEM_par: str, MLI: str, MLI_DEM_par: str, e_lks, n_lks, dtype = None, scale = None, exp = None):
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_DEM_par is not None and MLI_DEM_par != "-":
            Path(MLI_DEM_par).touch()

    def multi_look_geo(self, geo_SLC: str, SLC_DEM_par: str, MLI: str, MLI_DEM_par: str, e_lks, n_lks, dtype = None, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look_geo))

        if self.validate_inputs:
            self._validate_multi_look_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_look_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "multi_look_geo", supplied_args)


    def _validate_WSS_interp_lt(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, lookup_table: str, MLI1_par: str, MLI2_par: str, DIFF_par1: str, SLC_2R: str, SLC2R_par: str, DIFF_par2: str):
        if SLC_1 is not None:
            self._validate("WSS_interp_lt", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("WSS_interp_lt", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("WSS_interp_lt", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("WSS_interp_lt", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if lookup_table is not None:
            self._validate("WSS_interp_lt", lookup_table == "-" or Path(lookup_table).exists(), f"lookup_table path does not exist ({lookup_table})")
        if MLI1_par is not None:
            self._validate("WSS_interp_lt", MLI1_par == "-" or Path(MLI1_par).exists(), f"MLI1_par path does not exist ({MLI1_par})")
        if MLI2_par is not None:
            self._validate("WSS_interp_lt", MLI2_par == "-" or Path(MLI2_par).exists(), f"MLI2_par path does not exist ({MLI2_par})")
        if DIFF_par1 is not None:
            self._validate("WSS_interp_lt", DIFF_par1 == "-" or Path(DIFF_par1).exists(), f"DIFF_par1 path does not exist ({DIFF_par1})")

    def _mock_WSS_interp_lt_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, lookup_table: str, MLI1_par: str, MLI2_par: str, DIFF_par1: str, SLC_2R: str, SLC2R_par: str, DIFF_par2: str):
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()
        if DIFF_par2 is not None and DIFF_par2 != "-":
            Path(DIFF_par2).touch()

    def WSS_interp_lt(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, lookup_table: str, MLI1_par: str, MLI2_par: str, DIFF_par1: str, SLC_2R: str, SLC2R_par: str, DIFF_par2: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.WSS_interp_lt))

        if self.validate_inputs:
            self._validate_WSS_interp_lt(*supplied_args)

        if self.mock_outputs:
            self._mock_WSS_interp_lt_outputs(*supplied_args)

        return self._gamma_call("DIFF", "WSS_interp_lt", supplied_args)


    def _validate_dispmap_vec2(self, DEM_par: str, DEM: str, dispmap1, lv1_theta: str, lv1_phi: str, dispmap2, lv2_theta: str, lv2_phi: str, dv_norm: str, dv_theta: str = None, dv_phi: str = None, dv_x: str = None, dv_y: str = None, dv_z: str = None, mask_angle = None, mode = None, ax_north = None, ax_east = None):
        if DEM_par is not None:
            self._validate("dispmap_vec2", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("dispmap_vec2", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        if lv1_theta is not None:
            self._validate("dispmap_vec2", lv1_theta == "-" or Path(lv1_theta).exists(), f"lv1_theta path does not exist ({lv1_theta})")
        if lv1_phi is not None:
            self._validate("dispmap_vec2", lv1_phi == "-" or Path(lv1_phi).exists(), f"lv1_phi path does not exist ({lv1_phi})")
        if lv2_theta is not None:
            self._validate("dispmap_vec2", lv2_theta == "-" or Path(lv2_theta).exists(), f"lv2_theta path does not exist ({lv2_theta})")
        if lv2_phi is not None:
            self._validate("dispmap_vec2", lv2_phi == "-" or Path(lv2_phi).exists(), f"lv2_phi path does not exist ({lv2_phi})")
        valid_values = [0, 1, 2] + [None]
        self._validate("dispmap_vec2", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_dispmap_vec2_outputs(self, DEM_par: str, DEM: str, dispmap1, lv1_theta: str, lv1_phi: str, dispmap2, lv2_theta: str, lv2_phi: str, dv_norm: str, dv_theta: str = None, dv_phi: str = None, dv_x: str = None, dv_y: str = None, dv_z: str = None, mask_angle = None, mode = None, ax_north = None, ax_east = None):
        if dv_norm is not None and dv_norm != "-":
            Path(dv_norm).touch()
        if dv_theta is not None and dv_theta != "-":
            Path(dv_theta).touch()
        if dv_phi is not None and dv_phi != "-":
            Path(dv_phi).touch()
        if dv_x is not None and dv_x != "-":
            Path(dv_x).touch()
        if dv_y is not None and dv_y != "-":
            Path(dv_y).touch()
        if dv_z is not None and dv_z != "-":
            Path(dv_z).touch()

    def dispmap_vec2(self, DEM_par: str, DEM: str, dispmap1, lv1_theta: str, lv1_phi: str, dispmap2, lv2_theta: str, lv2_phi: str, dv_norm: str, dv_theta: str = None, dv_phi: str = None, dv_x: str = None, dv_y: str = None, dv_z: str = None, mask_angle = None, mode = None, ax_north = None, ax_east = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_vec2))

        if self.validate_inputs:
            self._validate_dispmap_vec2(*supplied_args)

        if self.mock_outputs:
            self._mock_dispmap_vec2_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dispmap_vec2", supplied_args)


    def _validate_diff_ls_unw(self, int_1: str, unw_2: str, DIFF_par, diff_int: str, int_type = None, ph_flag = None):
        if int_1 is not None:
            self._validate("diff_ls_unw", int_1 == "-" or Path(int_1).exists(), f"int_1 path does not exist ({int_1})")
        if unw_2 is not None:
            self._validate("diff_ls_unw", unw_2 == "-" or Path(unw_2).exists(), f"unw_2 path does not exist ({unw_2})")

    def _mock_diff_ls_unw_outputs(self, int_1: str, unw_2: str, DIFF_par, diff_int: str, int_type = None, ph_flag = None):
        if diff_int is not None and diff_int != "-":
            Path(diff_int).touch()

    def diff_ls_unw(self, int_1: str, unw_2: str, DIFF_par, diff_int: str, int_type = None, ph_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.diff_ls_unw))

        if self.validate_inputs:
            self._validate_diff_ls_unw(*supplied_args)

        if self.mock_outputs:
            self._mock_diff_ls_unw_outputs(*supplied_args)

        return self._gamma_call("DIFF", "diff_ls_unw", supplied_args)


    def _validate_offset_pwr_list(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, clist_RDC: str, clist_MAP: str, offs: str, ccp: str, nx, ny, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        if SLC_1 is not None:
            self._validate("offset_pwr_list", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("offset_pwr_list", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("offset_pwr_list", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("offset_pwr_list", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("offset_pwr_list", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if clist_RDC is not None:
            self._validate("offset_pwr_list", clist_RDC == "-" or Path(clist_RDC).exists(), f"clist_RDC path does not exist ({clist_RDC})")
        if clist_MAP is not None:
            self._validate("offset_pwr_list", clist_MAP == "-" or Path(clist_MAP).exists(), f"clist_MAP path does not exist ({clist_MAP})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_list", int_filt == "-" or int_filt in valid_values, f"int_filt is not a valid value (expects: {valid_values}, got: {int_filt})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_list", pflag == "-" or pflag in valid_values, f"pflag is not a valid value (expects: {valid_values}, got: {pflag})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("offset_pwr_list", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_offset_pwr_list_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, clist_RDC: str, clist_MAP: str, offs: str, ccp: str, nx, ny, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        if ccs is not None and ccs != "-":
            Path(ccs).touch()

    def offset_pwr_list(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, clist_RDC: str, clist_MAP: str, offs: str, ccp: str, nx, ny, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_list))

        if self.validate_inputs:
            self._validate_offset_pwr_list(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_pwr_list_outputs(*supplied_args)

        return self._gamma_call("DIFF", "offset_pwr_list", supplied_args)


    def _validate_geocode(self, lookup_table: str, data_in: str, width_in, data_out: str, width_out, nlines_out = None, interp_mode = None, dtype = None, lr_in = None, lr_out = None, n_ovr = None, rad_max = None, nintr = None):
        if lookup_table is not None:
            self._validate("geocode", lookup_table == "-" or Path(lookup_table).exists(), f"lookup_table path does not exist ({lookup_table})")
        if data_in is not None:
            self._validate("geocode", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        valid_values = [0, 1, 2, 3, 4] + [None]
        self._validate("geocode", interp_mode == "-" or interp_mode in valid_values, f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})")
        valid_values = [0, 1, 2, 3, 4, 5, 6] + [None]
        self._validate("geocode", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_geocode_outputs(self, lookup_table: str, data_in: str, width_in, data_out: str, width_out, nlines_out = None, interp_mode = None, dtype = None, lr_in = None, lr_out = None, n_ovr = None, rad_max = None, nintr = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def geocode(self, lookup_table: str, data_in: str, width_in, data_out: str, width_out, nlines_out = None, interp_mode = None, dtype = None, lr_in = None, lr_out = None, n_ovr = None, rad_max = None, nintr = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.geocode))

        if self.validate_inputs:
            self._validate_geocode(*supplied_args)

        if self.mock_outputs:
            self._mock_geocode_outputs(*supplied_args)

        return self._gamma_call("DIFF", "geocode", supplied_args)


    def _validate_par_TX_geo(self, annotation_XML: str, GeoTIFF: str, MLI_par: str, DEM_par: str, GEO: str, pol = None):
        if annotation_XML is not None:
            self._validate("par_TX_geo", annotation_XML == "-" or Path(annotation_XML).exists(), f"annotation_XML path does not exist ({annotation_XML})")
        if GeoTIFF is not None:
            self._validate("par_TX_geo", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")

    def _mock_par_TX_geo_outputs(self, annotation_XML: str, GeoTIFF: str, MLI_par: str, DEM_par: str, GEO: str, pol = None):
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if DEM_par is not None and DEM_par != "-":
            Path(DEM_par).touch()
        if GEO is not None and GEO != "-":
            Path(GEO).touch()

    def par_TX_geo(self, annotation_XML: str, GeoTIFF: str, MLI_par: str, DEM_par: str, GEO: str, pol = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_TX_geo))

        if self.validate_inputs:
            self._validate_par_TX_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_par_TX_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "par_TX_geo", supplied_args)


    def _validate_data2xyz(self, DEM_par: str, data, data_xyz: str, dflg = None):
        if DEM_par is not None:
            self._validate("data2xyz", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        valid_values = [0, 1] + [None]
        self._validate("data2xyz", dflg == "-" or dflg in valid_values, f"dflg is not a valid value (expects: {valid_values}, got: {dflg})")

    def _mock_data2xyz_outputs(self, DEM_par: str, data, data_xyz: str, dflg = None):
        if data_xyz is not None and data_xyz != "-":
            Path(data_xyz).touch()

    def data2xyz(self, DEM_par: str, data, data_xyz: str, dflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.data2xyz))

        if self.validate_inputs:
            self._validate_data2xyz(*supplied_args)

        if self.mock_outputs:
            self._mock_data2xyz_outputs(*supplied_args)

        return self._gamma_call("DIFF", "data2xyz", supplied_args)


    def _validate_ScanSAR_burst_diff_intf(self, SLC1_tab: str, SLC2R_tab: str, SIM_tab: str, DIFF_tab: str, SLCR_tab: str = None, DIFF_dir = None):
        if SLC1_tab is not None:
            self._validate("ScanSAR_burst_diff_intf", SLC1_tab == "-" or Path(SLC1_tab).exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        if SLC2R_tab is not None:
            self._validate("ScanSAR_burst_diff_intf", SLC2R_tab == "-" or Path(SLC2R_tab).exists(), f"SLC2R_tab path does not exist ({SLC2R_tab})")
        if SIM_tab is not None:
            self._validate("ScanSAR_burst_diff_intf", SIM_tab == "-" or Path(SIM_tab).exists(), f"SIM_tab path does not exist ({SIM_tab})")
        if SLCR_tab is not None:
            self._validate("ScanSAR_burst_diff_intf", SLCR_tab == "-" or Path(SLCR_tab).exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_ScanSAR_burst_diff_intf_outputs(self, SLC1_tab: str, SLC2R_tab: str, SIM_tab: str, DIFF_tab: str, SLCR_tab: str = None, DIFF_dir = None):
        if DIFF_tab is not None and DIFF_tab != "-" and not Path(DIFF_tab).exists():
            Path(DIFF_tab).touch()

    def ScanSAR_burst_diff_intf(self, SLC1_tab: str, SLC2R_tab: str, SIM_tab: str, DIFF_tab: str, SLCR_tab: str = None, DIFF_dir = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_diff_intf))

        if self.validate_inputs:
            self._validate_ScanSAR_burst_diff_intf(*supplied_args)

        if self.mock_outputs:
            self._mock_ScanSAR_burst_diff_intf_outputs(*supplied_args)

        return self._gamma_call("DIFF", "ScanSAR_burst_diff_intf", supplied_args)


    def _validate_dem_xyz(self, DEM_par: str, DEM: str, DEM_XYZ: str):
        if DEM_par is not None:
            self._validate("dem_xyz", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("dem_xyz", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")

    def _mock_dem_xyz_outputs(self, DEM_par: str, DEM: str, DEM_XYZ: str):
        if DEM_XYZ is not None and DEM_XYZ != "-":
            Path(DEM_XYZ).touch()

    def dem_xyz(self, DEM_par: str, DEM: str, DEM_XYZ: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_xyz))

        if self.validate_inputs:
            self._validate_dem_xyz(*supplied_args)

        if self.mock_outputs:
            self._mock_dem_xyz_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dem_xyz", supplied_args)


    def _validate_look_vector(self, SLC_par: str, OFF_par: str, DEM_par: str, DEM: str, lv_theta: str, lv_phi: str):
        if SLC_par is not None:
            self._validate("look_vector", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("look_vector", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if DEM_par is not None:
            self._validate("look_vector", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("look_vector", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")

    def _mock_look_vector_outputs(self, SLC_par: str, OFF_par: str, DEM_par: str, DEM: str, lv_theta: str, lv_phi: str):
        if lv_theta is not None and lv_theta != "-":
            Path(lv_theta).touch()
        if lv_phi is not None and lv_phi != "-":
            Path(lv_phi).touch()

    def look_vector(self, SLC_par: str, OFF_par: str, DEM_par: str, DEM: str, lv_theta: str, lv_phi: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.look_vector))

        if self.validate_inputs:
            self._validate_look_vector(*supplied_args)

        if self.mock_outputs:
            self._mock_look_vector_outputs(*supplied_args)

        return self._gamma_call("DIFF", "look_vector", supplied_args)


    def _validate_create_dem_par(self, DEM_par: str, SLC_par: str = None, terra_alt = None, delta_y = None, delta_x = None, EPSG = None, iflg = None):
        if SLC_par is not None:
            self._validate("create_dem_par", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        valid_values = [0, 1] + [None]
        self._validate("create_dem_par", iflg == "-" or iflg in valid_values, f"iflg is not a valid value (expects: {valid_values}, got: {iflg})")

    def _mock_create_dem_par_outputs(self, DEM_par: str, SLC_par: str = None, terra_alt = None, delta_y = None, delta_x = None, EPSG = None, iflg = None):
        if DEM_par is not None and DEM_par != "-" and not Path(DEM_par).exists():
            Path(DEM_par).touch()

    def create_dem_par(self, DEM_par: str, SLC_par: str = None, terra_alt = None, delta_y = None, delta_x = None, EPSG = None, iflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_dem_par))

        if self.validate_inputs:
            self._validate_create_dem_par(*supplied_args)

        if self.mock_outputs:
            self._mock_create_dem_par_outputs(*supplied_args)

        return self._gamma_call("DIFF", "create_dem_par", supplied_args)


    def _validate_dem_x_y_z(self, DEM_par: str, DEM: str, DEM_X: str, DEM_Y: str, DEM_Z: str, format_flag = None):
        if DEM_par is not None:
            self._validate("dem_x_y_z", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("dem_x_y_z", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        valid_values = [0, 1] + [None]
        self._validate("dem_x_y_z", format_flag == "-" or format_flag in valid_values, f"format_flag is not a valid value (expects: {valid_values}, got: {format_flag})")

    def _mock_dem_x_y_z_outputs(self, DEM_par: str, DEM: str, DEM_X: str, DEM_Y: str, DEM_Z: str, format_flag = None):
        if DEM_X is not None and DEM_X != "-":
            Path(DEM_X).touch()
        if DEM_Y is not None and DEM_Y != "-":
            Path(DEM_Y).touch()
        if DEM_Z is not None and DEM_Z != "-":
            Path(DEM_Z).touch()

    def dem_x_y_z(self, DEM_par: str, DEM: str, DEM_X: str, DEM_Y: str, DEM_Z: str, format_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_x_y_z))

        if self.validate_inputs:
            self._validate_dem_x_y_z(*supplied_args)

        if self.mock_outputs:
            self._mock_dem_x_y_z_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dem_x_y_z", supplied_args)


    def _validate_ras_clist(self, clist: str, ras_in: str, ras_out: str, xsf = None, ysf = None, r = None, g = None, b = None, xs = None, zflg = None):
        if clist is not None:
            self._validate("ras_clist", clist == "-" or Path(clist).exists(), f"clist path does not exist ({clist})")
        if ras_in is not None:
            self._validate("ras_clist", ras_in == "-" or Path(ras_in).exists(), f"ras_in path does not exist ({ras_in})")

    def _mock_ras_clist_outputs(self, clist: str, ras_in: str, ras_out: str, xsf = None, ysf = None, r = None, g = None, b = None, xs = None, zflg = None):
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()

    def ras_clist(self, clist: str, ras_in: str, ras_out: str, xsf = None, ysf = None, r = None, g = None, b = None, xs = None, zflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_clist))

        if self.validate_inputs:
            self._validate_ras_clist(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_clist_outputs(*supplied_args)

        return self._gamma_call("DIFF", "ras_clist", supplied_args)


    def _validate_dispmap_sim(self, LV: str, DEM_par: str, disp_east: str, disp_north: str, disp_up: str, disp_LOS: str):
        if LV is not None:
            self._validate("dispmap_sim", LV == "-" or Path(LV).exists(), f"LV path does not exist ({LV})")
        if DEM_par is not None:
            self._validate("dispmap_sim", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if disp_east is not None:
            self._validate("dispmap_sim", disp_east == "-" or Path(disp_east).exists(), f"disp_east path does not exist ({disp_east})")
        if disp_north is not None:
            self._validate("dispmap_sim", disp_north == "-" or Path(disp_north).exists(), f"disp_north path does not exist ({disp_north})")
        if disp_up is not None:
            self._validate("dispmap_sim", disp_up == "-" or Path(disp_up).exists(), f"disp_up path does not exist ({disp_up})")

    def _mock_dispmap_sim_outputs(self, LV: str, DEM_par: str, disp_east: str, disp_north: str, disp_up: str, disp_LOS: str):
        if disp_LOS is not None and disp_LOS != "-":
            Path(disp_LOS).touch()

    def dispmap_sim(self, LV: str, DEM_par: str, disp_east: str, disp_north: str, disp_up: str, disp_LOS: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_sim))

        if self.validate_inputs:
            self._validate_dispmap_sim(*supplied_args)

        if self.mock_outputs:
            self._mock_dispmap_sim_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dispmap_sim", supplied_args)


    def _validate_dem_gradient(self, DEM_par: str, DEM: str, theta: str, phi: str, mag: str, type = None):
        if DEM_par is not None:
            self._validate("dem_gradient", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("dem_gradient", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        valid_values = [0, 1] + [None]
        self._validate("dem_gradient", type == "-" or type in valid_values, f"type is not a valid value (expects: {valid_values}, got: {type})")

    def _mock_dem_gradient_outputs(self, DEM_par: str, DEM: str, theta: str, phi: str, mag: str, type = None):
        if theta is not None and theta != "-":
            Path(theta).touch()
        if phi is not None and phi != "-":
            Path(phi).touch()
        if mag is not None and mag != "-":
            Path(mag).touch()

    def dem_gradient(self, DEM_par: str, DEM: str, theta: str, phi: str, mag: str, type = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_gradient))

        if self.validate_inputs:
            self._validate_dem_gradient(*supplied_args)

        if self.mock_outputs:
            self._mock_dem_gradient_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dem_gradient", supplied_args)


    def _validate_offset_pwr_trackingm(self, MLI_1: str, MLI_2: str, DIFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, lanczos = None, bw_frac = None, pflag = None, pltflg = None, ccs: str = None, std_mean = None):
        if MLI_1 is not None:
            self._validate("offset_pwr_trackingm", MLI_1 == "-" or Path(MLI_1).exists(), f"MLI_1 path does not exist ({MLI_1})")
        if MLI_2 is not None:
            self._validate("offset_pwr_trackingm", MLI_2 == "-" or Path(MLI_2).exists(), f"MLI_2 path does not exist ({MLI_2})")
        if DIFF_par is not None:
            self._validate("offset_pwr_trackingm", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_trackingm", pflag == "-" or pflag in valid_values, f"pflag is not a valid value (expects: {valid_values}, got: {pflag})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("offset_pwr_trackingm", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_offset_pwr_trackingm_outputs(self, MLI_1: str, MLI_2: str, DIFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, lanczos = None, bw_frac = None, pflag = None, pltflg = None, ccs: str = None, std_mean = None):
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        if ccs is not None and ccs != "-":
            Path(ccs).touch()

    def offset_pwr_trackingm(self, MLI_1: str, MLI_2: str, DIFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, lanczos = None, bw_frac = None, pflag = None, pltflg = None, ccs: str = None, std_mean = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_trackingm))

        if self.validate_inputs:
            self._validate_offset_pwr_trackingm(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_pwr_trackingm_outputs(*supplied_args)

        return self._gamma_call("DIFF", "offset_pwr_trackingm", supplied_args)


    def _validate_init_offsetm(self, MLI_1, MLI_2, DIFF_par, rlks = None, azlks = None, rpos = None, azpos = None, offr = None, offaz = None, thres = None, patch = None, cflag = None):
        valid_values = [0, 1] + [None]
        self._validate("init_offsetm", cflag == "-" or cflag in valid_values, f"cflag is not a valid value (expects: {valid_values}, got: {cflag})")

    def _mock_init_offsetm_outputs(self, MLI_1, MLI_2, DIFF_par, rlks = None, azlks = None, rpos = None, azpos = None, offr = None, offaz = None, thres = None, patch = None, cflag = None):
        pass

    def init_offsetm(self, MLI_1, MLI_2, DIFF_par, rlks = None, azlks = None, rpos = None, azpos = None, offr = None, offaz = None, thres = None, patch = None, cflag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.init_offsetm))

        if self.validate_inputs:
            self._validate_init_offsetm(*supplied_args)

        if self.mock_outputs:
            self._mock_init_offsetm_outputs(*supplied_args)

        return self._gamma_call("DIFF", "init_offsetm", supplied_args)


    def _validate_gc_map_fd(self, MLI_par: str, fd_tab: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None, ls_mode = None, r_ovr = None):
        if MLI_par is not None:
            self._validate("gc_map_fd", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if fd_tab is not None:
            self._validate("gc_map_fd", fd_tab == "-" or Path(fd_tab).exists(), f"fd_tab path does not exist ({fd_tab})")
        if DEM_par is not None:
            self._validate("gc_map_fd", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("gc_map_fd", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("gc_map_fd", ls_mode == "-" or ls_mode in valid_values, f"ls_mode is not a valid value (expects: {valid_values}, got: {ls_mode})")

    def _mock_gc_map_fd_outputs(self, MLI_par: str, fd_tab: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None, ls_mode = None, r_ovr = None):
        if DEM_seg_par is not None and DEM_seg_par != "-" and not Path(DEM_seg_par).exists():
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()

    def gc_map_fd(self, MLI_par: str, fd_tab: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None, ls_mode = None, r_ovr = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map_fd))

        if self.validate_inputs:
            self._validate_gc_map_fd(*supplied_args)

        if self.mock_outputs:
            self._mock_gc_map_fd_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gc_map_fd", supplied_args)


    def _validate_phase_sim_orb(self, SLC1_par: str, SLC2R_par: str, OFF_par: str, hgt, sim_unw: str, SLC_ref_par: str = None, definition = None, delta_t = None, int_mode = None, ph_mode = None):
        if SLC1_par is not None:
            self._validate("phase_sim_orb", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2R_par is not None:
            self._validate("phase_sim_orb", SLC2R_par == "-" or Path(SLC2R_par).exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        if OFF_par is not None:
            self._validate("phase_sim_orb", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if SLC_ref_par is not None:
            self._validate("phase_sim_orb", SLC_ref_par == "-" or Path(SLC_ref_par).exists(), f"SLC_ref_par path does not exist ({SLC_ref_par})")
        valid_values = [0, 1] + [None]
        self._validate("phase_sim_orb", int_mode == "-" or int_mode in valid_values, f"int_mode is not a valid value (expects: {valid_values}, got: {int_mode})")
        valid_values = [0, 1] + [None]
        self._validate("phase_sim_orb", ph_mode == "-" or ph_mode in valid_values, f"ph_mode is not a valid value (expects: {valid_values}, got: {ph_mode})")

    def _mock_phase_sim_orb_outputs(self, SLC1_par: str, SLC2R_par: str, OFF_par: str, hgt, sim_unw: str, SLC_ref_par: str = None, definition = None, delta_t = None, int_mode = None, ph_mode = None):
        if sim_unw is not None and sim_unw != "-":
            Path(sim_unw).touch()

    def phase_sim_orb(self, SLC1_par: str, SLC2R_par: str, OFF_par: str, hgt, sim_unw: str, SLC_ref_par: str = None, definition = None, delta_t = None, int_mode = None, ph_mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.phase_sim_orb))

        if self.validate_inputs:
            self._validate_phase_sim_orb(*supplied_args)

        if self.mock_outputs:
            self._mock_phase_sim_orb_outputs(*supplied_args)

        return self._gamma_call("DIFF", "phase_sim_orb", supplied_args)


    def _validate_gec_map(self, SLC_par: str, OFF_par: str, DEM_par: str, href: str, DEM_seg_par: str, lookup_table: str, lat_ovr = None, lon_ovr = None):
        if SLC_par is not None:
            self._validate("gec_map", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("gec_map", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if DEM_par is not None:
            self._validate("gec_map", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if href is not None:
            self._validate("gec_map", href == "-" or Path(href).exists(), f"href path does not exist ({href})")

    def _mock_gec_map_outputs(self, SLC_par: str, OFF_par: str, DEM_par: str, href: str, DEM_seg_par: str, lookup_table: str, lat_ovr = None, lon_ovr = None):
        if DEM_seg_par is not None and DEM_seg_par != "-" and not Path(DEM_seg_par).exists():
            Path(DEM_seg_par).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()

    def gec_map(self, SLC_par: str, OFF_par: str, DEM_par: str, href: str, DEM_seg_par: str, lookup_table: str, lat_ovr = None, lon_ovr = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gec_map))

        if self.validate_inputs:
            self._validate_gec_map(*supplied_args)

        if self.mock_outputs:
            self._mock_gec_map_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gec_map", supplied_args)


    def _validate_dh_map_orb(self, SLC1_par: str, SLC2R_par: str, OFF_par: str, hgt, dp, dpdh: str, dh: str, SLC_ref_par: str = None, int_mode = None):
        if SLC1_par is not None:
            self._validate("dh_map_orb", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2R_par is not None:
            self._validate("dh_map_orb", SLC2R_par == "-" or Path(SLC2R_par).exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        if OFF_par is not None:
            self._validate("dh_map_orb", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if SLC_ref_par is not None:
            self._validate("dh_map_orb", SLC_ref_par == "-" or Path(SLC_ref_par).exists(), f"SLC_ref_par path does not exist ({SLC_ref_par})")
        valid_values = [0, 1] + [None]
        self._validate("dh_map_orb", int_mode == "-" or int_mode in valid_values, f"int_mode is not a valid value (expects: {valid_values}, got: {int_mode})")

    def _mock_dh_map_orb_outputs(self, SLC1_par: str, SLC2R_par: str, OFF_par: str, hgt, dp, dpdh: str, dh: str, SLC_ref_par: str = None, int_mode = None):
        if dpdh is not None and dpdh != "-":
            Path(dpdh).touch()
        if dh is not None and dh != "-":
            Path(dh).touch()

    def dh_map_orb(self, SLC1_par: str, SLC2R_par: str, OFF_par: str, hgt, dp, dpdh: str, dh: str, SLC_ref_par: str = None, int_mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dh_map_orb))

        if self.validate_inputs:
            self._validate_dh_map_orb(*supplied_args)

        if self.mock_outputs:
            self._mock_dh_map_orb_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dh_map_orb", supplied_args)


    def _validate_offset_subm(self, offs: str, DIFF_par: str, offs_sub: str):
        if offs is not None:
            self._validate("offset_subm", offs == "-" or Path(offs).exists(), f"offs path does not exist ({offs})")
        if DIFF_par is not None:
            self._validate("offset_subm", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_offset_subm_outputs(self, offs: str, DIFF_par: str, offs_sub: str):
        if offs_sub is not None and offs_sub != "-":
            Path(offs_sub).touch()

    def offset_subm(self, offs: str, DIFF_par: str, offs_sub: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_subm))

        if self.validate_inputs:
            self._validate_offset_subm(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_subm_outputs(*supplied_args)

        return self._gamma_call("DIFF", "offset_subm", supplied_args)


    def _validate_offset_trackingm(self, offs: str, snr, MLI_par: str, DIFF_par: str, coffs_map: str, coffsets: str = None, mode = None, thres = None, poly_flag = None):
        if offs is not None:
            self._validate("offset_trackingm", offs == "-" or Path(offs).exists(), f"offs path does not exist ({offs})")
        if MLI_par is not None:
            self._validate("offset_trackingm", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if DIFF_par is not None:
            self._validate("offset_trackingm", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")
        valid_values = [0, 1, 2] + [None]
        self._validate("offset_trackingm", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")
        valid_values = [0, 1] + [None]
        self._validate("offset_trackingm", poly_flag == "-" or poly_flag in valid_values, f"poly_flag is not a valid value (expects: {valid_values}, got: {poly_flag})")

    def _mock_offset_trackingm_outputs(self, offs: str, snr, MLI_par: str, DIFF_par: str, coffs_map: str, coffsets: str = None, mode = None, thres = None, poly_flag = None):
        if coffs_map is not None and coffs_map != "-":
            Path(coffs_map).touch()
        if coffsets is not None and coffsets != "-":
            Path(coffsets).touch()

    def offset_trackingm(self, offs: str, snr, MLI_par: str, DIFF_par: str, coffs_map: str, coffsets: str = None, mode = None, thres = None, poly_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_trackingm))

        if self.validate_inputs:
            self._validate_offset_trackingm(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_trackingm_outputs(*supplied_args)

        return self._gamma_call("DIFF", "offset_trackingm", supplied_args)


    def _validate_comb_interfs(self, int_1, int_2, base_1, base_2, factor_1, factor_2, width, combi_out, combi_base, sm = None, Only = None):
        pass

    def _mock_comb_interfs_outputs(self, int_1, int_2, base_1, base_2, factor_1, factor_2, width, combi_out, combi_base, sm = None, Only = None):
        pass

    def comb_interfs(self, int_1, int_2, base_1, base_2, factor_1, factor_2, width, combi_out, combi_base, sm = None, Only = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.comb_interfs))

        if self.validate_inputs:
            self._validate_comb_interfs(*supplied_args)

        if self.mock_outputs:
            self._mock_comb_interfs_outputs(*supplied_args)

        return self._gamma_call("DIFF", "comb_interfs", supplied_args)


    def _validate_gc_insar(self, SLC_par: str, OFF_par: str, hgt, DEM_par, lookup_table: str):
        if SLC_par is not None:
            self._validate("gc_insar", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("gc_insar", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_gc_insar_outputs(self, SLC_par: str, OFF_par: str, hgt, DEM_par, lookup_table: str):
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()

    def gc_insar(self, SLC_par: str, OFF_par: str, hgt, DEM_par, lookup_table: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_insar))

        if self.validate_inputs:
            self._validate_gc_insar(*supplied_args)

        if self.mock_outputs:
            self._mock_gc_insar_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gc_insar", supplied_args)


    def _validate_par_KS_geo(self, HDF5: str, MLI_par: str):
        if HDF5 is not None:
            self._validate("par_KS_geo", HDF5 == "-" or Path(HDF5).exists(), f"HDF5 path does not exist ({HDF5})")
        if MLI_par is not None:
            self._validate("par_KS_geo", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")

    def _mock_par_KS_geo_outputs(self, HDF5: str, MLI_par: str):
        pass

    def par_KS_geo(self, HDF5: str, MLI_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_KS_geo))

        if self.validate_inputs:
            self._validate_par_KS_geo(*supplied_args)

        if self.mock_outputs:
            self._mock_par_KS_geo_outputs(*supplied_args)

        return self._gamma_call("DIFF", "par_KS_geo", supplied_args)


    def _validate_offset_pwrm(self, MLI_1: str, MLI_2: str, DIFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, nr = None, naz = None, thres = None, lanczos = None, bw_frac = None, pflag = None, pltflg = None, ccs: str = None, std_mean = None):
        if MLI_1 is not None:
            self._validate("offset_pwrm", MLI_1 == "-" or Path(MLI_1).exists(), f"MLI_1 path does not exist ({MLI_1})")
        if MLI_2 is not None:
            self._validate("offset_pwrm", MLI_2 == "-" or Path(MLI_2).exists(), f"MLI_2 path does not exist ({MLI_2})")
        if DIFF_par is not None:
            self._validate("offset_pwrm", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwrm", pflag == "-" or pflag in valid_values, f"pflag is not a valid value (expects: {valid_values}, got: {pflag})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("offset_pwrm", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_offset_pwrm_outputs(self, MLI_1: str, MLI_2: str, DIFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, nr = None, naz = None, thres = None, lanczos = None, bw_frac = None, pflag = None, pltflg = None, ccs: str = None, std_mean = None):
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        if ccs is not None and ccs != "-":
            Path(ccs).touch()

    def offset_pwrm(self, MLI_1: str, MLI_2: str, DIFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, nr = None, naz = None, thres = None, lanczos = None, bw_frac = None, pflag = None, pltflg = None, ccs: str = None, std_mean = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwrm))

        if self.validate_inputs:
            self._validate_offset_pwrm(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_pwrm_outputs(*supplied_args)

        return self._gamma_call("DIFF", "offset_pwrm", supplied_args)


    def _validate_coord_to_sarpix_list(self, SLC_par: str, OFF_par: str, DEM_par: str, MAP_coord: str, SAR_coord: str, DIFF_par: str = None):
        if SLC_par is not None:
            self._validate("coord_to_sarpix_list", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("coord_to_sarpix_list", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if DEM_par is not None:
            self._validate("coord_to_sarpix_list", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if MAP_coord is not None:
            self._validate("coord_to_sarpix_list", MAP_coord == "-" or Path(MAP_coord).exists(), f"MAP_coord path does not exist ({MAP_coord})")
        if DIFF_par is not None:
            self._validate("coord_to_sarpix_list", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_coord_to_sarpix_list_outputs(self, SLC_par: str, OFF_par: str, DEM_par: str, MAP_coord: str, SAR_coord: str, DIFF_par: str = None):
        if SAR_coord is not None and SAR_coord != "-":
            Path(SAR_coord).touch()

    def coord_to_sarpix_list(self, SLC_par: str, OFF_par: str, DEM_par: str, MAP_coord: str, SAR_coord: str, DIFF_par: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.coord_to_sarpix_list))

        if self.validate_inputs:
            self._validate_coord_to_sarpix_list(*supplied_args)

        if self.mock_outputs:
            self._mock_coord_to_sarpix_list_outputs(*supplied_args)

        return self._gamma_call("DIFF", "coord_to_sarpix_list", supplied_args)


    def _validate_offset_fitm(self, offs: str, ccp, DIFF_par: str, coffs: str = None, coffsets: str = None, thres = None, npoly = None, interact_mode = None):
        if offs is not None:
            self._validate("offset_fitm", offs == "-" or Path(offs).exists(), f"offs path does not exist ({offs})")
        if DIFF_par is not None:
            self._validate("offset_fitm", DIFF_par == "-" or Path(DIFF_par).exists(), f"DIFF_par path does not exist ({DIFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("offset_fitm", interact_mode == "-" or interact_mode in valid_values, f"interact_mode is not a valid value (expects: {valid_values}, got: {interact_mode})")

    def _mock_offset_fitm_outputs(self, offs: str, ccp, DIFF_par: str, coffs: str = None, coffsets: str = None, thres = None, npoly = None, interact_mode = None):
        if coffs is not None and coffs != "-":
            Path(coffs).touch()
        if coffsets is not None and coffsets != "-":
            Path(coffsets).touch()

    def offset_fitm(self, offs: str, ccp, DIFF_par: str, coffs: str = None, coffsets: str = None, thres = None, npoly = None, interact_mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_fitm))

        if self.validate_inputs:
            self._validate_offset_fitm(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_fitm_outputs(*supplied_args)

        return self._gamma_call("DIFF", "offset_fitm", supplied_args)


    def _validate_dispmap_ENU(self, LV_tab: str, DISP_tab: str, SIGMA_tab: str, DEM_par: str, disp_east: str, disp_north: str, disp_up: str, sigma_east: str = None, sigma_north: str = None, sigma_up: str = None, chi2: str = None, min_obs = None, tol = None):
        if LV_tab is not None:
            self._validate("dispmap_ENU", LV_tab == "-" or Path(LV_tab).exists(), f"LV_tab path does not exist ({LV_tab})")
        if DISP_tab is not None:
            self._validate("dispmap_ENU", DISP_tab == "-" or Path(DISP_tab).exists(), f"DISP_tab path does not exist ({DISP_tab})")
        if SIGMA_tab is not None:
            self._validate("dispmap_ENU", SIGMA_tab == "-" or Path(SIGMA_tab).exists(), f"SIGMA_tab path does not exist ({SIGMA_tab})")
        if DEM_par is not None:
            self._validate("dispmap_ENU", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_dispmap_ENU_outputs(self, LV_tab: str, DISP_tab: str, SIGMA_tab: str, DEM_par: str, disp_east: str, disp_north: str, disp_up: str, sigma_east: str = None, sigma_north: str = None, sigma_up: str = None, chi2: str = None, min_obs = None, tol = None):
        if disp_east is not None and disp_east != "-":
            Path(disp_east).touch()
        if disp_north is not None and disp_north != "-":
            Path(disp_north).touch()
        if disp_up is not None and disp_up != "-":
            Path(disp_up).touch()
        if sigma_east is not None and sigma_east != "-":
            Path(sigma_east).touch()
        if sigma_north is not None and sigma_north != "-":
            Path(sigma_north).touch()
        if sigma_up is not None and sigma_up != "-":
            Path(sigma_up).touch()
        if chi2 is not None and chi2 != "-":
            Path(chi2).touch()

    def dispmap_ENU(self, LV_tab: str, DISP_tab: str, SIGMA_tab: str, DEM_par: str, disp_east: str, disp_north: str, disp_up: str, sigma_east: str = None, sigma_north: str = None, sigma_up: str = None, chi2: str = None, min_obs = None, tol = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_ENU))

        if self.validate_inputs:
            self._validate_dispmap_ENU(*supplied_args)

        if self.mock_outputs:
            self._mock_dispmap_ENU_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dispmap_ENU", supplied_args)


    def _validate_dem_coord(self, DEM_par: str, east: str, north: str, dtype = None):
        if DEM_par is not None:
            self._validate("dem_coord", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        valid_values = [0, 1] + [None]
        self._validate("dem_coord", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_dem_coord_outputs(self, DEM_par: str, east: str, north: str, dtype = None):
        if east is not None and east != "-":
            Path(east).touch()
        if north is not None and north != "-":
            Path(north).touch()

    def dem_coord(self, DEM_par: str, east: str, north: str, dtype = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_coord))

        if self.validate_inputs:
            self._validate_dem_coord(*supplied_args)

        if self.mock_outputs:
            self._mock_dem_coord_outputs(*supplied_args)

        return self._gamma_call("DIFF", "dem_coord", supplied_args)


    def _validate_rotate_image(self, data_in: str, width_in, angle, data_out: str, width_out, nlines_out, interp_mode = None, dtype = None, order = None):
        if data_in is not None:
            self._validate("rotate_image", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7] + [None]
        self._validate("rotate_image", interp_mode == "-" or interp_mode in valid_values, f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})")
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        self._validate("rotate_image", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_rotate_image_outputs(self, data_in: str, width_in, angle, data_out: str, width_out, nlines_out, interp_mode = None, dtype = None, order = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def rotate_image(self, data_in: str, width_in, angle, data_out: str, width_out, nlines_out, interp_mode = None, dtype = None, order = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rotate_image))

        if self.validate_inputs:
            self._validate_rotate_image(*supplied_args)

        if self.mock_outputs:
            self._mock_rotate_image_outputs(*supplied_args)

        return self._gamma_call("DIFF", "rotate_image", supplied_args)


    def _validate_geocode_back(self, data_in: str, width_in, lookup_table: str, data_out: str, width_out, nlines_out = None, interp_mode = None, dtype = None, lr_in = None, lr_out = None, order = None, e_flag = None):
        if data_in is not None:
            self._validate("geocode_back", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        if lookup_table is not None:
            self._validate("geocode_back", lookup_table == "-" or Path(lookup_table).exists(), f"lookup_table path does not exist ({lookup_table})")
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        self._validate("geocode_back", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1] + [None]
        self._validate("geocode_back", e_flag == "-" or e_flag in valid_values, f"e_flag is not a valid value (expects: {valid_values}, got: {e_flag})")

    def _mock_geocode_back_outputs(self, data_in: str, width_in, lookup_table: str, data_out: str, width_out, nlines_out = None, interp_mode = None, dtype = None, lr_in = None, lr_out = None, order = None, e_flag = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def geocode_back(self, data_in: str, width_in, lookup_table: str, data_out: str, width_out, nlines_out = None, interp_mode = None, dtype = None, lr_in = None, lr_out = None, order = None, e_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.geocode_back))

        if self.validate_inputs:
            self._validate_geocode_back(*supplied_args)

        if self.mock_outputs:
            self._mock_geocode_back_outputs(*supplied_args)

        return self._gamma_call("DIFF", "geocode_back", supplied_args)


    def _validate_sarpix_coord(self, SLC_par: str, OFF_par: str = None, DEM_par: str = None, azlin = None, rpix = None, ref_hgt = None):
        if SLC_par is not None:
            self._validate("sarpix_coord", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("sarpix_coord", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if DEM_par is not None:
            self._validate("sarpix_coord", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_sarpix_coord_outputs(self, SLC_par: str, OFF_par: str = None, DEM_par: str = None, azlin = None, rpix = None, ref_hgt = None):
        pass

    def sarpix_coord(self, SLC_par: str, OFF_par: str = None, DEM_par: str = None, azlin = None, rpix = None, ref_hgt = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sarpix_coord))

        if self.validate_inputs:
            self._validate_sarpix_coord(*supplied_args)

        if self.mock_outputs:
            self._mock_sarpix_coord_outputs(*supplied_args)

        return self._gamma_call("DIFF", "sarpix_coord", supplied_args)


    def _validate_resamp_image(self, data_in: str, width_in, xscale, yscale, data_out: str, width_out, nlines_out, interp_mode = None, dtype = None, order = None):
        if data_in is not None:
            self._validate("resamp_image", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        self._validate("resamp_image", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_resamp_image_outputs(self, data_in: str, width_in, xscale, yscale, data_out: str, width_out, nlines_out, interp_mode = None, dtype = None, order = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def resamp_image(self, data_in: str, width_in, xscale, yscale, data_out: str, width_out, nlines_out, interp_mode = None, dtype = None, order = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.resamp_image))

        if self.validate_inputs:
            self._validate_resamp_image(*supplied_args)

        if self.mock_outputs:
            self._mock_resamp_image_outputs(*supplied_args)

        return self._gamma_call("DIFF", "resamp_image", supplied_args)


    def _validate_pol2rec(self, data1: str, SLC_par1: str, data2: str, SLC_par2: str, pix_size: str, dtype, mode = None, xmin = None, nx = None, ymin = None, ny = None, rmax = None):
        if data1 is not None:
            self._validate("pol2rec", data1 == "-" or Path(data1).exists(), f"data1 path does not exist ({data1})")
        if SLC_par1 is not None:
            self._validate("pol2rec", SLC_par1 == "-" or Path(SLC_par1).exists(), f"SLC_par1 path does not exist ({SLC_par1})")
        valid_values = [0, 1]
        self._validate("pol2rec", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1] + [None]
        self._validate("pol2rec", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_pol2rec_outputs(self, data1: str, SLC_par1: str, data2: str, SLC_par2: str, pix_size: str, dtype, mode = None, xmin = None, nx = None, ymin = None, ny = None, rmax = None):
        if data2 is not None and data2 != "-":
            Path(data2).touch()
        if SLC_par2 is not None and SLC_par2 != "-":
            Path(SLC_par2).touch()
        if pix_size is not None and pix_size != "-":
            Path(pix_size).touch()

    def pol2rec(self, data1: str, SLC_par1: str, data2: str, SLC_par2: str, pix_size: str, dtype, mode = None, xmin = None, nx = None, ymin = None, ny = None, rmax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pol2rec))

        if self.validate_inputs:
            self._validate_pol2rec(*supplied_args)

        if self.mock_outputs:
            self._mock_pol2rec_outputs(*supplied_args)

        return self._gamma_call("DIFF", "pol2rec", supplied_args)


    def _validate_WSS_interp(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, DIFF_par, SLC_2R: str, SLC2R_par: str):
        if SLC_1 is not None:
            self._validate("WSS_interp", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("WSS_interp", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("WSS_interp", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("WSS_interp", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_WSS_interp_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, DIFF_par, SLC_2R: str, SLC2R_par: str):
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()

    def WSS_interp(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, DIFF_par, SLC_2R: str, SLC2R_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.WSS_interp))

        if self.validate_inputs:
            self._validate_WSS_interp(*supplied_args)

        if self.mock_outputs:
            self._mock_WSS_interp_outputs(*supplied_args)

        return self._gamma_call("DIFF", "WSS_interp", supplied_args)


    def _validate_gc_GPRI_map(self, MLI_par: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, lv_theta: str = None, lv_phi: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None):
        if MLI_par is not None:
            self._validate("gc_GPRI_map", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if DEM_par is not None:
            self._validate("gc_GPRI_map", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if DEM is not None:
            self._validate("gc_GPRI_map", DEM == "-" or Path(DEM).exists(), f"DEM path does not exist ({DEM})")

    def _mock_gc_GPRI_map_outputs(self, MLI_par: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, lv_theta: str = None, lv_phi: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None):
        if DEM_seg_par is not None and DEM_seg_par != "-" and not Path(DEM_seg_par).exists():
            Path(DEM_seg_par).touch()
        if DEM_seg is not None and DEM_seg != "-":
            Path(DEM_seg).touch()
        if lookup_table is not None and lookup_table != "-":
            Path(lookup_table).touch()
        if sim_sar is not None and sim_sar != "-":
            Path(sim_sar).touch()
        if lv_theta is not None and lv_theta != "-":
            Path(lv_theta).touch()
        if lv_phi is not None and lv_phi != "-":
            Path(lv_phi).touch()
        if u is not None and u != "-":
            Path(u).touch()
        if v is not None and v != "-":
            Path(v).touch()
        if inc is not None and inc != "-":
            Path(inc).touch()
        if psi is not None and psi != "-":
            Path(psi).touch()
        if pix is not None and pix != "-":
            Path(pix).touch()
        if ls_map is not None and ls_map != "-":
            Path(ls_map).touch()

    def gc_GPRI_map(self, MLI_par: str, DEM_par: str, DEM: str, DEM_seg_par: str, DEM_seg: str, lookup_table: str, lat_ovr = None, lon_ovr = None, sim_sar: str = None, lv_theta: str = None, lv_phi: str = None, u: str = None, v: str = None, inc: str = None, psi: str = None, pix: str = None, ls_map: str = None, frame = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_GPRI_map))

        if self.validate_inputs:
            self._validate_gc_GPRI_map(*supplied_args)

        if self.mock_outputs:
            self._mock_gc_GPRI_map_outputs(*supplied_args)

        return self._gamma_call("DIFF", "gc_GPRI_map", supplied_args)


    def _validate_dop_mlcc(self, SAR_par: str, PROC_par: str, signal_data: str, plot_data: str = None, loff = None, nlines = None):
        if SAR_par is not None:
            self._validate("dop_mlcc", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("dop_mlcc", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("dop_mlcc", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_dop_mlcc_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, plot_data: str = None, loff = None, nlines = None):
        if plot_data is not None and plot_data != "-":
            Path(plot_data).touch()

    def dop_mlcc(self, SAR_par: str, PROC_par: str, signal_data: str, plot_data: str = None, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dop_mlcc))

        if self.validate_inputs:
            self._validate_dop_mlcc(*supplied_args)

        if self.mock_outputs:
            self._mock_dop_mlcc_outputs(*supplied_args)

        return self._gamma_call("MSP", "dop_mlcc", supplied_args)


    def _validate_ERS_proc_ASF_2000(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_ASF_2000", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_ASF_2000_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_ASF_2000(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ASF_2000))

        if self.validate_inputs:
            self._validate_ERS_proc_ASF_2000(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_ASF_2000_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_ASF_2000", supplied_args)


    def _validate_ERS_proc_ASF(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_ASF", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_ASF_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_ASF(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ASF))

        if self.validate_inputs:
            self._validate_ERS_proc_ASF(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_ASF_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_ASF", supplied_args)


    def _validate_doppler_2d(self, SAR_par: str, PROC_par: str, signal_data: str, dop2d: str, loff = None, blsz = None, nbl = None, a2_flg = None, b0_flg = None, b1_flg = None, c0_flg = None, ambig_flag = None, namb = None):
        if SAR_par is not None:
            self._validate("doppler_2d", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("doppler_2d", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("doppler_2d", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_doppler_2d_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, dop2d: str, loff = None, blsz = None, nbl = None, a2_flg = None, b0_flg = None, b1_flg = None, c0_flg = None, ambig_flag = None, namb = None):
        if dop2d is not None and dop2d != "-":
            Path(dop2d).touch()

    def doppler_2d(self, SAR_par: str, PROC_par: str, signal_data: str, dop2d: str, loff = None, blsz = None, nbl = None, a2_flg = None, b0_flg = None, b1_flg = None, c0_flg = None, ambig_flag = None, namb = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.doppler_2d))

        if self.validate_inputs:
            self._validate_doppler_2d(*supplied_args)

        if self.mock_outputs:
            self._mock_doppler_2d_outputs(*supplied_args)

        return self._gamma_call("MSP", "doppler_2d", supplied_args)


    def _validate_ERS_proc_ESA(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_ESA", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_ESA_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_ESA(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ESA))

        if self.validate_inputs:
            self._validate_ERS_proc_ESA(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_ESA_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_ESA", supplied_args)


    def _validate_az_proc(self, SAR_par: str, PROC_par: str, rc_data: str, SLC: str, az_patch = None, SLC_format = None, cal_fact = None, SLC_type = None, kaiser = None, npatch = None):
        if SAR_par is not None:
            self._validate("az_proc", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("az_proc", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if rc_data is not None:
            self._validate("az_proc", rc_data == "-" or Path(rc_data).exists(), f"rc_data path does not exist ({rc_data})")
        valid_values = [0, 1] + [None]
        self._validate("az_proc", SLC_format == "-" or SLC_format in valid_values, f"SLC_format is not a valid value (expects: {valid_values}, got: {SLC_format})")
        valid_values = [0, 1] + [None]
        self._validate("az_proc", SLC_type == "-" or SLC_type in valid_values, f"SLC_type is not a valid value (expects: {valid_values}, got: {SLC_type})")

    def _mock_az_proc_outputs(self, SAR_par: str, PROC_par: str, rc_data: str, SLC: str, az_patch = None, SLC_format = None, cal_fact = None, SLC_type = None, kaiser = None, npatch = None):
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def az_proc(self, SAR_par: str, PROC_par: str, rc_data: str, SLC: str, az_patch = None, SLC_format = None, cal_fact = None, SLC_type = None, kaiser = None, npatch = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.az_proc))

        if self.validate_inputs:
            self._validate_az_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_az_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "az_proc", supplied_args)


    def _validate_dop_interf(self, SAR_par1: str, PROC_par1: str, PROC_par2: str, PROC_par1_out: str, PROC_par2_out: str, dop: str):
        if SAR_par1 is not None:
            self._validate("dop_interf", SAR_par1 == "-" or Path(SAR_par1).exists(), f"SAR_par1 path does not exist ({SAR_par1})")
        if PROC_par1 is not None:
            self._validate("dop_interf", PROC_par1 == "-" or Path(PROC_par1).exists(), f"PROC_par1 path does not exist ({PROC_par1})")
        if PROC_par2 is not None:
            self._validate("dop_interf", PROC_par2 == "-" or Path(PROC_par2).exists(), f"PROC_par2 path does not exist ({PROC_par2})")

    def _mock_dop_interf_outputs(self, SAR_par1: str, PROC_par1: str, PROC_par2: str, PROC_par1_out: str, PROC_par2_out: str, dop: str):
        if PROC_par1_out is not None and PROC_par1_out != "-":
            Path(PROC_par1_out).touch()
        if PROC_par2_out is not None and PROC_par2_out != "-":
            Path(PROC_par2_out).touch()
        if dop is not None and dop != "-":
            Path(dop).touch()

    def dop_interf(self, SAR_par1: str, PROC_par1: str, PROC_par2: str, PROC_par1_out: str, PROC_par2_out: str, dop: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dop_interf))

        if self.validate_inputs:
            self._validate_dop_interf(*supplied_args)

        if self.mock_outputs:
            self._mock_dop_interf_outputs(*supplied_args)

        return self._gamma_call("MSP", "dop_interf", supplied_args)


    def _validate_CS_proc(self, HDF5: str, SAR_par: str, PROC_par: str, raw_out: str, loff = None, nl = None):
        if HDF5 is not None:
            self._validate("CS_proc", HDF5 == "-" or Path(HDF5).exists(), f"HDF5 path does not exist ({HDF5})")

    def _mock_CS_proc_outputs(self, HDF5: str, SAR_par: str, PROC_par: str, raw_out: str, loff = None, nl = None):
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw_out is not None and raw_out != "-":
            Path(raw_out).touch()

    def CS_proc(self, HDF5: str, SAR_par: str, PROC_par: str, raw_out: str, loff = None, nl = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.CS_proc))

        if self.validate_inputs:
            self._validate_CS_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_CS_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "CS_proc", supplied_args)


    def _validate_azsp_SLC(self, SAR_par: str, PROC_par: str, SAR_data: str, spectrum, loff = None, roff = None, nsub = None, data_format = None, pltflg = None):
        if SAR_par is not None:
            self._validate("azsp_SLC", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("azsp_SLC", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if SAR_data is not None:
            self._validate("azsp_SLC", SAR_data == "-" or Path(SAR_data).exists(), f"SAR_data path does not exist ({SAR_data})")
        valid_values = [0, 1] + [None]
        self._validate("azsp_SLC", data_format == "-" or data_format in valid_values, f"data_format is not a valid value (expects: {valid_values}, got: {data_format})")
        valid_values = [0, 1] + [None]
        self._validate("azsp_SLC", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_azsp_SLC_outputs(self, SAR_par: str, PROC_par: str, SAR_data: str, spectrum, loff = None, roff = None, nsub = None, data_format = None, pltflg = None):
        pass

    def azsp_SLC(self, SAR_par: str, PROC_par: str, SAR_data: str, spectrum, loff = None, roff = None, nsub = None, data_format = None, pltflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.azsp_SLC))

        if self.validate_inputs:
            self._validate_azsp_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_azsp_SLC_outputs(*supplied_args)

        return self._gamma_call("MSP", "azsp_SLC", supplied_args)


    def _validate_pre_rc_JERS(self, SAR_par: str, PROC_par: str, rspec: str, signal_data: str, rc_data: str, prefilt_dec = None, kaiser = None, filt_lm = None):
        if SAR_par is not None:
            self._validate("pre_rc_JERS", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("pre_rc_JERS", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if rspec is not None:
            self._validate("pre_rc_JERS", rspec == "-" or Path(rspec).exists(), f"rspec path does not exist ({rspec})")
        if signal_data is not None:
            self._validate("pre_rc_JERS", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_pre_rc_JERS_outputs(self, SAR_par: str, PROC_par: str, rspec: str, signal_data: str, rc_data: str, prefilt_dec = None, kaiser = None, filt_lm = None):
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()

    def pre_rc_JERS(self, SAR_par: str, PROC_par: str, rspec: str, signal_data: str, rc_data: str, prefilt_dec = None, kaiser = None, filt_lm = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pre_rc_JERS))

        if self.validate_inputs:
            self._validate_pre_rc_JERS(*supplied_args)

        if self.mock_outputs:
            self._mock_pre_rc_JERS_outputs(*supplied_args)

        return self._gamma_call("MSP", "pre_rc_JERS", supplied_args)


    def _validate_ERS_proc_NASDA(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_NASDA", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_NASDA_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_NASDA(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_NASDA))

        if self.validate_inputs:
            self._validate_ERS_proc_NASDA(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_NASDA_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_NASDA", supplied_args)


    def _validate_ERS_proc_ARG(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_ARG", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_ARG_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_ARG(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ARG))

        if self.validate_inputs:
            self._validate_ERS_proc_ARG(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_ARG_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_ARG", supplied_args)


    def _validate_PALSAR_proc(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, CEOS_raw_data: str, raw_out: str, TX_POL = None, RX_POL = None):
        if CEOS_SAR_leader is not None:
            self._validate("PALSAR_proc", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        if CEOS_raw_data is not None:
            self._validate("PALSAR_proc", CEOS_raw_data == "-" or Path(CEOS_raw_data).exists(), f"CEOS_raw_data path does not exist ({CEOS_raw_data})")
        valid_values = [0, 1] + [None]
        self._validate("PALSAR_proc", TX_POL == "-" or TX_POL in valid_values, f"TX_POL is not a valid value (expects: {valid_values}, got: {TX_POL})")
        valid_values = [0, 1] + [None]
        self._validate("PALSAR_proc", RX_POL == "-" or RX_POL in valid_values, f"RX_POL is not a valid value (expects: {valid_values}, got: {RX_POL})")

    def _mock_PALSAR_proc_outputs(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, CEOS_raw_data: str, raw_out: str, TX_POL = None, RX_POL = None):
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw_out is not None and raw_out != "-":
            Path(raw_out).touch()

    def PALSAR_proc(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, CEOS_raw_data: str, raw_out: str, TX_POL = None, RX_POL = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PALSAR_proc))

        if self.validate_inputs:
            self._validate_PALSAR_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_PALSAR_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "PALSAR_proc", supplied_args)


    def _validate_rspec_real(self, SAR_par: str, PROC_par: str, signal_data: str, range_spec: str, loff = None, nlspec = None, nrfft = None, pltflg = None):
        if SAR_par is not None:
            self._validate("rspec_real", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("rspec_real", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("rspec_real", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")
        valid_values = [0, 1] + [None]
        self._validate("rspec_real", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_rspec_real_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, range_spec: str, loff = None, nlspec = None, nrfft = None, pltflg = None):
        if range_spec is not None and range_spec != "-":
            Path(range_spec).touch()

    def rspec_real(self, SAR_par: str, PROC_par: str, signal_data: str, range_spec: str, loff = None, nlspec = None, nrfft = None, pltflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rspec_real))

        if self.validate_inputs:
            self._validate_rspec_real(*supplied_args)

        if self.mock_outputs:
            self._mock_rspec_real_outputs(*supplied_args)

        return self._gamma_call("MSP", "rspec_real", supplied_args)


    def _validate_rspec_IQ(self, SAR_par: str, PROC_par: str, signal_data: str, range_spec: str, loff = None, nlspec = None, nrfft = None, roff = None, pltflg = None):
        if SAR_par is not None:
            self._validate("rspec_IQ", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("rspec_IQ", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("rspec_IQ", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")
        valid_values = [0, 1] + [None]
        self._validate("rspec_IQ", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_rspec_IQ_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, range_spec: str, loff = None, nlspec = None, nrfft = None, roff = None, pltflg = None):
        if range_spec is not None and range_spec != "-":
            Path(range_spec).touch()

    def rspec_IQ(self, SAR_par: str, PROC_par: str, signal_data: str, range_spec: str, loff = None, nlspec = None, nrfft = None, roff = None, pltflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rspec_IQ))

        if self.validate_inputs:
            self._validate_rspec_IQ(*supplied_args)

        if self.mock_outputs:
            self._mock_rspec_IQ_outputs(*supplied_args)

        return self._gamma_call("MSP", "rspec_IQ", supplied_args)


    def _validate_af(self, SAR_par: str, PROC_par: str, SLC: str, rwin = None, azwin = None, dr = None, daz = None, thres = None, update_flg = None, a1_flg = None, b0_flg = None, offsets: str = None, dac_flg = None, n_ovr = None, roff = None, azoff = None):
        if SAR_par is not None:
            self._validate("af", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("af", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if SLC is not None:
            self._validate("af", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        valid_values = [0, 1] + [None]
        self._validate("af", update_flg == "-" or update_flg in valid_values, f"update_flg is not a valid value (expects: {valid_values}, got: {update_flg})")
        valid_values = [0, 1] + [None]
        self._validate("af", a1_flg == "-" or a1_flg in valid_values, f"a1_flg is not a valid value (expects: {valid_values}, got: {a1_flg})")
        valid_values = [0, 1] + [None]
        self._validate("af", b0_flg == "-" or b0_flg in valid_values, f"b0_flg is not a valid value (expects: {valid_values}, got: {b0_flg})")
        valid_values = [0, 1] + [None]
        self._validate("af", dac_flg == "-" or dac_flg in valid_values, f"dac_flg is not a valid value (expects: {valid_values}, got: {dac_flg})")

    def _mock_af_outputs(self, SAR_par: str, PROC_par: str, SLC: str, rwin = None, azwin = None, dr = None, daz = None, thres = None, update_flg = None, a1_flg = None, b0_flg = None, offsets: str = None, dac_flg = None, n_ovr = None, roff = None, azoff = None):
        if offsets is not None and offsets != "-":
            Path(offsets).touch()

    def af(self, SAR_par: str, PROC_par: str, SLC: str, rwin = None, azwin = None, dr = None, daz = None, thres = None, update_flg = None, a1_flg = None, b0_flg = None, offsets: str = None, dac_flg = None, n_ovr = None, roff = None, azoff = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.af))

        if self.validate_inputs:
            self._validate_af(*supplied_args)

        if self.mock_outputs:
            self._mock_af_outputs(*supplied_args)

        return self._gamma_call("MSP", "af", supplied_args)


    def _validate_hist_IQ(self, SAR_par: str, PROC_par: str, signal_data: str, historgram: str, loff = None, nl = None):
        if SAR_par is not None:
            self._validate("hist_IQ", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("hist_IQ", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("hist_IQ", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_hist_IQ_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, historgram: str, loff = None, nl = None):
        if historgram is not None and historgram != "-":
            Path(historgram).touch()

    def hist_IQ(self, SAR_par: str, PROC_par: str, signal_data: str, historgram: str, loff = None, nl = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.hist_IQ))

        if self.validate_inputs:
            self._validate_hist_IQ(*supplied_args)

        if self.mock_outputs:
            self._mock_hist_IQ_outputs(*supplied_args)

        return self._gamma_call("MSP", "hist_IQ", supplied_args)


    def _validate_PALSAR_burst_sync(self, SAR_par1: str, PROC_par1: str, raw1: str, SAR_par2: str, PROC_par2: str, raw2: str, PROC_par1_out: str, raw1_out: str, PROC_par2_out: str, raw2_out: str):
        if SAR_par1 is not None:
            self._validate("PALSAR_burst_sync", SAR_par1 == "-" or Path(SAR_par1).exists(), f"SAR_par1 path does not exist ({SAR_par1})")
        if PROC_par1 is not None:
            self._validate("PALSAR_burst_sync", PROC_par1 == "-" or Path(PROC_par1).exists(), f"PROC_par1 path does not exist ({PROC_par1})")
        if raw1 is not None:
            self._validate("PALSAR_burst_sync", raw1 == "-" or Path(raw1).exists(), f"raw1 path does not exist ({raw1})")
        if SAR_par2 is not None:
            self._validate("PALSAR_burst_sync", SAR_par2 == "-" or Path(SAR_par2).exists(), f"SAR_par2 path does not exist ({SAR_par2})")
        if PROC_par2 is not None:
            self._validate("PALSAR_burst_sync", PROC_par2 == "-" or Path(PROC_par2).exists(), f"PROC_par2 path does not exist ({PROC_par2})")
        if raw2 is not None:
            self._validate("PALSAR_burst_sync", raw2 == "-" or Path(raw2).exists(), f"raw2 path does not exist ({raw2})")

    def _mock_PALSAR_burst_sync_outputs(self, SAR_par1: str, PROC_par1: str, raw1: str, SAR_par2: str, PROC_par2: str, raw2: str, PROC_par1_out: str, raw1_out: str, PROC_par2_out: str, raw2_out: str):
        if PROC_par1_out is not None and PROC_par1_out != "-":
            Path(PROC_par1_out).touch()
        if raw1_out is not None and raw1_out != "-":
            Path(raw1_out).touch()
        if PROC_par2_out is not None and PROC_par2_out != "-":
            Path(PROC_par2_out).touch()
        if raw2_out is not None and raw2_out != "-":
            Path(raw2_out).touch()

    def PALSAR_burst_sync(self, SAR_par1: str, PROC_par1: str, raw1: str, SAR_par2: str, PROC_par2: str, raw2: str, PROC_par1_out: str, raw1_out: str, PROC_par2_out: str, raw2_out: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PALSAR_burst_sync))

        if self.validate_inputs:
            self._validate_PALSAR_burst_sync(*supplied_args)

        if self.mock_outputs:
            self._mock_PALSAR_burst_sync_outputs(*supplied_args)

        return self._gamma_call("MSP", "PALSAR_burst_sync", supplied_args)


    def _validate_swap_IQ(self, SAR_par: str, raw_IQ: str, raw_IQ_swap: str):
        if SAR_par is not None:
            self._validate("swap_IQ", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if raw_IQ is not None:
            self._validate("swap_IQ", raw_IQ == "-" or Path(raw_IQ).exists(), f"raw_IQ path does not exist ({raw_IQ})")

    def _mock_swap_IQ_outputs(self, SAR_par: str, raw_IQ: str, raw_IQ_swap: str):
        if raw_IQ_swap is not None and raw_IQ_swap != "-":
            Path(raw_IQ_swap).touch()

    def swap_IQ(self, SAR_par: str, raw_IQ: str, raw_IQ_swap: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.swap_IQ))

        if self.validate_inputs:
            self._validate_swap_IQ(*supplied_args)

        if self.mock_outputs:
            self._mock_swap_IQ_outputs(*supplied_args)

        return self._gamma_call("MSP", "swap_IQ", supplied_args)


    def _validate_dop_ambig(self, SAR_par: str, PROC_par: str, signal_data: str, algorithm = None, loff = None, output_plot: str = None):
        if SAR_par is not None:
            self._validate("dop_ambig", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("dop_ambig", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("dop_ambig", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")
        valid_values = [1, 2] + [None]
        self._validate("dop_ambig", algorithm == "-" or algorithm in valid_values, f"algorithm is not a valid value (expects: {valid_values}, got: {algorithm})")

    def _mock_dop_ambig_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, algorithm = None, loff = None, output_plot: str = None):
        if output_plot is not None and output_plot != "-":
            Path(output_plot).touch()

    def dop_ambig(self, SAR_par: str, PROC_par: str, signal_data: str, algorithm = None, loff = None, output_plot: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dop_ambig))

        if self.validate_inputs:
            self._validate_dop_ambig(*supplied_args)

        if self.mock_outputs:
            self._mock_dop_ambig_outputs(*supplied_args)

        return self._gamma_call("MSP", "dop_ambig", supplied_args)


    def _validate_PRC_proc(self, PROC_par: str, PRC, nstate = None):
        if PROC_par is not None:
            self._validate("PRC_proc", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")

    def _mock_PRC_proc_outputs(self, PROC_par: str, PRC, nstate = None):
        pass

    def PRC_proc(self, PROC_par: str, PRC, nstate = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PRC_proc))

        if self.validate_inputs:
            self._validate_PRC_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_PRC_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "PRC_proc", supplied_args)


    def _validate_rc_fmcw(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, nrc_off, nrc_samp = None, loff = None, nl = None, kaiser = None):
        if SAR_par is not None:
            self._validate("rc_fmcw", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("rc_fmcw", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("rc_fmcw", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_rc_fmcw_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, nrc_off, nrc_samp = None, loff = None, nl = None, kaiser = None):
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()

    def rc_fmcw(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, nrc_off, nrc_samp = None, loff = None, nl = None, kaiser = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rc_fmcw))

        if self.validate_inputs:
            self._validate_rc_fmcw(*supplied_args)

        if self.mock_outputs:
            self._mock_rc_fmcw_outputs(*supplied_args)

        return self._gamma_call("MSP", "rc_fmcw", supplied_args)


    def _validate_RSAT_lks(self, SLC_PROC_par: str, MLI_PROC_par: str, SLC_image: str, ML_image: str, kaiser = None):
        if SLC_PROC_par is not None:
            self._validate("RSAT_lks", SLC_PROC_par == "-" or Path(SLC_PROC_par).exists(), f"SLC_PROC_par path does not exist ({SLC_PROC_par})")
        if SLC_image is not None:
            self._validate("RSAT_lks", SLC_image == "-" or Path(SLC_image).exists(), f"SLC_image path does not exist ({SLC_image})")

    def _mock_RSAT_lks_outputs(self, SLC_PROC_par: str, MLI_PROC_par: str, SLC_image: str, ML_image: str, kaiser = None):
        if MLI_PROC_par is not None and MLI_PROC_par != "-":
            Path(MLI_PROC_par).touch()
        if ML_image is not None and ML_image != "-":
            Path(ML_image).touch()

    def RSAT_lks(self, SLC_PROC_par: str, MLI_PROC_par: str, SLC_image: str, ML_image: str, kaiser = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.RSAT_lks))

        if self.validate_inputs:
            self._validate_RSAT_lks(*supplied_args)

        if self.mock_outputs:
            self._mock_RSAT_lks_outputs(*supplied_args)

        return self._gamma_call("MSP", "RSAT_lks", supplied_args)


    def _validate_extract_psd(self, spectra, num, output_spectrum):
        pass

    def _mock_extract_psd_outputs(self, spectra, num, output_spectrum):
        pass

    def extract_psd(self, spectra, num, output_spectrum):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.extract_psd))

        if self.validate_inputs:
            self._validate_extract_psd(*supplied_args)

        if self.mock_outputs:
            self._mock_extract_psd_outputs(*supplied_args)

        return self._gamma_call("MSP", "extract_psd", supplied_args)


    def _validate_doppler_real(self, SAR_par: str, PROC_par: str, signal_data: str, doppler: str, loff = None, nsub = None, ambig_flag = None, namb = None):
        if SAR_par is not None:
            self._validate("doppler_real", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("doppler_real", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("doppler_real", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_doppler_real_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, doppler: str, loff = None, nsub = None, ambig_flag = None, namb = None):
        if doppler is not None and doppler != "-":
            Path(doppler).touch()

    def doppler_real(self, SAR_par: str, PROC_par: str, signal_data: str, doppler: str, loff = None, nsub = None, ambig_flag = None, namb = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.doppler_real))

        if self.validate_inputs:
            self._validate_doppler_real(*supplied_args)

        if self.mock_outputs:
            self._mock_doppler_real_outputs(*supplied_args)

        return self._gamma_call("MSP", "doppler_real", supplied_args)


    def _validate_pre_rc(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, prefilt_dec = None, loff = None, nl = None, nr_samp = None, kaiser = None, filt_lm = None, nr_ext = None, fr_ext = None, pre_ext = None, post_ext = None, RFI_filt = None, RFI_thres = None, fc_offset = None, win_bw = None):
        if SAR_par is not None:
            self._validate("pre_rc", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("pre_rc", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("pre_rc", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")
        valid_values = [0, 1] + [None]
        self._validate("pre_rc", RFI_filt == "-" or RFI_filt in valid_values, f"RFI_filt is not a valid value (expects: {valid_values}, got: {RFI_filt})")

    def _mock_pre_rc_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, prefilt_dec = None, loff = None, nl = None, nr_samp = None, kaiser = None, filt_lm = None, nr_ext = None, fr_ext = None, pre_ext = None, post_ext = None, RFI_filt = None, RFI_thres = None, fc_offset = None, win_bw = None):
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()

    def pre_rc(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, prefilt_dec = None, loff = None, nl = None, nr_samp = None, kaiser = None, filt_lm = None, nr_ext = None, fr_ext = None, pre_ext = None, post_ext = None, RFI_filt = None, RFI_thres = None, fc_offset = None, win_bw = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pre_rc))

        if self.validate_inputs:
            self._validate_pre_rc(*supplied_args)

        if self.mock_outputs:
            self._mock_pre_rc_outputs(*supplied_args)

        return self._gamma_call("MSP", "pre_rc", supplied_args)


    def _validate_PALSAR_proc_WB(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, CEOS_raw_data: str, beam: str, raw_out: str, prf: str = None, wflg: str = None):
        if CEOS_SAR_leader is not None:
            self._validate("PALSAR_proc_WB", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        if CEOS_raw_data is not None:
            self._validate("PALSAR_proc_WB", CEOS_raw_data == "-" or Path(CEOS_raw_data).exists(), f"CEOS_raw_data path does not exist ({CEOS_raw_data})")
        if beam is not None:
            self._validate("PALSAR_proc_WB", beam == "-" or Path(beam).exists(), f"beam path does not exist ({beam})")
        if prf is not None:
            self._validate("PALSAR_proc_WB", prf == "-" or Path(prf).exists(), f"prf path does not exist ({prf})")
        if wflg is not None:
            self._validate("PALSAR_proc_WB", wflg == "-" or Path(wflg).exists(), f"wflg path does not exist ({wflg})")

    def _mock_PALSAR_proc_WB_outputs(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, CEOS_raw_data: str, beam: str, raw_out: str, prf: str = None, wflg: str = None):
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw_out is not None and raw_out != "-":
            Path(raw_out).touch()

    def PALSAR_proc_WB(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, CEOS_raw_data: str, beam: str, raw_out: str, prf: str = None, wflg: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PALSAR_proc_WB))

        if self.validate_inputs:
            self._validate_PALSAR_proc_WB(*supplied_args)

        if self.mock_outputs:
            self._mock_PALSAR_proc_WB_outputs(*supplied_args)

        return self._gamma_call("MSP", "PALSAR_proc_WB", supplied_args)


    def _validate_ORRM_proc(self, PROC_par: str, ORRM: str, nstate = None):
        if ORRM is not None:
            self._validate("ORRM_proc", ORRM == "-" or Path(ORRM).exists(), f"ORRM path does not exist ({ORRM})")

    def _mock_ORRM_proc_outputs(self, PROC_par: str, ORRM: str, nstate = None):
        if PROC_par is not None and PROC_par != "-" and not Path(PROC_par).exists():
            Path(PROC_par).touch()

    def ORRM_proc(self, PROC_par: str, ORRM: str, nstate = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORRM_proc))

        if self.validate_inputs:
            self._validate_ORRM_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_ORRM_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "ORRM_proc", supplied_args)


    def _validate_ERS_proc_UK(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_UK", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_UK_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_UK(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_UK))

        if self.validate_inputs:
            self._validate_ERS_proc_UK(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_UK_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_UK", supplied_args)


    def _validate_RSAT_raw(self, CEOS_leader: str, SAR_par: str, PROC_par: str, raw_data_files: str = None):
        if CEOS_leader is not None:
            self._validate("RSAT_raw", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if raw_data_files is not None:
            self._validate("RSAT_raw", raw_data_files == "-" or Path(raw_data_files).exists(), f"raw_data_files path does not exist ({raw_data_files})")

    def _mock_RSAT_raw_outputs(self, CEOS_leader: str, SAR_par: str, PROC_par: str, raw_data_files: str = None):
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def RSAT_raw(self, CEOS_leader: str, SAR_par: str, PROC_par: str, raw_data_files: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.RSAT_raw))

        if self.validate_inputs:
            self._validate_RSAT_raw(*supplied_args)

        if self.mock_outputs:
            self._mock_RSAT_raw_outputs(*supplied_args)

        return self._gamma_call("MSP", "RSAT_raw", supplied_args)


    def _validate_ERS_ENVISAT_proc(self, L0: str, SAR_par: str, PROC_par: str, raw: str, loff = None, nl = None, swst_flg = None):
        if L0 is not None:
            self._validate("ERS_ENVISAT_proc", L0 == "-" or Path(L0).exists(), f"L0 path does not exist ({L0})")
        valid_values = [0, 1] + [None]
        self._validate("ERS_ENVISAT_proc", swst_flg == "-" or swst_flg in valid_values, f"swst_flg is not a valid value (expects: {valid_values}, got: {swst_flg})")

    def _mock_ERS_ENVISAT_proc_outputs(self, L0: str, SAR_par: str, PROC_par: str, raw: str, loff = None, nl = None, swst_flg = None):
        if SAR_par is not None and SAR_par != "-" and not Path(SAR_par).exists():
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw is not None and raw != "-":
            Path(raw).touch()

    def ERS_ENVISAT_proc(self, L0: str, SAR_par: str, PROC_par: str, raw: str, loff = None, nl = None, swst_flg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_ENVISAT_proc))

        if self.validate_inputs:
            self._validate_ERS_ENVISAT_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_ENVISAT_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_ENVISAT_proc", supplied_args)


    def _validate_multi_SLC(self, SLC_PROC_par: str, MLI_PROC_par: str, SLC: str, MLI: str, rlks, azlks, slc_format = None):
        if SLC_PROC_par is not None:
            self._validate("multi_SLC", SLC_PROC_par == "-" or Path(SLC_PROC_par).exists(), f"SLC_PROC_par path does not exist ({SLC_PROC_par})")
        if SLC is not None:
            self._validate("multi_SLC", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        valid_values = [0, 1] + [None]
        self._validate("multi_SLC", slc_format == "-" or slc_format in valid_values, f"slc_format is not a valid value (expects: {valid_values}, got: {slc_format})")

    def _mock_multi_SLC_outputs(self, SLC_PROC_par: str, MLI_PROC_par: str, SLC: str, MLI: str, rlks, azlks, slc_format = None):
        if MLI_PROC_par is not None and MLI_PROC_par != "-":
            Path(MLI_PROC_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()

    def multi_SLC(self, SLC_PROC_par: str, MLI_PROC_par: str, SLC: str, MLI: str, rlks, azlks, slc_format = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_SLC))

        if self.validate_inputs:
            self._validate_multi_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_SLC_outputs(*supplied_args)

        return self._gamma_call("MSP", "multi_SLC", supplied_args)


    def _validate_JERS_acs(self, USER_HEADER: str, SEG_DESCR: str, ORBIT_DATA: str, SENSOR_DATA: str, track: str, SAR_par: str, PROC_par: str, raw_out: str, loff, nl, nsx = None, fsx = None, deskew = None, terra_alt = None):
        if USER_HEADER is not None:
            self._validate("JERS_acs", USER_HEADER == "-" or Path(USER_HEADER).exists(), f"USER_HEADER path does not exist ({USER_HEADER})")
        if SEG_DESCR is not None:
            self._validate("JERS_acs", SEG_DESCR == "-" or Path(SEG_DESCR).exists(), f"SEG_DESCR path does not exist ({SEG_DESCR})")
        if ORBIT_DATA is not None:
            self._validate("JERS_acs", ORBIT_DATA == "-" or Path(ORBIT_DATA).exists(), f"ORBIT_DATA path does not exist ({ORBIT_DATA})")
        if SENSOR_DATA is not None:
            self._validate("JERS_acs", SENSOR_DATA == "-" or Path(SENSOR_DATA).exists(), f"SENSOR_DATA path does not exist ({SENSOR_DATA})")

    def _mock_JERS_acs_outputs(self, USER_HEADER: str, SEG_DESCR: str, ORBIT_DATA: str, SENSOR_DATA: str, track: str, SAR_par: str, PROC_par: str, raw_out: str, loff, nl, nsx = None, fsx = None, deskew = None, terra_alt = None):
        if track is not None and track != "-":
            Path(track).touch()
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw_out is not None and raw_out != "-":
            Path(raw_out).touch()

    def JERS_acs(self, USER_HEADER: str, SEG_DESCR: str, ORBIT_DATA: str, SENSOR_DATA: str, track: str, SAR_par: str, PROC_par: str, raw_out: str, loff, nl, nsx = None, fsx = None, deskew = None, terra_alt = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.JERS_acs))

        if self.validate_inputs:
            self._validate_JERS_acs(*supplied_args)

        if self.mock_outputs:
            self._mock_JERS_acs_outputs(*supplied_args)

        return self._gamma_call("MSP", "JERS_acs", supplied_args)


    def _validate_DORIS_proc(self, PROC_par: str, DOR: str, nstate = None):
        if DOR is not None:
            self._validate("DORIS_proc", DOR == "-" or Path(DOR).exists(), f"DOR path does not exist ({DOR})")

    def _mock_DORIS_proc_outputs(self, PROC_par: str, DOR: str, nstate = None):
        if PROC_par is not None and PROC_par != "-" and not Path(PROC_par).exists():
            Path(PROC_par).touch()

    def DORIS_proc(self, PROC_par: str, DOR: str, nstate = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.DORIS_proc))

        if self.validate_inputs:
            self._validate_DORIS_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_DORIS_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "DORIS_proc", supplied_args)


    def _validate_ASAR_AP_proc(self, L0: str, INS: str, SAR_par1: str, SAR_par2: str, PROC_par1: str, PROC_par2: str, raw1: str, raw2: str, ant_gain1: str, ant_gain2: str, loff = None, nl = None, roff = None, nr = None, refer = None):
        if L0 is not None:
            self._validate("ASAR_AP_proc", L0 == "-" or Path(L0).exists(), f"L0 path does not exist ({L0})")
        if INS is not None:
            self._validate("ASAR_AP_proc", INS == "-" or Path(INS).exists(), f"INS path does not exist ({INS})")
        if ant_gain1 is not None:
            self._validate("ASAR_AP_proc", ant_gain1 == "-" or Path(ant_gain1).exists(), f"ant_gain1 path does not exist ({ant_gain1})")
        if ant_gain2 is not None:
            self._validate("ASAR_AP_proc", ant_gain2 == "-" or Path(ant_gain2).exists(), f"ant_gain2 path does not exist ({ant_gain2})")

    def _mock_ASAR_AP_proc_outputs(self, L0: str, INS: str, SAR_par1: str, SAR_par2: str, PROC_par1: str, PROC_par2: str, raw1: str, raw2: str, ant_gain1: str, ant_gain2: str, loff = None, nl = None, roff = None, nr = None, refer = None):
        if SAR_par1 is not None and SAR_par1 != "-":
            Path(SAR_par1).touch()
        if SAR_par2 is not None and SAR_par2 != "-":
            Path(SAR_par2).touch()
        if PROC_par1 is not None and PROC_par1 != "-":
            Path(PROC_par1).touch()
        if PROC_par2 is not None and PROC_par2 != "-":
            Path(PROC_par2).touch()
        if raw1 is not None and raw1 != "-":
            Path(raw1).touch()
        if raw2 is not None and raw2 != "-":
            Path(raw2).touch()

    def ASAR_AP_proc(self, L0: str, INS: str, SAR_par1: str, SAR_par2: str, PROC_par1: str, PROC_par2: str, raw1: str, raw2: str, ant_gain1: str, ant_gain2: str, loff = None, nl = None, roff = None, nr = None, refer = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ASAR_AP_proc))

        if self.validate_inputs:
            self._validate_ASAR_AP_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_ASAR_AP_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "ASAR_AP_proc", supplied_args)


    def _validate_JERS_proc_ASF(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("JERS_proc_ASF", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_JERS_proc_ASF_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def JERS_proc_ASF(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.JERS_proc_ASF))

        if self.validate_inputs:
            self._validate_JERS_proc_ASF(*supplied_args)

        if self.mock_outputs:
            self._mock_JERS_proc_ASF_outputs(*supplied_args)

        return self._gamma_call("MSP", "JERS_proc_ASF", supplied_args)


    def _validate_rc_real(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, loff = None, nl = None, kaiser = None, nr_ext = None, fr_ext = None, r_chirp: str = None, rfi_filt = None, rfi_thres = None):
        if SAR_par is not None:
            self._validate("rc_real", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("rc_real", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("rc_real", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")
        if r_chirp is not None:
            self._validate("rc_real", r_chirp == "-" or Path(r_chirp).exists(), f"r_chirp path does not exist ({r_chirp})")

    def _mock_rc_real_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, loff = None, nl = None, kaiser = None, nr_ext = None, fr_ext = None, r_chirp: str = None, rfi_filt = None, rfi_thres = None):
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()

    def rc_real(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, loff = None, nl = None, kaiser = None, nr_ext = None, fr_ext = None, r_chirp: str = None, rfi_filt = None, rfi_thres = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rc_real))

        if self.validate_inputs:
            self._validate_rc_real(*supplied_args)

        if self.mock_outputs:
            self._mock_rc_real_outputs(*supplied_args)

        return self._gamma_call("MSP", "rc_real", supplied_args)


    def _validate_ERS_proc_CRISP(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_CRISP", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_CRISP_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_CRISP(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_CRISP))

        if self.validate_inputs:
            self._validate_ERS_proc_CRISP(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_CRISP_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_CRISP", supplied_args)


    def _validate_prefilt(self, SAR_par: str, PROC_par: str, rc_data: str, prefilt_out: str, prefilt_dec, filt_lm = None):
        if SAR_par is not None:
            self._validate("prefilt", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("prefilt", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if rc_data is not None:
            self._validate("prefilt", rc_data == "-" or Path(rc_data).exists(), f"rc_data path does not exist ({rc_data})")

    def _mock_prefilt_outputs(self, SAR_par: str, PROC_par: str, rc_data: str, prefilt_out: str, prefilt_dec, filt_lm = None):
        if prefilt_out is not None and prefilt_out != "-":
            Path(prefilt_out).touch()

    def prefilt(self, SAR_par: str, PROC_par: str, rc_data: str, prefilt_out: str, prefilt_dec, filt_lm = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.prefilt))

        if self.validate_inputs:
            self._validate_prefilt(*supplied_args)

        if self.mock_outputs:
            self._mock_prefilt_outputs(*supplied_args)

        return self._gamma_call("MSP", "prefilt", supplied_args)


    def _validate_doppler(self, SAR_par: str, PROC_par: str, signal_data: str, doppler: str, loff = None, nsub = None, ambig_flag = None, namb = None, order = None, pltflg = None):
        if SAR_par is not None:
            self._validate("doppler", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("doppler", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("doppler", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")
        valid_values = [0, 1, 2] + [None]
        self._validate("doppler", ambig_flag == "-" or ambig_flag in valid_values, f"ambig_flag is not a valid value (expects: {valid_values}, got: {ambig_flag})")
        valid_values = [0, 1] + [None]
        self._validate("doppler", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_doppler_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, doppler: str, loff = None, nsub = None, ambig_flag = None, namb = None, order = None, pltflg = None):
        if doppler is not None and doppler != "-":
            Path(doppler).touch()

    def doppler(self, SAR_par: str, PROC_par: str, signal_data: str, doppler: str, loff = None, nsub = None, ambig_flag = None, namb = None, order = None, pltflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.doppler))

        if self.validate_inputs:
            self._validate_doppler(*supplied_args)

        if self.mock_outputs:
            self._mock_doppler_outputs(*supplied_args)

        return self._gamma_call("MSP", "doppler", supplied_args)


    def _validate_DELFT_proc2(self, PROC_par: str, DELFT_dir, nstate = None, interval = None, ODR = None):
        if PROC_par is not None:
            self._validate("DELFT_proc2", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")

    def _mock_DELFT_proc2_outputs(self, PROC_par: str, DELFT_dir, nstate = None, interval = None, ODR = None):
        pass

    def DELFT_proc2(self, PROC_par: str, DELFT_dir, nstate = None, interval = None, ODR = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.DELFT_proc2))

        if self.validate_inputs:
            self._validate_DELFT_proc2(*supplied_args)

        if self.mock_outputs:
            self._mock_DELFT_proc2_outputs(*supplied_args)

        return self._gamma_call("MSP", "DELFT_proc2", supplied_args)


    def _validate_copy(self, infile: str, outfile: str, lbytes, start = None, nlines = None, offset = None, file_ldr = None, offb = None, nbyte = None):
        if infile is not None:
            self._validate("copy", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")

    def _mock_copy_outputs(self, infile: str, outfile: str, lbytes, start = None, nlines = None, offset = None, file_ldr = None, offb = None, nbyte = None):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def copy(self, infile: str, outfile: str, lbytes, start = None, nlines = None, offset = None, file_ldr = None, offb = None, nbyte = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.copy))

        if self.validate_inputs:
            self._validate_copy(*supplied_args)

        if self.mock_outputs:
            self._mock_copy_outputs(*supplied_args)

        return self._gamma_call("MSP", "copy", supplied_args)


    def _validate_ERS_proc_ESRIN_ACS(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_ESRIN_ACS", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_ESRIN_ACS_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_ESRIN_ACS(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ESRIN_ACS))

        if self.validate_inputs:
            self._validate_ERS_proc_ESRIN_ACS(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_ESRIN_ACS_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_ESRIN_ACS", supplied_args)


    def _validate_ERS_proc_ASF_91(self, CEOS_SAR_leader: str, CEOS_trailer: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_ASF_91", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        if CEOS_trailer is not None:
            self._validate("ERS_proc_ASF_91", CEOS_trailer == "-" or Path(CEOS_trailer).exists(), f"CEOS_trailer path does not exist ({CEOS_trailer})")

    def _mock_ERS_proc_ASF_91_outputs(self, CEOS_SAR_leader: str, CEOS_trailer: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_ASF_91(self, CEOS_SAR_leader: str, CEOS_trailer: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ASF_91))

        if self.validate_inputs:
            self._validate_ERS_proc_ASF_91(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_ASF_91_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_ASF_91", supplied_args)


    def _validate_ORB_prop(self, PROC_par: str, nstate = None, interval = None, extra = None):
        if PROC_par is not None:
            self._validate("ORB_prop", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")

    def _mock_ORB_prop_outputs(self, PROC_par: str, nstate = None, interval = None, extra = None):
        pass

    def ORB_prop(self, PROC_par: str, nstate = None, interval = None, extra = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORB_prop))

        if self.validate_inputs:
            self._validate_ORB_prop(*supplied_args)

        if self.mock_outputs:
            self._mock_ORB_prop_outputs(*supplied_args)

        return self._gamma_call("MSP", "ORB_prop", supplied_args)


    def _validate_ERS_fix(self, ERS_PAF, SAR_par: str, PROC_par: str, cc_flag, raw = None):
        if SAR_par is not None:
            self._validate("ERS_fix", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("ERS_fix", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")

    def _mock_ERS_fix_outputs(self, ERS_PAF, SAR_par: str, PROC_par: str, cc_flag, raw = None):
        pass

    def ERS_fix(self, ERS_PAF, SAR_par: str, PROC_par: str, cc_flag, raw = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_fix))

        if self.validate_inputs:
            self._validate_ERS_fix(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_fix_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_fix", supplied_args)


    def _validate_ERS_proc_CCRS(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_CCRS", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_CCRS_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_CCRS(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_CCRS))

        if self.validate_inputs:
            self._validate_ERS_proc_CCRS(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_CCRS_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_CCRS", supplied_args)


    def _validate_ptarg(self, SLC: str, width: str, r_samp: str, az_samp: str, ptr_image: str, r_plot: str, az_plot: str, data_format, win = None, pltflg = None):
        if SLC is not None:
            self._validate("ptarg", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        if width is not None:
            self._validate("ptarg", width == "-" or Path(width).exists(), f"width path does not exist ({width})")
        if r_samp is not None:
            self._validate("ptarg", r_samp == "-" or Path(r_samp).exists(), f"r_samp path does not exist ({r_samp})")
        if az_samp is not None:
            self._validate("ptarg", az_samp == "-" or Path(az_samp).exists(), f"az_samp path does not exist ({az_samp})")
        valid_values = [0, 1]
        self._validate("ptarg", data_format == "-" or data_format in valid_values, f"data_format is not a valid value (expects: {valid_values}, got: {data_format})")
        valid_values = [0, 1, 2] + [None]
        self._validate("ptarg", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_ptarg_outputs(self, SLC: str, width: str, r_samp: str, az_samp: str, ptr_image: str, r_plot: str, az_plot: str, data_format, win = None, pltflg = None):
        if ptr_image is not None and ptr_image != "-":
            Path(ptr_image).touch()
        if r_plot is not None and r_plot != "-":
            Path(r_plot).touch()
        if az_plot is not None and az_plot != "-":
            Path(az_plot).touch()

    def ptarg(self, SLC: str, width: str, r_samp: str, az_samp: str, ptr_image: str, r_plot: str, az_plot: str, data_format, win = None, pltflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ptarg))

        if self.validate_inputs:
            self._validate_ptarg(*supplied_args)

        if self.mock_outputs:
            self._mock_ptarg_outputs(*supplied_args)

        return self._gamma_call("MSP", "ptarg", supplied_args)


    def _validate_multi_GRD_SLC(self, SLC_PROC_par: str, GRD_PROC_par: str, SLC_image: str, GRD_image: str, rlks, azlks, interp_mode = None, sample_spacing = None, gr_start = None, t_start = None, t_end = None):
        if SLC_PROC_par is not None:
            self._validate("multi_GRD_SLC", SLC_PROC_par == "-" or Path(SLC_PROC_par).exists(), f"SLC_PROC_par path does not exist ({SLC_PROC_par})")
        if SLC_image is not None:
            self._validate("multi_GRD_SLC", SLC_image == "-" or Path(SLC_image).exists(), f"SLC_image path does not exist ({SLC_image})")
        valid_values = [0, 1] + [None]
        self._validate("multi_GRD_SLC", interp_mode == "-" or interp_mode in valid_values, f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})")

    def _mock_multi_GRD_SLC_outputs(self, SLC_PROC_par: str, GRD_PROC_par: str, SLC_image: str, GRD_image: str, rlks, azlks, interp_mode = None, sample_spacing = None, gr_start = None, t_start = None, t_end = None):
        if GRD_PROC_par is not None and GRD_PROC_par != "-":
            Path(GRD_PROC_par).touch()
        if GRD_image is not None and GRD_image != "-":
            Path(GRD_image).touch()

    def multi_GRD_SLC(self, SLC_PROC_par: str, GRD_PROC_par: str, SLC_image: str, GRD_image: str, rlks, azlks, interp_mode = None, sample_spacing = None, gr_start = None, t_start = None, t_end = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_GRD_SLC))

        if self.validate_inputs:
            self._validate_multi_GRD_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_GRD_SLC_outputs(*supplied_args)

        return self._gamma_call("MSP", "multi_GRD_SLC", supplied_args)


    def _validate_create_sar_par(self, SAR_par: str):
        pass

    def _mock_create_sar_par_outputs(self, SAR_par: str):
        if SAR_par is not None and SAR_par != "-" and not Path(SAR_par).exists():
            Path(SAR_par).touch()

    def create_sar_par(self, SAR_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_sar_par))

        if self.validate_inputs:
            self._validate_create_sar_par(*supplied_args)

        if self.mock_outputs:
            self._mock_create_sar_par_outputs(*supplied_args)

        return self._gamma_call("MSP", "create_sar_par", supplied_args)


    def _validate_rspec_JERS(self, SAR_par: str, PROC_par: str, signal_data: str, range_spec: str, nr_samp = None, nl_spec = None, loff = None, nlines = None, nr_ext = None, fr_ext = None):
        if SAR_par is not None:
            self._validate("rspec_JERS", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("rspec_JERS", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("rspec_JERS", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_rspec_JERS_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, range_spec: str, nr_samp = None, nl_spec = None, loff = None, nlines = None, nr_ext = None, fr_ext = None):
        if range_spec is not None and range_spec != "-":
            Path(range_spec).touch()

    def rspec_JERS(self, SAR_par: str, PROC_par: str, signal_data: str, range_spec: str, nr_samp = None, nl_spec = None, loff = None, nlines = None, nr_ext = None, fr_ext = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rspec_JERS))

        if self.validate_inputs:
            self._validate_rspec_JERS(*supplied_args)

        if self.mock_outputs:
            self._mock_rspec_JERS_outputs(*supplied_args)

        return self._gamma_call("MSP", "rspec_JERS", supplied_args)


    def _validate_azsp_IQ(self, SAR_par: str, PROC_par: str, signal_data: str, spectrum: str, loff = None, roff = None, nsub = None, ambig_flg = None, namb = None, pltflg = None):
        if SAR_par is not None:
            self._validate("azsp_IQ", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("azsp_IQ", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("azsp_IQ", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")
        valid_values = [0, 1] + [None]
        self._validate("azsp_IQ", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_azsp_IQ_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, spectrum: str, loff = None, roff = None, nsub = None, ambig_flg = None, namb = None, pltflg = None):
        if spectrum is not None and spectrum != "-":
            Path(spectrum).touch()

    def azsp_IQ(self, SAR_par: str, PROC_par: str, signal_data: str, spectrum: str, loff = None, roff = None, nsub = None, ambig_flg = None, namb = None, pltflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.azsp_IQ))

        if self.validate_inputs:
            self._validate_azsp_IQ(*supplied_args)

        if self.mock_outputs:
            self._mock_azsp_IQ_outputs(*supplied_args)

        return self._gamma_call("MSP", "azsp_IQ", supplied_args)


    def _validate_ERS_proc_ACRES(self, CEOS_SAR_leader: str, PROC_par: str, type = None):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_ACRES", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        valid_values = [0, 1] + [None]
        self._validate("ERS_proc_ACRES", type == "-" or type in valid_values, f"type is not a valid value (expects: {valid_values}, got: {type})")

    def _mock_ERS_proc_ACRES_outputs(self, CEOS_SAR_leader: str, PROC_par: str, type = None):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_ACRES(self, CEOS_SAR_leader: str, PROC_par: str, type = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ACRES))

        if self.validate_inputs:
            self._validate_ERS_proc_ACRES(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_ACRES_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_ACRES", supplied_args)


    def _validate_pre_rc_RSAT(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, prefilt_dec = None, loff = None, nl = None, nr_samp = None, kaiser = None, filt_lm = None, nr_ext = None, fr_ext = None):
        if SAR_par is not None:
            self._validate("pre_rc_RSAT", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("pre_rc_RSAT", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if signal_data is not None:
            self._validate("pre_rc_RSAT", signal_data == "-" or Path(signal_data).exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_pre_rc_RSAT_outputs(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, prefilt_dec = None, loff = None, nl = None, nr_samp = None, kaiser = None, filt_lm = None, nr_ext = None, fr_ext = None):
        if rc_data is not None and rc_data != "-":
            Path(rc_data).touch()

    def pre_rc_RSAT(self, SAR_par: str, PROC_par: str, signal_data: str, rc_data: str, prefilt_dec = None, loff = None, nl = None, nr_samp = None, kaiser = None, filt_lm = None, nr_ext = None, fr_ext = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pre_rc_RSAT))

        if self.validate_inputs:
            self._validate_pre_rc_RSAT(*supplied_args)

        if self.mock_outputs:
            self._mock_pre_rc_RSAT_outputs(*supplied_args)

        return self._gamma_call("MSP", "pre_rc_RSAT", supplied_args)


    def _validate_autof(self, SAR_par: str, PROC_par: str, rc_data: str, autofocus: str, SNR_min = None, prefilter = None, auto_az = None, az_offset = None, auto_bins = None, dop_ambig = None):
        if SAR_par is not None:
            self._validate("autof", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("autof", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if rc_data is not None:
            self._validate("autof", rc_data == "-" or Path(rc_data).exists(), f"rc_data path does not exist ({rc_data})")
        valid_values = [0, 1] + [None]
        self._validate("autof", dop_ambig == "-" or dop_ambig in valid_values, f"dop_ambig is not a valid value (expects: {valid_values}, got: {dop_ambig})")

    def _mock_autof_outputs(self, SAR_par: str, PROC_par: str, rc_data: str, autofocus: str, SNR_min = None, prefilter = None, auto_az = None, az_offset = None, auto_bins = None, dop_ambig = None):
        if autofocus is not None and autofocus != "-":
            Path(autofocus).touch()

    def autof(self, SAR_par: str, PROC_par: str, rc_data: str, autofocus: str, SNR_min = None, prefilter = None, auto_az = None, az_offset = None, auto_bins = None, dop_ambig = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.autof))

        if self.validate_inputs:
            self._validate_autof(*supplied_args)

        if self.mock_outputs:
            self._mock_autof_outputs(*supplied_args)

        return self._gamma_call("MSP", "autof", supplied_args)


    def _validate_cat_raw(self, RAW_list: str, SAR_par: str, PROC_par: str, RAW_out: str, fill = None, loff = None, nl = None):
        if RAW_list is not None:
            self._validate("cat_raw", RAW_list == "-" or Path(RAW_list).exists(), f"RAW_list path does not exist ({RAW_list})")
        valid_values = [0, 1] + [None]
        self._validate("cat_raw", fill == "-" or fill in valid_values, f"fill is not a valid value (expects: {valid_values}, got: {fill})")

    def _mock_cat_raw_outputs(self, RAW_list: str, SAR_par: str, PROC_par: str, RAW_out: str, fill = None, loff = None, nl = None):
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if RAW_out is not None and RAW_out != "-":
            Path(RAW_out).touch()

    def cat_raw(self, RAW_list: str, SAR_par: str, PROC_par: str, RAW_out: str, fill = None, loff = None, nl = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cat_raw))

        if self.validate_inputs:
            self._validate_cat_raw(*supplied_args)

        if self.mock_outputs:
            self._mock_cat_raw_outputs(*supplied_args)

        return self._gamma_call("MSP", "cat_raw", supplied_args)


    def _validate_ERS_proc_ASI(self, CEOS_SAR_leader: str, PROC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("ERS_proc_ASI", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_ERS_proc_ASI_outputs(self, CEOS_SAR_leader: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def ERS_proc_ASI(self, CEOS_SAR_leader: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ASI))

        if self.validate_inputs:
            self._validate_ERS_proc_ASI(*supplied_args)

        if self.mock_outputs:
            self._mock_ERS_proc_ASI_outputs(*supplied_args)

        return self._gamma_call("MSP", "ERS_proc_ASI", supplied_args)


    def _validate_JERS_proc(self, CEOS_SAR_ldr: str, PROC_par: str):
        if CEOS_SAR_ldr is not None:
            self._validate("JERS_proc", CEOS_SAR_ldr == "-" or Path(CEOS_SAR_ldr).exists(), f"CEOS_SAR_ldr path does not exist ({CEOS_SAR_ldr})")

    def _mock_JERS_proc_outputs(self, CEOS_SAR_ldr: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def JERS_proc(self, CEOS_SAR_ldr: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.JERS_proc))

        if self.validate_inputs:
            self._validate_JERS_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_JERS_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "JERS_proc", supplied_args)


    def _validate_PALSAR_antpat(self, SAR_par: str, PROC_par: str, PAL_ANT: str, ant_file: str, Beam_ID = None, TX_POL = None, RX_POL = None, Beam = None):
        if SAR_par is not None:
            self._validate("PALSAR_antpat", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("PALSAR_antpat", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        if PAL_ANT is not None:
            self._validate("PALSAR_antpat", PAL_ANT == "-" or Path(PAL_ANT).exists(), f"PAL_ANT path does not exist ({PAL_ANT})")
        valid_values = [0, 1] + [None]
        self._validate("PALSAR_antpat", TX_POL == "-" or TX_POL in valid_values, f"TX_POL is not a valid value (expects: {valid_values}, got: {TX_POL})")
        valid_values = [0, 1] + [None]
        self._validate("PALSAR_antpat", RX_POL == "-" or RX_POL in valid_values, f"RX_POL is not a valid value (expects: {valid_values}, got: {RX_POL})")

    def _mock_PALSAR_antpat_outputs(self, SAR_par: str, PROC_par: str, PAL_ANT: str, ant_file: str, Beam_ID = None, TX_POL = None, RX_POL = None, Beam = None):
        if ant_file is not None and ant_file != "-":
            Path(ant_file).touch()

    def PALSAR_antpat(self, SAR_par: str, PROC_par: str, PAL_ANT: str, ant_file: str, Beam_ID = None, TX_POL = None, RX_POL = None, Beam = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PALSAR_antpat))

        if self.validate_inputs:
            self._validate_PALSAR_antpat(*supplied_args)

        if self.mock_outputs:
            self._mock_PALSAR_antpat_outputs(*supplied_args)

        return self._gamma_call("MSP", "PALSAR_antpat", supplied_args)


    def _validate_create_proc_par(self, SAR_par: str, PROC_par: str):
        if SAR_par is not None:
            self._validate("create_proc_par", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")

    def _mock_create_proc_par_outputs(self, SAR_par: str, PROC_par: str):
        if PROC_par is not None and PROC_par != "-" and not Path(PROC_par).exists():
            Path(PROC_par).touch()

    def create_proc_par(self, SAR_par: str, PROC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_proc_par))

        if self.validate_inputs:
            self._validate_create_proc_par(*supplied_args)

        if self.mock_outputs:
            self._mock_create_proc_par_outputs(*supplied_args)

        return self._gamma_call("MSP", "create_proc_par", supplied_args)


    def _validate_SIRC_proc(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, UTC_MET = None):
        if CEOS_SAR_leader is not None:
            self._validate("SIRC_proc", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_SIRC_proc_outputs(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, UTC_MET = None):
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()

    def SIRC_proc(self, CEOS_SAR_leader: str, SAR_par: str, PROC_par: str, UTC_MET = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SIRC_proc))

        if self.validate_inputs:
            self._validate_SIRC_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_SIRC_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "SIRC_proc", supplied_args)


    def _validate_ASAR_IM_proc(self, L0: str, INS: str, SAR_par: str, PROC_par: str, raw: str, ant_gain: str, loff = None, nl = None):
        if L0 is not None:
            self._validate("ASAR_IM_proc", L0 == "-" or Path(L0).exists(), f"L0 path does not exist ({L0})")
        if INS is not None:
            self._validate("ASAR_IM_proc", INS == "-" or Path(INS).exists(), f"INS path does not exist ({INS})")
        if ant_gain is not None:
            self._validate("ASAR_IM_proc", ant_gain == "-" or Path(ant_gain).exists(), f"ant_gain path does not exist ({ant_gain})")

    def _mock_ASAR_IM_proc_outputs(self, L0: str, INS: str, SAR_par: str, PROC_par: str, raw: str, ant_gain: str, loff = None, nl = None):
        if SAR_par is not None and SAR_par != "-":
            Path(SAR_par).touch()
        if PROC_par is not None and PROC_par != "-":
            Path(PROC_par).touch()
        if raw is not None and raw != "-":
            Path(raw).touch()

    def ASAR_IM_proc(self, L0: str, INS: str, SAR_par: str, PROC_par: str, raw: str, ant_gain: str, loff = None, nl = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ASAR_IM_proc))

        if self.validate_inputs:
            self._validate_ASAR_IM_proc(*supplied_args)

        if self.mock_outputs:
            self._mock_ASAR_IM_proc_outputs(*supplied_args)

        return self._gamma_call("MSP", "ASAR_IM_proc", supplied_args)


    def _validate_dishgt(self, hgt, pwr, width, start_hgt = None, start_pwr = None, nlines = None, m_cycle = None, scale = None, exp = None):
        pass

    def _mock_dishgt_outputs(self, hgt, pwr, width, start_hgt = None, start_pwr = None, nlines = None, m_cycle = None, scale = None, exp = None):
        pass

    def dishgt(self, hgt, pwr, width, start_hgt = None, start_pwr = None, nlines = None, m_cycle = None, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dishgt))

        if self.validate_inputs:
            self._validate_dishgt(*supplied_args)

        if self.mock_outputs:
            self._mock_dishgt_outputs(*supplied_args)

        return self._gamma_call("DISP", "dishgt", supplied_args)


    def _validate_rasdt_pwr(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cycle = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        pass

    def _mock_rasdt_pwr_outputs(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cycle = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasdt_pwr(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cycle = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasdt_pwr))

        if self.validate_inputs:
            self._validate_rasdt_pwr(*supplied_args)

        if self.mock_outputs:
            self._mock_rasdt_pwr_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasdt_pwr", supplied_args)


    def _validate_rasdt_cmap(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, min = None, max = None, mflg = None, cmap = None, scale = None, exp = None, rasf: str = None):
        valid_values = [0, 1] + [None]
        self._validate("rasdt_cmap", mflg == "-" or mflg in valid_values, f"mflg is not a valid value (expects: {valid_values}, got: {mflg})")

    def _mock_rasdt_cmap_outputs(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, min = None, max = None, mflg = None, cmap = None, scale = None, exp = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasdt_cmap(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, min = None, max = None, mflg = None, cmap = None, scale = None, exp = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasdt_cmap))

        if self.validate_inputs:
            self._validate_rasdt_cmap(*supplied_args)

        if self.mock_outputs:
            self._mock_rasdt_cmap_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasdt_cmap", supplied_args)


    def _validate_dis2hgt(self, hgt1, hgt2, width1, width2, start = None, nlines = None, roff = None, azoff = None, m_cycle = None):
        pass

    def _mock_dis2hgt_outputs(self, hgt1, hgt2, width1, width2, start = None, nlines = None, roff = None, azoff = None, m_cycle = None):
        pass

    def dis2hgt(self, hgt1, hgt2, width1, width2, start = None, nlines = None, roff = None, azoff = None, m_cycle = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2hgt))

        if self.validate_inputs:
            self._validate_dis2hgt(*supplied_args)

        if self.mock_outputs:
            self._mock_dis2hgt_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis2hgt", supplied_args)


    def _validate_gcp_ras(self, ras: str, GCP: str, mag = None, win_sz = None):
        if ras is not None:
            self._validate("gcp_ras", ras == "-" or Path(ras).exists(), f"ras path does not exist ({ras})")

    def _mock_gcp_ras_outputs(self, ras: str, GCP: str, mag = None, win_sz = None):
        if GCP is not None and GCP != "-":
            Path(GCP).touch()

    def gcp_ras(self, ras: str, GCP: str, mag = None, win_sz = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gcp_ras))

        if self.validate_inputs:
            self._validate_gcp_ras(*supplied_args)

        if self.mock_outputs:
            self._mock_gcp_ras_outputs(*supplied_args)

        return self._gamma_call("DISP", "gcp_ras", supplied_args)


    def _validate_cpx_math(self, d1: str, d2: str, d_out: str, width, mode, roff = None, loff = None, nr = None, nl = None, c_re = None, c_im = None, zflg = None, rflg = None):
        if d1 is not None:
            self._validate("cpx_math", d1 == "-" or Path(d1).exists(), f"d1 path does not exist ({d1})")
        if d2 is not None:
            self._validate("cpx_math", d2 == "-" or Path(d2).exists(), f"d2 path does not exist ({d2})")
        valid_values = [0, 1, 2, 3]
        self._validate("cpx_math", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")
        valid_values = [0, 1] + [None]
        self._validate("cpx_math", zflg == "-" or zflg in valid_values, f"zflg is not a valid value (expects: {valid_values}, got: {zflg})")

    def _mock_cpx_math_outputs(self, d1: str, d2: str, d_out: str, width, mode, roff = None, loff = None, nr = None, nl = None, c_re = None, c_im = None, zflg = None, rflg = None):
        if d_out is not None and d_out != "-":
            Path(d_out).touch()

    def cpx_math(self, d1: str, d2: str, d_out: str, width, mode, roff = None, loff = None, nr = None, nl = None, c_re = None, c_im = None, zflg = None, rflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cpx_math))

        if self.validate_inputs:
            self._validate_cpx_math(*supplied_args)

        if self.mock_outputs:
            self._mock_cpx_math_outputs(*supplied_args)

        return self._gamma_call("DISP", "cpx_math", supplied_args)


    def _validate_disflag(self, flag: str, width, start = None, nlines = None):
        if flag is not None:
            self._validate("disflag", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")

    def _mock_disflag_outputs(self, flag: str, width, start = None, nlines = None):
        pass

    def disflag(self, flag: str, width, start = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disflag))

        if self.validate_inputs:
            self._validate_disflag(*supplied_args)

        if self.mock_outputs:
            self._mock_disflag_outputs(*supplied_args)

        return self._gamma_call("DISP", "disflag", supplied_args)


    def _validate_set_value(self, PAR_in: str, PAR_out: str, keyword, value, new_key = None):
        if PAR_in is not None:
            self._validate("set_value", PAR_in == "-" or Path(PAR_in).exists(), f"PAR_in path does not exist ({PAR_in})")
        valid_values = [0, 1] + [None]
        self._validate("set_value", new_key == "-" or new_key in valid_values, f"new_key is not a valid value (expects: {valid_values}, got: {new_key})")

    def _mock_set_value_outputs(self, PAR_in: str, PAR_out: str, keyword, value, new_key = None):
        if PAR_out is not None and PAR_out != "-":
            Path(PAR_out).touch()

    def set_value(self, PAR_in: str, PAR_out: str, keyword, value, new_key = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.set_value))

        if self.validate_inputs:
            self._validate_set_value(*supplied_args)

        if self.mock_outputs:
            self._mock_set_value_outputs(*supplied_args)

        return self._gamma_call("DISP", "set_value", supplied_args)


    def _validate_cpx_to_real(self, cpx: str, real: str, width, type):
        if cpx is not None:
            self._validate("cpx_to_real", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")
        valid_values = [0, 1, 2, 3, 4]
        self._validate("cpx_to_real", type == "-" or type in valid_values, f"type is not a valid value (expects: {valid_values}, got: {type})")

    def _mock_cpx_to_real_outputs(self, cpx: str, real: str, width, type):
        if real is not None and real != "-":
            Path(real).touch()

    def cpx_to_real(self, cpx: str, real: str, width, type):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cpx_to_real))

        if self.validate_inputs:
            self._validate_cpx_to_real(*supplied_args)

        if self.mock_outputs:
            self._mock_cpx_to_real_outputs(*supplied_args)

        return self._gamma_call("DISP", "cpx_to_real", supplied_args)


    def _validate_rascc(self, cc, pwr, width, start_cc = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cmin = None, cmax = None, scale = None, exp = None, LR = None, rasf: str = None):
        pass

    def _mock_rascc_outputs(self, cc, pwr, width, start_cc = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cmin = None, cmax = None, scale = None, exp = None, LR = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rascc(self, cc, pwr, width, start_cc = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cmin = None, cmax = None, scale = None, exp = None, LR = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rascc))

        if self.validate_inputs:
            self._validate_rascc(*supplied_args)

        if self.mock_outputs:
            self._mock_rascc_outputs(*supplied_args)

        return self._gamma_call("DISP", "rascc", supplied_args)


    def _validate_disgbyte(self, image: str, width, start = None, nlines = None, scale = None):
        if image is not None:
            self._validate("disgbyte", image == "-" or Path(image).exists(), f"image path does not exist ({image})")

    def _mock_disgbyte_outputs(self, image: str, width, start = None, nlines = None, scale = None):
        pass

    def disgbyte(self, image: str, width, start = None, nlines = None, scale = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disgbyte))

        if self.validate_inputs:
            self._validate_disgbyte(*supplied_args)

        if self.mock_outputs:
            self._mock_disgbyte_outputs(*supplied_args)

        return self._gamma_call("DISP", "disgbyte", supplied_args)


    def _validate_dis_dB(self, pwr, width, start = None, nlines = None, min_dB = None, max_dB = None):
        pass

    def _mock_dis_dB_outputs(self, pwr, width, start = None, nlines = None, min_dB = None, max_dB = None):
        pass

    def dis_dB(self, pwr, width, start = None, nlines = None, min_dB = None, max_dB = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis_dB))

        if self.validate_inputs:
            self._validate_dis_dB(*supplied_args)

        if self.mock_outputs:
            self._mock_dis_dB_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis_dB", supplied_args)


    def _validate_discc(self, cc, pwr, width, start_cc = None, start_pwr = None, nlines = None, min_corr = None, max_corr = None, scale = None, exp = None):
        pass

    def _mock_discc_outputs(self, cc, pwr, width, start_cc = None, start_pwr = None, nlines = None, min_corr = None, max_corr = None, scale = None, exp = None):
        pass

    def discc(self, cc, pwr, width, start_cc = None, start_pwr = None, nlines = None, min_corr = None, max_corr = None, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.discc))

        if self.validate_inputs:
            self._validate_discc(*supplied_args)

        if self.mock_outputs:
            self._mock_discc_outputs(*supplied_args)

        return self._gamma_call("DISP", "discc", supplied_args)


    def _validate_svg_map(self, image: str, dem_par: str, svg: str, font = None, fsize = None, color = None, gcolor = None, majorx = None, majory = None, minorx = None, minory = None, thick = None, grid = None, gopac = None):
        if image is not None:
            self._validate("svg_map", image == "-" or Path(image).exists(), f"image path does not exist ({image})")
        if dem_par is not None:
            self._validate("svg_map", dem_par == "-" or Path(dem_par).exists(), f"dem_par path does not exist ({dem_par})")

    def _mock_svg_map_outputs(self, image: str, dem_par: str, svg: str, font = None, fsize = None, color = None, gcolor = None, majorx = None, majory = None, minorx = None, minory = None, thick = None, grid = None, gopac = None):
        if svg is not None and svg != "-":
            Path(svg).touch()

    def svg_map(self, image: str, dem_par: str, svg: str, font = None, fsize = None, color = None, gcolor = None, majorx = None, majory = None, minorx = None, minory = None, thick = None, grid = None, gopac = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.svg_map))

        if self.validate_inputs:
            self._validate_svg_map(*supplied_args)

        if self.mock_outputs:
            self._mock_svg_map_outputs(*supplied_args)

        return self._gamma_call("DISP", "svg_map", supplied_args)


    def _validate_gbyte2float(self, infile: str, outfile: str):
        if infile is not None:
            self._validate("gbyte2float", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")

    def _mock_gbyte2float_outputs(self, infile: str, outfile: str):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def gbyte2float(self, infile: str, outfile: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gbyte2float))

        if self.validate_inputs:
            self._validate_gbyte2float(*supplied_args)

        if self.mock_outputs:
            self._mock_gbyte2float_outputs(*supplied_args)

        return self._gamma_call("DISP", "gbyte2float", supplied_args)


    def _validate_real_to_cpx(self, data1: str, data2: str = None):
        if data1 is not None:
            self._validate("real_to_cpx", data1 == "-" or Path(data1).exists(), f"data1 path does not exist ({data1})")
        if data2 is not None:
            self._validate("real_to_cpx", data2 == "-" or Path(data2).exists(), f"data2 path does not exist ({data2})")

    def _mock_real_to_cpx_outputs(self, data1: str, data2: str = None):
        pass

    def real_to_cpx(self, data1: str, data2: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.real_to_cpx))

        if self.validate_inputs:
            self._validate_real_to_cpx(*supplied_args)

        if self.mock_outputs:
            self._mock_real_to_cpx_outputs(*supplied_args)

        return self._gamma_call("DISP", "real_to_cpx", supplied_args)


    def _validate_rasmph_pwr(self, cpx: str, pwr: str, width, start_cpx = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        if cpx is not None:
            self._validate("rasmph_pwr", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")
        if pwr is not None:
            self._validate("rasmph_pwr", pwr == "-" or Path(pwr).exists(), f"pwr path does not exist ({pwr})")

    def _mock_rasmph_pwr_outputs(self, cpx: str, pwr: str, width, start_cpx = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasmph_pwr(self, cpx: str, pwr: str, width, start_cpx = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasmph_pwr))

        if self.validate_inputs:
            self._validate_rasmph_pwr(*supplied_args)

        if self.mock_outputs:
            self._mock_rasmph_pwr_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasmph_pwr", supplied_args)


    def _validate_data2geotiff(self, DEM_par: str, data: str, type, GeoTIFF: str, nodata = None):
        if DEM_par is not None:
            self._validate("data2geotiff", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if data is not None:
            self._validate("data2geotiff", data == "-" or Path(data).exists(), f"data path does not exist ({data})")
        valid_values = [0, 1, 2, 3, 4, 5]
        self._validate("data2geotiff", type == "-" or type in valid_values, f"type is not a valid value (expects: {valid_values}, got: {type})")

    def _mock_data2geotiff_outputs(self, DEM_par: str, data: str, type, GeoTIFF: str, nodata = None):
        if GeoTIFF is not None and GeoTIFF != "-":
            Path(GeoTIFF).touch()

    def data2geotiff(self, DEM_par: str, data: str, type, GeoTIFF: str, nodata = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.data2geotiff))

        if self.validate_inputs:
            self._validate_data2geotiff(*supplied_args)

        if self.mock_outputs:
            self._mock_data2geotiff_outputs(*supplied_args)

        return self._gamma_call("DISP", "data2geotiff", supplied_args)


    def _validate_disras(self, ras: str, mag = None, win_sz = None):
        if ras is not None:
            self._validate("disras", ras == "-" or Path(ras).exists(), f"ras path does not exist ({ras})")

    def _mock_disras_outputs(self, ras: str, mag = None, win_sz = None):
        pass

    def disras(self, ras: str, mag = None, win_sz = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disras))

        if self.validate_inputs:
            self._validate_disras(*supplied_args)

        if self.mock_outputs:
            self._mock_disras_outputs(*supplied_args)

        return self._gamma_call("DISP", "disras", supplied_args)


    def _validate_disrmg(self, unw, pwr, width, start_unw = None, start_pwr = None, nlines = None, ph_scale = None, scale = None, exp = None, ph_offset = None):
        pass

    def _mock_disrmg_outputs(self, unw, pwr, width, start_unw = None, start_pwr = None, nlines = None, ph_scale = None, scale = None, exp = None, ph_offset = None):
        pass

    def disrmg(self, unw, pwr, width, start_unw = None, start_pwr = None, nlines = None, ph_scale = None, scale = None, exp = None, ph_offset = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disrmg))

        if self.validate_inputs:
            self._validate_disrmg(*supplied_args)

        if self.mock_outputs:
            self._mock_disrmg_outputs(*supplied_args)

        return self._gamma_call("DISP", "disrmg", supplied_args)


    def _validate_dis2rmg(self, unw1, unw2, width1, width2, start = None, nlines = None, roff = None, azoff = None, ph_scale = None, ph_offset = None):
        pass

    def _mock_dis2rmg_outputs(self, unw1, unw2, width1, width2, start = None, nlines = None, roff = None, azoff = None, ph_scale = None, ph_offset = None):
        pass

    def dis2rmg(self, unw1, unw2, width1, width2, start = None, nlines = None, roff = None, azoff = None, ph_scale = None, ph_offset = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2rmg))

        if self.validate_inputs:
            self._validate_dis2rmg(*supplied_args)

        if self.mock_outputs:
            self._mock_dis2rmg_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis2rmg", supplied_args)


    def _validate_dis2ras(self, ras1: str, ras2: str, mag = None, win_sz = None):
        if ras1 is not None:
            self._validate("dis2ras", ras1 == "-" or Path(ras1).exists(), f"ras1 path does not exist ({ras1})")
        if ras2 is not None:
            self._validate("dis2ras", ras2 == "-" or Path(ras2).exists(), f"ras2 path does not exist ({ras2})")

    def _mock_dis2ras_outputs(self, ras1: str, ras2: str, mag = None, win_sz = None):
        pass

    def dis2ras(self, ras1: str, ras2: str, mag = None, win_sz = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2ras))

        if self.validate_inputs:
            self._validate_dis2ras(*supplied_args)

        if self.mock_outputs:
            self._mock_dis2ras_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis2ras", supplied_args)


    def _validate_dismph_pwr(self, cpx: str, pwr, width, start_cpx = None, start_pwr = None, nlines = None, scale = None, exp = None):
        if cpx is not None:
            self._validate("dismph_pwr", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")

    def _mock_dismph_pwr_outputs(self, cpx: str, pwr, width, start_cpx = None, start_pwr = None, nlines = None, scale = None, exp = None):
        pass

    def dismph_pwr(self, cpx: str, pwr, width, start_cpx = None, start_pwr = None, nlines = None, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dismph_pwr))

        if self.validate_inputs:
            self._validate_dismph_pwr(*supplied_args)

        if self.mock_outputs:
            self._mock_dismph_pwr_outputs(*supplied_args)

        return self._gamma_call("DISP", "dismph_pwr", supplied_args)


    def _validate_vec_math(self, d1, d2, d_out: str, width, mode, c1 = None, c2 = None, c3 = None, nflg = None, nl = None):
        valid_values = [0, 1, 2, 3, 4, 5, 6]
        self._validate("vec_math", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_vec_math_outputs(self, d1, d2, d_out: str, width, mode, c1 = None, c2 = None, c3 = None, nflg = None, nl = None):
        if d_out is not None and d_out != "-":
            Path(d_out).touch()

    def vec_math(self, d1, d2, d_out: str, width, mode, c1 = None, c2 = None, c3 = None, nflg = None, nl = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.vec_math))

        if self.validate_inputs:
            self._validate_vec_math(*supplied_args)

        if self.mock_outputs:
            self._mock_vec_math_outputs(*supplied_args)

        return self._gamma_call("DISP", "vec_math", supplied_args)


    def _validate_dismph_fft(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None, nfft = None, mag = None, data_type = None):
        if cpx is not None:
            self._validate("dismph_fft", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")
        valid_values = [0, 1] + [None]
        self._validate("dismph_fft", data_type == "-" or data_type in valid_values, f"data_type is not a valid value (expects: {valid_values}, got: {data_type})")

    def _mock_dismph_fft_outputs(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None, nfft = None, mag = None, data_type = None):
        pass

    def dismph_fft(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None, nfft = None, mag = None, data_type = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dismph_fft))

        if self.validate_inputs:
            self._validate_dismph_fft(*supplied_args)

        if self.mock_outputs:
            self._mock_dismph_fft_outputs(*supplied_args)

        return self._gamma_call("DISP", "dismph_fft", supplied_args)


    def _validate_svg_arrow(self, dv_norm, dv_phi, width, svg: str, image = None, norm = None, gridx = None, gridy = None, color = None, thick = None, head = None):
        pass

    def _mock_svg_arrow_outputs(self, dv_norm, dv_phi, width, svg: str, image = None, norm = None, gridx = None, gridy = None, color = None, thick = None, head = None):
        if svg is not None and svg != "-":
            Path(svg).touch()

    def svg_arrow(self, dv_norm, dv_phi, width, svg: str, image = None, norm = None, gridx = None, gridy = None, color = None, thick = None, head = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.svg_arrow))

        if self.validate_inputs:
            self._validate_svg_arrow(*supplied_args)

        if self.mock_outputs:
            self._mock_svg_arrow_outputs(*supplied_args)

        return self._gamma_call("DISP", "svg_arrow", supplied_args)


    def _validate_ras3pwr(self, d1, d2, d3, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale1 = None, scale2 = None, scale3 = None, exp = None, rasf: str = None):
        pass

    def _mock_ras3pwr_outputs(self, d1, d2, d3, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale1 = None, scale2 = None, scale3 = None, exp = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras3pwr(self, d1, d2, d3, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale1 = None, scale2 = None, scale3 = None, exp = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras3pwr))

        if self.validate_inputs:
            self._validate_ras3pwr(*supplied_args)

        if self.mock_outputs:
            self._mock_ras3pwr_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras3pwr", supplied_args)


    def _validate_disdt_pwr(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, cycle = None, scale = None, exp = None):
        pass

    def _mock_disdt_pwr_outputs(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, cycle = None, scale = None, exp = None):
        pass

    def disdt_pwr(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, cycle = None, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disdt_pwr))

        if self.validate_inputs:
            self._validate_disdt_pwr(*supplied_args)

        if self.mock_outputs:
            self._mock_disdt_pwr_outputs(*supplied_args)

        return self._gamma_call("DISP", "disdt_pwr", supplied_args)


    def _validate_real_to_vec(self, cmp1, cmp2, cmp3, width, vec: str):
        pass

    def _mock_real_to_vec_outputs(self, cmp1, cmp2, cmp3, width, vec: str):
        if vec is not None and vec != "-":
            Path(vec).touch()

    def real_to_vec(self, cmp1, cmp2, cmp3, width, vec: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.real_to_vec))

        if self.validate_inputs:
            self._validate_real_to_vec(*supplied_args)

        if self.mock_outputs:
            self._mock_real_to_vec_outputs(*supplied_args)

        return self._gamma_call("DISP", "real_to_vec", supplied_args)


    def _validate_float2short(self, infile, outfile: str, scale = None, exp = None, neg = None, output = None):
        pass

    def _mock_float2short_outputs(self, infile, outfile: str, scale = None, exp = None, neg = None, output = None):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def float2short(self, infile, outfile: str, scale = None, exp = None, neg = None, output = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2short))

        if self.validate_inputs:
            self._validate_float2short(*supplied_args)

        if self.mock_outputs:
            self._mock_float2short_outputs(*supplied_args)

        return self._gamma_call("DISP", "float2short", supplied_args)


    def _validate_disdt_pwr24(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, cycle = None, scale = None, exp = None):
        pass

    def _mock_disdt_pwr24_outputs(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, cycle = None, scale = None, exp = None):
        pass

    def disdt_pwr24(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, cycle = None, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disdt_pwr24))

        if self.validate_inputs:
            self._validate_disdt_pwr24(*supplied_args)

        if self.mock_outputs:
            self._mock_disdt_pwr24_outputs(*supplied_args)

        return self._gamma_call("DISP", "disdt_pwr24", supplied_args)


    def _validate_rashgt_shd(self, hgt, data, width, col_post, row_post = None, start = None, nlines = None, pixavr = None, pixavaz = None, theta0 = None, phi0 = None, color0 = None, m_cycle = None, LR = None, rasf: str = None):
        pass

    def _mock_rashgt_shd_outputs(self, hgt, data, width, col_post, row_post = None, start = None, nlines = None, pixavr = None, pixavaz = None, theta0 = None, phi0 = None, color0 = None, m_cycle = None, LR = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rashgt_shd(self, hgt, data, width, col_post, row_post = None, start = None, nlines = None, pixavr = None, pixavaz = None, theta0 = None, phi0 = None, color0 = None, m_cycle = None, LR = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rashgt_shd))

        if self.validate_inputs:
            self._validate_rashgt_shd(*supplied_args)

        if self.mock_outputs:
            self._mock_rashgt_shd_outputs(*supplied_args)

        return self._gamma_call("DISP", "rashgt_shd", supplied_args)


    def _validate_ras2ras(self, ras_in: str, ras_out: str, cmap = None, force24 = None):
        if ras_in is not None:
            self._validate("ras2ras", ras_in == "-" or Path(ras_in).exists(), f"ras_in path does not exist ({ras_in})")
        valid_values = [0, 1] + [None]
        self._validate("ras2ras", force24 == "-" or force24 in valid_values, f"force24 is not a valid value (expects: {valid_values}, got: {force24})")

    def _mock_ras2ras_outputs(self, ras_in: str, ras_out: str, cmap = None, force24 = None):
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()

    def ras2ras(self, ras_in: str, ras_out: str, cmap = None, force24 = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras2ras))

        if self.validate_inputs:
            self._validate_ras2ras(*supplied_args)

        if self.mock_outputs:
            self._mock_ras2ras_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras2ras", supplied_args)


    def _validate_ras24_float(self, f1, f2, f3, width, rasf: str, color_model = None, h0 = None, hrange = None, imin = None, imax = None, sat_min = None, sat_max = None, sc1 = None, A1 = None, B1 = None, cyclic1 = None, sc2 = None, A2 = None, B2 = None, start_f1 = None, start_f2 = None, nlines = None, pixavr = None, pixavaz = None, LR = None, General = None):
        valid_values = [0, 1, 2] + [None]
        self._validate("ras24_float", color_model == "-" or color_model in valid_values, f"color_model is not a valid value (expects: {valid_values}, got: {color_model})")

    def _mock_ras24_float_outputs(self, f1, f2, f3, width, rasf: str, color_model = None, h0 = None, hrange = None, imin = None, imax = None, sat_min = None, sat_max = None, sc1 = None, A1 = None, B1 = None, cyclic1 = None, sc2 = None, A2 = None, B2 = None, start_f1 = None, start_f2 = None, nlines = None, pixavr = None, pixavaz = None, LR = None, General = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras24_float(self, f1, f2, f3, width, rasf: str, color_model = None, h0 = None, hrange = None, imin = None, imax = None, sat_min = None, sat_max = None, sc1 = None, A1 = None, B1 = None, cyclic1 = None, sc2 = None, A2 = None, B2 = None, start_f1 = None, start_f2 = None, nlines = None, pixavr = None, pixavaz = None, LR = None, General = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras24_float))

        if self.validate_inputs:
            self._validate_ras24_float(*supplied_args)

        if self.mock_outputs:
            self._mock_ras24_float_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras24_float", supplied_args)


    def _validate_double2float(self, infile: str, outfile: str, scale = None, exp = None):
        if infile is not None:
            self._validate("double2float", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")

    def _mock_double2float_outputs(self, infile: str, outfile: str, scale = None, exp = None):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def double2float(self, infile: str, outfile: str, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.double2float))

        if self.validate_inputs:
            self._validate_double2float(*supplied_args)

        if self.mock_outputs:
            self._mock_double2float_outputs(*supplied_args)

        return self._gamma_call("DISP", "double2float", supplied_args)


    def _validate_float2uchar(self, infile, outfile, scale, exp):
        pass

    def _mock_float2uchar_outputs(self, infile, outfile, scale, exp):
        pass

    def float2uchar(self, infile, outfile, scale, exp):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2uchar))

        if self.validate_inputs:
            self._validate_float2uchar(*supplied_args)

        if self.mock_outputs:
            self._mock_float2uchar_outputs(*supplied_args)

        return self._gamma_call("DISP", "float2uchar", supplied_args)


    def _validate_float_math(self, d1, d2, d_out: str, width, mode, roff = None, loff = None, nr = None, nl = None, c0 = None, zflg = None):
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
        self._validate("float_math", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")
        valid_values = [0, 1] + [None]
        self._validate("float_math", zflg == "-" or zflg in valid_values, f"zflg is not a valid value (expects: {valid_values}, got: {zflg})")

    def _mock_float_math_outputs(self, d1, d2, d_out: str, width, mode, roff = None, loff = None, nr = None, nl = None, c0 = None, zflg = None):
        if d_out is not None and d_out != "-":
            Path(d_out).touch()

    def float_math(self, d1, d2, d_out: str, width, mode, roff = None, loff = None, nr = None, nl = None, c0 = None, zflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float_math))

        if self.validate_inputs:
            self._validate_float_math(*supplied_args)

        if self.mock_outputs:
            self._mock_float_math_outputs(*supplied_args)

        return self._gamma_call("DISP", "float_math", supplied_args)


    def _validate_cpd(self, din: str, dout: str, width, dtype, xoff, nx, yoff, ny):
        if din is not None:
            self._validate("cpd", din == "-" or Path(din).exists(), f"din path does not exist ({din})")
        valid_values = [0, 1, 2]
        self._validate("cpd", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_cpd_outputs(self, din: str, dout: str, width, dtype, xoff, nx, yoff, ny):
        if dout is not None and dout != "-":
            Path(dout).touch()

    def cpd(self, din: str, dout: str, width, dtype, xoff, nx, yoff, ny):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cpd))

        if self.validate_inputs:
            self._validate_cpd(*supplied_args)

        if self.mock_outputs:
            self._mock_cpd_outputs(*supplied_args)

        return self._gamma_call("DISP", "cpd", supplied_args)


    def _validate_disras_dem_par(self, ras: str, DEM_par: str, mag = None, win_sz = None):
        if ras is not None:
            self._validate("disras_dem_par", ras == "-" or Path(ras).exists(), f"ras path does not exist ({ras})")
        if DEM_par is not None:
            self._validate("disras_dem_par", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_disras_dem_par_outputs(self, ras: str, DEM_par: str, mag = None, win_sz = None):
        pass

    def disras_dem_par(self, ras: str, DEM_par: str, mag = None, win_sz = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disras_dem_par))

        if self.validate_inputs:
            self._validate_disras_dem_par(*supplied_args)

        if self.mock_outputs:
            self._mock_disras_dem_par_outputs(*supplied_args)

        return self._gamma_call("DISP", "disras_dem_par", supplied_args)


    def _validate_dismph(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None, dtype = None):
        if cpx is not None:
            self._validate("dismph", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")
        valid_values = [0, 1] + [None]
        self._validate("dismph", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_dismph_outputs(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None, dtype = None):
        pass

    def dismph(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None, dtype = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dismph))

        if self.validate_inputs:
            self._validate_dismph(*supplied_args)

        if self.mock_outputs:
            self._mock_dismph_outputs(*supplied_args)

        return self._gamma_call("DISP", "dismph", supplied_args)


    def _validate_rasshd(self, DEM, width, col_post, row_post = None, start = None, nlines = None, pixavr = None, pixavaz = None, theta0 = None, phi0 = None, LR = None, rasf: str = None, dtype = None, zero_flag = None):
        valid_values = [0, 1] + [None]
        self._validate("rasshd", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1] + [None]
        self._validate("rasshd", zero_flag == "-" or zero_flag in valid_values, f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})")

    def _mock_rasshd_outputs(self, DEM, width, col_post, row_post = None, start = None, nlines = None, pixavr = None, pixavaz = None, theta0 = None, phi0 = None, LR = None, rasf: str = None, dtype = None, zero_flag = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasshd(self, DEM, width, col_post, row_post = None, start = None, nlines = None, pixavr = None, pixavaz = None, theta0 = None, phi0 = None, LR = None, rasf: str = None, dtype = None, zero_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasshd))

        if self.validate_inputs:
            self._validate_rasshd(*supplied_args)

        if self.mock_outputs:
            self._mock_rasshd_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasshd", supplied_args)


    def _validate_dis2mph(self, cpx1: str, cpx2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None, exp = None, sc_abs1 = None, sc_abs2 = None, dtype = None):
        if cpx1 is not None:
            self._validate("dis2mph", cpx1 == "-" or Path(cpx1).exists(), f"cpx1 path does not exist ({cpx1})")
        if cpx2 is not None:
            self._validate("dis2mph", cpx2 == "-" or Path(cpx2).exists(), f"cpx2 path does not exist ({cpx2})")
        valid_values = [0, 1] + [None]
        self._validate("dis2mph", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_dis2mph_outputs(self, cpx1: str, cpx2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None, exp = None, sc_abs1 = None, sc_abs2 = None, dtype = None):
        pass

    def dis2mph(self, cpx1: str, cpx2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None, exp = None, sc_abs1 = None, sc_abs2 = None, dtype = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2mph))

        if self.validate_inputs:
            self._validate_dis2mph(*supplied_args)

        if self.mock_outputs:
            self._mock_dis2mph_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis2mph", supplied_args)


    def _validate_dis2SLC(self, SLC1: str, SLC2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None, exp = None, data_type = None):
        if SLC1 is not None:
            self._validate("dis2SLC", SLC1 == "-" or Path(SLC1).exists(), f"SLC1 path does not exist ({SLC1})")
        if SLC2 is not None:
            self._validate("dis2SLC", SLC2 == "-" or Path(SLC2).exists(), f"SLC2 path does not exist ({SLC2})")
        valid_values = [0, 1] + [None]
        self._validate("dis2SLC", data_type == "-" or data_type in valid_values, f"data_type is not a valid value (expects: {valid_values}, got: {data_type})")

    def _mock_dis2SLC_outputs(self, SLC1: str, SLC2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None, exp = None, data_type = None):
        pass

    def dis2SLC(self, SLC1: str, SLC2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None, exp = None, data_type = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2SLC))

        if self.validate_inputs:
            self._validate_dis2SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_dis2SLC_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis2SLC", supplied_args)


    def _validate_raspwr(self, pwr: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, data_type = None, hdrz = None):
        if pwr is not None:
            self._validate("raspwr", pwr == "-" or Path(pwr).exists(), f"pwr path does not exist ({pwr})")
        valid_values = [0, 1, 2] + [None]
        self._validate("raspwr", data_type == "-" or data_type in valid_values, f"data_type is not a valid value (expects: {valid_values}, got: {data_type})")

    def _mock_raspwr_outputs(self, pwr: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, data_type = None, hdrz = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def raspwr(self, pwr: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, data_type = None, hdrz = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.raspwr))

        if self.validate_inputs:
            self._validate_raspwr(*supplied_args)

        if self.mock_outputs:
            self._mock_raspwr_outputs(*supplied_args)

        return self._gamma_call("DISP", "raspwr", supplied_args)


    def _validate_disSLC(self, SLC: str, width, start = None, nlines = None, scale = None, exp = None, data_type = None):
        if SLC is not None:
            self._validate("disSLC", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        valid_values = [0, 1] + [None]
        self._validate("disSLC", data_type == "-" or data_type in valid_values, f"data_type is not a valid value (expects: {valid_values}, got: {data_type})")

    def _mock_disSLC_outputs(self, SLC: str, width, start = None, nlines = None, scale = None, exp = None, data_type = None):
        pass

    def disSLC(self, SLC: str, width, start = None, nlines = None, scale = None, exp = None, data_type = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disSLC))

        if self.validate_inputs:
            self._validate_disSLC(*supplied_args)

        if self.mock_outputs:
            self._mock_disSLC_outputs(*supplied_args)

        return self._gamma_call("DISP", "disSLC", supplied_args)


    def _validate_ras8_colormap(self, model, h0, hrange, ival, sat, cm: str, cm_ras: str = None, width = None, nlines = None):
        valid_values = [0, 1, 2, 3]
        self._validate("ras8_colormap", model == "-" or model in valid_values, f"model is not a valid value (expects: {valid_values}, got: {model})")

    def _mock_ras8_colormap_outputs(self, model, h0, hrange, ival, sat, cm: str, cm_ras: str = None, width = None, nlines = None):
        if cm is not None and cm != "-":
            Path(cm).touch()
        if cm_ras is not None and cm_ras != "-":
            Path(cm_ras).touch()

    def ras8_colormap(self, model, h0, hrange, ival, sat, cm: str, cm_ras: str = None, width = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras8_colormap))

        if self.validate_inputs:
            self._validate_ras8_colormap(*supplied_args)

        if self.mock_outputs:
            self._mock_ras8_colormap_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras8_colormap", supplied_args)


    def _validate_cp_data(self, infile: str, outfile: str, lbytes, start = None, nlines = None, offset = None, file_ldr = None, offb = None, nbyte = None):
        if infile is not None:
            self._validate("cp_data", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")

    def _mock_cp_data_outputs(self, infile: str, outfile: str, lbytes, start = None, nlines = None, offset = None, file_ldr = None, offb = None, nbyte = None):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def cp_data(self, infile: str, outfile: str, lbytes, start = None, nlines = None, offset = None, file_ldr = None, offb = None, nbyte = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cp_data))

        if self.validate_inputs:
            self._validate_cp_data(*supplied_args)

        if self.mock_outputs:
            self._mock_cp_data_outputs(*supplied_args)

        return self._gamma_call("DISP", "cp_data", supplied_args)


    def _validate_ras_cpt(self, data, width, cpt: str, color_model = None, start = None, nlines = None, pixavr = None, pixavaz = None, LR = None, rasf: str = None):
        if cpt is not None:
            self._validate("ras_cpt", cpt == "-" or Path(cpt).exists(), f"cpt path does not exist ({cpt})")
        valid_values = [0, 1, 2] + [None]
        self._validate("ras_cpt", color_model == "-" or color_model in valid_values, f"color_model is not a valid value (expects: {valid_values}, got: {color_model})")

    def _mock_ras_cpt_outputs(self, data, width, cpt: str, color_model = None, start = None, nlines = None, pixavr = None, pixavaz = None, LR = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras_cpt(self, data, width, cpt: str, color_model = None, start = None, nlines = None, pixavr = None, pixavaz = None, LR = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_cpt))

        if self.validate_inputs:
            self._validate_ras_cpt(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_cpt_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras_cpt", supplied_args)


    def _validate_uchar2float(self, infile: str, outfile, scale, exp, offset = None):
        if infile is not None:
            self._validate("uchar2float", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")

    def _mock_uchar2float_outputs(self, infile: str, outfile, scale, exp, offset = None):
        pass

    def uchar2float(self, infile: str, outfile, scale, exp, offset = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.uchar2float))

        if self.validate_inputs:
            self._validate_uchar2float(*supplied_args)

        if self.mock_outputs:
            self._mock_uchar2float_outputs(*supplied_args)

        return self._gamma_call("DISP", "uchar2float", supplied_args)


    def _validate_rasdt_pwr24(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cycle = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        pass

    def _mock_rasdt_pwr24_outputs(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cycle = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasdt_pwr24(self, data, pwr, width, start_data = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cycle = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasdt_pwr24))

        if self.validate_inputs:
            self._validate_rasdt_pwr24(*supplied_args)

        if self.mock_outputs:
            self._mock_rasdt_pwr24_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasdt_pwr24", supplied_args)


    def _validate_float2gbyte(self, infile: str, outfile: str):
        if infile is not None:
            self._validate("float2gbyte", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")

    def _mock_float2gbyte_outputs(self, infile: str, outfile: str):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def float2gbyte(self, infile: str, outfile: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2gbyte))

        if self.validate_inputs:
            self._validate_float2gbyte(*supplied_args)

        if self.mock_outputs:
            self._mock_float2gbyte_outputs(*supplied_args)

        return self._gamma_call("DISP", "float2gbyte", supplied_args)


    def _validate_disbyte(self, image: str, width, start = None, nlines = None, scale = None):
        if image is not None:
            self._validate("disbyte", image == "-" or Path(image).exists(), f"image path does not exist ({image})")

    def _mock_disbyte_outputs(self, image: str, width, start = None, nlines = None, scale = None):
        pass

    def disbyte(self, image: str, width, start = None, nlines = None, scale = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disbyte))

        if self.validate_inputs:
            self._validate_disbyte(*supplied_args)

        if self.mock_outputs:
            self._mock_disbyte_outputs(*supplied_args)

        return self._gamma_call("DISP", "disbyte", supplied_args)


    def _validate_rasrmg(self, unw, pwr, width, start_unw = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, ph_scale = None, scale = None, exp = None, ph_offset = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        pass

    def _mock_rasrmg_outputs(self, unw, pwr, width, start_unw = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, ph_scale = None, scale = None, exp = None, ph_offset = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasrmg(self, unw, pwr, width, start_unw = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, ph_scale = None, scale = None, exp = None, ph_offset = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasrmg))

        if self.validate_inputs:
            self._validate_rasrmg(*supplied_args)

        if self.mock_outputs:
            self._mock_rasrmg_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasrmg", supplied_args)


    def _validate_kml_plan(self, MLI_par: str, DEM_par: str, lookup_table: str, kml: str, geoid = None, geoid_par: str = None, extension = None, flight_path = None, t_event = None, pt_list: str = None):
        if MLI_par is not None:
            self._validate("kml_plan", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if DEM_par is not None:
            self._validate("kml_plan", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")
        if lookup_table is not None:
            self._validate("kml_plan", lookup_table == "-" or Path(lookup_table).exists(), f"lookup_table path does not exist ({lookup_table})")
        if geoid_par is not None:
            self._validate("kml_plan", geoid_par == "-" or Path(geoid_par).exists(), f"geoid_par path does not exist ({geoid_par})")
        valid_values = [0, 1, 2] + [None]
        self._validate("kml_plan", flight_path == "-" or flight_path in valid_values, f"flight_path is not a valid value (expects: {valid_values}, got: {flight_path})")
        if pt_list is not None:
            self._validate("kml_plan", pt_list == "-" or Path(pt_list).exists(), f"pt_list path does not exist ({pt_list})")

    def _mock_kml_plan_outputs(self, MLI_par: str, DEM_par: str, lookup_table: str, kml: str, geoid = None, geoid_par: str = None, extension = None, flight_path = None, t_event = None, pt_list: str = None):
        if kml is not None and kml != "-":
            Path(kml).touch()

    def kml_plan(self, MLI_par: str, DEM_par: str, lookup_table: str, kml: str, geoid = None, geoid_par: str = None, extension = None, flight_path = None, t_event = None, pt_list: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.kml_plan))

        if self.validate_inputs:
            self._validate_kml_plan(*supplied_args)

        if self.mock_outputs:
            self._mock_kml_plan_outputs(*supplied_args)

        return self._gamma_call("DISP", "kml_plan", supplied_args)


    def _validate_kml_map(self, image: str, dem_par: str, kml: str):
        if image is not None:
            self._validate("kml_map", image == "-" or Path(image).exists(), f"image path does not exist ({image})")
        if dem_par is not None:
            self._validate("kml_map", dem_par == "-" or Path(dem_par).exists(), f"dem_par path does not exist ({dem_par})")

    def _mock_kml_map_outputs(self, image: str, dem_par: str, kml: str):
        if kml is not None and kml != "-":
            Path(kml).touch()

    def kml_map(self, image: str, dem_par: str, kml: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.kml_map))

        if self.validate_inputs:
            self._validate_kml_map(*supplied_args)

        if self.mock_outputs:
            self._mock_kml_map_outputs(*supplied_args)

        return self._gamma_call("DISP", "kml_map", supplied_args)


    def _validate_dismph_pk(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None, data_type = None):
        if cpx is not None:
            self._validate("dismph_pk", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")
        valid_values = [0, 1] + [None]
        self._validate("dismph_pk", data_type == "-" or data_type in valid_values, f"data_type is not a valid value (expects: {valid_values}, got: {data_type})")

    def _mock_dismph_pk_outputs(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None, data_type = None):
        pass

    def dismph_pk(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None, data_type = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dismph_pk))

        if self.validate_inputs:
            self._validate_dismph_pk(*supplied_args)

        if self.mock_outputs:
            self._mock_dismph_pk_outputs(*supplied_args)

        return self._gamma_call("DISP", "dismph_pk", supplied_args)


    def _validate_ras_dB(self, pwr, width, start = None, nlines = None, pixavr = None, pixavaz = None, min_dB = None, max_dB = None, dB_offset = None, LR = None, rasf: str = None, abs_flag = None, inverse = None, channel = None):
        valid_values = [0, 1] + [None]
        self._validate("ras_dB", abs_flag == "-" or abs_flag in valid_values, f"abs_flag is not a valid value (expects: {valid_values}, got: {abs_flag})")
        valid_values = [1, 2, 3] + [None]
        self._validate("ras_dB", channel == "-" or channel in valid_values, f"channel is not a valid value (expects: {valid_values}, got: {channel})")

    def _mock_ras_dB_outputs(self, pwr, width, start = None, nlines = None, pixavr = None, pixavaz = None, min_dB = None, max_dB = None, dB_offset = None, LR = None, rasf: str = None, abs_flag = None, inverse = None, channel = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras_dB(self, pwr, width, start = None, nlines = None, pixavr = None, pixavaz = None, min_dB = None, max_dB = None, dB_offset = None, LR = None, rasf: str = None, abs_flag = None, inverse = None, channel = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_dB))

        if self.validate_inputs:
            self._validate_ras_dB(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_dB_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras_dB", supplied_args)


    def _validate_thres_data(self, data_in: str, width, data_out: str, t_data: str, t_min, t_max, dtype = None):
        if data_in is not None:
            self._validate("thres_data", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        if t_data is not None:
            self._validate("thres_data", t_data == "-" or Path(t_data).exists(), f"t_data path does not exist ({t_data})")
        valid_values = [0, 1, 2] + [None]
        self._validate("thres_data", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_thres_data_outputs(self, data_in: str, width, data_out: str, t_data: str, t_min, t_max, dtype = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def thres_data(self, data_in: str, width, data_out: str, t_data: str, t_min, t_max, dtype = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.thres_data))

        if self.validate_inputs:
            self._validate_thres_data(*supplied_args)

        if self.mock_outputs:
            self._mock_thres_data_outputs(*supplied_args)

        return self._gamma_call("DISP", "thres_data", supplied_args)


    def _validate_distree(self, flag: str, unw, cpx: str, width, start = None, nlines = None, ph_scale = None):
        if flag is not None:
            self._validate("distree", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")
        if cpx is not None:
            self._validate("distree", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")

    def _mock_distree_outputs(self, flag: str, unw, cpx: str, width, start = None, nlines = None, ph_scale = None):
        pass

    def distree(self, flag: str, unw, cpx: str, width, start = None, nlines = None, ph_scale = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.distree))

        if self.validate_inputs:
            self._validate_distree(*supplied_args)

        if self.mock_outputs:
            self._mock_distree_outputs(*supplied_args)

        return self._gamma_call("DISP", "distree", supplied_args)


    def _validate_dis_linear(self, pwr, width, start = None, nlines = None, min = None, max = None):
        pass

    def _mock_dis_linear_outputs(self, pwr, width, start = None, nlines = None, min = None, max = None):
        pass

    def dis_linear(self, pwr, width, start = None, nlines = None, min = None, max = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis_linear))

        if self.validate_inputs:
            self._validate_dis_linear(*supplied_args)

        if self.mock_outputs:
            self._mock_dis_linear_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis_linear", supplied_args)


    def _validate_disdem_par(self, DEM, DEM_par: str, start = None, nlines = None, exaggerate = None, theta0 = None, phi0 = None):
        if DEM_par is not None:
            self._validate("disdem_par", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_disdem_par_outputs(self, DEM, DEM_par: str, start = None, nlines = None, exaggerate = None, theta0 = None, phi0 = None):
        pass

    def disdem_par(self, DEM, DEM_par: str, start = None, nlines = None, exaggerate = None, theta0 = None, phi0 = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disdem_par))

        if self.validate_inputs:
            self._validate_disdem_par(*supplied_args)

        if self.mock_outputs:
            self._mock_disdem_par_outputs(*supplied_args)

        return self._gamma_call("DISP", "disdem_par", supplied_args)


    def _validate_gcp_2ras(self, ras1: str, ras2: str, gcp: str, mag = None, win_sz = None):
        if ras1 is not None:
            self._validate("gcp_2ras", ras1 == "-" or Path(ras1).exists(), f"ras1 path does not exist ({ras1})")
        if ras2 is not None:
            self._validate("gcp_2ras", ras2 == "-" or Path(ras2).exists(), f"ras2 path does not exist ({ras2})")

    def _mock_gcp_2ras_outputs(self, ras1: str, ras2: str, gcp: str, mag = None, win_sz = None):
        if gcp is not None and gcp != "-":
            Path(gcp).touch()

    def gcp_2ras(self, ras1: str, ras2: str, gcp: str, mag = None, win_sz = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gcp_2ras))

        if self.validate_inputs:
            self._validate_gcp_2ras(*supplied_args)

        if self.mock_outputs:
            self._mock_gcp_2ras_outputs(*supplied_args)

        return self._gamma_call("DISP", "gcp_2ras", supplied_args)


    def _validate_rashgt(self, hgt, pwr, width, start_hgt = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, m_cycle = None, scale = None, exp = None, LR = None, rasf: str = None):
        pass

    def _mock_rashgt_outputs(self, hgt, pwr, width, start_hgt = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, m_cycle = None, scale = None, exp = None, LR = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rashgt(self, hgt, pwr, width, start_hgt = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, m_cycle = None, scale = None, exp = None, LR = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rashgt))

        if self.validate_inputs:
            self._validate_rashgt(*supplied_args)

        if self.mock_outputs:
            self._mock_rashgt_outputs(*supplied_args)

        return self._gamma_call("DISP", "rashgt", supplied_args)


    def _validate_ras_linear(self, pwr, width, start = None, nlines = None, pixavr = None, pixavaz = None, min = None, max = None, LR = None, rasf: str = None, inverse = None, channel = None):
        valid_values = [1, 2, 3] + [None]
        self._validate("ras_linear", channel == "-" or channel in valid_values, f"channel is not a valid value (expects: {valid_values}, got: {channel})")

    def _mock_ras_linear_outputs(self, pwr, width, start = None, nlines = None, pixavr = None, pixavaz = None, min = None, max = None, LR = None, rasf: str = None, inverse = None, channel = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras_linear(self, pwr, width, start = None, nlines = None, pixavr = None, pixavaz = None, min = None, max = None, LR = None, rasf: str = None, inverse = None, channel = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_linear))

        if self.validate_inputs:
            self._validate_ras_linear(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_linear_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras_linear", supplied_args)


    def _validate_tree_edit(self, flag: str, ras: str, mag = None, win_sz = None):
        if flag is not None:
            self._validate("tree_edit", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")
        if ras is not None:
            self._validate("tree_edit", ras == "-" or Path(ras).exists(), f"ras path does not exist ({ras})")

    def _mock_tree_edit_outputs(self, flag: str, ras: str, mag = None, win_sz = None):
        pass

    def tree_edit(self, flag: str, ras: str, mag = None, win_sz = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.tree_edit))

        if self.validate_inputs:
            self._validate_tree_edit(*supplied_args)

        if self.mock_outputs:
            self._mock_tree_edit_outputs(*supplied_args)

        return self._gamma_call("DISP", "tree_edit", supplied_args)


    def _validate_fill(self, d1, d2, dout: str, width):
        pass

    def _mock_fill_outputs(self, d1, d2, dout: str, width):
        if dout is not None and dout != "-":
            Path(dout).touch()

    def fill(self, d1, d2, dout: str, width):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.fill))

        if self.validate_inputs:
            self._validate_fill(*supplied_args)

        if self.mock_outputs:
            self._mock_fill_outputs(*supplied_args)

        return self._gamma_call("DISP", "fill", supplied_args)


    def _validate_dis2pwr(self, pwr1, pwr2, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None, exp = None, dtype = None, sc_abs1 = None, sc_abs2 = None):
        valid_values = [0, 1] + [None]
        self._validate("dis2pwr", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_dis2pwr_outputs(self, pwr1, pwr2, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None, exp = None, dtype = None, sc_abs1 = None, sc_abs2 = None):
        pass

    def dis2pwr(self, pwr1, pwr2, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None, exp = None, dtype = None, sc_abs1 = None, sc_abs2 = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2pwr))

        if self.validate_inputs:
            self._validate_dis2pwr(*supplied_args)

        if self.mock_outputs:
            self._mock_dis2pwr_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis2pwr", supplied_args)


    def _validate_dispwr(self, pwr: str, width, start = None, nlines = None, scale = None, exp = None, data_type = None, sc_abs = None):
        if pwr is not None:
            self._validate("dispwr", pwr == "-" or Path(pwr).exists(), f"pwr path does not exist ({pwr})")
        valid_values = [0, 1] + [None]
        self._validate("dispwr", data_type == "-" or data_type in valid_values, f"data_type is not a valid value (expects: {valid_values}, got: {data_type})")

    def _mock_dispwr_outputs(self, pwr: str, width, start = None, nlines = None, scale = None, exp = None, data_type = None, sc_abs = None):
        pass

    def dispwr(self, pwr: str, width, start = None, nlines = None, scale = None, exp = None, data_type = None, sc_abs = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispwr))

        if self.validate_inputs:
            self._validate_dispwr(*supplied_args)

        if self.mock_outputs:
            self._mock_dispwr_outputs(*supplied_args)

        return self._gamma_call("DISP", "dispwr", supplied_args)


    def _validate_rasSLC(self, SLC: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, data_type = None, header = None, rasf: str = None):
        if SLC is not None:
            self._validate("rasSLC", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        valid_values = [0, 1] + [None]
        self._validate("rasSLC", data_type == "-" or data_type in valid_values, f"data_type is not a valid value (expects: {valid_values}, got: {data_type})")

    def _mock_rasSLC_outputs(self, SLC: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, data_type = None, header = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasSLC(self, SLC: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, data_type = None, header = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasSLC))

        if self.validate_inputs:
            self._validate_rasSLC(*supplied_args)

        if self.mock_outputs:
            self._mock_rasSLC_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasSLC", supplied_args)


    def _validate_rasmph_pwr24(self, cpx: str, pwr, width, start_cpx = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        if cpx is not None:
            self._validate("rasmph_pwr24", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")

    def _mock_rasmph_pwr24_outputs(self, cpx: str, pwr, width, start_cpx = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasmph_pwr24(self, cpx: str, pwr, width, start_cpx = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, cc = None, start_cc = None, cc_min = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasmph_pwr24))

        if self.validate_inputs:
            self._validate_rasmph_pwr24(*supplied_args)

        if self.mock_outputs:
            self._mock_rasmph_pwr24_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasmph_pwr24", supplied_args)


    def _validate_dismph_ub(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None):
        if cpx is not None:
            self._validate("dismph_ub", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")

    def _mock_dismph_ub_outputs(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None):
        pass

    def dismph_ub(self, cpx: str, width, start = None, nlines = None, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dismph_ub))

        if self.validate_inputs:
            self._validate_dismph_ub(*supplied_args)

        if self.mock_outputs:
            self._mock_dismph_ub_outputs(*supplied_args)

        return self._gamma_call("DISP", "dismph_ub", supplied_args)


    def _validate_short2float(self, infile: str, outfile: str, scale = None, exp = None):
        if infile is not None:
            self._validate("short2float", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")

    def _mock_short2float_outputs(self, infile: str, outfile: str, scale = None, exp = None):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def short2float(self, infile: str, outfile: str, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.short2float))

        if self.validate_inputs:
            self._validate_short2float(*supplied_args)

        if self.mock_outputs:
            self._mock_short2float_outputs(*supplied_args)

        return self._gamma_call("DISP", "short2float", supplied_args)


    def _validate_ras8_color_scale(self, rasf: str, color_model = None, h0 = None, hrange = None, ival = None, sat = None, chip_width = None, gap = None, chip_height = None, nval = None):
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("ras8_color_scale", color_model == "-" or color_model in valid_values, f"color_model is not a valid value (expects: {valid_values}, got: {color_model})")

    def _mock_ras8_color_scale_outputs(self, rasf: str, color_model = None, h0 = None, hrange = None, ival = None, sat = None, chip_width = None, gap = None, chip_height = None, nval = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras8_color_scale(self, rasf: str, color_model = None, h0 = None, hrange = None, ival = None, sat = None, chip_width = None, gap = None, chip_height = None, nval = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras8_color_scale))

        if self.validate_inputs:
            self._validate_ras8_color_scale(*supplied_args)

        if self.mock_outputs:
            self._mock_ras8_color_scale_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras8_color_scale", supplied_args)


    def _validate_rasmph(self, cpx: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, data_type = None):
        if cpx is not None:
            self._validate("rasmph", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")
        valid_values = [0, 1] + [None]
        self._validate("rasmph", data_type == "-" or data_type in valid_values, f"data_type is not a valid value (expects: {valid_values}, got: {data_type})")

    def _mock_rasmph_outputs(self, cpx: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, data_type = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasmph(self, cpx: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, LR = None, rasf: str = None, data_type = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasmph))

        if self.validate_inputs:
            self._validate_rasmph(*supplied_args)

        if self.mock_outputs:
            self._mock_rasmph_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasmph", supplied_args)


    def _validate_get_value(self, PAR_in, keyword):
        pass

    def _mock_get_value_outputs(self, PAR_in, keyword):
        pass

    def get_value(self, PAR_in, keyword):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.get_value))

        if self.validate_inputs:
            self._validate_get_value(*supplied_args)

        if self.mock_outputs:
            self._mock_get_value_outputs(*supplied_args)

        return self._gamma_call("DISP", "get_value", supplied_args)


    def _validate_polyras(self, ras: str, mag = None, win_sz = None, poly_file: str = None):
        if ras is not None:
            self._validate("polyras", ras == "-" or Path(ras).exists(), f"ras path does not exist ({ras})")

    def _mock_polyras_outputs(self, ras: str, mag = None, win_sz = None, poly_file: str = None):
        if poly_file is not None and poly_file != "-":
            Path(poly_file).touch()

    def polyras(self, ras: str, mag = None, win_sz = None, poly_file: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polyras))

        if self.validate_inputs:
            self._validate_polyras(*supplied_args)

        if self.mock_outputs:
            self._mock_polyras_outputs(*supplied_args)

        return self._gamma_call("DISP", "polyras", supplied_args)


    def _validate_rastree(self, flag: str, unw, cpx, width, start = None, nlines = None, ph_scale = None, rasf: str = None):
        if flag is not None:
            self._validate("rastree", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")

    def _mock_rastree_outputs(self, flag: str, unw, cpx, width, start = None, nlines = None, ph_scale = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rastree(self, flag: str, unw, cpx, width, start = None, nlines = None, ph_scale = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rastree))

        if self.validate_inputs:
            self._validate_rastree(*supplied_args)

        if self.mock_outputs:
            self._mock_rastree_outputs(*supplied_args)

        return self._gamma_call("DISP", "rastree", supplied_args)


    def _validate_disshd(self, DEM, width, col_post, row_post = None, start = None, nlines = None, theta0 = None, phi0 = None, data_type = None):
        valid_values = [0, 1] + [None]
        self._validate("disshd", data_type == "-" or data_type in valid_values, f"data_type is not a valid value (expects: {valid_values}, got: {data_type})")

    def _mock_disshd_outputs(self, DEM, width, col_post, row_post = None, start = None, nlines = None, theta0 = None, phi0 = None, data_type = None):
        pass

    def disshd(self, DEM, width, col_post, row_post = None, start = None, nlines = None, theta0 = None, phi0 = None, data_type = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disshd))

        if self.validate_inputs:
            self._validate_disshd(*supplied_args)

        if self.mock_outputs:
            self._mock_disshd_outputs(*supplied_args)

        return self._gamma_call("DISP", "disshd", supplied_args)


    def _validate_dis2gbyte(self, image1: str, image2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None):
        if image1 is not None:
            self._validate("dis2gbyte", image1 == "-" or Path(image1).exists(), f"image1 path does not exist ({image1})")
        if image2 is not None:
            self._validate("dis2gbyte", image2 == "-" or Path(image2).exists(), f"image2 path does not exist ({image2})")

    def _mock_dis2gbyte_outputs(self, image1: str, image2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None):
        pass

    def dis2gbyte(self, image1: str, image2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2gbyte))

        if self.validate_inputs:
            self._validate_dis2gbyte(*supplied_args)

        if self.mock_outputs:
            self._mock_dis2gbyte_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis2gbyte", supplied_args)


    def _validate_ras8_float(self, f1, f2, width, rasf: str, color_model = None, h0 = None, hrange = None, imin = None, imax = None, sat = None, sc1 = None, A1 = None, B1 = None, cyclic1 = None, sc2 = None, A2 = None, B2 = None, start_f1 = None, start_f2 = None, nlines = None, pixavr = None, pixavaz = None, LR = None):
        valid_values = [0, 1, 2, 3, 4] + [None]
        self._validate("ras8_float", color_model == "-" or color_model in valid_values, f"color_model is not a valid value (expects: {valid_values}, got: {color_model})")

    def _mock_ras8_float_outputs(self, f1, f2, width, rasf: str, color_model = None, h0 = None, hrange = None, imin = None, imax = None, sat = None, sc1 = None, A1 = None, B1 = None, cyclic1 = None, sc2 = None, A2 = None, B2 = None, start_f1 = None, start_f2 = None, nlines = None, pixavr = None, pixavaz = None, LR = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras8_float(self, f1, f2, width, rasf: str, color_model = None, h0 = None, hrange = None, imin = None, imax = None, sat = None, sc1 = None, A1 = None, B1 = None, cyclic1 = None, sc2 = None, A2 = None, B2 = None, start_f1 = None, start_f2 = None, nlines = None, pixavr = None, pixavaz = None, LR = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras8_float))

        if self.validate_inputs:
            self._validate_ras8_float(*supplied_args)

        if self.mock_outputs:
            self._mock_ras8_float_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras8_float", supplied_args)


    def _validate_flip(self, infile, outfile: str, width, format = None, sense = None):
        pass

    def _mock_flip_outputs(self, infile, outfile: str, width, format = None, sense = None):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def flip(self, infile, outfile: str, width, format = None, sense = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.flip))

        if self.validate_inputs:
            self._validate_flip(*supplied_args)

        if self.mock_outputs:
            self._mock_flip_outputs(*supplied_args)

        return self._gamma_call("DISP", "flip", supplied_args)


    def _validate_create_array(self, output: str, width, nlines, dtype = None, val = None, val_im = None):
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        self._validate("create_array", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_create_array_outputs(self, output: str, width, nlines, dtype = None, val = None, val_im = None):
        if output is not None and output != "-":
            Path(output).touch()

    def create_array(self, output: str, width, nlines, dtype = None, val = None, val_im = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_array))

        if self.validate_inputs:
            self._validate_create_array(*supplied_args)

        if self.mock_outputs:
            self._mock_create_array_outputs(*supplied_args)

        return self._gamma_call("DISP", "create_array", supplied_args)


    def _validate_ascii2float(self, data_in: str, width, data_out: str, loff = None, nl = None, coff = None, nv = None):
        if data_in is not None:
            self._validate("ascii2float", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")

    def _mock_ascii2float_outputs(self, data_in: str, width, data_out: str, loff = None, nl = None, coff = None, nv = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def ascii2float(self, data_in: str, width, data_out: str, loff = None, nl = None, coff = None, nv = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ascii2float))

        if self.validate_inputs:
            self._validate_ascii2float(*supplied_args)

        if self.mock_outputs:
            self._mock_ascii2float_outputs(*supplied_args)

        return self._gamma_call("DISP", "ascii2float", supplied_args)


    def _validate_data2tiff(self, data: str, width, type, TIFF: str, nodata = None, xspacing = None, yspacing = None):
        if data is not None:
            self._validate("data2tiff", data == "-" or Path(data).exists(), f"data path does not exist ({data})")
        valid_values = [0, 1, 2, 3, 4, 5]
        self._validate("data2tiff", type == "-" or type in valid_values, f"type is not a valid value (expects: {valid_values}, got: {type})")

    def _mock_data2tiff_outputs(self, data: str, width, type, TIFF: str, nodata = None, xspacing = None, yspacing = None):
        if TIFF is not None and TIFF != "-":
            Path(TIFF).touch()

    def data2tiff(self, data: str, width, type, TIFF: str, nodata = None, xspacing = None, yspacing = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.data2tiff))

        if self.validate_inputs:
            self._validate_data2tiff(*supplied_args)

        if self.mock_outputs:
            self._mock_data2tiff_outputs(*supplied_args)

        return self._gamma_call("DISP", "data2tiff", supplied_args)


    def _validate_mapshd(self, DEM, width, col_post, row_post, theta0, phi0, shade: str, dtype = None, zero_flag = None):
        valid_values = [0, 1] + [None]
        self._validate("mapshd", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1] + [None]
        self._validate("mapshd", zero_flag == "-" or zero_flag in valid_values, f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})")

    def _mock_mapshd_outputs(self, DEM, width, col_post, row_post, theta0, phi0, shade: str, dtype = None, zero_flag = None):
        if shade is not None and shade != "-":
            Path(shade).touch()

    def mapshd(self, DEM, width, col_post, row_post, theta0, phi0, shade: str, dtype = None, zero_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mapshd))

        if self.validate_inputs:
            self._validate_mapshd(*supplied_args)

        if self.mock_outputs:
            self._mock_mapshd_outputs(*supplied_args)

        return self._gamma_call("DISP", "mapshd", supplied_args)


    def _validate_kml_pt(self, table: str, lat_col, lon_col, val1_col, val1_label, val2_col, val2_label, val3_col, val3_label, id_col, kml: str, icon_URL = None, logo_URL = None, legend_URL = None, color_model = None, h0 = None, hrange = None, imin = None, imax = None, sat_min = None, sat_max = None, sc1 = None, A1 = None, B1 = None, cyclic1 = None, sc2 = None, A2 = None, B2 = None, start_f1 = None, start_f2 = None, B3 = None):
        if table is not None:
            self._validate("kml_pt", table == "-" or Path(table).exists(), f"table path does not exist ({table})")
        valid_values = [0, 1, 2] + [None]
        self._validate("kml_pt", color_model == "-" or color_model in valid_values, f"color_model is not a valid value (expects: {valid_values}, got: {color_model})")

    def _mock_kml_pt_outputs(self, table: str, lat_col, lon_col, val1_col, val1_label, val2_col, val2_label, val3_col, val3_label, id_col, kml: str, icon_URL = None, logo_URL = None, legend_URL = None, color_model = None, h0 = None, hrange = None, imin = None, imax = None, sat_min = None, sat_max = None, sc1 = None, A1 = None, B1 = None, cyclic1 = None, sc2 = None, A2 = None, B2 = None, start_f1 = None, start_f2 = None, B3 = None):
        if kml is not None and kml != "-":
            Path(kml).touch()

    def kml_pt(self, table: str, lat_col, lon_col, val1_col, val1_label, val2_col, val2_label, val3_col, val3_label, id_col, kml: str, icon_URL = None, logo_URL = None, legend_URL = None, color_model = None, h0 = None, hrange = None, imin = None, imax = None, sat_min = None, sat_max = None, sc1 = None, A1 = None, B1 = None, cyclic1 = None, sc2 = None, A2 = None, B2 = None, start_f1 = None, start_f2 = None, B3 = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.kml_pt))

        if self.validate_inputs:
            self._validate_kml_pt(*supplied_args)

        if self.mock_outputs:
            self._mock_kml_pt_outputs(*supplied_args)

        return self._gamma_call("DISP", "kml_pt", supplied_args)


    def _validate_vec_to_real(self, vec, width, index, cmp: str):
        valid_values = [1, 2, 3]
        self._validate("vec_to_real", index == "-" or index in valid_values, f"index is not a valid value (expects: {valid_values}, got: {index})")

    def _mock_vec_to_real_outputs(self, vec, width, index, cmp: str):
        if cmp is not None and cmp != "-":
            Path(cmp).touch()

    def vec_to_real(self, vec, width, index, cmp: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.vec_to_real))

        if self.validate_inputs:
            self._validate_vec_to_real(*supplied_args)

        if self.mock_outputs:
            self._mock_vec_to_real_outputs(*supplied_args)

        return self._gamma_call("DISP", "vec_to_real", supplied_args)


    def _validate_dismph_pwr24(self, cpx: str, pwr, width, start_cpx = None, start_pwr = None, nlines = None, scale = None, exp = None):
        if cpx is not None:
            self._validate("dismph_pwr24", cpx == "-" or Path(cpx).exists(), f"cpx path does not exist ({cpx})")

    def _mock_dismph_pwr24_outputs(self, cpx: str, pwr, width, start_cpx = None, start_pwr = None, nlines = None, scale = None, exp = None):
        pass

    def dismph_pwr24(self, cpx: str, pwr, width, start_cpx = None, start_pwr = None, nlines = None, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dismph_pwr24))

        if self.validate_inputs:
            self._validate_dismph_pwr24(*supplied_args)

        if self.mock_outputs:
            self._mock_dismph_pwr24_outputs(*supplied_args)

        return self._gamma_call("DISP", "dismph_pwr24", supplied_args)


    def _validate_swap_bytes(self, infile: str, outfile: str, swap_type):
        if infile is not None:
            self._validate("swap_bytes", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")
        valid_values = [2, 4, 8]
        self._validate("swap_bytes", swap_type == "-" or swap_type in valid_values, f"swap_type is not a valid value (expects: {valid_values}, got: {swap_type})")

    def _mock_swap_bytes_outputs(self, infile: str, outfile: str, swap_type):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def swap_bytes(self, infile: str, outfile: str, swap_type):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.swap_bytes))

        if self.validate_inputs:
            self._validate_swap_bytes(*supplied_args)

        if self.mock_outputs:
            self._mock_swap_bytes_outputs(*supplied_args)

        return self._gamma_call("DISP", "swap_bytes", supplied_args)


    def _validate_float2double(self, infile, outfile: str, scale, exp):
        pass

    def _mock_float2double_outputs(self, infile, outfile: str, scale, exp):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def float2double(self, infile, outfile: str, scale, exp):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2double))

        if self.validate_inputs:
            self._validate_float2double(*supplied_args)

        if self.mock_outputs:
            self._mock_float2double_outputs(*supplied_args)

        return self._gamma_call("DISP", "float2double", supplied_args)


    def _validate_dis2byte(self, image1: str, image2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None):
        if image1 is not None:
            self._validate("dis2byte", image1 == "-" or Path(image1).exists(), f"image1 path does not exist ({image1})")
        if image2 is not None:
            self._validate("dis2byte", image2 == "-" or Path(image2).exists(), f"image2 path does not exist ({image2})")

    def _mock_dis2byte_outputs(self, image1: str, image2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None):
        pass

    def dis2byte(self, image1: str, image2: str, width1, width2, start = None, nlines = None, roff = None, azoff = None, scale = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2byte))

        if self.validate_inputs:
            self._validate_dis2byte(*supplied_args)

        if self.mock_outputs:
            self._mock_dis2byte_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis2byte", supplied_args)


    def _validate_svg_poly(self, image: str, dem_par: str, poly: str, svg: str, width = None, nlines = None, thick = None, lcolor = None, lopac = None, pcolor = None, popac = None, tcolor = None, font = None, fsize = None):
        if image is not None:
            self._validate("svg_poly", image == "-" or Path(image).exists(), f"image path does not exist ({image})")
        if dem_par is not None:
            self._validate("svg_poly", dem_par == "-" or Path(dem_par).exists(), f"dem_par path does not exist ({dem_par})")
        if poly is not None:
            self._validate("svg_poly", poly == "-" or Path(poly).exists(), f"poly path does not exist ({poly})")
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] + [None]
        self._validate("svg_poly", thick == "-" or thick in valid_values, f"thick is not a valid value (expects: {valid_values}, got: {thick})")

    def _mock_svg_poly_outputs(self, image: str, dem_par: str, poly: str, svg: str, width = None, nlines = None, thick = None, lcolor = None, lopac = None, pcolor = None, popac = None, tcolor = None, font = None, fsize = None):
        if svg is not None and svg != "-":
            Path(svg).touch()

    def svg_poly(self, image: str, dem_par: str, poly: str, svg: str, width = None, nlines = None, thick = None, lcolor = None, lopac = None, pcolor = None, popac = None, tcolor = None, font = None, fsize = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.svg_poly))

        if self.validate_inputs:
            self._validate_svg_poly(*supplied_args)

        if self.mock_outputs:
            self._mock_svg_poly_outputs(*supplied_args)

        return self._gamma_call("DISP", "svg_poly", supplied_args)


    def _validate_rasbyte(self, raw: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, LR = None, rasf: str = None):
        if raw is not None:
            self._validate("rasbyte", raw == "-" or Path(raw).exists(), f"raw path does not exist ({raw})")

    def _mock_rasbyte_outputs(self, raw: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, LR = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rasbyte(self, raw: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, LR = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasbyte))

        if self.validate_inputs:
            self._validate_rasbyte(*supplied_args)

        if self.mock_outputs:
            self._mock_rasbyte_outputs(*supplied_args)

        return self._gamma_call("DISP", "rasbyte", supplied_args)


    def _validate_ras_cpt_scale(self, rasf: str, cpt: str, color_model = None, width = None, nlines = None, start_value = None, end_value = None):
        if cpt is not None:
            self._validate("ras_cpt_scale", cpt == "-" or Path(cpt).exists(), f"cpt path does not exist ({cpt})")
        valid_values = [0, 1, 2] + [None]
        self._validate("ras_cpt_scale", color_model == "-" or color_model in valid_values, f"color_model is not a valid value (expects: {valid_values}, got: {color_model})")

    def _mock_ras_cpt_scale_outputs(self, rasf: str, cpt: str, color_model = None, width = None, nlines = None, start_value = None, end_value = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras_cpt_scale(self, rasf: str, cpt: str, color_model = None, width = None, nlines = None, start_value = None, end_value = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_cpt_scale))

        if self.validate_inputs:
            self._validate_ras_cpt_scale(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_cpt_scale_outputs(*supplied_args)

        return self._gamma_call("DISP", "ras_cpt_scale", supplied_args)


    def _validate_dis2cc(self, cc1, cc2, width1, width2, start = None, nlines = None, roff = None, azoff = None, cmin = None, cmax = None):
        pass

    def _mock_dis2cc_outputs(self, cc1, cc2, width1, width2, start = None, nlines = None, roff = None, azoff = None, cmin = None, cmax = None):
        pass

    def dis2cc(self, cc1, cc2, width1, width2, start = None, nlines = None, roff = None, azoff = None, cmin = None, cmax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2cc))

        if self.validate_inputs:
            self._validate_dis2cc(*supplied_args)

        if self.mock_outputs:
            self._mock_dis2cc_outputs(*supplied_args)

        return self._gamma_call("DISP", "dis2cc", supplied_args)


    def _validate_float2ascii(self, din, width, data_out: str, loff = None, nl = None):
        pass

    def _mock_float2ascii_outputs(self, din, width, data_out: str, loff = None, nl = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def float2ascii(self, din, width, data_out: str, loff = None, nl = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2ascii))

        if self.validate_inputs:
            self._validate_float2ascii(*supplied_args)

        if self.mock_outputs:
            self._mock_float2ascii_outputs(*supplied_args)

        return self._gamma_call("DISP", "float2ascii", supplied_args)


    def _validate_replace_values(self, f_in: str, value, new_value, f_out: str, width, rpl_flg = None, dtype = None, zflg = None):
        if f_in is not None:
            self._validate("replace_values", f_in == "-" or Path(f_in).exists(), f"f_in path does not exist ({f_in})")
        valid_values = [0, 1, 2] + [None]
        self._validate("replace_values", rpl_flg == "-" or rpl_flg in valid_values, f"rpl_flg is not a valid value (expects: {valid_values}, got: {rpl_flg})")
        valid_values = [2, 4] + [None]
        self._validate("replace_values", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1] + [None]
        self._validate("replace_values", zflg == "-" or zflg in valid_values, f"zflg is not a valid value (expects: {valid_values}, got: {zflg})")

    def _mock_replace_values_outputs(self, f_in: str, value, new_value, f_out: str, width, rpl_flg = None, dtype = None, zflg = None):
        if f_out is not None and f_out != "-":
            Path(f_out).touch()

    def replace_values(self, f_in: str, value, new_value, f_out: str, width, rpl_flg = None, dtype = None, zflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.replace_values))

        if self.validate_inputs:
            self._validate_replace_values(*supplied_args)

        if self.mock_outputs:
            self._mock_replace_values_outputs(*supplied_args)

        return self._gamma_call("DISP", "replace_values", supplied_args)


    def _validate_sbi_offset(self, sbi_unw, SLCf_par: str, SLCb_par: str, OFF_par: str, az_offset: str):
        if SLCf_par is not None:
            self._validate("sbi_offset", SLCf_par == "-" or Path(SLCf_par).exists(), f"SLCf_par path does not exist ({SLCf_par})")
        if SLCb_par is not None:
            self._validate("sbi_offset", SLCb_par == "-" or Path(SLCb_par).exists(), f"SLCb_par path does not exist ({SLCb_par})")
        if OFF_par is not None:
            self._validate("sbi_offset", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_sbi_offset_outputs(self, sbi_unw, SLCf_par: str, SLCb_par: str, OFF_par: str, az_offset: str):
        if az_offset is not None and az_offset != "-":
            Path(az_offset).touch()

    def sbi_offset(self, sbi_unw, SLCf_par: str, SLCb_par: str, OFF_par: str, az_offset: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sbi_offset))

        if self.validate_inputs:
            self._validate_sbi_offset(*supplied_args)

        if self.mock_outputs:
            self._mock_sbi_offset_outputs(*supplied_args)

        return self._gamma_call("ISP", "sbi_offset", supplied_args)


    def _validate_par_ASF_RSAT_SS(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str):
        if CEOS_leader is not None:
            self._validate("par_ASF_RSAT_SS", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_data is not None:
            self._validate("par_ASF_RSAT_SS", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_ASF_RSAT_SS_outputs(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str):
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_ASF_RSAT_SS(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_RSAT_SS))

        if self.validate_inputs:
            self._validate_par_ASF_RSAT_SS(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ASF_RSAT_SS_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ASF_RSAT_SS", supplied_args)


    def _validate_par_ASF_SLC(self, CEOS_SAR_leader: str, SLC_par: str, CEOS_data: str = None, SLC: str = None):
        if CEOS_SAR_leader is not None:
            self._validate("par_ASF_SLC", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        if CEOS_data is not None:
            self._validate("par_ASF_SLC", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_ASF_SLC_outputs(self, CEOS_SAR_leader: str, SLC_par: str, CEOS_data: str = None, SLC: str = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_ASF_SLC(self, CEOS_SAR_leader: str, SLC_par: str, CEOS_data: str = None, SLC: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_SLC))

        if self.validate_inputs:
            self._validate_par_ASF_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ASF_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ASF_SLC", supplied_args)


    def _validate_par_KS_SLC(self, HDF5: str, trunk: str):
        if HDF5 is not None:
            self._validate("par_KS_SLC", HDF5 == "-" or Path(HDF5).exists(), f"HDF5 path does not exist ({HDF5})")

    def _mock_par_KS_SLC_outputs(self, HDF5: str, trunk: str):
        if trunk is not None and trunk != "-":
            Path(trunk).touch()

    def par_KS_SLC(self, HDF5: str, trunk: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_KS_SLC))

        if self.validate_inputs:
            self._validate_par_KS_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_KS_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_KS_SLC", supplied_args)


    def _validate_ScanSAR_full_aperture_SLC(self, SLC1_tab: str, SLC2_tab: str, SLCR_tab: str = None, SLCR_dir = None, vmode = None, wflg = None, imode = None, order = None, n_ovr = None):
        if SLC1_tab is not None:
            self._validate("ScanSAR_full_aperture_SLC", SLC1_tab == "-" or Path(SLC1_tab).exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        if SLCR_tab is not None:
            self._validate("ScanSAR_full_aperture_SLC", SLCR_tab == "-" or Path(SLCR_tab).exists(), f"SLCR_tab path does not exist ({SLCR_tab})")
        valid_values = [0, 1] + [None]
        self._validate("ScanSAR_full_aperture_SLC", vmode == "-" or vmode in valid_values, f"vmode is not a valid value (expects: {valid_values}, got: {vmode})")
        valid_values = [0, 1] + [None]
        self._validate("ScanSAR_full_aperture_SLC", wflg == "-" or wflg in valid_values, f"wflg is not a valid value (expects: {valid_values}, got: {wflg})")
        valid_values = [0, 1] + [None]
        self._validate("ScanSAR_full_aperture_SLC", imode == "-" or imode in valid_values, f"imode is not a valid value (expects: {valid_values}, got: {imode})")

    def _mock_ScanSAR_full_aperture_SLC_outputs(self, SLC1_tab: str, SLC2_tab: str, SLCR_tab: str = None, SLCR_dir = None, vmode = None, wflg = None, imode = None, order = None, n_ovr = None):
        if SLC2_tab is not None and SLC2_tab != "-" and not Path(SLC2_tab).exists():
            Path(SLC2_tab).touch()

    def ScanSAR_full_aperture_SLC(self, SLC1_tab: str, SLC2_tab: str, SLCR_tab: str = None, SLCR_dir = None, vmode = None, wflg = None, imode = None, order = None, n_ovr = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_full_aperture_SLC))

        if self.validate_inputs:
            self._validate_ScanSAR_full_aperture_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_ScanSAR_full_aperture_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "ScanSAR_full_aperture_SLC", supplied_args)


    def _validate_init_offset(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, rlks = None, azlks = None, rpos = None, azpos = None, offr = None, offaz = None, thres = None, rwin = None, azwin = None, cflag = None, deramp = None):
        if SLC_1 is not None:
            self._validate("init_offset", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("init_offset", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("init_offset", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("init_offset", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("init_offset", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("init_offset", cflag == "-" or cflag in valid_values, f"cflag is not a valid value (expects: {valid_values}, got: {cflag})")
        valid_values = [0, 1] + [None]
        self._validate("init_offset", deramp == "-" or deramp in valid_values, f"deramp is not a valid value (expects: {valid_values}, got: {deramp})")

    def _mock_init_offset_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, rlks = None, azlks = None, rpos = None, azpos = None, offr = None, offaz = None, thres = None, rwin = None, azwin = None, cflag = None, deramp = None):
        pass

    def init_offset(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, rlks = None, azlks = None, rpos = None, azpos = None, offr = None, offaz = None, thres = None, rwin = None, azwin = None, cflag = None, deramp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.init_offset))

        if self.validate_inputs:
            self._validate_init_offset(*supplied_args)

        if self.mock_outputs:
            self._mock_init_offset_outputs(*supplied_args)

        return self._gamma_call("ISP", "init_offset", supplied_args)


    def _validate_bridge(self, int: str, flag: str, unw: str, bridge: str, width, xmin = None, xmax = None, ymin = None, ymax = None):
        if int is not None:
            self._validate("bridge", int == "-" or Path(int).exists(), f"int path does not exist ({int})")
        if flag is not None:
            self._validate("bridge", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")
        if bridge is not None:
            self._validate("bridge", bridge == "-" or Path(bridge).exists(), f"bridge path does not exist ({bridge})")

    def _mock_bridge_outputs(self, int: str, flag: str, unw: str, bridge: str, width, xmin = None, xmax = None, ymin = None, ymax = None):
        if unw is not None and unw != "-" and not Path(unw).exists():
            Path(unw).touch()

    def bridge(self, int: str, flag: str, unw: str, bridge: str, width, xmin = None, xmax = None, ymin = None, ymax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.bridge))

        if self.validate_inputs:
            self._validate_bridge(*supplied_args)

        if self.mock_outputs:
            self._mock_bridge_outputs(*supplied_args)

        return self._gamma_call("ISP", "bridge", supplied_args)


    def _validate_par_ERSDAC_PALSAR(self, VEXCEL_SLC_par, SLC_par: str):
        pass

    def _mock_par_ERSDAC_PALSAR_outputs(self, VEXCEL_SLC_par, SLC_par: str):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()

    def par_ERSDAC_PALSAR(self, VEXCEL_SLC_par, SLC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ERSDAC_PALSAR))

        if self.validate_inputs:
            self._validate_par_ERSDAC_PALSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ERSDAC_PALSAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ERSDAC_PALSAR", supplied_args)


    def _validate_SR_to_GRD(self, MLI_par, OFF_par: str, GRD_par: str, in_file, out_file: str, rlks = None, azlks = None, interp_mode = None, grd_rsp = None, grd_azsp = None):
        if OFF_par is not None:
            self._validate("SR_to_GRD", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1, 2] + [None]
        self._validate("SR_to_GRD", interp_mode == "-" or interp_mode in valid_values, f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})")

    def _mock_SR_to_GRD_outputs(self, MLI_par, OFF_par: str, GRD_par: str, in_file, out_file: str, rlks = None, azlks = None, interp_mode = None, grd_rsp = None, grd_azsp = None):
        if GRD_par is not None and GRD_par != "-" and not Path(GRD_par).exists():
            Path(GRD_par).touch()
        if out_file is not None and out_file != "-":
            Path(out_file).touch()

    def SR_to_GRD(self, MLI_par, OFF_par: str, GRD_par: str, in_file, out_file: str, rlks = None, azlks = None, interp_mode = None, grd_rsp = None, grd_azsp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SR_to_GRD))

        if self.validate_inputs:
            self._validate_SR_to_GRD(*supplied_args)

        if self.mock_outputs:
            self._mock_SR_to_GRD_outputs(*supplied_args)

        return self._gamma_call("ISP", "SR_to_GRD", supplied_args)


    def _validate_par_ACS_ERS(self, CEOS_SAR_leader: str, SLC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("par_ACS_ERS", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_par_ACS_ERS_outputs(self, CEOS_SAR_leader: str, SLC_par: str):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()

    def par_ACS_ERS(self, CEOS_SAR_leader: str, SLC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ACS_ERS))

        if self.validate_inputs:
            self._validate_par_ACS_ERS(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ACS_ERS_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ACS_ERS", supplied_args)


    def _validate_offset_fit(self, offs: str, ccp, OFF_par: str, coffs: str = None, coffsets: str = None, thres = None, npoly = None, interact_flag = None):
        if offs is not None:
            self._validate("offset_fit", offs == "-" or Path(offs).exists(), f"offs path does not exist ({offs})")
        if OFF_par is not None:
            self._validate("offset_fit", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("offset_fit", interact_flag == "-" or interact_flag in valid_values, f"interact_flag is not a valid value (expects: {valid_values}, got: {interact_flag})")

    def _mock_offset_fit_outputs(self, offs: str, ccp, OFF_par: str, coffs: str = None, coffsets: str = None, thres = None, npoly = None, interact_flag = None):
        if coffs is not None and coffs != "-":
            Path(coffs).touch()
        if coffsets is not None and coffsets != "-":
            Path(coffsets).touch()

    def offset_fit(self, offs: str, ccp, OFF_par: str, coffs: str = None, coffsets: str = None, thres = None, npoly = None, interact_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_fit))

        if self.validate_inputs:
            self._validate_offset_fit(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_fit_outputs(*supplied_args)

        return self._gamma_call("ISP", "offset_fit", supplied_args)


    def _validate_radcal_PRI(self, PRI: str, PRI_PAR: str, GRD: str, GRD_PAR: str, K_dB = None, inc_ref = None, roff = None, nr = None, loff = None, nl = None):
        if PRI is not None:
            self._validate("radcal_PRI", PRI == "-" or Path(PRI).exists(), f"PRI path does not exist ({PRI})")
        if PRI_PAR is not None:
            self._validate("radcal_PRI", PRI_PAR == "-" or Path(PRI_PAR).exists(), f"PRI_PAR path does not exist ({PRI_PAR})")

    def _mock_radcal_PRI_outputs(self, PRI: str, PRI_PAR: str, GRD: str, GRD_PAR: str, K_dB = None, inc_ref = None, roff = None, nr = None, loff = None, nl = None):
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if GRD_PAR is not None and GRD_PAR != "-":
            Path(GRD_PAR).touch()

    def radcal_PRI(self, PRI: str, PRI_PAR: str, GRD: str, GRD_PAR: str, K_dB = None, inc_ref = None, roff = None, nr = None, loff = None, nl = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.radcal_PRI))

        if self.validate_inputs:
            self._validate_radcal_PRI(*supplied_args)

        if self.mock_outputs:
            self._mock_radcal_PRI_outputs(*supplied_args)

        return self._gamma_call("ISP", "radcal_PRI", supplied_args)


    def _validate_gcp_phase(self, unw: str, OFF_par: str, gcp: str, gcp_ph: str, win_sz = None):
        if unw is not None:
            self._validate("gcp_phase", unw == "-" or Path(unw).exists(), f"unw path does not exist ({unw})")
        if OFF_par is not None:
            self._validate("gcp_phase", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if gcp is not None:
            self._validate("gcp_phase", gcp == "-" or Path(gcp).exists(), f"gcp path does not exist ({gcp})")

    def _mock_gcp_phase_outputs(self, unw: str, OFF_par: str, gcp: str, gcp_ph: str, win_sz = None):
        if gcp_ph is not None and gcp_ph != "-":
            Path(gcp_ph).touch()

    def gcp_phase(self, unw: str, OFF_par: str, gcp: str, gcp_ph: str, win_sz = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gcp_phase))

        if self.validate_inputs:
            self._validate_gcp_phase(*supplied_args)

        if self.mock_outputs:
            self._mock_gcp_phase_outputs(*supplied_args)

        return self._gamma_call("ISP", "gcp_phase", supplied_args)


    def _validate_par_MSP(self, SAR_par: str, PROC_par: str, SLC_MLI_par: str, image_format = None):
        if SAR_par is not None:
            self._validate("par_MSP", SAR_par == "-" or Path(SAR_par).exists(), f"SAR_par path does not exist ({SAR_par})")
        if PROC_par is not None:
            self._validate("par_MSP", PROC_par == "-" or Path(PROC_par).exists(), f"PROC_par path does not exist ({PROC_par})")
        valid_values = [0, 1, 2] + [None]
        self._validate("par_MSP", image_format == "-" or image_format in valid_values, f"image_format is not a valid value (expects: {valid_values}, got: {image_format})")

    def _mock_par_MSP_outputs(self, SAR_par: str, PROC_par: str, SLC_MLI_par: str, image_format = None):
        if SLC_MLI_par is not None and SLC_MLI_par != "-":
            Path(SLC_MLI_par).touch()

    def par_MSP(self, SAR_par: str, PROC_par: str, SLC_MLI_par: str, image_format = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_MSP))

        if self.validate_inputs:
            self._validate_par_MSP(*supplied_args)

        if self.mock_outputs:
            self._mock_par_MSP_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_MSP", supplied_args)


    def _validate_offset_pwr_tracking2(self, SLC1: str, SLC2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, ccp: str, OFF_par2: str = None, offs2: str = None, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        if SLC1 is not None:
            self._validate("offset_pwr_tracking2", SLC1 == "-" or Path(SLC1).exists(), f"SLC1 path does not exist ({SLC1})")
        if SLC2 is not None:
            self._validate("offset_pwr_tracking2", SLC2 == "-" or Path(SLC2).exists(), f"SLC2 path does not exist ({SLC2})")
        if SLC1_par is not None:
            self._validate("offset_pwr_tracking2", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("offset_pwr_tracking2", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("offset_pwr_tracking2", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if OFF_par2 is not None:
            self._validate("offset_pwr_tracking2", OFF_par2 == "-" or Path(OFF_par2).exists(), f"OFF_par2 path does not exist ({OFF_par2})")
        if offs2 is not None:
            self._validate("offset_pwr_tracking2", offs2 == "-" or Path(offs2).exists(), f"offs2 path does not exist ({offs2})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_tracking2", deramp == "-" or deramp in valid_values, f"deramp is not a valid value (expects: {valid_values}, got: {deramp})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_tracking2", int_filt == "-" or int_filt in valid_values, f"int_filt is not a valid value (expects: {valid_values}, got: {int_filt})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_tracking2", pflag == "-" or pflag in valid_values, f"pflag is not a valid value (expects: {valid_values}, got: {pflag})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("offset_pwr_tracking2", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_offset_pwr_tracking2_outputs(self, SLC1: str, SLC2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, ccp: str, OFF_par2: str = None, offs2: str = None, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        if ccs is not None and ccs != "-":
            Path(ccs).touch()

    def offset_pwr_tracking2(self, SLC1: str, SLC2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, ccp: str, OFF_par2: str = None, offs2: str = None, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_tracking2))

        if self.validate_inputs:
            self._validate_offset_pwr_tracking2(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_pwr_tracking2_outputs(*supplied_args)

        return self._gamma_call("ISP", "offset_pwr_tracking2", supplied_args)


    def _validate_offset_tracking(self, offs: str, ccp, SLC_par: str, OFF_par: str, disp_map: str, disp_val: str = None, mode = None, thres = None, poly_flag = None):
        if offs is not None:
            self._validate("offset_tracking", offs == "-" or Path(offs).exists(), f"offs path does not exist ({offs})")
        if SLC_par is not None:
            self._validate("offset_tracking", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("offset_tracking", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1, 2] + [None]
        self._validate("offset_tracking", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")
        valid_values = [0, 1] + [None]
        self._validate("offset_tracking", poly_flag == "-" or poly_flag in valid_values, f"poly_flag is not a valid value (expects: {valid_values}, got: {poly_flag})")

    def _mock_offset_tracking_outputs(self, offs: str, ccp, SLC_par: str, OFF_par: str, disp_map: str, disp_val: str = None, mode = None, thres = None, poly_flag = None):
        if disp_map is not None and disp_map != "-":
            Path(disp_map).touch()
        if disp_val is not None and disp_val != "-":
            Path(disp_val).touch()

    def offset_tracking(self, offs: str, ccp, SLC_par: str, OFF_par: str, disp_map: str, disp_val: str = None, mode = None, thres = None, poly_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_tracking))

        if self.validate_inputs:
            self._validate_offset_tracking(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_tracking_outputs(*supplied_args)

        return self._gamma_call("ISP", "offset_tracking", supplied_args)


    def _validate_SLC_interp_ScanSAR(self, SLC2_tab: str, SLC2_par: str, SLC1_tab: str, SLC1_par: str, OFF_par, SLC2R_tab: str, SLC_2R: str = None, SLC2R_par: str = None, mode = None, order = None, SLC2R_dir = None):
        if SLC2_tab is not None:
            self._validate("SLC_interp_ScanSAR", SLC2_tab == "-" or Path(SLC2_tab).exists(), f"SLC2_tab path does not exist ({SLC2_tab})")
        if SLC2_par is not None:
            self._validate("SLC_interp_ScanSAR", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if SLC1_tab is not None:
            self._validate("SLC_interp_ScanSAR", SLC1_tab == "-" or Path(SLC1_tab).exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        if SLC1_par is not None:
            self._validate("SLC_interp_ScanSAR", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_interp_ScanSAR", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_SLC_interp_ScanSAR_outputs(self, SLC2_tab: str, SLC2_par: str, SLC1_tab: str, SLC1_par: str, OFF_par, SLC2R_tab: str, SLC_2R: str = None, SLC2R_par: str = None, mode = None, order = None, SLC2R_dir = None):
        if SLC2R_tab is not None and SLC2R_tab != "-" and not Path(SLC2R_tab).exists():
            Path(SLC2R_tab).touch()
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()

    def SLC_interp_ScanSAR(self, SLC2_tab: str, SLC2_par: str, SLC1_tab: str, SLC1_par: str, OFF_par, SLC2R_tab: str, SLC_2R: str = None, SLC2R_par: str = None, mode = None, order = None, SLC2R_dir = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp_ScanSAR))

        if self.validate_inputs:
            self._validate_SLC_interp_ScanSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_interp_ScanSAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_interp_ScanSAR", supplied_args)


    def _validate_error_stat(self, d1: str, d2: str, width, dtype, roff, loff, nr, nl, report):
        if d1 is not None:
            self._validate("error_stat", d1 == "-" or Path(d1).exists(), f"d1 path does not exist ({d1})")
        if d2 is not None:
            self._validate("error_stat", d2 == "-" or Path(d2).exists(), f"d2 path does not exist ({d2})")
        valid_values = [0, 1]
        self._validate("error_stat", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_error_stat_outputs(self, d1: str, d2: str, width, dtype, roff, loff, nr, nl, report):
        pass

    def error_stat(self, d1: str, d2: str, width, dtype, roff, loff, nr, nl, report):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.error_stat))

        if self.validate_inputs:
            self._validate_error_stat(*supplied_args)

        if self.mock_outputs:
            self._mock_error_stat_outputs(*supplied_args)

        return self._gamma_call("ISP", "error_stat", supplied_args)


    def _validate_res_map(self, hgt: str, gr: str, data, SLC_par: str, OFF_par, res_hgt: str, res_data: str, nr = None, naz = None, azps_res = None, loff = None, nlines = None):
        if hgt is not None:
            self._validate("res_map", hgt == "-" or Path(hgt).exists(), f"hgt path does not exist ({hgt})")
        if gr is not None:
            self._validate("res_map", gr == "-" or Path(gr).exists(), f"gr path does not exist ({gr})")
        if SLC_par is not None:
            self._validate("res_map", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_res_map_outputs(self, hgt: str, gr: str, data, SLC_par: str, OFF_par, res_hgt: str, res_data: str, nr = None, naz = None, azps_res = None, loff = None, nlines = None):
        if res_hgt is not None and res_hgt != "-":
            Path(res_hgt).touch()
        if res_data is not None and res_data != "-":
            Path(res_data).touch()

    def res_map(self, hgt: str, gr: str, data, SLC_par: str, OFF_par, res_hgt: str, res_data: str, nr = None, naz = None, azps_res = None, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.res_map))

        if self.validate_inputs:
            self._validate_res_map(*supplied_args)

        if self.mock_outputs:
            self._mock_res_map_outputs(*supplied_args)

        return self._gamma_call("ISP", "res_map", supplied_args)


    def _validate_RSAT2_vec(self, SLC_par: str, RSAT2_orb, nstate = None):
        if SLC_par is not None:
            self._validate("RSAT2_vec", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_RSAT2_vec_outputs(self, SLC_par: str, RSAT2_orb, nstate = None):
        pass

    def RSAT2_vec(self, SLC_par: str, RSAT2_orb, nstate = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.RSAT2_vec))

        if self.validate_inputs:
            self._validate_RSAT2_vec(*supplied_args)

        if self.mock_outputs:
            self._mock_RSAT2_vec_outputs(*supplied_args)

        return self._gamma_call("ISP", "RSAT2_vec", supplied_args)


    def _validate_par_S1_GRD(self, GeoTIFF: str, annotation_XML: str, calibration_XML: str, noise_XML: str, MLI_par: str, MLI: str, GRD_par: str = None, GRD: str = None, eflg = None, rps = None, noise_pwr = None, edge_flag = None):
        if GeoTIFF is not None:
            self._validate("par_S1_GRD", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        if annotation_XML is not None:
            self._validate("par_S1_GRD", annotation_XML == "-" or Path(annotation_XML).exists(), f"annotation_XML path does not exist ({annotation_XML})")
        if calibration_XML is not None:
            self._validate("par_S1_GRD", calibration_XML == "-" or Path(calibration_XML).exists(), f"calibration_XML path does not exist ({calibration_XML})")
        if noise_XML is not None:
            self._validate("par_S1_GRD", noise_XML == "-" or Path(noise_XML).exists(), f"noise_XML path does not exist ({noise_XML})")

    def _mock_par_S1_GRD_outputs(self, GeoTIFF: str, annotation_XML: str, calibration_XML: str, noise_XML: str, MLI_par: str, MLI: str, GRD_par: str = None, GRD: str = None, eflg = None, rps = None, noise_pwr = None, edge_flag = None):
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_S1_GRD(self, GeoTIFF: str, annotation_XML: str, calibration_XML: str, noise_XML: str, MLI_par: str, MLI: str, GRD_par: str = None, GRD: str = None, eflg = None, rps = None, noise_pwr = None, edge_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_S1_GRD))

        if self.validate_inputs:
            self._validate_par_S1_GRD(*supplied_args)

        if self.mock_outputs:
            self._mock_par_S1_GRD_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_S1_GRD", supplied_args)


    def _validate_SLC_deramp_S1_TOPS(self, SLC1_tab: str, SLC2_tab: str, mode, phflg):
        if SLC1_tab is not None:
            self._validate("SLC_deramp_S1_TOPS", SLC1_tab == "-" or Path(SLC1_tab).exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        if SLC2_tab is not None:
            self._validate("SLC_deramp_S1_TOPS", SLC2_tab == "-" or Path(SLC2_tab).exists(), f"SLC2_tab path does not exist ({SLC2_tab})")
        valid_values = [0, 1]
        self._validate("SLC_deramp_S1_TOPS", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")
        valid_values = [0, 1]
        self._validate("SLC_deramp_S1_TOPS", phflg == "-" or phflg in valid_values, f"phflg is not a valid value (expects: {valid_values}, got: {phflg})")

    def _mock_SLC_deramp_S1_TOPS_outputs(self, SLC1_tab: str, SLC2_tab: str, mode, phflg):
        pass

    def SLC_deramp_S1_TOPS(self, SLC1_tab: str, SLC2_tab: str, mode, phflg):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_deramp_S1_TOPS))

        if self.validate_inputs:
            self._validate_SLC_deramp_S1_TOPS(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_deramp_S1_TOPS_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_deramp_S1_TOPS", supplied_args)


    def _validate_par_RSAT_SGF(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str, sc_dB = None, dt = None):
        if CEOS_leader is not None:
            self._validate("par_RSAT_SGF", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_data is not None:
            self._validate("par_RSAT_SGF", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_RSAT_SGF_outputs(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str, sc_dB = None, dt = None):
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_RSAT_SGF(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str, sc_dB = None, dt = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT_SGF))

        if self.validate_inputs:
            self._validate_par_RSAT_SGF(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RSAT_SGF_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RSAT_SGF", supplied_args)


    def _validate_par_ICEYE_GRD(self, GeoTIFF: str, MLI_par: str, mli: str = None, GRD_par: str = None, GRD: str = None, rps = None):
        if GeoTIFF is not None:
            self._validate("par_ICEYE_GRD", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        if MLI_par is not None:
            self._validate("par_ICEYE_GRD", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")

    def _mock_par_ICEYE_GRD_outputs(self, GeoTIFF: str, MLI_par: str, mli: str = None, GRD_par: str = None, GRD: str = None, rps = None):
        if mli is not None and mli != "-":
            Path(mli).touch()
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_ICEYE_GRD(self, GeoTIFF: str, MLI_par: str, mli: str = None, GRD_par: str = None, GRD: str = None, rps = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ICEYE_GRD))

        if self.validate_inputs:
            self._validate_par_ICEYE_GRD(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ICEYE_GRD_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ICEYE_GRD", supplied_args)


    def _validate_par_CS_SLC_TIF(self, GeoTIFF: str, XML: str, trunk: str):
        if GeoTIFF is not None:
            self._validate("par_CS_SLC_TIF", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        if XML is not None:
            self._validate("par_CS_SLC_TIF", XML == "-" or Path(XML).exists(), f"XML path does not exist ({XML})")

    def _mock_par_CS_SLC_TIF_outputs(self, GeoTIFF: str, XML: str, trunk: str):
        if trunk is not None and trunk != "-":
            Path(trunk).touch()

    def par_CS_SLC_TIF(self, GeoTIFF: str, XML: str, trunk: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_CS_SLC_TIF))

        if self.validate_inputs:
            self._validate_par_CS_SLC_TIF(*supplied_args)

        if self.mock_outputs:
            self._mock_par_CS_SLC_TIF_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_CS_SLC_TIF", supplied_args)


    def _validate_DORIS_vec(self, SLC_PAR: str, DOR: str, nstate = None):
        if DOR is not None:
            self._validate("DORIS_vec", DOR == "-" or Path(DOR).exists(), f"DOR path does not exist ({DOR})")

    def _mock_DORIS_vec_outputs(self, SLC_PAR: str, DOR: str, nstate = None):
        if SLC_PAR is not None and SLC_PAR != "-" and not Path(SLC_PAR).exists():
            Path(SLC_PAR).touch()

    def DORIS_vec(self, SLC_PAR: str, DOR: str, nstate = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.DORIS_vec))

        if self.validate_inputs:
            self._validate_DORIS_vec(*supplied_args)

        if self.mock_outputs:
            self._mock_DORIS_vec_outputs(*supplied_args)

        return self._gamma_call("ISP", "DORIS_vec", supplied_args)


    def _validate_bpf(self, data_in, data_out: str, width, fc_x, bw_x, fc_y, bw_y, roff = None, azoff = None, nr = None, naz = None, data_type = None, f_mode = None, beta = None, fir_len = None):
        pass

    def _mock_bpf_outputs(self, data_in, data_out: str, width, fc_x, bw_x, fc_y, bw_y, roff = None, azoff = None, nr = None, naz = None, data_type = None, f_mode = None, beta = None, fir_len = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def bpf(self, data_in, data_out: str, width, fc_x, bw_x, fc_y, bw_y, roff = None, azoff = None, nr = None, naz = None, data_type = None, f_mode = None, beta = None, fir_len = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.bpf))

        if self.validate_inputs:
            self._validate_bpf(*supplied_args)

        if self.mock_outputs:
            self._mock_bpf_outputs(*supplied_args)

        return self._gamma_call("ISP", "bpf", supplied_args)


    def _validate_image_stat(self, image, width, roff, loff, nr, nl, report):
        pass

    def _mock_image_stat_outputs(self, image, width, roff, loff, nr, nl, report):
        pass

    def image_stat(self, image, width, roff, loff, nr, nl, report):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.image_stat))

        if self.validate_inputs:
            self._validate_image_stat(*supplied_args)

        if self.mock_outputs:
            self._mock_image_stat_outputs(*supplied_args)

        return self._gamma_call("ISP", "image_stat", supplied_args)


    def _validate_clear_flag(self, flag: str, width, flag_bits, xmin, xmax, ymin = None, ymax = None):
        if flag is not None:
            self._validate("clear_flag", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")

    def _mock_clear_flag_outputs(self, flag: str, width, flag_bits, xmin, xmax, ymin = None, ymax = None):
        pass

    def clear_flag(self, flag: str, width, flag_bits, xmin, xmax, ymin = None, ymax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.clear_flag))

        if self.validate_inputs:
            self._validate_clear_flag(*supplied_args)

        if self.mock_outputs:
            self._mock_clear_flag_outputs(*supplied_args)

        return self._gamma_call("ISP", "clear_flag", supplied_args)


    def _validate_par_NovaSAR_GRD(self, GeoTIFF: str, XML: str, polarization, MLI_par: str, MLI: str = None, GRD_par: str = None, GRD: str = None, rps = None):
        if GeoTIFF is not None:
            self._validate("par_NovaSAR_GRD", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        if XML is not None:
            self._validate("par_NovaSAR_GRD", XML == "-" or Path(XML).exists(), f"XML path does not exist ({XML})")

    def _mock_par_NovaSAR_GRD_outputs(self, GeoTIFF: str, XML: str, polarization, MLI_par: str, MLI: str = None, GRD_par: str = None, GRD: str = None, rps = None):
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_NovaSAR_GRD(self, GeoTIFF: str, XML: str, polarization, MLI_par: str, MLI: str = None, GRD_par: str = None, GRD: str = None, rps = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_NovaSAR_GRD))

        if self.validate_inputs:
            self._validate_par_NovaSAR_GRD(*supplied_args)

        if self.mock_outputs:
            self._mock_par_NovaSAR_GRD_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_NovaSAR_GRD", supplied_args)


    def _validate_slant_range(self, SLC_par: str, slr: str):
        if SLC_par is not None:
            self._validate("slant_range", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_slant_range_outputs(self, SLC_par: str, slr: str):
        if slr is not None and slr != "-":
            Path(slr).touch()

    def slant_range(self, SLC_par: str, slr: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.slant_range))

        if self.validate_inputs:
            self._validate_slant_range(*supplied_args)

        if self.mock_outputs:
            self._mock_slant_range_outputs(*supplied_args)

        return self._gamma_call("ISP", "slant_range", supplied_args)


    def _validate_par_IECAS_SLC(self, aux_data: str, slc_Re: str, slc_Im: str, date: str, SLC_par: str, SLC: str):
        if aux_data is not None:
            self._validate("par_IECAS_SLC", aux_data == "-" or Path(aux_data).exists(), f"aux_data path does not exist ({aux_data})")
        if slc_Re is not None:
            self._validate("par_IECAS_SLC", slc_Re == "-" or Path(slc_Re).exists(), f"slc_Re path does not exist ({slc_Re})")
        if slc_Im is not None:
            self._validate("par_IECAS_SLC", slc_Im == "-" or Path(slc_Im).exists(), f"slc_Im path does not exist ({slc_Im})")
        if date is not None:
            self._validate("par_IECAS_SLC", date == "-" or Path(date).exists(), f"date path does not exist ({date})")

    def _mock_par_IECAS_SLC_outputs(self, aux_data: str, slc_Re: str, slc_Im: str, date: str, SLC_par: str, SLC: str):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_IECAS_SLC(self, aux_data: str, slc_Re: str, slc_Im: str, date: str, SLC_par: str, SLC: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_IECAS_SLC))

        if self.validate_inputs:
            self._validate_par_IECAS_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_IECAS_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_IECAS_SLC", supplied_args)


    def _validate_corr_flag(self, corr: str, flag: str, width, corr_thr, xmin = None, xmax = None, ymin = None, ymax = None, border = None):
        if corr is not None:
            self._validate("corr_flag", corr == "-" or Path(corr).exists(), f"corr path does not exist ({corr})")

    def _mock_corr_flag_outputs(self, corr: str, flag: str, width, corr_thr, xmin = None, xmax = None, ymin = None, ymax = None, border = None):
        if flag is not None and flag != "-" and not Path(flag).exists():
            Path(flag).touch()

    def corr_flag(self, corr: str, flag: str, width, corr_thr, xmin = None, xmax = None, ymin = None, ymax = None, border = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.corr_flag))

        if self.validate_inputs:
            self._validate_corr_flag(*supplied_args)

        if self.mock_outputs:
            self._mock_corr_flag_outputs(*supplied_args)

        return self._gamma_call("ISP", "corr_flag", supplied_args)


    def _validate_ptarg_cal_MLI(self, MLI_par: str, MLI: str, r_samp, az_samp, psigma, c_r_samp, c_az_samp, ptr_image: str, r_plot: str, az_plot: str, pcal: str, osf = None, win = None, pltflg = None, psz = None, csz = None, theta_inc = None):
        if MLI_par is not None:
            self._validate("ptarg_cal_MLI", MLI_par == "-" or Path(MLI_par).exists(), f"MLI_par path does not exist ({MLI_par})")
        if MLI is not None:
            self._validate("ptarg_cal_MLI", MLI == "-" or Path(MLI).exists(), f"MLI path does not exist ({MLI})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("ptarg_cal_MLI", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_ptarg_cal_MLI_outputs(self, MLI_par: str, MLI: str, r_samp, az_samp, psigma, c_r_samp, c_az_samp, ptr_image: str, r_plot: str, az_plot: str, pcal: str, osf = None, win = None, pltflg = None, psz = None, csz = None, theta_inc = None):
        if ptr_image is not None and ptr_image != "-":
            Path(ptr_image).touch()
        if r_plot is not None and r_plot != "-":
            Path(r_plot).touch()
        if az_plot is not None and az_plot != "-":
            Path(az_plot).touch()
        if pcal is not None and pcal != "-":
            Path(pcal).touch()

    def ptarg_cal_MLI(self, MLI_par: str, MLI: str, r_samp, az_samp, psigma, c_r_samp, c_az_samp, ptr_image: str, r_plot: str, az_plot: str, pcal: str, osf = None, win = None, pltflg = None, psz = None, csz = None, theta_inc = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ptarg_cal_MLI))

        if self.validate_inputs:
            self._validate_ptarg_cal_MLI(*supplied_args)

        if self.mock_outputs:
            self._mock_ptarg_cal_MLI_outputs(*supplied_args)

        return self._gamma_call("ISP", "ptarg_cal_MLI", supplied_args)


    def _validate_ORB_filt(self, SLC_par_in: str, SLC_par_out: str, interval = None, extra = None):
        if SLC_par_in is not None:
            self._validate("ORB_filt", SLC_par_in == "-" or Path(SLC_par_in).exists(), f"SLC_par_in path does not exist ({SLC_par_in})")

    def _mock_ORB_filt_outputs(self, SLC_par_in: str, SLC_par_out: str, interval = None, extra = None):
        if SLC_par_out is not None and SLC_par_out != "-":
            Path(SLC_par_out).touch()

    def ORB_filt(self, SLC_par_in: str, SLC_par_out: str, interval = None, extra = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORB_filt))

        if self.validate_inputs:
            self._validate_ORB_filt(*supplied_args)

        if self.mock_outputs:
            self._mock_ORB_filt_outputs(*supplied_args)

        return self._gamma_call("ISP", "ORB_filt", supplied_args)


    def _validate_offset_sub(self, offs: str, OFF_par: str, offs_sub: str):
        if offs is not None:
            self._validate("offset_sub", offs == "-" or Path(offs).exists(), f"offs path does not exist ({offs})")
        if OFF_par is not None:
            self._validate("offset_sub", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_offset_sub_outputs(self, offs: str, OFF_par: str, offs_sub: str):
        if offs_sub is not None and offs_sub != "-":
            Path(offs_sub).touch()

    def offset_sub(self, offs: str, OFF_par: str, offs_sub: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_sub))

        if self.validate_inputs:
            self._validate_offset_sub(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_sub_outputs(*supplied_args)

        return self._gamma_call("ISP", "offset_sub", supplied_args)


    def _validate_radcal_MLI(self, MLI, MLI_PAR: str, OFF_par: str, CMLI: str, antenna: str = None, rloss_flag = None, ant_flag = None, refarea_flag = None, sc_dB = None, K_dB = None, pix_area: str = None):
        if MLI_PAR is not None:
            self._validate("radcal_MLI", MLI_PAR == "-" or Path(MLI_PAR).exists(), f"MLI_PAR path does not exist ({MLI_PAR})")
        if OFF_par is not None:
            self._validate("radcal_MLI", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if antenna is not None:
            self._validate("radcal_MLI", antenna == "-" or Path(antenna).exists(), f"antenna path does not exist ({antenna})")

    def _mock_radcal_MLI_outputs(self, MLI, MLI_PAR: str, OFF_par: str, CMLI: str, antenna: str = None, rloss_flag = None, ant_flag = None, refarea_flag = None, sc_dB = None, K_dB = None, pix_area: str = None):
        if CMLI is not None and CMLI != "-":
            Path(CMLI).touch()
        if pix_area is not None and pix_area != "-":
            Path(pix_area).touch()

    def radcal_MLI(self, MLI, MLI_PAR: str, OFF_par: str, CMLI: str, antenna: str = None, rloss_flag = None, ant_flag = None, refarea_flag = None, sc_dB = None, K_dB = None, pix_area: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.radcal_MLI))

        if self.validate_inputs:
            self._validate_radcal_MLI(*supplied_args)

        if self.mock_outputs:
            self._mock_radcal_MLI_outputs(*supplied_args)

        return self._gamma_call("ISP", "radcal_MLI", supplied_args)


    def _validate_S1_OPOD_vec(self, SLC_PAR: str, OPOD: str, nstate = None):
        if OPOD is not None:
            self._validate("S1_OPOD_vec", OPOD == "-" or Path(OPOD).exists(), f"OPOD path does not exist ({OPOD})")

    def _mock_S1_OPOD_vec_outputs(self, SLC_PAR: str, OPOD: str, nstate = None):
        if SLC_PAR is not None and SLC_PAR != "-" and not Path(SLC_PAR).exists():
            Path(SLC_PAR).touch()

    def S1_OPOD_vec(self, SLC_PAR: str, OPOD: str, nstate = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.S1_OPOD_vec))

        if self.validate_inputs:
            self._validate_S1_OPOD_vec(*supplied_args)

        if self.mock_outputs:
            self._mock_S1_OPOD_vec_outputs(*supplied_args)

        return self._gamma_call("ISP", "S1_OPOD_vec", supplied_args)


    def _validate_par_RCM_GRD(self, RCM_dir: str, polarization, radcal, noise, MLI_par: str = None, MLI: str = None, GRD_par: str = None, GRD: str = None, rps = None, noise_pwr: str = None):
        if RCM_dir is not None:
            self._validate("par_RCM_GRD", RCM_dir == "-" or Path(RCM_dir).exists(), f"RCM_dir path does not exist ({RCM_dir})")
        valid_values = [0, 1, 2, 3]
        self._validate("par_RCM_GRD", radcal == "-" or radcal in valid_values, f"radcal is not a valid value (expects: {valid_values}, got: {radcal})")

    def _mock_par_RCM_GRD_outputs(self, RCM_dir: str, polarization, radcal, noise, MLI_par: str = None, MLI: str = None, GRD_par: str = None, GRD: str = None, rps = None, noise_pwr: str = None):
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()
        if noise_pwr is not None and noise_pwr != "-":
            Path(noise_pwr).touch()

    def par_RCM_GRD(self, RCM_dir: str, polarization, radcal, noise, MLI_par: str = None, MLI: str = None, GRD_par: str = None, GRD: str = None, rps = None, noise_pwr: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_GRD))

        if self.validate_inputs:
            self._validate_par_RCM_GRD(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RCM_GRD_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RCM_GRD", supplied_args)


    def _validate_offset_pwr_tracking(self, SLC1: str, SLC2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, lanczos = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        if SLC1 is not None:
            self._validate("offset_pwr_tracking", SLC1 == "-" or Path(SLC1).exists(), f"SLC1 path does not exist ({SLC1})")
        if SLC2 is not None:
            self._validate("offset_pwr_tracking", SLC2 == "-" or Path(SLC2).exists(), f"SLC2 path does not exist ({SLC2})")
        if SLC1_par is not None:
            self._validate("offset_pwr_tracking", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("offset_pwr_tracking", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("offset_pwr_tracking", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_tracking", deramp == "-" or deramp in valid_values, f"deramp is not a valid value (expects: {valid_values}, got: {deramp})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_tracking", int_filt == "-" or int_filt in valid_values, f"int_filt is not a valid value (expects: {valid_values}, got: {int_filt})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr_tracking", pflag == "-" or pflag in valid_values, f"pflag is not a valid value (expects: {valid_values}, got: {pflag})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("offset_pwr_tracking", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_offset_pwr_tracking_outputs(self, SLC1: str, SLC2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, lanczos = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        if ccs is not None and ccs != "-":
            Path(ccs).touch()

    def offset_pwr_tracking(self, SLC1: str, SLC2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, lanczos = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_tracking))

        if self.validate_inputs:
            self._validate_offset_pwr_tracking(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_pwr_tracking_outputs(*supplied_args)

        return self._gamma_call("ISP", "offset_pwr_tracking", supplied_args)


    def _validate_SLC_phase_shift(self, SLC_1: str, SLC_par1: str, SLC_2: str, SLC_par2: str, ph_shift):
        if SLC_1 is not None:
            self._validate("SLC_phase_shift", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_par1 is not None:
            self._validate("SLC_phase_shift", SLC_par1 == "-" or Path(SLC_par1).exists(), f"SLC_par1 path does not exist ({SLC_par1})")

    def _mock_SLC_phase_shift_outputs(self, SLC_1: str, SLC_par1: str, SLC_2: str, SLC_par2: str, ph_shift):
        if SLC_2 is not None and SLC_2 != "-":
            Path(SLC_2).touch()
        if SLC_par2 is not None and SLC_par2 != "-":
            Path(SLC_par2).touch()

    def SLC_phase_shift(self, SLC_1: str, SLC_par1: str, SLC_2: str, SLC_par2: str, ph_shift):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_phase_shift))

        if self.validate_inputs:
            self._validate_SLC_phase_shift(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_phase_shift_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_phase_shift", supplied_args)


    def _validate_unw_model(self, interf: str, unw_model, unw: str, width, xinit = None, yinit = None, ref_ph = None, width_model = None):
        if interf is not None:
            self._validate("unw_model", interf == "-" or Path(interf).exists(), f"interf path does not exist ({interf})")

    def _mock_unw_model_outputs(self, interf: str, unw_model, unw: str, width, xinit = None, yinit = None, ref_ph = None, width_model = None):
        if unw is not None and unw != "-":
            Path(unw).touch()

    def unw_model(self, interf: str, unw_model, unw: str, width, xinit = None, yinit = None, ref_ph = None, width_model = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.unw_model))

        if self.validate_inputs:
            self._validate_unw_model(*supplied_args)

        if self.mock_outputs:
            self._mock_unw_model_outputs(*supplied_args)

        return self._gamma_call("ISP", "unw_model", supplied_args)


    def _validate_par_TX_SLC(self, annotation_XML: str, COSAR, SLC_par: str, SLC: str, pol = None):
        if annotation_XML is not None:
            self._validate("par_TX_SLC", annotation_XML == "-" or Path(annotation_XML).exists(), f"annotation_XML path does not exist ({annotation_XML})")

    def _mock_par_TX_SLC_outputs(self, annotation_XML: str, COSAR, SLC_par: str, SLC: str, pol = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_TX_SLC(self, annotation_XML: str, COSAR, SLC_par: str, SLC: str, pol = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_TX_SLC))

        if self.validate_inputs:
            self._validate_par_TX_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_TX_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_TX_SLC", supplied_args)


    def _validate_ScanSAR_burst_MLI(self, SLC_tab: str, MLI_tab: str, rlks, azlks, bflg = None, SLCR_tab: str = None, MLI_dir = None):
        if SLC_tab is not None:
            self._validate("ScanSAR_burst_MLI", SLC_tab == "-" or Path(SLC_tab).exists(), f"SLC_tab path does not exist ({SLC_tab})")
        valid_values = [0, 1] + [None]
        self._validate("ScanSAR_burst_MLI", bflg == "-" or bflg in valid_values, f"bflg is not a valid value (expects: {valid_values}, got: {bflg})")
        if SLCR_tab is not None:
            self._validate("ScanSAR_burst_MLI", SLCR_tab == "-" or Path(SLCR_tab).exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_ScanSAR_burst_MLI_outputs(self, SLC_tab: str, MLI_tab: str, rlks, azlks, bflg = None, SLCR_tab: str = None, MLI_dir = None):
        if MLI_tab is not None and MLI_tab != "-":
            Path(MLI_tab).touch()

    def ScanSAR_burst_MLI(self, SLC_tab: str, MLI_tab: str, rlks, azlks, bflg = None, SLCR_tab: str = None, MLI_dir = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_MLI))

        if self.validate_inputs:
            self._validate_ScanSAR_burst_MLI(*supplied_args)

        if self.mock_outputs:
            self._mock_ScanSAR_burst_MLI_outputs(*supplied_args)

        return self._gamma_call("ISP", "ScanSAR_burst_MLI", supplied_args)


    def _validate_base_copy(self, SLC1_par: str, baseline_1: str, SLC2_par: str, baseline_2: str, time_rev = None):
        if SLC1_par is not None:
            self._validate("base_copy", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if baseline_1 is not None:
            self._validate("base_copy", baseline_1 == "-" or Path(baseline_1).exists(), f"baseline_1 path does not exist ({baseline_1})")
        if SLC2_par is not None:
            self._validate("base_copy", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_base_copy_outputs(self, SLC1_par: str, baseline_1: str, SLC2_par: str, baseline_2: str, time_rev = None):
        if baseline_2 is not None and baseline_2 != "-":
            Path(baseline_2).touch()

    def base_copy(self, SLC1_par: str, baseline_1: str, SLC2_par: str, baseline_2: str, time_rev = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_copy))

        if self.validate_inputs:
            self._validate_base_copy(*supplied_args)

        if self.mock_outputs:
            self._mock_base_copy_outputs(*supplied_args)

        return self._gamma_call("ISP", "base_copy", supplied_args)


    def _validate_SLC_interp_map(self, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, SLC_2R: str, SLC2R_par: str, OFF_par2: str, coffs_sm: str, loff = None, nlines = None, mode = None):
        if SLC_2 is not None:
            self._validate("SLC_interp_map", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("SLC_interp_map", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("SLC_interp_map", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("SLC_interp_map", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if OFF_par2 is not None:
            self._validate("SLC_interp_map", OFF_par2 == "-" or Path(OFF_par2).exists(), f"OFF_par2 path does not exist ({OFF_par2})")
        if coffs_sm is not None:
            self._validate("SLC_interp_map", coffs_sm == "-" or Path(coffs_sm).exists(), f"coffs_sm path does not exist ({coffs_sm})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_interp_map", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_SLC_interp_map_outputs(self, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, SLC_2R: str, SLC2R_par: str, OFF_par2: str, coffs_sm: str, loff = None, nlines = None, mode = None):
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()

    def SLC_interp_map(self, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, SLC_2R: str, SLC2R_par: str, OFF_par2: str, coffs_sm: str, loff = None, nlines = None, mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp_map))

        if self.validate_inputs:
            self._validate_SLC_interp_map(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_interp_map_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_interp_map", supplied_args)


    def _validate_base_perp(self, baseline: str, SLC1_par: str, OFF_par: str, time_rev = None):
        if baseline is not None:
            self._validate("base_perp", baseline == "-" or Path(baseline).exists(), f"baseline path does not exist ({baseline})")
        if SLC1_par is not None:
            self._validate("base_perp", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if OFF_par is not None:
            self._validate("base_perp", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_base_perp_outputs(self, baseline: str, SLC1_par: str, OFF_par: str, time_rev = None):
        pass

    def base_perp(self, baseline: str, SLC1_par: str, OFF_par: str, time_rev = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_perp))

        if self.validate_inputs:
            self._validate_base_perp(*supplied_args)

        if self.mock_outputs:
            self._mock_base_perp_outputs(*supplied_args)

        return self._gamma_call("ISP", "base_perp", supplied_args)


    def _validate_SLC_adf(self, SLC: str, ref_SLC: str, ref_SLC_par: str, SLC_filt: str, mode = None, alpha = None, nfft_r = None, nfft_az = None, r_step = None, az_step = None, mwin_r = None, mwin_az = None):
        if SLC is not None:
            self._validate("SLC_adf", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        if ref_SLC is not None:
            self._validate("SLC_adf", ref_SLC == "-" or Path(ref_SLC).exists(), f"ref_SLC path does not exist ({ref_SLC})")
        if ref_SLC_par is not None:
            self._validate("SLC_adf", ref_SLC_par == "-" or Path(ref_SLC_par).exists(), f"ref_SLC_par path does not exist ({ref_SLC_par})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("SLC_adf", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_SLC_adf_outputs(self, SLC: str, ref_SLC: str, ref_SLC_par: str, SLC_filt: str, mode = None, alpha = None, nfft_r = None, nfft_az = None, r_step = None, az_step = None, mwin_r = None, mwin_az = None):
        if SLC_filt is not None and SLC_filt != "-":
            Path(SLC_filt).touch()

    def SLC_adf(self, SLC: str, ref_SLC: str, ref_SLC_par: str, SLC_filt: str, mode = None, alpha = None, nfft_r = None, nfft_az = None, r_step = None, az_step = None, mwin_r = None, mwin_az = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_adf))

        if self.validate_inputs:
            self._validate_SLC_adf(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_adf_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_adf", supplied_args)


    def _validate_offset_SLC(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, snr: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, nr = None, naz = None, thres = None, ISZ = None, pflag = None):
        if SLC_1 is not None:
            self._validate("offset_SLC", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("offset_SLC", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("offset_SLC", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("offset_SLC", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("offset_SLC", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_offset_SLC_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, snr: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, nr = None, naz = None, thres = None, ISZ = None, pflag = None):
        if offs is not None and offs != "-":
            Path(offs).touch()
        if snr is not None and snr != "-":
            Path(snr).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()

    def offset_SLC(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, snr: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, nr = None, naz = None, thres = None, ISZ = None, pflag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_SLC))

        if self.validate_inputs:
            self._validate_offset_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "offset_SLC", supplied_args)


    def _validate_adf(self, interf: str, sm: str, cc: str, width, alpha = None, nfft = None, cc_win = None, step = None, loff = None, nlines = None, wfrac = None):
        if interf is not None:
            self._validate("adf", interf == "-" or Path(interf).exists(), f"interf path does not exist ({interf})")

    def _mock_adf_outputs(self, interf: str, sm: str, cc: str, width, alpha = None, nfft = None, cc_win = None, step = None, loff = None, nlines = None, wfrac = None):
        if sm is not None and sm != "-":
            Path(sm).touch()
        if cc is not None and cc != "-":
            Path(cc).touch()

    def adf(self, interf: str, sm: str, cc: str, width, alpha = None, nfft = None, cc_win = None, step = None, loff = None, nlines = None, wfrac = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.adf))

        if self.validate_inputs:
            self._validate_adf(*supplied_args)

        if self.mock_outputs:
            self._mock_adf_outputs(*supplied_args)

        return self._gamma_call("ISP", "adf", supplied_args)


    def _validate_PRC_vec(self, SLC_par: str, PRC: str, nstate = None):
        if PRC is not None:
            self._validate("PRC_vec", PRC == "-" or Path(PRC).exists(), f"PRC path does not exist ({PRC})")

    def _mock_PRC_vec_outputs(self, SLC_par: str, PRC: str, nstate = None):
        if SLC_par is not None and SLC_par != "-" and not Path(SLC_par).exists():
            Path(SLC_par).touch()

    def PRC_vec(self, SLC_par: str, PRC: str, nstate = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PRC_vec))

        if self.validate_inputs:
            self._validate_PRC_vec(*supplied_args)

        if self.mock_outputs:
            self._mock_PRC_vec_outputs(*supplied_args)

        return self._gamma_call("ISP", "PRC_vec", supplied_args)


    def _validate_adapt_filt(self, int: str, sm: str, width, low_SNR_thr = None, filt_width = None, xmin = None, xmax = None, ymin = None, ymax = None):
        if int is not None:
            self._validate("adapt_filt", int == "-" or Path(int).exists(), f"int path does not exist ({int})")

    def _mock_adapt_filt_outputs(self, int: str, sm: str, width, low_SNR_thr = None, filt_width = None, xmin = None, xmax = None, ymin = None, ymax = None):
        if sm is not None and sm != "-":
            Path(sm).touch()

    def adapt_filt(self, int: str, sm: str, width, low_SNR_thr = None, filt_width = None, xmin = None, xmax = None, ymin = None, ymax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.adapt_filt))

        if self.validate_inputs:
            self._validate_adapt_filt(*supplied_args)

        if self.mock_outputs:
            self._mock_adapt_filt_outputs(*supplied_args)

        return self._gamma_call("ISP", "adapt_filt", supplied_args)


    def _validate_par_RSAT2_SG(self, product_XML: str, lut_XML: str, GeoTIFF: str, polarization, GRD_par: str, GRD: str):
        if product_XML is not None:
            self._validate("par_RSAT2_SG", product_XML == "-" or Path(product_XML).exists(), f"product_XML path does not exist ({product_XML})")
        if lut_XML is not None:
            self._validate("par_RSAT2_SG", lut_XML == "-" or Path(lut_XML).exists(), f"lut_XML path does not exist ({lut_XML})")
        if GeoTIFF is not None:
            self._validate("par_RSAT2_SG", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")

    def _mock_par_RSAT2_SG_outputs(self, product_XML: str, lut_XML: str, GeoTIFF: str, polarization, GRD_par: str, GRD: str):
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_RSAT2_SG(self, product_XML: str, lut_XML: str, GeoTIFF: str, polarization, GRD_par: str, GRD: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT2_SG))

        if self.validate_inputs:
            self._validate_par_RSAT2_SG(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RSAT2_SG_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RSAT2_SG", supplied_args)


    def _validate_ScanSAR_burst_corners(self, SLC_par: str, TOPS_par: str, KML: str = None):
        if SLC_par is not None:
            self._validate("ScanSAR_burst_corners", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if TOPS_par is not None:
            self._validate("ScanSAR_burst_corners", TOPS_par == "-" or Path(TOPS_par).exists(), f"TOPS_par path does not exist ({TOPS_par})")

    def _mock_ScanSAR_burst_corners_outputs(self, SLC_par: str, TOPS_par: str, KML: str = None):
        if KML is not None and KML != "-":
            Path(KML).touch()

    def ScanSAR_burst_corners(self, SLC_par: str, TOPS_par: str, KML: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_corners))

        if self.validate_inputs:
            self._validate_ScanSAR_burst_corners(*supplied_args)

        if self.mock_outputs:
            self._mock_ScanSAR_burst_corners_outputs(*supplied_args)

        return self._gamma_call("ISP", "ScanSAR_burst_corners", supplied_args)


    def _validate_par_RCM_SLC_ScanSAR(self, RCM_dir: str, polarization, radcal, noise_in, root_name: str, SLC_tab: str = None, beam = None, noise_out = None):
        if RCM_dir is not None:
            self._validate("par_RCM_SLC_ScanSAR", RCM_dir == "-" or Path(RCM_dir).exists(), f"RCM_dir path does not exist ({RCM_dir})")
        valid_values = [0, 1, 2, 3]
        self._validate("par_RCM_SLC_ScanSAR", radcal == "-" or radcal in valid_values, f"radcal is not a valid value (expects: {valid_values}, got: {radcal})")

    def _mock_par_RCM_SLC_ScanSAR_outputs(self, RCM_dir: str, polarization, radcal, noise_in, root_name: str, SLC_tab: str = None, beam = None, noise_out = None):
        if root_name is not None and root_name != "-":
            Path(root_name).touch()
        if SLC_tab is not None and SLC_tab != "-":
            Path(SLC_tab).touch()

    def par_RCM_SLC_ScanSAR(self, RCM_dir: str, polarization, radcal, noise_in, root_name: str, SLC_tab: str = None, beam = None, noise_out = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_SLC_ScanSAR))

        if self.validate_inputs:
            self._validate_par_RCM_SLC_ScanSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RCM_SLC_ScanSAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RCM_SLC_ScanSAR", supplied_args)


    def _validate_offset_add(self, OFF_par1: str, OFF_par2: str, OFF_par3: str):
        if OFF_par1 is not None:
            self._validate("offset_add", OFF_par1 == "-" or Path(OFF_par1).exists(), f"OFF_par1 path does not exist ({OFF_par1})")
        if OFF_par2 is not None:
            self._validate("offset_add", OFF_par2 == "-" or Path(OFF_par2).exists(), f"OFF_par2 path does not exist ({OFF_par2})")

    def _mock_offset_add_outputs(self, OFF_par1: str, OFF_par2: str, OFF_par3: str):
        if OFF_par3 is not None and OFF_par3 != "-":
            Path(OFF_par3).touch()

    def offset_add(self, OFF_par1: str, OFF_par2: str, OFF_par3: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_add))

        if self.validate_inputs:
            self._validate_offset_add(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_add_outputs(*supplied_args)

        return self._gamma_call("ISP", "offset_add", supplied_args)


    def _validate_multi_SLC_WSS(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str):
        if SLC is not None:
            self._validate("multi_SLC_WSS", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        if SLC_par is not None:
            self._validate("multi_SLC_WSS", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_multi_SLC_WSS_outputs(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str):
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()

    def multi_SLC_WSS(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_SLC_WSS))

        if self.validate_inputs:
            self._validate_multi_SLC_WSS(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_SLC_WSS_outputs(*supplied_args)

        return self._gamma_call("ISP", "multi_SLC_WSS", supplied_args)


    def _validate_SLC_cat_ScanSAR(self, SLC_tab1: str, SLC_tab2: str, SLC_tab3: str):
        if SLC_tab1 is not None:
            self._validate("SLC_cat_ScanSAR", SLC_tab1 == "-" or Path(SLC_tab1).exists(), f"SLC_tab1 path does not exist ({SLC_tab1})")
        if SLC_tab2 is not None:
            self._validate("SLC_cat_ScanSAR", SLC_tab2 == "-" or Path(SLC_tab2).exists(), f"SLC_tab2 path does not exist ({SLC_tab2})")
        if SLC_tab3 is not None:
            self._validate("SLC_cat_ScanSAR", SLC_tab3 == "-" or Path(SLC_tab3).exists(), f"SLC_tab3 path does not exist ({SLC_tab3})")

    def _mock_SLC_cat_ScanSAR_outputs(self, SLC_tab1: str, SLC_tab2: str, SLC_tab3: str):
        pass

    def SLC_cat_ScanSAR(self, SLC_tab1: str, SLC_tab2: str, SLC_tab3: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_cat_ScanSAR))

        if self.validate_inputs:
            self._validate_SLC_cat_ScanSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_cat_ScanSAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_cat_ScanSAR", supplied_args)


    def _validate_par_RSAT_SLC(self, CEOS_leader: str, SLC_par: str, CEOS_data: str, SLC: str = None, sc_dB = None, dt = None):
        if CEOS_leader is not None:
            self._validate("par_RSAT_SLC", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_data is not None:
            self._validate("par_RSAT_SLC", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_RSAT_SLC_outputs(self, CEOS_leader: str, SLC_par: str, CEOS_data: str, SLC: str = None, sc_dB = None, dt = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_RSAT_SLC(self, CEOS_leader: str, SLC_par: str, CEOS_data: str, SLC: str = None, sc_dB = None, dt = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT_SLC))

        if self.validate_inputs:
            self._validate_par_RSAT_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RSAT_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RSAT_SLC", supplied_args)


    def _validate_base_est_fft(self, interf: str, SLC1_par: str, OFF_par: str, baseline: str, nazfft = None, r_samp = None, az_line = None, nrfft = None):
        if interf is not None:
            self._validate("base_est_fft", interf == "-" or Path(interf).exists(), f"interf path does not exist ({interf})")
        if SLC1_par is not None:
            self._validate("base_est_fft", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if OFF_par is not None:
            self._validate("base_est_fft", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_base_est_fft_outputs(self, interf: str, SLC1_par: str, OFF_par: str, baseline: str, nazfft = None, r_samp = None, az_line = None, nrfft = None):
        if baseline is not None and baseline != "-":
            Path(baseline).touch()

    def base_est_fft(self, interf: str, SLC1_par: str, OFF_par: str, baseline: str, nazfft = None, r_samp = None, az_line = None, nrfft = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_est_fft))

        if self.validate_inputs:
            self._validate_base_est_fft(*supplied_args)

        if self.mock_outputs:
            self._mock_base_est_fft_outputs(*supplied_args)

        return self._gamma_call("ISP", "base_est_fft", supplied_args)


    def _validate_par_RCM_GRC(self, RCM_dir: str, polarization, radcal, noise, SLC_par: str = None, SLC: str = None, GRC_par: str = None, GRC: str = None, rps = None, noise_pwr: str = None):
        if RCM_dir is not None:
            self._validate("par_RCM_GRC", RCM_dir == "-" or Path(RCM_dir).exists(), f"RCM_dir path does not exist ({RCM_dir})")
        valid_values = [0, 1, 2, 3]
        self._validate("par_RCM_GRC", radcal == "-" or radcal in valid_values, f"radcal is not a valid value (expects: {valid_values}, got: {radcal})")

    def _mock_par_RCM_GRC_outputs(self, RCM_dir: str, polarization, radcal, noise, SLC_par: str = None, SLC: str = None, GRC_par: str = None, GRC: str = None, rps = None, noise_pwr: str = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if GRC_par is not None and GRC_par != "-":
            Path(GRC_par).touch()
        if GRC is not None and GRC != "-":
            Path(GRC).touch()
        if noise_pwr is not None and noise_pwr != "-":
            Path(noise_pwr).touch()

    def par_RCM_GRC(self, RCM_dir: str, polarization, radcal, noise, SLC_par: str = None, SLC: str = None, GRC_par: str = None, GRC: str = None, rps = None, noise_pwr: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_GRC))

        if self.validate_inputs:
            self._validate_par_RCM_GRC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RCM_GRC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RCM_GRC", supplied_args)


    def _validate_base_orbit(self, SLC1_par: str, SLC2_par: str, baseline: str):
        if SLC1_par is not None:
            self._validate("base_orbit", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("base_orbit", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_base_orbit_outputs(self, SLC1_par: str, SLC2_par: str, baseline: str):
        if baseline is not None and baseline != "-":
            Path(baseline).touch()

    def base_orbit(self, SLC1_par: str, SLC2_par: str, baseline: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_orbit))

        if self.validate_inputs:
            self._validate_base_orbit(*supplied_args)

        if self.mock_outputs:
            self._mock_base_orbit_outputs(*supplied_args)

        return self._gamma_call("ISP", "base_orbit", supplied_args)


    def _validate_par_KS_DGM(self, HDF5: str, trunk: str):
        if HDF5 is not None:
            self._validate("par_KS_DGM", HDF5 == "-" or Path(HDF5).exists(), f"HDF5 path does not exist ({HDF5})")

    def _mock_par_KS_DGM_outputs(self, HDF5: str, trunk: str):
        if trunk is not None and trunk != "-":
            Path(trunk).touch()

    def par_KS_DGM(self, HDF5: str, trunk: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_KS_DGM))

        if self.validate_inputs:
            self._validate_par_KS_DGM(*supplied_args)

        if self.mock_outputs:
            self._mock_par_KS_DGM_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_KS_DGM", supplied_args)


    def _validate_par_RSI_ERS(self, CEOS_SAR_leader, SLC_par: str):
        pass

    def _mock_par_RSI_ERS_outputs(self, CEOS_SAR_leader, SLC_par: str):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()

    def par_RSI_ERS(self, CEOS_SAR_leader, SLC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSI_ERS))

        if self.validate_inputs:
            self._validate_par_RSI_ERS(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RSI_ERS_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RSI_ERS", supplied_args)


    def _validate_af_SLC(self, SLC_par: str, SLC: str, rwin = None, azwin = None, dr = None, daz = None, thres = None, a1_flg = None, b0_flg = None, offsets: str = None, n_ovr = None, roff = None, azoff = None):
        if SLC_par is not None:
            self._validate("af_SLC", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if SLC is not None:
            self._validate("af_SLC", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        valid_values = [0, 1] + [None]
        self._validate("af_SLC", a1_flg == "-" or a1_flg in valid_values, f"a1_flg is not a valid value (expects: {valid_values}, got: {a1_flg})")
        valid_values = [0, 1] + [None]
        self._validate("af_SLC", b0_flg == "-" or b0_flg in valid_values, f"b0_flg is not a valid value (expects: {valid_values}, got: {b0_flg})")

    def _mock_af_SLC_outputs(self, SLC_par: str, SLC: str, rwin = None, azwin = None, dr = None, daz = None, thres = None, a1_flg = None, b0_flg = None, offsets: str = None, n_ovr = None, roff = None, azoff = None):
        if offsets is not None and offsets != "-":
            Path(offsets).touch()

    def af_SLC(self, SLC_par: str, SLC: str, rwin = None, azwin = None, dr = None, daz = None, thres = None, a1_flg = None, b0_flg = None, offsets: str = None, n_ovr = None, roff = None, azoff = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.af_SLC))

        if self.validate_inputs:
            self._validate_af_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_af_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "af_SLC", supplied_args)


    def _validate_par_EORC_JERS_SLC(self, CEOS_SAR_leader: str, SLC_par: str, CEOS_data: str = None, slc: str = None):
        if CEOS_SAR_leader is not None:
            self._validate("par_EORC_JERS_SLC", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        if CEOS_data is not None:
            self._validate("par_EORC_JERS_SLC", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_EORC_JERS_SLC_outputs(self, CEOS_SAR_leader: str, SLC_par: str, CEOS_data: str = None, slc: str = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if slc is not None and slc != "-":
            Path(slc).touch()

    def par_EORC_JERS_SLC(self, CEOS_SAR_leader: str, SLC_par: str, CEOS_data: str = None, slc: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_EORC_JERS_SLC))

        if self.validate_inputs:
            self._validate_par_EORC_JERS_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_EORC_JERS_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_EORC_JERS_SLC", supplied_args)


    def _validate_fill_gaps(self, data_in: str, width, data_out: str, dtype = None, method = None, max_dist = None, bp_flag = None, win = None, ds_method = None, ds_size = None, ds_data: str = None):
        if data_in is not None:
            self._validate("fill_gaps", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        valid_values = [0, 1] + [None]
        self._validate("fill_gaps", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_fill_gaps_outputs(self, data_in: str, width, data_out: str, dtype = None, method = None, max_dist = None, bp_flag = None, win = None, ds_method = None, ds_size = None, ds_data: str = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if ds_data is not None and ds_data != "-":
            Path(ds_data).touch()

    def fill_gaps(self, data_in: str, width, data_out: str, dtype = None, method = None, max_dist = None, bp_flag = None, win = None, ds_method = None, ds_size = None, ds_data: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.fill_gaps))

        if self.validate_inputs:
            self._validate_fill_gaps(*supplied_args)

        if self.mock_outputs:
            self._mock_fill_gaps_outputs(*supplied_args)

        return self._gamma_call("ISP", "fill_gaps", supplied_args)


    def _validate_rascc_mask_thinning(self, ras_in: str, in_file, width, ras_out: str, nmax = None, thresh_1 = None, thresh_nmax = None, *args):
        if ras_in is not None:
            self._validate("rascc_mask_thinning", ras_in == "-" or Path(ras_in).exists(), f"ras_in path does not exist ({ras_in})")

    def _mock_rascc_mask_thinning_outputs(self, ras_in: str, in_file, width, ras_out: str, nmax = None, thresh_1 = None, thresh_nmax = None, *args):
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()

    def rascc_mask_thinning(self, ras_in: str, in_file, width, ras_out: str, nmax = None, thresh_1 = None, thresh_nmax = None, *args):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rascc_mask_thinning))

        if self.validate_inputs:
            self._validate_rascc_mask_thinning(*supplied_args)

        if self.mock_outputs:
            self._mock_rascc_mask_thinning_outputs(*supplied_args)

        return self._gamma_call("ISP", "rascc_mask_thinning", supplied_args)


    def _validate_GRD_to_SR(self, GRD_par: str, SLC_par: str, OFF_par: str, in_file, out_file: str, rlks = None, azlks = None, interp_mode = None, sr_rsp = None, sr_azsp = None):
        if GRD_par is not None:
            self._validate("GRD_to_SR", GRD_par == "-" or Path(GRD_par).exists(), f"GRD_par path does not exist ({GRD_par})")
        if OFF_par is not None:
            self._validate("GRD_to_SR", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1, 2] + [None]
        self._validate("GRD_to_SR", interp_mode == "-" or interp_mode in valid_values, f"interp_mode is not a valid value (expects: {valid_values}, got: {interp_mode})")

    def _mock_GRD_to_SR_outputs(self, GRD_par: str, SLC_par: str, OFF_par: str, in_file, out_file: str, rlks = None, azlks = None, interp_mode = None, sr_rsp = None, sr_azsp = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if out_file is not None and out_file != "-":
            Path(out_file).touch()

    def GRD_to_SR(self, GRD_par: str, SLC_par: str, OFF_par: str, in_file, out_file: str, rlks = None, azlks = None, interp_mode = None, sr_rsp = None, sr_azsp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.GRD_to_SR))

        if self.validate_inputs:
            self._validate_GRD_to_SR(*supplied_args)

        if self.mock_outputs:
            self._mock_GRD_to_SR_outputs(*supplied_args)

        return self._gamma_call("ISP", "GRD_to_SR", supplied_args)


    def _validate_multi_look2(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str, r_dec, az_dec, rwin = None, azwin = None, wflg = None, lanczos = None, beta = None):
        if SLC is not None:
            self._validate("multi_look2", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        if SLC_par is not None:
            self._validate("multi_look2", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        valid_values = [0, 1] + [None]
        self._validate("multi_look2", wflg == "-" or wflg in valid_values, f"wflg is not a valid value (expects: {valid_values}, got: {wflg})")

    def _mock_multi_look2_outputs(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str, r_dec, az_dec, rwin = None, azwin = None, wflg = None, lanczos = None, beta = None):
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()

    def multi_look2(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str, r_dec, az_dec, rwin = None, azwin = None, wflg = None, lanczos = None, beta = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look2))

        if self.validate_inputs:
            self._validate_multi_look2(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_look2_outputs(*supplied_args)

        return self._gamma_call("ISP", "multi_look2", supplied_args)


    def _validate_dcomp_sirc(self, infile: str, outfile: str, samples, loff = None, nlines = None):
        if infile is not None:
            self._validate("dcomp_sirc", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")

    def _mock_dcomp_sirc_outputs(self, infile: str, outfile: str, samples, loff = None, nlines = None):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def dcomp_sirc(self, infile: str, outfile: str, samples, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dcomp_sirc))

        if self.validate_inputs:
            self._validate_dcomp_sirc(*supplied_args)

        if self.mock_outputs:
            self._mock_dcomp_sirc_outputs(*supplied_args)

        return self._gamma_call("ISP", "dcomp_sirc", supplied_args)


    def _validate_subtract_phase(self, interf_in: str, phase_file, interf_out: str, width, factor = None):
        if interf_in is not None:
            self._validate("subtract_phase", interf_in == "-" or Path(interf_in).exists(), f"interf_in path does not exist ({interf_in})")

    def _mock_subtract_phase_outputs(self, interf_in: str, phase_file, interf_out: str, width, factor = None):
        if interf_out is not None and interf_out != "-":
            Path(interf_out).touch()

    def subtract_phase(self, interf_in: str, phase_file, interf_out: str, width, factor = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.subtract_phase))

        if self.validate_inputs:
            self._validate_subtract_phase(*supplied_args)

        if self.mock_outputs:
            self._mock_subtract_phase_outputs(*supplied_args)

        return self._gamma_call("ISP", "subtract_phase", supplied_args)


    def _validate_dcomp_sirc_quad(self, infile: str, outfile: str, samples, parameter, loff = None, nlines = None):
        if infile is not None:
            self._validate("dcomp_sirc_quad", infile == "-" or Path(infile).exists(), f"infile path does not exist ({infile})")
        valid_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        self._validate("dcomp_sirc_quad", parameter == "-" or parameter in valid_values, f"parameter is not a valid value (expects: {valid_values}, got: {parameter})")

    def _mock_dcomp_sirc_quad_outputs(self, infile: str, outfile: str, samples, parameter, loff = None, nlines = None):
        if outfile is not None and outfile != "-":
            Path(outfile).touch()

    def dcomp_sirc_quad(self, infile: str, outfile: str, samples, parameter, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dcomp_sirc_quad))

        if self.validate_inputs:
            self._validate_dcomp_sirc_quad(*supplied_args)

        if self.mock_outputs:
            self._mock_dcomp_sirc_quad_outputs(*supplied_args)

        return self._gamma_call("ISP", "dcomp_sirc_quad", supplied_args)


    def _validate_SLC_copy_ScanSAR(self, SLC1_tab: str, SLC2_tab: str, BURST_tab: str, dtype = None, SLC2_dir = None):
        if SLC1_tab is not None:
            self._validate("SLC_copy_ScanSAR", SLC1_tab == "-" or Path(SLC1_tab).exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        if BURST_tab is not None:
            self._validate("SLC_copy_ScanSAR", BURST_tab == "-" or Path(BURST_tab).exists(), f"BURST_tab path does not exist ({BURST_tab})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_copy_ScanSAR", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_SLC_copy_ScanSAR_outputs(self, SLC1_tab: str, SLC2_tab: str, BURST_tab: str, dtype = None, SLC2_dir = None):
        if SLC2_tab is not None and SLC2_tab != "-" and not Path(SLC2_tab).exists():
            Path(SLC2_tab).touch()

    def SLC_copy_ScanSAR(self, SLC1_tab: str, SLC2_tab: str, BURST_tab: str, dtype = None, SLC2_dir = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_copy_ScanSAR))

        if self.validate_inputs:
            self._validate_SLC_copy_ScanSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_copy_ScanSAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_copy_ScanSAR", supplied_args)


    def _validate_par_RISAT_SLC(self, CEOS_leader: str, BAND_META, SLC_par: str, CEOS_image: str, SLC: str = None, line_dir = None, pix_dir = None, cal_flg = None, KdB = None):
        if CEOS_leader is not None:
            self._validate("par_RISAT_SLC", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_image is not None:
            self._validate("par_RISAT_SLC", CEOS_image == "-" or Path(CEOS_image).exists(), f"CEOS_image path does not exist ({CEOS_image})")
        valid_values = [0, 1] + [None]
        self._validate("par_RISAT_SLC", cal_flg == "-" or cal_flg in valid_values, f"cal_flg is not a valid value (expects: {valid_values}, got: {cal_flg})")

    def _mock_par_RISAT_SLC_outputs(self, CEOS_leader: str, BAND_META, SLC_par: str, CEOS_image: str, SLC: str = None, line_dir = None, pix_dir = None, cal_flg = None, KdB = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_RISAT_SLC(self, CEOS_leader: str, BAND_META, SLC_par: str, CEOS_image: str, SLC: str = None, line_dir = None, pix_dir = None, cal_flg = None, KdB = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RISAT_SLC))

        if self.validate_inputs:
            self._validate_par_RISAT_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RISAT_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RISAT_SLC", supplied_args)


    def _validate_SLC_freq_shift(self, SLC: str, SLC_par: str, SLC_shift: str, SLC_shift_par: str, freq_shift):
        if SLC is not None:
            self._validate("SLC_freq_shift", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        if SLC_par is not None:
            self._validate("SLC_freq_shift", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_SLC_freq_shift_outputs(self, SLC: str, SLC_par: str, SLC_shift: str, SLC_shift_par: str, freq_shift):
        if SLC_shift is not None and SLC_shift != "-":
            Path(SLC_shift).touch()
        if SLC_shift_par is not None and SLC_shift_par != "-":
            Path(SLC_shift_par).touch()

    def SLC_freq_shift(self, SLC: str, SLC_par: str, SLC_shift: str, SLC_shift_par: str, freq_shift):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_freq_shift))

        if self.validate_inputs:
            self._validate_SLC_freq_shift(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_freq_shift_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_freq_shift", supplied_args)


    def _validate_DELFT_vec2(self, SLC_par: str, DELFT_dir, nstate = None, interval = None, ODR = None):
        if SLC_par is not None:
            self._validate("DELFT_vec2", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_DELFT_vec2_outputs(self, SLC_par: str, DELFT_dir, nstate = None, interval = None, ODR = None):
        pass

    def DELFT_vec2(self, SLC_par: str, DELFT_dir, nstate = None, interval = None, ODR = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.DELFT_vec2))

        if self.validate_inputs:
            self._validate_DELFT_vec2(*supplied_args)

        if self.mock_outputs:
            self._mock_DELFT_vec2_outputs(*supplied_args)

        return self._gamma_call("ISP", "DELFT_vec2", supplied_args)


    def _validate_SLC_intf(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, OFF_par: str, interf: str, rlks, azlks, loff = None, nlines = None, sps_flg = None, azf_flg = None, rp1_flg = None, rp2_flg = None, SLC_1s = None, SLC_2Rs = None, SLC_1s_par = None, SLC_2Rs_par = None, az_beta = None):
        if SLC_1 is not None:
            self._validate("SLC_intf", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2R is not None:
            self._validate("SLC_intf", SLC_2R == "-" or Path(SLC_2R).exists(), f"SLC_2R path does not exist ({SLC_2R})")
        if SLC1_par is not None:
            self._validate("SLC_intf", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2R_par is not None:
            self._validate("SLC_intf", SLC2R_par == "-" or Path(SLC2R_par).exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        if OFF_par is not None:
            self._validate("SLC_intf", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [1, 0] + [None]
        self._validate("SLC_intf", sps_flg == "-" or sps_flg in valid_values, f"sps_flg is not a valid value (expects: {valid_values}, got: {sps_flg})")
        valid_values = [1, 0] + [None]
        self._validate("SLC_intf", azf_flg == "-" or azf_flg in valid_values, f"azf_flg is not a valid value (expects: {valid_values}, got: {azf_flg})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_intf", rp1_flg == "-" or rp1_flg in valid_values, f"rp1_flg is not a valid value (expects: {valid_values}, got: {rp1_flg})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_intf", rp2_flg == "-" or rp2_flg in valid_values, f"rp2_flg is not a valid value (expects: {valid_values}, got: {rp2_flg})")

    def _mock_SLC_intf_outputs(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, OFF_par: str, interf: str, rlks, azlks, loff = None, nlines = None, sps_flg = None, azf_flg = None, rp1_flg = None, rp2_flg = None, SLC_1s = None, SLC_2Rs = None, SLC_1s_par = None, SLC_2Rs_par = None, az_beta = None):
        if interf is not None and interf != "-":
            Path(interf).touch()

    def SLC_intf(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, OFF_par: str, interf: str, rlks, azlks, loff = None, nlines = None, sps_flg = None, azf_flg = None, rp1_flg = None, rp2_flg = None, SLC_1s = None, SLC_2Rs = None, SLC_1s_par = None, SLC_2Rs_par = None, az_beta = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_intf))

        if self.validate_inputs:
            self._validate_SLC_intf(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_intf_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_intf", supplied_args)


    def _validate_ptarg_cal_SLC(self, SLC_par: str, SLC: str, r_samp, az_samp, psigma, c_r_samp, c_az_samp, ptr_image: str, r_plot: str, az_plot: str, pcal: str, osf = None, win = None, pltflg = None, psz = None, csz = None, c_image: str = None):
        if SLC_par is not None:
            self._validate("ptarg_cal_SLC", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if SLC is not None:
            self._validate("ptarg_cal_SLC", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("ptarg_cal_SLC", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_ptarg_cal_SLC_outputs(self, SLC_par: str, SLC: str, r_samp, az_samp, psigma, c_r_samp, c_az_samp, ptr_image: str, r_plot: str, az_plot: str, pcal: str, osf = None, win = None, pltflg = None, psz = None, csz = None, c_image: str = None):
        if ptr_image is not None and ptr_image != "-":
            Path(ptr_image).touch()
        if r_plot is not None and r_plot != "-":
            Path(r_plot).touch()
        if az_plot is not None and az_plot != "-":
            Path(az_plot).touch()
        if pcal is not None and pcal != "-":
            Path(pcal).touch()
        if c_image is not None and c_image != "-":
            Path(c_image).touch()

    def ptarg_cal_SLC(self, SLC_par: str, SLC: str, r_samp, az_samp, psigma, c_r_samp, c_az_samp, ptr_image: str, r_plot: str, az_plot: str, pcal: str, osf = None, win = None, pltflg = None, psz = None, csz = None, c_image: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ptarg_cal_SLC))

        if self.validate_inputs:
            self._validate_ptarg_cal_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_ptarg_cal_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "ptarg_cal_SLC", supplied_args)


    def _validate_sbi_filt(self, SLC_1: str, SLC1_par: str, SLC2R_par: str, SLCf: str, SLCf_par: str, SLCb: str, SLCb_par: str, norm_sq, iwflg = None):
        if SLC_1 is not None:
            self._validate("sbi_filt", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC1_par is not None:
            self._validate("sbi_filt", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2R_par is not None:
            self._validate("sbi_filt", SLC2R_par == "-" or Path(SLC2R_par).exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        valid_values = [0, 1] + [None]
        self._validate("sbi_filt", iwflg == "-" or iwflg in valid_values, f"iwflg is not a valid value (expects: {valid_values}, got: {iwflg})")

    def _mock_sbi_filt_outputs(self, SLC_1: str, SLC1_par: str, SLC2R_par: str, SLCf: str, SLCf_par: str, SLCb: str, SLCb_par: str, norm_sq, iwflg = None):
        if SLCf is not None and SLCf != "-":
            Path(SLCf).touch()
        if SLCf_par is not None and SLCf_par != "-":
            Path(SLCf_par).touch()
        if SLCb is not None and SLCb != "-":
            Path(SLCb).touch()
        if SLCb_par is not None and SLCb_par != "-":
            Path(SLCb_par).touch()

    def sbi_filt(self, SLC_1: str, SLC1_par: str, SLC2R_par: str, SLCf: str, SLCf_par: str, SLCb: str, SLCb_par: str, norm_sq, iwflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sbi_filt))

        if self.validate_inputs:
            self._validate_sbi_filt(*supplied_args)

        if self.mock_outputs:
            self._mock_sbi_filt_outputs(*supplied_args)

        return self._gamma_call("ISP", "sbi_filt", supplied_args)


    def _validate_ph_slope_base(self, int_in: str, SLC_par: str, OFF_par: str, base: str, int_out: str, int_type = None, inverse = None):
        if int_in is not None:
            self._validate("ph_slope_base", int_in == "-" or Path(int_in).exists(), f"int_in path does not exist ({int_in})")
        if SLC_par is not None:
            self._validate("ph_slope_base", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("ph_slope_base", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if base is not None:
            self._validate("ph_slope_base", base == "-" or Path(base).exists(), f"base path does not exist ({base})")

    def _mock_ph_slope_base_outputs(self, int_in: str, SLC_par: str, OFF_par: str, base: str, int_out: str, int_type = None, inverse = None):
        if int_out is not None and int_out != "-":
            Path(int_out).touch()

    def ph_slope_base(self, int_in: str, SLC_par: str, OFF_par: str, base: str, int_out: str, int_type = None, inverse = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ph_slope_base))

        if self.validate_inputs:
            self._validate_ph_slope_base(*supplied_args)

        if self.mock_outputs:
            self._mock_ph_slope_base_outputs(*supplied_args)

        return self._gamma_call("ISP", "ph_slope_base", supplied_args)


    def _validate_multi_look_ScanSAR(self, SLC_tab: str, MLI: str, MLI_par: str, rlks, azlks, bflg = None, SLCR_tab: str = None):
        if SLC_tab is not None:
            self._validate("multi_look_ScanSAR", SLC_tab == "-" or Path(SLC_tab).exists(), f"SLC_tab path does not exist ({SLC_tab})")
        valid_values = [0, 1] + [None]
        self._validate("multi_look_ScanSAR", bflg == "-" or bflg in valid_values, f"bflg is not a valid value (expects: {valid_values}, got: {bflg})")
        if SLCR_tab is not None:
            self._validate("multi_look_ScanSAR", SLCR_tab == "-" or Path(SLCR_tab).exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_multi_look_ScanSAR_outputs(self, SLC_tab: str, MLI: str, MLI_par: str, rlks, azlks, bflg = None, SLCR_tab: str = None):
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()

    def multi_look_ScanSAR(self, SLC_tab: str, MLI: str, MLI_par: str, rlks, azlks, bflg = None, SLCR_tab: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look_ScanSAR))

        if self.validate_inputs:
            self._validate_multi_look_ScanSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_look_ScanSAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "multi_look_ScanSAR", supplied_args)


    def _validate_par_ASNARO2(self, CEOS_data: str, CEOS_leader: str, SLC_par: str, SLC: str = None, reramp = None):
        if CEOS_data is not None:
            self._validate("par_ASNARO2", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")
        if CEOS_leader is not None:
            self._validate("par_ASNARO2", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        valid_values = [0, 1] + [None]
        self._validate("par_ASNARO2", reramp == "-" or reramp in valid_values, f"reramp is not a valid value (expects: {valid_values}, got: {reramp})")

    def _mock_par_ASNARO2_outputs(self, CEOS_data: str, CEOS_leader: str, SLC_par: str, SLC: str = None, reramp = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_ASNARO2(self, CEOS_data: str, CEOS_leader: str, SLC_par: str, SLC: str = None, reramp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASNARO2))

        if self.validate_inputs:
            self._validate_par_ASNARO2(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ASNARO2_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ASNARO2", supplied_args)


    def _validate_grasses(self, int: str, flag: str, unw: str, width, xmin = None, xmax = None, ymin = None, ymax = None, xinit = None, yinit = None, init_ph = None):
        if int is not None:
            self._validate("grasses", int == "-" or Path(int).exists(), f"int path does not exist ({int})")
        if flag is not None:
            self._validate("grasses", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")

    def _mock_grasses_outputs(self, int: str, flag: str, unw: str, width, xmin = None, xmax = None, ymin = None, ymax = None, xinit = None, yinit = None, init_ph = None):
        if unw is not None and unw != "-":
            Path(unw).touch()

    def grasses(self, int: str, flag: str, unw: str, width, xmin = None, xmax = None, ymin = None, ymax = None, xinit = None, yinit = None, init_ph = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.grasses))

        if self.validate_inputs:
            self._validate_grasses(*supplied_args)

        if self.mock_outputs:
            self._mock_grasses_outputs(*supplied_args)

        return self._gamma_call("ISP", "grasses", supplied_args)


    def _validate_mask_data(self, data_in: str, width, data_out: str, mask: str, dtype = None):
        if data_in is not None:
            self._validate("mask_data", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        if mask is not None:
            self._validate("mask_data", mask == "-" or Path(mask).exists(), f"mask path does not exist ({mask})")
        valid_values = [0, 1] + [None]
        self._validate("mask_data", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_mask_data_outputs(self, data_in: str, width, data_out: str, mask: str, dtype = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def mask_data(self, data_in: str, width, data_out: str, mask: str, dtype = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mask_data))

        if self.validate_inputs:
            self._validate_mask_data(*supplied_args)

        if self.mock_outputs:
            self._mock_mask_data_outputs(*supplied_args)

        return self._gamma_call("ISP", "mask_data", supplied_args)


    def _validate_par_ESA_JERS_SEASAT_SLC(self, CEOS_data: str, CEOS_leader: str, SLC_par: str, SLC: str = None):
        if CEOS_data is not None:
            self._validate("par_ESA_JERS_SEASAT_SLC", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")
        if CEOS_leader is not None:
            self._validate("par_ESA_JERS_SEASAT_SLC", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")

    def _mock_par_ESA_JERS_SEASAT_SLC_outputs(self, CEOS_data: str, CEOS_leader: str, SLC_par: str, SLC: str = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_ESA_JERS_SEASAT_SLC(self, CEOS_data: str, CEOS_leader: str, SLC_par: str, SLC: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ESA_JERS_SEASAT_SLC))

        if self.validate_inputs:
            self._validate_par_ESA_JERS_SEASAT_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ESA_JERS_SEASAT_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ESA_JERS_SEASAT_SLC", supplied_args)


    def _validate_ScanSAR_burst_overlap(self, SLC_tab: str, root_name: str, rlks, azlks, mode = None, bflg = None, SLCR_tab: str = None, dburst = None):
        if SLC_tab is not None:
            self._validate("ScanSAR_burst_overlap", SLC_tab == "-" or Path(SLC_tab).exists(), f"SLC_tab path does not exist ({SLC_tab})")
        valid_values = [0, 1, 2] + [None]
        self._validate("ScanSAR_burst_overlap", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")
        valid_values = [0, 1] + [None]
        self._validate("ScanSAR_burst_overlap", bflg == "-" or bflg in valid_values, f"bflg is not a valid value (expects: {valid_values}, got: {bflg})")
        if SLCR_tab is not None:
            self._validate("ScanSAR_burst_overlap", SLCR_tab == "-" or Path(SLCR_tab).exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_ScanSAR_burst_overlap_outputs(self, SLC_tab: str, root_name: str, rlks, azlks, mode = None, bflg = None, SLCR_tab: str = None, dburst = None):
        if root_name is not None and root_name != "-":
            Path(root_name).touch()

    def ScanSAR_burst_overlap(self, SLC_tab: str, root_name: str, rlks, azlks, mode = None, bflg = None, SLCR_tab: str = None, dburst = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_overlap))

        if self.validate_inputs:
            self._validate_ScanSAR_burst_overlap(*supplied_args)

        if self.mock_outputs:
            self._mock_ScanSAR_burst_overlap_outputs(*supplied_args)

        return self._gamma_call("ISP", "ScanSAR_burst_overlap", supplied_args)


    def _validate_ORB_prop_SLC(self, SLC_par: str, nstate = None, interval = None, extra = None, mode = None):
        if SLC_par is not None:
            self._validate("ORB_prop_SLC", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_ORB_prop_SLC_outputs(self, SLC_par: str, nstate = None, interval = None, extra = None, mode = None):
        pass

    def ORB_prop_SLC(self, SLC_par: str, nstate = None, interval = None, extra = None, mode = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORB_prop_SLC))

        if self.validate_inputs:
            self._validate_ORB_prop_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_ORB_prop_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "ORB_prop_SLC", supplied_args)


    def _validate_interp_ad(self, data_in: str, data_out: str, width, r_max = None, np_min = None, np_max = None, w_mode = None, dtype = None, cp_data = None):
        if data_in is not None:
            self._validate("interp_ad", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("interp_ad", w_mode == "-" or w_mode in valid_values, f"w_mode is not a valid value (expects: {valid_values}, got: {w_mode})")
        valid_values = [0, 1, 2, 3, 4] + [None]
        self._validate("interp_ad", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1] + [None]
        self._validate("interp_ad", cp_data == "-" or cp_data in valid_values, f"cp_data is not a valid value (expects: {valid_values}, got: {cp_data})")

    def _mock_interp_ad_outputs(self, data_in: str, data_out: str, width, r_max = None, np_min = None, np_max = None, w_mode = None, dtype = None, cp_data = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def interp_ad(self, data_in: str, data_out: str, width, r_max = None, np_min = None, np_max = None, w_mode = None, dtype = None, cp_data = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.interp_ad))

        if self.validate_inputs:
            self._validate_interp_ad(*supplied_args)

        if self.mock_outputs:
            self._mock_interp_ad_outputs(*supplied_args)

        return self._gamma_call("ISP", "interp_ad", supplied_args)


    def _validate_par_RISAT_GRD(self, CEOS_leader: str, BAND_META, GRD_par: str, CEOS_image: str, GRD: str = None, line_dir = None, pix_dir = None, cal_flg = None, KdB = None):
        if CEOS_leader is not None:
            self._validate("par_RISAT_GRD", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_image is not None:
            self._validate("par_RISAT_GRD", CEOS_image == "-" or Path(CEOS_image).exists(), f"CEOS_image path does not exist ({CEOS_image})")
        valid_values = [0, 1] + [None]
        self._validate("par_RISAT_GRD", cal_flg == "-" or cal_flg in valid_values, f"cal_flg is not a valid value (expects: {valid_values}, got: {cal_flg})")

    def _mock_par_RISAT_GRD_outputs(self, CEOS_leader: str, BAND_META, GRD_par: str, CEOS_image: str, GRD: str = None, line_dir = None, pix_dir = None, cal_flg = None, KdB = None):
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_RISAT_GRD(self, CEOS_leader: str, BAND_META, GRD_par: str, CEOS_image: str, GRD: str = None, line_dir = None, pix_dir = None, cal_flg = None, KdB = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RISAT_GRD))

        if self.validate_inputs:
            self._validate_par_RISAT_GRD(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RISAT_GRD_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RISAT_GRD", supplied_args)


    def _validate_par_RSAT_SCW(self, CEOS_leader: str, CEOS_trailer: str, CEOS_data: str, GRD_par: str, GRD: str, sc_dB = None, dt = None):
        if CEOS_leader is not None:
            self._validate("par_RSAT_SCW", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_trailer is not None:
            self._validate("par_RSAT_SCW", CEOS_trailer == "-" or Path(CEOS_trailer).exists(), f"CEOS_trailer path does not exist ({CEOS_trailer})")
        if CEOS_data is not None:
            self._validate("par_RSAT_SCW", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_RSAT_SCW_outputs(self, CEOS_leader: str, CEOS_trailer: str, CEOS_data: str, GRD_par: str, GRD: str, sc_dB = None, dt = None):
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_RSAT_SCW(self, CEOS_leader: str, CEOS_trailer: str, CEOS_data: str, GRD_par: str, GRD: str, sc_dB = None, dt = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT_SCW))

        if self.validate_inputs:
            self._validate_par_RSAT_SCW(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RSAT_SCW_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RSAT_SCW", supplied_args)


    def _validate_neutron(self, intensity: str, flag: str, width, n_thres, ymin = None, ymax = None):
        if intensity is not None:
            self._validate("neutron", intensity == "-" or Path(intensity).exists(), f"intensity path does not exist ({intensity})")
        if flag is not None:
            self._validate("neutron", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")

    def _mock_neutron_outputs(self, intensity: str, flag: str, width, n_thres, ymin = None, ymax = None):
        pass

    def neutron(self, intensity: str, flag: str, width, n_thres, ymin = None, ymax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.neutron))

        if self.validate_inputs:
            self._validate_neutron(*supplied_args)

        if self.mock_outputs:
            self._mock_neutron_outputs(*supplied_args)

        return self._gamma_call("ISP", "neutron", supplied_args)


    def _validate_SLC_mosaic_S1_TOPS(self, SLC_tab: str, SLC: str, SLC_par: str, rlks, azlks, bflg = None, SLCR_tab: str = None):
        if SLC_tab is not None:
            self._validate("SLC_mosaic_S1_TOPS", SLC_tab == "-" or Path(SLC_tab).exists(), f"SLC_tab path does not exist ({SLC_tab})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_mosaic_S1_TOPS", bflg == "-" or bflg in valid_values, f"bflg is not a valid value (expects: {valid_values}, got: {bflg})")
        if SLCR_tab is not None:
            self._validate("SLC_mosaic_S1_TOPS", SLCR_tab == "-" or Path(SLCR_tab).exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_SLC_mosaic_S1_TOPS_outputs(self, SLC_tab: str, SLC: str, SLC_par: str, rlks, azlks, bflg = None, SLCR_tab: str = None):
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()

    def SLC_mosaic_S1_TOPS(self, SLC_tab: str, SLC: str, SLC_par: str, rlks, azlks, bflg = None, SLCR_tab: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_mosaic_S1_TOPS))

        if self.validate_inputs:
            self._validate_SLC_mosaic_S1_TOPS(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_mosaic_S1_TOPS_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_mosaic_S1_TOPS", supplied_args)


    def _validate_multi_look(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str, rlks, azlks, loff = None, nlines = None, scale = None, exp = None):
        if SLC is not None:
            self._validate("multi_look", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        if SLC_par is not None:
            self._validate("multi_look", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_multi_look_outputs(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str, rlks, azlks, loff = None, nlines = None, scale = None, exp = None):
        if MLI is not None and MLI != "-":
            Path(MLI).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()

    def multi_look(self, SLC: str, SLC_par: str, MLI: str, MLI_par: str, rlks, azlks, loff = None, nlines = None, scale = None, exp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look))

        if self.validate_inputs:
            self._validate_multi_look(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_look_outputs(*supplied_args)

        return self._gamma_call("ISP", "multi_look", supplied_args)


    def _validate_mosaic_WB(self, data_tab: str, dtype: str, data_out: str, data_par_out: str, sc_flg = None):
        if data_tab is not None:
            self._validate("mosaic_WB", data_tab == "-" or Path(data_tab).exists(), f"data_tab path does not exist ({data_tab})")
        if dtype is not None:
            self._validate("mosaic_WB", dtype == "-" or Path(dtype).exists(), f"dtype path does not exist ({dtype})")
        valid_values = [0, 1] + [None]
        self._validate("mosaic_WB", sc_flg == "-" or sc_flg in valid_values, f"sc_flg is not a valid value (expects: {valid_values}, got: {sc_flg})")

    def _mock_mosaic_WB_outputs(self, data_tab: str, dtype: str, data_out: str, data_par_out: str, sc_flg = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if data_par_out is not None and data_par_out != "-":
            Path(data_par_out).touch()

    def mosaic_WB(self, data_tab: str, dtype: str, data_out: str, data_par_out: str, sc_flg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mosaic_WB))

        if self.validate_inputs:
            self._validate_mosaic_WB(*supplied_args)

        if self.mock_outputs:
            self._mock_mosaic_WB_outputs(*supplied_args)

        return self._gamma_call("ISP", "mosaic_WB", supplied_args)


    def _validate_ScanSAR_burst_to_mosaic(self, DATA_tab: str, mosaic: str, MLI_par: str, mflg = None, dtype: str = None):
        if DATA_tab is not None:
            self._validate("ScanSAR_burst_to_mosaic", DATA_tab == "-" or Path(DATA_tab).exists(), f"DATA_tab path does not exist ({DATA_tab})")
        valid_values = [0, 1, 2] + [None]
        self._validate("ScanSAR_burst_to_mosaic", mflg == "-" or mflg in valid_values, f"mflg is not a valid value (expects: {valid_values}, got: {mflg})")
        if dtype is not None:
            self._validate("ScanSAR_burst_to_mosaic", dtype == "-" or Path(dtype).exists(), f"dtype path does not exist ({dtype})")

    def _mock_ScanSAR_burst_to_mosaic_outputs(self, DATA_tab: str, mosaic: str, MLI_par: str, mflg = None, dtype: str = None):
        if mosaic is not None and mosaic != "-":
            Path(mosaic).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()

    def ScanSAR_burst_to_mosaic(self, DATA_tab: str, mosaic: str, MLI_par: str, mflg = None, dtype: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_to_mosaic))

        if self.validate_inputs:
            self._validate_ScanSAR_burst_to_mosaic(*supplied_args)

        if self.mock_outputs:
            self._mock_ScanSAR_burst_to_mosaic_outputs(*supplied_args)

        return self._gamma_call("ISP", "ScanSAR_burst_to_mosaic", supplied_args)


    def _validate_par_UAVSAR_SLC(self, ann: str, SLC_MLC_in: str, SLC_MLI_par: str, SLC_MLI_out: str = None, image_type = None, image_format = None, DOP: str = None):
        if ann is not None:
            self._validate("par_UAVSAR_SLC", ann == "-" or Path(ann).exists(), f"ann path does not exist ({ann})")
        if SLC_MLC_in is not None:
            self._validate("par_UAVSAR_SLC", SLC_MLC_in == "-" or Path(SLC_MLC_in).exists(), f"SLC_MLC_in path does not exist ({SLC_MLC_in})")
        valid_values = [0, 2] + [None]
        self._validate("par_UAVSAR_SLC", image_format == "-" or image_format in valid_values, f"image_format is not a valid value (expects: {valid_values}, got: {image_format})")
        if DOP is not None:
            self._validate("par_UAVSAR_SLC", DOP == "-" or Path(DOP).exists(), f"DOP path does not exist ({DOP})")

    def _mock_par_UAVSAR_SLC_outputs(self, ann: str, SLC_MLC_in: str, SLC_MLI_par: str, SLC_MLI_out: str = None, image_type = None, image_format = None, DOP: str = None):
        if SLC_MLI_par is not None and SLC_MLI_par != "-":
            Path(SLC_MLI_par).touch()
        if SLC_MLI_out is not None and SLC_MLI_out != "-":
            Path(SLC_MLI_out).touch()

    def par_UAVSAR_SLC(self, ann: str, SLC_MLC_in: str, SLC_MLI_par: str, SLC_MLI_out: str = None, image_type = None, image_format = None, DOP: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_UAVSAR_SLC))

        if self.validate_inputs:
            self._validate_par_UAVSAR_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_UAVSAR_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_UAVSAR_SLC", supplied_args)


    def _validate_ScanSAR_burst_copy(self, SLC, SLC_par: str, TOPS_par: str, SLC_out: str, SLC_out_par: str, burst_num, drflg = None, SLC_par2: str = None, dtype = None):
        if SLC_par is not None:
            self._validate("ScanSAR_burst_copy", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if TOPS_par is not None:
            self._validate("ScanSAR_burst_copy", TOPS_par == "-" or Path(TOPS_par).exists(), f"TOPS_par path does not exist ({TOPS_par})")
        valid_values = [0, 1] + [None]
        self._validate("ScanSAR_burst_copy", drflg == "-" or drflg in valid_values, f"drflg is not a valid value (expects: {valid_values}, got: {drflg})")
        valid_values = [0, 1] + [None]
        self._validate("ScanSAR_burst_copy", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_ScanSAR_burst_copy_outputs(self, SLC, SLC_par: str, TOPS_par: str, SLC_out: str, SLC_out_par: str, burst_num, drflg = None, SLC_par2: str = None, dtype = None):
        if SLC_out is not None and SLC_out != "-":
            Path(SLC_out).touch()
        if SLC_out_par is not None and SLC_out_par != "-":
            Path(SLC_out_par).touch()
        if SLC_par2 is not None and SLC_par2 != "-":
            Path(SLC_par2).touch()

    def ScanSAR_burst_copy(self, SLC, SLC_par: str, TOPS_par: str, SLC_out: str, SLC_out_par: str, burst_num, drflg = None, SLC_par2: str = None, dtype = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_copy))

        if self.validate_inputs:
            self._validate_ScanSAR_burst_copy(*supplied_args)

        if self.mock_outputs:
            self._mock_ScanSAR_burst_copy_outputs(*supplied_args)

        return self._gamma_call("ISP", "ScanSAR_burst_copy", supplied_args)


    def _validate_hgt_map(self, unw: str, SLC_par: str, OFF_par, baseline: str, hgt: str, gr: str, ph_flag = None, loff = None, nlines = None, SLC2R_par = None):
        if unw is not None:
            self._validate("hgt_map", unw == "-" or Path(unw).exists(), f"unw path does not exist ({unw})")
        if SLC_par is not None:
            self._validate("hgt_map", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if baseline is not None:
            self._validate("hgt_map", baseline == "-" or Path(baseline).exists(), f"baseline path does not exist ({baseline})")

    def _mock_hgt_map_outputs(self, unw: str, SLC_par: str, OFF_par, baseline: str, hgt: str, gr: str, ph_flag = None, loff = None, nlines = None, SLC2R_par = None):
        if hgt is not None and hgt != "-":
            Path(hgt).touch()
        if gr is not None and gr != "-":
            Path(gr).touch()

    def hgt_map(self, unw: str, SLC_par: str, OFF_par, baseline: str, hgt: str, gr: str, ph_flag = None, loff = None, nlines = None, SLC2R_par = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.hgt_map))

        if self.validate_inputs:
            self._validate_hgt_map(*supplied_args)

        if self.mock_outputs:
            self._mock_hgt_map_outputs(*supplied_args)

        return self._gamma_call("ISP", "hgt_map", supplied_args)


    def _validate_par_CS_SLC(self, HDF5: str, trunk: str):
        if HDF5 is not None:
            self._validate("par_CS_SLC", HDF5 == "-" or Path(HDF5).exists(), f"HDF5 path does not exist ({HDF5})")

    def _mock_par_CS_SLC_outputs(self, HDF5: str, trunk: str):
        if trunk is not None and trunk != "-":
            Path(trunk).touch()

    def par_CS_SLC(self, HDF5: str, trunk: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_CS_SLC))

        if self.validate_inputs:
            self._validate_par_CS_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_CS_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_CS_SLC", supplied_args)


    def _validate_par_TX_GRD(self, annotation_XML: str, COSAR: str, GRD_par, GRD: str, pol = None):
        if annotation_XML is not None:
            self._validate("par_TX_GRD", annotation_XML == "-" or Path(annotation_XML).exists(), f"annotation_XML path does not exist ({annotation_XML})")
        if COSAR is not None:
            self._validate("par_TX_GRD", COSAR == "-" or Path(COSAR).exists(), f"COSAR path does not exist ({COSAR})")

    def _mock_par_TX_GRD_outputs(self, annotation_XML: str, COSAR: str, GRD_par, GRD: str, pol = None):
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_TX_GRD(self, annotation_XML: str, COSAR: str, GRD_par, GRD: str, pol = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_TX_GRD))

        if self.validate_inputs:
            self._validate_par_TX_GRD(*supplied_args)

        if self.mock_outputs:
            self._mock_par_TX_GRD_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_TX_GRD", supplied_args)


    def _validate_split_WB(self, data_in: str, data_par_in: str, data_tab: str, dtype: str):
        if data_in is not None:
            self._validate("split_WB", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        if data_par_in is not None:
            self._validate("split_WB", data_par_in == "-" or Path(data_par_in).exists(), f"data_par_in path does not exist ({data_par_in})")
        if data_tab is not None:
            self._validate("split_WB", data_tab == "-" or Path(data_tab).exists(), f"data_tab path does not exist ({data_tab})")
        if dtype is not None:
            self._validate("split_WB", dtype == "-" or Path(dtype).exists(), f"dtype path does not exist ({dtype})")

    def _mock_split_WB_outputs(self, data_in: str, data_par_in: str, data_tab: str, dtype: str):
        pass

    def split_WB(self, data_in: str, data_par_in: str, data_tab: str, dtype: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.split_WB))

        if self.validate_inputs:
            self._validate_split_WB(*supplied_args)

        if self.mock_outputs:
            self._mock_split_WB_outputs(*supplied_args)

        return self._gamma_call("ISP", "split_WB", supplied_args)


    def _validate_base_init(self, SLC1_par: str, SLC2_par: str, OFF_par: str, interf: str, base: str, mflag = None, nrfft = None, nazfft = None, r_samp = None, az_line = None):
        if SLC1_par is not None:
            self._validate("base_init", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("base_init", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("base_init", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if interf is not None:
            self._validate("base_init", interf == "-" or Path(interf).exists(), f"interf path does not exist ({interf})")
        valid_values = [0, 1, 2, 3, 4] + [None]
        self._validate("base_init", mflag == "-" or mflag in valid_values, f"mflag is not a valid value (expects: {valid_values}, got: {mflag})")

    def _mock_base_init_outputs(self, SLC1_par: str, SLC2_par: str, OFF_par: str, interf: str, base: str, mflag = None, nrfft = None, nazfft = None, r_samp = None, az_line = None):
        if base is not None and base != "-":
            Path(base).touch()

    def base_init(self, SLC1_par: str, SLC2_par: str, OFF_par: str, interf: str, base: str, mflag = None, nrfft = None, nazfft = None, r_samp = None, az_line = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_init))

        if self.validate_inputs:
            self._validate_base_init(*supplied_args)

        if self.mock_outputs:
            self._mock_base_init_outputs(*supplied_args)

        return self._gamma_call("ISP", "base_init", supplied_args)


    def _validate_par_SIRC(self, CEOS_leader: str, SLC_par: str, UTC_MET = None):
        if CEOS_leader is not None:
            self._validate("par_SIRC", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")

    def _mock_par_SIRC_outputs(self, CEOS_leader: str, SLC_par: str, UTC_MET = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()

    def par_SIRC(self, CEOS_leader: str, SLC_par: str, UTC_MET = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_SIRC))

        if self.validate_inputs:
            self._validate_par_SIRC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_SIRC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_SIRC", supplied_args)


    def _validate_rascc_mask(self, cc, pwr, width, start_cc = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cc_thres = None, pwr_thres = None, cc_min = None, cc_max = None, scale = None, exp = None, LR = None, rasf: str = None):
        pass

    def _mock_rascc_mask_outputs(self, cc, pwr, width, start_cc = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cc_thres = None, pwr_thres = None, cc_min = None, cc_max = None, scale = None, exp = None, LR = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def rascc_mask(self, cc, pwr, width, start_cc = None, start_pwr = None, nlines = None, pixavr = None, pixavaz = None, cc_thres = None, pwr_thres = None, cc_min = None, cc_max = None, scale = None, exp = None, LR = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rascc_mask))

        if self.validate_inputs:
            self._validate_rascc_mask(*supplied_args)

        if self.mock_outputs:
            self._mock_rascc_mask_outputs(*supplied_args)

        return self._gamma_call("ISP", "rascc_mask", supplied_args)


    def _validate_init_offset_orbit(self, SLC1_par: str, SLC2_par: str, OFF_par: str, rpos = None, azpos = None, cflag = None):
        if SLC1_par is not None:
            self._validate("init_offset_orbit", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("init_offset_orbit", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        valid_values = [0, 1] + [None]
        self._validate("init_offset_orbit", cflag == "-" or cflag in valid_values, f"cflag is not a valid value (expects: {valid_values}, got: {cflag})")

    def _mock_init_offset_orbit_outputs(self, SLC1_par: str, SLC2_par: str, OFF_par: str, rpos = None, azpos = None, cflag = None):
        if OFF_par is not None and OFF_par != "-" and not Path(OFF_par).exists():
            Path(OFF_par).touch()

    def init_offset_orbit(self, SLC1_par: str, SLC2_par: str, OFF_par: str, rpos = None, azpos = None, cflag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.init_offset_orbit))

        if self.validate_inputs:
            self._validate_init_offset_orbit(*supplied_args)

        if self.mock_outputs:
            self._mock_init_offset_orbit_outputs(*supplied_args)

        return self._gamma_call("ISP", "init_offset_orbit", supplied_args)


    def _validate_interf_SLC(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, MLI_1: str, MLI_2: str, interf, nrlk = None, nazlk = None, loff = None, nltot = None, rfilt = None, azfilt = None, s_off = None):
        if SLC_1 is not None:
            self._validate("interf_SLC", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("interf_SLC", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("interf_SLC", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("interf_SLC", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("interf_SLC", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("interf_SLC", rfilt == "-" or rfilt in valid_values, f"rfilt is not a valid value (expects: {valid_values}, got: {rfilt})")
        valid_values = [0, 1] + [None]
        self._validate("interf_SLC", azfilt == "-" or azfilt in valid_values, f"azfilt is not a valid value (expects: {valid_values}, got: {azfilt})")

    def _mock_interf_SLC_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, MLI_1: str, MLI_2: str, interf, nrlk = None, nazlk = None, loff = None, nltot = None, rfilt = None, azfilt = None, s_off = None):
        if MLI_1 is not None and MLI_1 != "-":
            Path(MLI_1).touch()
        if MLI_2 is not None and MLI_2 != "-":
            Path(MLI_2).touch()

    def interf_SLC(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, MLI_1: str, MLI_2: str, interf, nrlk = None, nazlk = None, loff = None, nltot = None, rfilt = None, azfilt = None, s_off = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.interf_SLC))

        if self.validate_inputs:
            self._validate_interf_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_interf_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "interf_SLC", supplied_args)


    def _validate_MLI_cat(self, MLI_1: str, MLI_2: str, MLI1_par: str, MLI2_par: str, MLI_3: str, MLI3_par: str, dtype = None, mflg = None, overlap = None, interp_mode = None, degree = None, extrapol = None):
        if MLI_1 is not None:
            self._validate("MLI_cat", MLI_1 == "-" or Path(MLI_1).exists(), f"MLI_1 path does not exist ({MLI_1})")
        if MLI_2 is not None:
            self._validate("MLI_cat", MLI_2 == "-" or Path(MLI_2).exists(), f"MLI_2 path does not exist ({MLI_2})")
        if MLI1_par is not None:
            self._validate("MLI_cat", MLI1_par == "-" or Path(MLI1_par).exists(), f"MLI1_par path does not exist ({MLI1_par})")
        if MLI2_par is not None:
            self._validate("MLI_cat", MLI2_par == "-" or Path(MLI2_par).exists(), f"MLI2_par path does not exist ({MLI2_par})")
        valid_values = [0, 1] + [None]
        self._validate("MLI_cat", mflg == "-" or mflg in valid_values, f"mflg is not a valid value (expects: {valid_values}, got: {mflg})")
        valid_values = [0, 1] + [None]
        self._validate("MLI_cat", extrapol == "-" or extrapol in valid_values, f"extrapol is not a valid value (expects: {valid_values}, got: {extrapol})")

    def _mock_MLI_cat_outputs(self, MLI_1: str, MLI_2: str, MLI1_par: str, MLI2_par: str, MLI_3: str, MLI3_par: str, dtype = None, mflg = None, overlap = None, interp_mode = None, degree = None, extrapol = None):
        if MLI_3 is not None and MLI_3 != "-":
            Path(MLI_3).touch()
        if MLI3_par is not None and MLI3_par != "-":
            Path(MLI3_par).touch()

    def MLI_cat(self, MLI_1: str, MLI_2: str, MLI1_par: str, MLI2_par: str, MLI_3: str, MLI3_par: str, dtype = None, mflg = None, overlap = None, interp_mode = None, degree = None, extrapol = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.MLI_cat))

        if self.validate_inputs:
            self._validate_MLI_cat(*supplied_args)

        if self.mock_outputs:
            self._mock_MLI_cat_outputs(*supplied_args)

        return self._gamma_call("ISP", "MLI_cat", supplied_args)


    def _validate_par_RCM_SLC(self, RCM_dir: str, polarization, radcal, noise, SLC_par: str, SLC: str, noise_pwr: str = None):
        if RCM_dir is not None:
            self._validate("par_RCM_SLC", RCM_dir == "-" or Path(RCM_dir).exists(), f"RCM_dir path does not exist ({RCM_dir})")
        valid_values = [0, 1, 2, 3]
        self._validate("par_RCM_SLC", radcal == "-" or radcal in valid_values, f"radcal is not a valid value (expects: {valid_values}, got: {radcal})")

    def _mock_par_RCM_SLC_outputs(self, RCM_dir: str, polarization, radcal, noise, SLC_par: str, SLC: str, noise_pwr: str = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if noise_pwr is not None and noise_pwr != "-":
            Path(noise_pwr).touch()

    def par_RCM_SLC(self, RCM_dir: str, polarization, radcal, noise, SLC_par: str, SLC: str, noise_pwr: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_SLC))

        if self.validate_inputs:
            self._validate_par_RCM_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RCM_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RCM_SLC", supplied_args)


    def _validate_phase_slope(self, interf: str, slopes: str, width, win_sz = None, thres = None, xmin = None, xmax = None, ymin = None, ymax = None):
        if interf is not None:
            self._validate("phase_slope", interf == "-" or Path(interf).exists(), f"interf path does not exist ({interf})")

    def _mock_phase_slope_outputs(self, interf: str, slopes: str, width, win_sz = None, thres = None, xmin = None, xmax = None, ymin = None, ymax = None):
        if slopes is not None and slopes != "-":
            Path(slopes).touch()

    def phase_slope(self, interf: str, slopes: str, width, win_sz = None, thres = None, xmin = None, xmax = None, ymin = None, ymax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.phase_slope))

        if self.validate_inputs:
            self._validate_phase_slope(*supplied_args)

        if self.mock_outputs:
            self._mock_phase_slope_outputs(*supplied_args)

        return self._gamma_call("ISP", "phase_slope", supplied_args)


    def _validate_par_TX_ScanSAR(self, annot_XML: str, swath, SLC_par: str, SLC: str, TOPS_par: str, bwflg = None):
        if annot_XML is not None:
            self._validate("par_TX_ScanSAR", annot_XML == "-" or Path(annot_XML).exists(), f"annot_XML path does not exist ({annot_XML})")
        valid_values = [0, 1] + [None]
        self._validate("par_TX_ScanSAR", bwflg == "-" or bwflg in valid_values, f"bwflg is not a valid value (expects: {valid_values}, got: {bwflg})")

    def _mock_par_TX_ScanSAR_outputs(self, annot_XML: str, swath, SLC_par: str, SLC: str, TOPS_par: str, bwflg = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if TOPS_par is not None and TOPS_par != "-":
            Path(TOPS_par).touch()

    def par_TX_ScanSAR(self, annot_XML: str, swath, SLC_par: str, SLC: str, TOPS_par: str, bwflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_TX_ScanSAR))

        if self.validate_inputs:
            self._validate_par_TX_ScanSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_par_TX_ScanSAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_TX_ScanSAR", supplied_args)


    def _validate_ave_image(self, im_list, width, ave: str, start = None, nlines = None, pixav_x = None, pixav_y = None, zflag = None, nmin = None):
        valid_values = [0, 1] + [None]
        self._validate("ave_image", zflag == "-" or zflag in valid_values, f"zflag is not a valid value (expects: {valid_values}, got: {zflag})")

    def _mock_ave_image_outputs(self, im_list, width, ave: str, start = None, nlines = None, pixav_x = None, pixav_y = None, zflag = None, nmin = None):
        if ave is not None and ave != "-":
            Path(ave).touch()

    def ave_image(self, im_list, width, ave: str, start = None, nlines = None, pixav_x = None, pixav_y = None, zflag = None, nmin = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ave_image))

        if self.validate_inputs:
            self._validate_ave_image(*supplied_args)

        if self.mock_outputs:
            self._mock_ave_image_outputs(*supplied_args)

        return self._gamma_call("ISP", "ave_image", supplied_args)


    def _validate_multi_cpx(self, data_in: str, OFF_par_in: str, data_out: str, OFF_par_out: str, rlks = None, azlks = None, loff = None, nlines = None, roff = None, nsamp = None):
        if data_in is not None:
            self._validate("multi_cpx", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        if OFF_par_in is not None:
            self._validate("multi_cpx", OFF_par_in == "-" or Path(OFF_par_in).exists(), f"OFF_par_in path does not exist ({OFF_par_in})")

    def _mock_multi_cpx_outputs(self, data_in: str, OFF_par_in: str, data_out: str, OFF_par_out: str, rlks = None, azlks = None, loff = None, nlines = None, roff = None, nsamp = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if OFF_par_out is not None and OFF_par_out != "-" and not Path(OFF_par_out).exists():
            Path(OFF_par_out).touch()

    def multi_cpx(self, data_in: str, OFF_par_in: str, data_out: str, OFF_par_out: str, rlks = None, azlks = None, loff = None, nlines = None, roff = None, nsamp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_cpx))

        if self.validate_inputs:
            self._validate_multi_cpx(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_cpx_outputs(*supplied_args)

        return self._gamma_call("ISP", "multi_cpx", supplied_args)


    def _validate_ASAR_LO_phase_drift(self, SLC1_par: str, SLC2_par: str, OFF_par: str, ph_drift: str):
        if SLC1_par is not None:
            self._validate("ASAR_LO_phase_drift", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("ASAR_LO_phase_drift", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("ASAR_LO_phase_drift", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_ASAR_LO_phase_drift_outputs(self, SLC1_par: str, SLC2_par: str, OFF_par: str, ph_drift: str):
        if ph_drift is not None and ph_drift != "-":
            Path(ph_drift).touch()

    def ASAR_LO_phase_drift(self, SLC1_par: str, SLC2_par: str, OFF_par: str, ph_drift: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ASAR_LO_phase_drift))

        if self.validate_inputs:
            self._validate_ASAR_LO_phase_drift(*supplied_args)

        if self.mock_outputs:
            self._mock_ASAR_LO_phase_drift_outputs(*supplied_args)

        return self._gamma_call("ISP", "ASAR_LO_phase_drift", supplied_args)


    def _validate_radcal_pwr_stat(self, SLC_tab: str, SLC_tab_cal: str, plist: str, MSR_cal, PWR_cal, roff = None, loff = None, nr = None, nl = None, plist_out = None):
        if SLC_tab is not None:
            self._validate("radcal_pwr_stat", SLC_tab == "-" or Path(SLC_tab).exists(), f"SLC_tab path does not exist ({SLC_tab})")
        if SLC_tab_cal is not None:
            self._validate("radcal_pwr_stat", SLC_tab_cal == "-" or Path(SLC_tab_cal).exists(), f"SLC_tab_cal path does not exist ({SLC_tab_cal})")
        if plist is not None:
            self._validate("radcal_pwr_stat", plist == "-" or Path(plist).exists(), f"plist path does not exist ({plist})")

    def _mock_radcal_pwr_stat_outputs(self, SLC_tab: str, SLC_tab_cal: str, plist: str, MSR_cal, PWR_cal, roff = None, loff = None, nr = None, nl = None, plist_out = None):
        pass

    def radcal_pwr_stat(self, SLC_tab: str, SLC_tab_cal: str, plist: str, MSR_cal, PWR_cal, roff = None, loff = None, nr = None, nl = None, plist_out = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.radcal_pwr_stat))

        if self.validate_inputs:
            self._validate_radcal_pwr_stat(*supplied_args)

        if self.mock_outputs:
            self._mock_radcal_pwr_stat_outputs(*supplied_args)

        return self._gamma_call("ISP", "radcal_pwr_stat", supplied_args)


    def _validate_par_ICEYE_SLC(self, HDF5: str, SLC_par: str, slc: str = None, dtype = None):
        if HDF5 is not None:
            self._validate("par_ICEYE_SLC", HDF5 == "-" or Path(HDF5).exists(), f"HDF5 path does not exist ({HDF5})")
        valid_values = [0, 1] + [None]
        self._validate("par_ICEYE_SLC", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_par_ICEYE_SLC_outputs(self, HDF5: str, SLC_par: str, slc: str = None, dtype = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if slc is not None and slc != "-":
            Path(slc).touch()

    def par_ICEYE_SLC(self, HDF5: str, SLC_par: str, slc: str = None, dtype = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ICEYE_SLC))

        if self.validate_inputs:
            self._validate_par_ICEYE_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ICEYE_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ICEYE_SLC", supplied_args)


    def _validate_offset_SLC_tracking(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, snr: str, rsw = None, azsw = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, ISZ = None, pflag = None):
        if SLC_1 is not None:
            self._validate("offset_SLC_tracking", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("offset_SLC_tracking", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("offset_SLC_tracking", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("offset_SLC_tracking", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("offset_SLC_tracking", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("offset_SLC_tracking", pflag == "-" or pflag in valid_values, f"pflag is not a valid value (expects: {valid_values}, got: {pflag})")

    def _mock_offset_SLC_tracking_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, snr: str, rsw = None, azsw = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, ISZ = None, pflag = None):
        if offs is not None and offs != "-":
            Path(offs).touch()
        if snr is not None and snr != "-":
            Path(snr).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()

    def offset_SLC_tracking(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, snr: str, rsw = None, azsw = None, offsets: str = None, n_ovr = None, thres = None, rstep = None, azstep = None, rstart = None, rstop = None, azstart = None, azstop = None, ISZ = None, pflag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_SLC_tracking))

        if self.validate_inputs:
            self._validate_offset_SLC_tracking(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_SLC_tracking_outputs(*supplied_args)

        return self._gamma_call("ISP", "offset_SLC_tracking", supplied_args)


    def _validate_tree_cc(self, flag: str, width, mbl = None, xmin = None, xmax = None):
        if flag is not None:
            self._validate("tree_cc", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")

    def _mock_tree_cc_outputs(self, flag: str, width, mbl = None, xmin = None, xmax = None):
        pass

    def tree_cc(self, flag: str, width, mbl = None, xmin = None, xmax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.tree_cc))

        if self.validate_inputs:
            self._validate_tree_cc(*supplied_args)

        if self.mock_outputs:
            self._mock_tree_cc_outputs(*supplied_args)

        return self._gamma_call("ISP", "tree_cc", supplied_args)


    def _validate_MLI_copy(self, MLI_in, MLI_in_par: str, MLI_out: str, MLI_out_par: str, roff = None, nr = None, loff = None, nl = None):
        if MLI_in_par is not None:
            self._validate("MLI_copy", MLI_in_par == "-" or Path(MLI_in_par).exists(), f"MLI_in_par path does not exist ({MLI_in_par})")

    def _mock_MLI_copy_outputs(self, MLI_in, MLI_in_par: str, MLI_out: str, MLI_out_par: str, roff = None, nr = None, loff = None, nl = None):
        if MLI_out is not None and MLI_out != "-":
            Path(MLI_out).touch()
        if MLI_out_par is not None and MLI_out_par != "-":
            Path(MLI_out_par).touch()

    def MLI_copy(self, MLI_in, MLI_in_par: str, MLI_out: str, MLI_out_par: str, roff = None, nr = None, loff = None, nl = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.MLI_copy))

        if self.validate_inputs:
            self._validate_MLI_copy(*supplied_args)

        if self.mock_outputs:
            self._mock_MLI_copy_outputs(*supplied_args)

        return self._gamma_call("ISP", "MLI_copy", supplied_args)


    def _validate_ORRM_vec(self, SLC_par: str, ORRM: str, nstate = None):
        if ORRM is not None:
            self._validate("ORRM_vec", ORRM == "-" or Path(ORRM).exists(), f"ORRM path does not exist ({ORRM})")

    def _mock_ORRM_vec_outputs(self, SLC_par: str, ORRM: str, nstate = None):
        if SLC_par is not None and SLC_par != "-" and not Path(SLC_par).exists():
            Path(SLC_par).touch()

    def ORRM_vec(self, SLC_par: str, ORRM: str, nstate = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORRM_vec))

        if self.validate_inputs:
            self._validate_ORRM_vec(*supplied_args)

        if self.mock_outputs:
            self._mock_ORRM_vec_outputs(*supplied_args)

        return self._gamma_call("ISP", "ORRM_vec", supplied_args)


    def _validate_SLC_ovr(self, SLC: str, SLC_par: str, SLC_ovr: str, SLC_ovr_par: str, r_ovr = None, az_ovr = None, mode = None, order = None):
        if SLC is not None:
            self._validate("SLC_ovr", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        if SLC_par is not None:
            self._validate("SLC_ovr", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_ovr", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_SLC_ovr_outputs(self, SLC: str, SLC_par: str, SLC_ovr: str, SLC_ovr_par: str, r_ovr = None, az_ovr = None, mode = None, order = None):
        if SLC_ovr is not None and SLC_ovr != "-":
            Path(SLC_ovr).touch()
        if SLC_ovr_par is not None and SLC_ovr_par != "-":
            Path(SLC_ovr_par).touch()

    def SLC_ovr(self, SLC: str, SLC_par: str, SLC_ovr: str, SLC_ovr_par: str, r_ovr = None, az_ovr = None, mode = None, order = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_ovr))

        if self.validate_inputs:
            self._validate_SLC_ovr(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_ovr_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_ovr", supplied_args)


    def _validate_tree_gzw(self, flag: str, width, mbl = None, xmin = None, xmax = None):
        if flag is not None:
            self._validate("tree_gzw", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")

    def _mock_tree_gzw_outputs(self, flag: str, width, mbl = None, xmin = None, xmax = None):
        pass

    def tree_gzw(self, flag: str, width, mbl = None, xmin = None, xmax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.tree_gzw))

        if self.validate_inputs:
            self._validate_tree_gzw(*supplied_args)

        if self.mock_outputs:
            self._mock_tree_gzw_outputs(*supplied_args)

        return self._gamma_call("ISP", "tree_gzw", supplied_args)


    def _validate_mcf(self, interf: str, wgt, mask: str, unw: str, width, tri_mode = None, roff = None, loff = None, nr = None, nlines = None, npat_r = None, npat_az = None, ovrlap = None, r_init = None, az_init = None, init_flag = None):
        if interf is not None:
            self._validate("mcf", interf == "-" or Path(interf).exists(), f"interf path does not exist ({interf})")
        if mask is not None:
            self._validate("mcf", mask == "-" or Path(mask).exists(), f"mask path does not exist ({mask})")
        valid_values = [0, 1] + [None]
        self._validate("mcf", tri_mode == "-" or tri_mode in valid_values, f"tri_mode is not a valid value (expects: {valid_values}, got: {tri_mode})")
        valid_values = [0, 1] + [None]
        self._validate("mcf", init_flag == "-" or init_flag in valid_values, f"init_flag is not a valid value (expects: {valid_values}, got: {init_flag})")

    def _mock_mcf_outputs(self, interf: str, wgt, mask: str, unw: str, width, tri_mode = None, roff = None, loff = None, nr = None, nlines = None, npat_r = None, npat_az = None, ovrlap = None, r_init = None, az_init = None, init_flag = None):
        if unw is not None and unw != "-":
            Path(unw).touch()

    def mcf(self, interf: str, wgt, mask: str, unw: str, width, tri_mode = None, roff = None, loff = None, nr = None, nlines = None, npat_r = None, npat_az = None, ovrlap = None, r_init = None, az_init = None, init_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mcf))

        if self.validate_inputs:
            self._validate_mcf(*supplied_args)

        if self.mock_outputs:
            self._mock_mcf_outputs(*supplied_args)

        return self._gamma_call("ISP", "mcf", supplied_args)


    def _validate_par_ESA_ERS(self, CEOS_SAR_leader: str, SLC_par: str, CEOS_DAT: str = None, SLC: str = None):
        if CEOS_SAR_leader is not None:
            self._validate("par_ESA_ERS", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        if CEOS_DAT is not None:
            self._validate("par_ESA_ERS", CEOS_DAT == "-" or Path(CEOS_DAT).exists(), f"CEOS_DAT path does not exist ({CEOS_DAT})")

    def _mock_par_ESA_ERS_outputs(self, CEOS_SAR_leader: str, SLC_par: str, CEOS_DAT: str = None, SLC: str = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_ESA_ERS(self, CEOS_SAR_leader: str, SLC_par: str, CEOS_DAT: str = None, SLC: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ESA_ERS))

        if self.validate_inputs:
            self._validate_par_ESA_ERS(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ESA_ERS_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ESA_ERS", supplied_args)


    def _validate_SLC_interp(self, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, SLC_2R: str, SLC2R_par: str, loff = None, nlines = None, mode = None, order = None):
        if SLC_2 is not None:
            self._validate("SLC_interp", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("SLC_interp", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("SLC_interp", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("SLC_interp", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_interp", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_SLC_interp_outputs(self, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, SLC_2R: str, SLC2R_par: str, loff = None, nlines = None, mode = None, order = None):
        if SLC_2R is not None and SLC_2R != "-":
            Path(SLC_2R).touch()
        if SLC2R_par is not None and SLC2R_par != "-":
            Path(SLC2R_par).touch()

    def SLC_interp(self, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, SLC_2R: str, SLC2R_par: str, loff = None, nlines = None, mode = None, order = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp))

        if self.validate_inputs:
            self._validate_SLC_interp(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_interp_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_interp", supplied_args)


    def _validate_par_S1_SLC(self, GeoTIFF: str, annotation_XML: str, calibration_XML: str, noise_XML: str, SLC_par: str, SLC: str, TOPS_par: str = None, dtype = None, sc_dB = None, noise_pwr = None):
        if GeoTIFF is not None:
            self._validate("par_S1_SLC", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        if annotation_XML is not None:
            self._validate("par_S1_SLC", annotation_XML == "-" or Path(annotation_XML).exists(), f"annotation_XML path does not exist ({annotation_XML})")
        if calibration_XML is not None:
            self._validate("par_S1_SLC", calibration_XML == "-" or Path(calibration_XML).exists(), f"calibration_XML path does not exist ({calibration_XML})")
        if noise_XML is not None:
            self._validate("par_S1_SLC", noise_XML == "-" or Path(noise_XML).exists(), f"noise_XML path does not exist ({noise_XML})")
        valid_values = [0, 1] + [None]
        self._validate("par_S1_SLC", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_par_S1_SLC_outputs(self, GeoTIFF: str, annotation_XML: str, calibration_XML: str, noise_XML: str, SLC_par: str, SLC: str, TOPS_par: str = None, dtype = None, sc_dB = None, noise_pwr = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()
        if TOPS_par is not None and TOPS_par != "-":
            Path(TOPS_par).touch()

    def par_S1_SLC(self, GeoTIFF: str, annotation_XML: str, calibration_XML: str, noise_XML: str, SLC_par: str, SLC: str, TOPS_par: str = None, dtype = None, sc_dB = None, noise_pwr = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_S1_SLC))

        if self.validate_inputs:
            self._validate_par_S1_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_S1_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_S1_SLC", supplied_args)


    def _validate_par_ASAR(self, ASAR_ERS_file: str, output_name: str, K_dB = None, to = None):
        if ASAR_ERS_file is not None:
            self._validate("par_ASAR", ASAR_ERS_file == "-" or Path(ASAR_ERS_file).exists(), f"ASAR_ERS_file path does not exist ({ASAR_ERS_file})")

    def _mock_par_ASAR_outputs(self, ASAR_ERS_file: str, output_name: str, K_dB = None, to = None):
        if output_name is not None and output_name != "-":
            Path(output_name).touch()

    def par_ASAR(self, ASAR_ERS_file: str, output_name: str, K_dB = None, to = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASAR))

        if self.validate_inputs:
            self._validate_par_ASAR(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ASAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ASAR", supplied_args)


    def _validate_par_ASF_96(self, CEOS_SAR_leader: str, SLC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("par_ASF_96", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_par_ASF_96_outputs(self, CEOS_SAR_leader: str, SLC_par: str):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()

    def par_ASF_96(self, CEOS_SAR_leader: str, SLC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_96))

        if self.validate_inputs:
            self._validate_par_ASF_96(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ASF_96_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ASF_96", supplied_args)


    def _validate_ScanSAR_mosaic_to_burst(self, DATA: str, MLI_par, DATA_tab):
        if DATA is not None:
            self._validate("ScanSAR_mosaic_to_burst", DATA == "-" or Path(DATA).exists(), f"DATA path does not exist ({DATA})")

    def _mock_ScanSAR_mosaic_to_burst_outputs(self, DATA: str, MLI_par, DATA_tab):
        pass

    def ScanSAR_mosaic_to_burst(self, DATA: str, MLI_par, DATA_tab):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_mosaic_to_burst))

        if self.validate_inputs:
            self._validate_ScanSAR_mosaic_to_burst(*supplied_args)

        if self.mock_outputs:
            self._mock_ScanSAR_mosaic_to_burst_outputs(*supplied_args)

        return self._gamma_call("ISP", "ScanSAR_mosaic_to_burst", supplied_args)


    def _validate_base_ls(self, SLC_par: str, OFF_par: str, gcp_ph: str, baseline: str, ph_flag = None, bc_flag = None, bn_flag = None, bcdot_flag = None, bndot_flag = None, bperp_min = None, SLC2R_par: str = None):
        if SLC_par is not None:
            self._validate("base_ls", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("base_ls", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        if gcp_ph is not None:
            self._validate("base_ls", gcp_ph == "-" or Path(gcp_ph).exists(), f"gcp_ph path does not exist ({gcp_ph})")
        if baseline is not None:
            self._validate("base_ls", baseline == "-" or Path(baseline).exists(), f"baseline path does not exist ({baseline})")
        if SLC2R_par is not None:
            self._validate("base_ls", SLC2R_par == "-" or Path(SLC2R_par).exists(), f"SLC2R_par path does not exist ({SLC2R_par})")

    def _mock_base_ls_outputs(self, SLC_par: str, OFF_par: str, gcp_ph: str, baseline: str, ph_flag = None, bc_flag = None, bn_flag = None, bcdot_flag = None, bndot_flag = None, bperp_min = None, SLC2R_par: str = None):
        pass

    def base_ls(self, SLC_par: str, OFF_par: str, gcp_ph: str, baseline: str, ph_flag = None, bc_flag = None, bn_flag = None, bcdot_flag = None, bndot_flag = None, bperp_min = None, SLC2R_par: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_ls))

        if self.validate_inputs:
            self._validate_base_ls(*supplied_args)

        if self.mock_outputs:
            self._mock_base_ls_outputs(*supplied_args)

        return self._gamma_call("ISP", "base_ls", supplied_args)


    def _validate_az_spec_SLC(self, SLC: str, SLC_par: str, spectrum: str, roff = None, namb = None, pltflg = None):
        if SLC is not None:
            self._validate("az_spec_SLC", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        if SLC_par is not None:
            self._validate("az_spec_SLC", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        valid_values = [0, 1] + [None]
        self._validate("az_spec_SLC", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_az_spec_SLC_outputs(self, SLC: str, SLC_par: str, spectrum: str, roff = None, namb = None, pltflg = None):
        if spectrum is not None and spectrum != "-":
            Path(spectrum).touch()

    def az_spec_SLC(self, SLC: str, SLC_par: str, spectrum: str, roff = None, namb = None, pltflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.az_spec_SLC))

        if self.validate_inputs:
            self._validate_az_spec_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_az_spec_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "az_spec_SLC", supplied_args)


    def _validate_SLC_copy(self, SLC_in: str, SLC_par_in: str, SLC_out: str, SLC_par_out: str, fcase = None, sc = None, roff = None, nr = None, loff = None, nl = None, swap = None, header_lines = None):
        if SLC_in is not None:
            self._validate("SLC_copy", SLC_in == "-" or Path(SLC_in).exists(), f"SLC_in path does not exist ({SLC_in})")
        if SLC_par_in is not None:
            self._validate("SLC_copy", SLC_par_in == "-" or Path(SLC_par_in).exists(), f"SLC_par_in path does not exist ({SLC_par_in})")
        valid_values = [1, 2, 3, 4] + [None]
        self._validate("SLC_copy", fcase == "-" or fcase in valid_values, f"fcase is not a valid value (expects: {valid_values}, got: {fcase})")
        valid_values = [0, 1, 2] + [None]
        self._validate("SLC_copy", swap == "-" or swap in valid_values, f"swap is not a valid value (expects: {valid_values}, got: {swap})")

    def _mock_SLC_copy_outputs(self, SLC_in: str, SLC_par_in: str, SLC_out: str, SLC_par_out: str, fcase = None, sc = None, roff = None, nr = None, loff = None, nl = None, swap = None, header_lines = None):
        if SLC_out is not None and SLC_out != "-":
            Path(SLC_out).touch()
        if SLC_par_out is not None and SLC_par_out != "-":
            Path(SLC_par_out).touch()

    def SLC_copy(self, SLC_in: str, SLC_par_in: str, SLC_out: str, SLC_par_out: str, fcase = None, sc = None, roff = None, nr = None, loff = None, nl = None, swap = None, header_lines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_copy))

        if self.validate_inputs:
            self._validate_SLC_copy(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_copy_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_copy", supplied_args)


    def _validate_az_integrate(self, data, width: str, azi: str, cflg, scale = None, lz = None):
        if width is not None:
            self._validate("az_integrate", width == "-" or Path(width).exists(), f"width path does not exist ({width})")
        valid_values = [0, 1]
        self._validate("az_integrate", cflg == "-" or cflg in valid_values, f"cflg is not a valid value (expects: {valid_values}, got: {cflg})")

    def _mock_az_integrate_outputs(self, data, width: str, azi: str, cflg, scale = None, lz = None):
        if azi is not None and azi != "-":
            Path(azi).touch()

    def az_integrate(self, data, width: str, azi: str, cflg, scale = None, lz = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.az_integrate))

        if self.validate_inputs:
            self._validate_az_integrate(*supplied_args)

        if self.mock_outputs:
            self._mock_az_integrate_outputs(*supplied_args)

        return self._gamma_call("ISP", "az_integrate", supplied_args)


    def _validate_SLC_cat(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, SLC_3: str, SLC3_par: str, dopflg = None, iflg = None, phflg = None, gainflg = None):
        if SLC_1 is not None:
            self._validate("SLC_cat", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("SLC_cat", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("SLC_cat", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("SLC_cat", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("SLC_cat", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_cat", dopflg == "-" or dopflg in valid_values, f"dopflg is not a valid value (expects: {valid_values}, got: {dopflg})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_cat", iflg == "-" or iflg in valid_values, f"iflg is not a valid value (expects: {valid_values}, got: {iflg})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_cat", phflg == "-" or phflg in valid_values, f"phflg is not a valid value (expects: {valid_values}, got: {phflg})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_cat", gainflg == "-" or gainflg in valid_values, f"gainflg is not a valid value (expects: {valid_values}, got: {gainflg})")

    def _mock_SLC_cat_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, SLC_3: str, SLC3_par: str, dopflg = None, iflg = None, phflg = None, gainflg = None):
        if SLC_3 is not None and SLC_3 != "-":
            Path(SLC_3).touch()
        if SLC3_par is not None and SLC3_par != "-":
            Path(SLC3_par).touch()

    def SLC_cat(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, SLC_3: str, SLC3_par: str, dopflg = None, iflg = None, phflg = None, gainflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_cat))

        if self.validate_inputs:
            self._validate_SLC_cat(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_cat_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_cat", supplied_args)


    def _validate_par_NovaSAR_SLC(self, GeoTIFF: str, XML: str, polarization, SLC_par: str, SLC: str = None, dtype = None):
        if GeoTIFF is not None:
            self._validate("par_NovaSAR_SLC", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        if XML is not None:
            self._validate("par_NovaSAR_SLC", XML == "-" or Path(XML).exists(), f"XML path does not exist ({XML})")
        valid_values = [0, 1] + [None]
        self._validate("par_NovaSAR_SLC", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")

    def _mock_par_NovaSAR_SLC_outputs(self, GeoTIFF: str, XML: str, polarization, SLC_par: str, SLC: str = None, dtype = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_NovaSAR_SLC(self, GeoTIFF: str, XML: str, polarization, SLC_par: str, SLC: str = None, dtype = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_NovaSAR_SLC))

        if self.validate_inputs:
            self._validate_par_NovaSAR_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_NovaSAR_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_NovaSAR_SLC", supplied_args)


    def _validate_SLC_corners(self, SLC_par: str, terra_alt = None, kml: str = None):
        if SLC_par is not None:
            self._validate("SLC_corners", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_SLC_corners_outputs(self, SLC_par: str, terra_alt = None, kml: str = None):
        if kml is not None and kml != "-":
            Path(kml).touch()

    def SLC_corners(self, SLC_par: str, terra_alt = None, kml: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_corners))

        if self.validate_inputs:
            self._validate_SLC_corners(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_corners_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_corners", supplied_args)


    def _validate_SLC_deramp(self, SLC_1: str, SLC_par1: str, SLC_2: str, SLC_par2: str, mode, dop_ph: str = None):
        if SLC_1 is not None:
            self._validate("SLC_deramp", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_par1 is not None:
            self._validate("SLC_deramp", SLC_par1 == "-" or Path(SLC_par1).exists(), f"SLC_par1 path does not exist ({SLC_par1})")
        valid_values = [0, 1]
        self._validate("SLC_deramp", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_SLC_deramp_outputs(self, SLC_1: str, SLC_par1: str, SLC_2: str, SLC_par2: str, mode, dop_ph: str = None):
        if SLC_2 is not None and SLC_2 != "-":
            Path(SLC_2).touch()
        if SLC_par2 is not None and SLC_par2 != "-":
            Path(SLC_par2).touch()
        if dop_ph is not None and dop_ph != "-":
            Path(dop_ph).touch()

    def SLC_deramp(self, SLC_1: str, SLC_par1: str, SLC_2: str, SLC_par2: str, mode, dop_ph: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_deramp))

        if self.validate_inputs:
            self._validate_SLC_deramp(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_deramp_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_deramp", supplied_args)


    def _validate_residue(self, int: str, flag: str, width, xmin = None, xmax = None, ymin = None, ymax = None):
        if int is not None:
            self._validate("residue", int == "-" or Path(int).exists(), f"int path does not exist ({int})")
        if flag is not None:
            self._validate("residue", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")

    def _mock_residue_outputs(self, int: str, flag: str, width, xmin = None, xmax = None, ymin = None, ymax = None):
        pass

    def residue(self, int: str, flag: str, width, xmin = None, xmax = None, ymin = None, ymax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.residue))

        if self.validate_inputs:
            self._validate_residue(*supplied_args)

        if self.mock_outputs:
            self._mock_residue_outputs(*supplied_args)

        return self._gamma_call("ISP", "residue", supplied_args)


    def _validate_par_PRI(self, CEOS_SAR_leader: str, PRI_par: str, CEOS_DAT: str, PRI: str):
        if CEOS_SAR_leader is not None:
            self._validate("par_PRI", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        if CEOS_DAT is not None:
            self._validate("par_PRI", CEOS_DAT == "-" or Path(CEOS_DAT).exists(), f"CEOS_DAT path does not exist ({CEOS_DAT})")

    def _mock_par_PRI_outputs(self, CEOS_SAR_leader: str, PRI_par: str, CEOS_DAT: str, PRI: str):
        if PRI_par is not None and PRI_par != "-":
            Path(PRI_par).touch()
        if PRI is not None and PRI != "-":
            Path(PRI).touch()

    def par_PRI(self, CEOS_SAR_leader: str, PRI_par: str, CEOS_DAT: str, PRI: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_PRI))

        if self.validate_inputs:
            self._validate_par_PRI(*supplied_args)

        if self.mock_outputs:
            self._mock_par_PRI_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_PRI", supplied_args)


    def _validate_create_offset(self, SLC1_par: str, SLC2_par: str, OFF_par: str, algorithm = None, rlks = None, azlks = None, iflg = None):
        if SLC1_par is not None:
            self._validate("create_offset", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("create_offset", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        valid_values = [1, 2] + [None]
        self._validate("create_offset", algorithm == "-" or algorithm in valid_values, f"algorithm is not a valid value (expects: {valid_values}, got: {algorithm})")
        valid_values = [0, 1] + [None]
        self._validate("create_offset", iflg == "-" or iflg in valid_values, f"iflg is not a valid value (expects: {valid_values}, got: {iflg})")

    def _mock_create_offset_outputs(self, SLC1_par: str, SLC2_par: str, OFF_par: str, algorithm = None, rlks = None, azlks = None, iflg = None):
        if OFF_par is not None and OFF_par != "-" and not Path(OFF_par).exists():
            Path(OFF_par).touch()

    def create_offset(self, SLC1_par: str, SLC2_par: str, OFF_par: str, algorithm = None, rlks = None, azlks = None, iflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_offset))

        if self.validate_inputs:
            self._validate_create_offset(*supplied_args)

        if self.mock_outputs:
            self._mock_create_offset_outputs(*supplied_args)

        return self._gamma_call("ISP", "create_offset", supplied_args)


    def _validate_multi_look_MLI(self, MLI_in, MLI_in_par: str, MLI_out: str, MLI_out_par: str, rlks, azlks, loff = None, nlines = None, scale = None, e_flag = None):
        if MLI_in_par is not None:
            self._validate("multi_look_MLI", MLI_in_par == "-" or Path(MLI_in_par).exists(), f"MLI_in_par path does not exist ({MLI_in_par})")
        valid_values = [0, 1] + [None]
        self._validate("multi_look_MLI", e_flag == "-" or e_flag in valid_values, f"e_flag is not a valid value (expects: {valid_values}, got: {e_flag})")

    def _mock_multi_look_MLI_outputs(self, MLI_in, MLI_in_par: str, MLI_out: str, MLI_out_par: str, rlks, azlks, loff = None, nlines = None, scale = None, e_flag = None):
        if MLI_out is not None and MLI_out != "-":
            Path(MLI_out).touch()
        if MLI_out_par is not None and MLI_out_par != "-":
            Path(MLI_out_par).touch()

    def multi_look_MLI(self, MLI_in, MLI_in_par: str, MLI_out: str, MLI_out_par: str, rlks, azlks, loff = None, nlines = None, scale = None, e_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look_MLI))

        if self.validate_inputs:
            self._validate_multi_look_MLI(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_look_MLI_outputs(*supplied_args)

        return self._gamma_call("ISP", "multi_look_MLI", supplied_args)


    def _validate_multi_real(self, data_in, OFF_par_in: str, data_out: str, OFF_par_out: str, rlks = None, azlks = None, loff = None, nlines = None, roff = None, nsamp = None):
        if OFF_par_in is not None:
            self._validate("multi_real", OFF_par_in == "-" or Path(OFF_par_in).exists(), f"OFF_par_in path does not exist ({OFF_par_in})")

    def _mock_multi_real_outputs(self, data_in, OFF_par_in: str, data_out: str, OFF_par_out: str, rlks = None, azlks = None, loff = None, nlines = None, roff = None, nsamp = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if OFF_par_out is not None and OFF_par_out != "-" and not Path(OFF_par_out).exists():
            Path(OFF_par_out).touch()

    def multi_real(self, data_in, OFF_par_in: str, data_out: str, OFF_par_out: str, rlks = None, azlks = None, loff = None, nlines = None, roff = None, nsamp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_real))

        if self.validate_inputs:
            self._validate_multi_real(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_real_outputs(*supplied_args)

        return self._gamma_call("ISP", "multi_real", supplied_args)


    def _validate_SLC_intf2(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, MLI_1: str, MLI_2R: str, MLI1_par: str, MLI2R_par: str, interf: str, cc: str, r_dec, az_dec, rwin = None, azwin = None, wflg = None, lanczos = None, beta = None):
        if SLC_1 is not None:
            self._validate("SLC_intf2", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2R is not None:
            self._validate("SLC_intf2", SLC_2R == "-" or Path(SLC_2R).exists(), f"SLC_2R path does not exist ({SLC_2R})")
        if SLC1_par is not None:
            self._validate("SLC_intf2", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2R_par is not None:
            self._validate("SLC_intf2", SLC2R_par == "-" or Path(SLC2R_par).exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        valid_values = [0, 1] + [None]
        self._validate("SLC_intf2", wflg == "-" or wflg in valid_values, f"wflg is not a valid value (expects: {valid_values}, got: {wflg})")

    def _mock_SLC_intf2_outputs(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, MLI_1: str, MLI_2R: str, MLI1_par: str, MLI2R_par: str, interf: str, cc: str, r_dec, az_dec, rwin = None, azwin = None, wflg = None, lanczos = None, beta = None):
        if MLI_1 is not None and MLI_1 != "-":
            Path(MLI_1).touch()
        if MLI_2R is not None and MLI_2R != "-":
            Path(MLI_2R).touch()
        if MLI1_par is not None and MLI1_par != "-":
            Path(MLI1_par).touch()
        if MLI2R_par is not None and MLI2R_par != "-":
            Path(MLI2R_par).touch()
        if interf is not None and interf != "-":
            Path(interf).touch()
        if cc is not None and cc != "-":
            Path(cc).touch()

    def SLC_intf2(self, SLC_1: str, SLC_2R: str, SLC1_par: str, SLC2R_par: str, MLI_1: str, MLI_2R: str, MLI1_par: str, MLI2R_par: str, interf: str, cc: str, r_dec, az_dec, rwin = None, azwin = None, wflg = None, lanczos = None, beta = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_intf2))

        if self.validate_inputs:
            self._validate_SLC_intf2(*supplied_args)

        if self.mock_outputs:
            self._mock_SLC_intf2_outputs(*supplied_args)

        return self._gamma_call("ISP", "SLC_intf2", supplied_args)


    def _validate_par_ASF_PRI(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str):
        if CEOS_leader is not None:
            self._validate("par_ASF_PRI", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_data is not None:
            self._validate("par_ASF_PRI", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_ASF_PRI_outputs(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str):
        if GRD_par is not None and GRD_par != "-":
            Path(GRD_par).touch()
        if GRD is not None and GRD != "-":
            Path(GRD).touch()

    def par_ASF_PRI(self, CEOS_leader: str, CEOS_data: str, GRD_par: str, GRD: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_PRI))

        if self.validate_inputs:
            self._validate_par_ASF_PRI(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ASF_PRI_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ASF_PRI", supplied_args)


    def _validate_offset_pwr(self, SLC1: str, SLC2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, nr = None, naz = None, thres = None, lanczos = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        if SLC1 is not None:
            self._validate("offset_pwr", SLC1 == "-" or Path(SLC1).exists(), f"SLC1 path does not exist ({SLC1})")
        if SLC2 is not None:
            self._validate("offset_pwr", SLC2 == "-" or Path(SLC2).exists(), f"SLC2 path does not exist ({SLC2})")
        if SLC1_par is not None:
            self._validate("offset_pwr", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("offset_pwr", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if OFF_par is not None:
            self._validate("offset_pwr", OFF_par == "-" or Path(OFF_par).exists(), f"OFF_par path does not exist ({OFF_par})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr", deramp == "-" or deramp in valid_values, f"deramp is not a valid value (expects: {valid_values}, got: {deramp})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr", int_filt == "-" or int_filt in valid_values, f"int_filt is not a valid value (expects: {valid_values}, got: {int_filt})")
        valid_values = [0, 1] + [None]
        self._validate("offset_pwr", pflag == "-" or pflag in valid_values, f"pflag is not a valid value (expects: {valid_values}, got: {pflag})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("offset_pwr", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_offset_pwr_outputs(self, SLC1: str, SLC2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, nr = None, naz = None, thres = None, lanczos = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        if offs is not None and offs != "-":
            Path(offs).touch()
        if ccp is not None and ccp != "-":
            Path(ccp).touch()
        if offsets is not None and offsets != "-":
            Path(offsets).touch()
        if ccs is not None and ccs != "-":
            Path(ccs).touch()

    def offset_pwr(self, SLC1: str, SLC2: str, SLC1_par: str, SLC2_par: str, OFF_par: str, offs: str, ccp: str, rwin = None, azwin = None, offsets: str = None, n_ovr = None, nr = None, naz = None, thres = None, lanczos = None, bw_frac = None, deramp = None, int_filt = None, pflag = None, pltflg = None, ccs: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr))

        if self.validate_inputs:
            self._validate_offset_pwr(*supplied_args)

        if self.mock_outputs:
            self._mock_offset_pwr_outputs(*supplied_args)

        return self._gamma_call("ISP", "offset_pwr", supplied_args)


    def _validate_par_ATLSCI_ERS(self, CEOS_SAR_leader, CEOS_Image: str, SLC_par: str):
        if CEOS_Image is not None:
            self._validate("par_ATLSCI_ERS", CEOS_Image == "-" or Path(CEOS_Image).exists(), f"CEOS_Image path does not exist ({CEOS_Image})")

    def _mock_par_ATLSCI_ERS_outputs(self, CEOS_SAR_leader, CEOS_Image: str, SLC_par: str):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()

    def par_ATLSCI_ERS(self, CEOS_SAR_leader, CEOS_Image: str, SLC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ATLSCI_ERS))

        if self.validate_inputs:
            self._validate_par_ATLSCI_ERS(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ATLSCI_ERS_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ATLSCI_ERS", supplied_args)


    def _validate_par_PRI_ESRIN_JERS(self, CEOS_SAR_leader: str, PRI_par: str, CEOS_DAT: str, PRI: str):
        if CEOS_SAR_leader is not None:
            self._validate("par_PRI_ESRIN_JERS", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        if CEOS_DAT is not None:
            self._validate("par_PRI_ESRIN_JERS", CEOS_DAT == "-" or Path(CEOS_DAT).exists(), f"CEOS_DAT path does not exist ({CEOS_DAT})")

    def _mock_par_PRI_ESRIN_JERS_outputs(self, CEOS_SAR_leader: str, PRI_par: str, CEOS_DAT: str, PRI: str):
        if PRI_par is not None and PRI_par != "-":
            Path(PRI_par).touch()
        if PRI is not None and PRI != "-":
            Path(PRI).touch()

    def par_PRI_ESRIN_JERS(self, CEOS_SAR_leader: str, PRI_par: str, CEOS_DAT: str, PRI: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_PRI_ESRIN_JERS))

        if self.validate_inputs:
            self._validate_par_PRI_ESRIN_JERS(*supplied_args)

        if self.mock_outputs:
            self._mock_par_PRI_ESRIN_JERS_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_PRI_ESRIN_JERS", supplied_args)


    def _validate_par_KC_PALSAR_slr(self, facter_m: str, CEOS_leader: str, SLC_par: str, pol, pls_mode, KC_data: str, pwr: str, fdtab: str = None):
        if facter_m is not None:
            self._validate("par_KC_PALSAR_slr", facter_m == "-" or Path(facter_m).exists(), f"facter_m path does not exist ({facter_m})")
        if CEOS_leader is not None:
            self._validate("par_KC_PALSAR_slr", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        valid_values = [1, 2, 3]
        self._validate("par_KC_PALSAR_slr", pls_mode == "-" or pls_mode in valid_values, f"pls_mode is not a valid value (expects: {valid_values}, got: {pls_mode})")
        if KC_data is not None:
            self._validate("par_KC_PALSAR_slr", KC_data == "-" or Path(KC_data).exists(), f"KC_data path does not exist ({KC_data})")

    def _mock_par_KC_PALSAR_slr_outputs(self, facter_m: str, CEOS_leader: str, SLC_par: str, pol, pls_mode, KC_data: str, pwr: str, fdtab: str = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if pwr is not None and pwr != "-":
            Path(pwr).touch()
        if fdtab is not None and fdtab != "-":
            Path(fdtab).touch()

    def par_KC_PALSAR_slr(self, facter_m: str, CEOS_leader: str, SLC_par: str, pol, pls_mode, KC_data: str, pwr: str, fdtab: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_KC_PALSAR_slr))

        if self.validate_inputs:
            self._validate_par_KC_PALSAR_slr(*supplied_args)

        if self.mock_outputs:
            self._mock_par_KC_PALSAR_slr_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_KC_PALSAR_slr", supplied_args)


    def _validate_ptarg_SLC(self, SLC_par: str, SLC: str, r_samp, az_samp, ptr_image: str, r_plot: str, az_plot: str, ptr_par: str = None, osf = None, win = None, pltflg = None):
        if SLC_par is not None:
            self._validate("ptarg_SLC", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")
        if SLC is not None:
            self._validate("ptarg_SLC", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        valid_values = [0, 1, 2, 3] + [None]
        self._validate("ptarg_SLC", pltflg == "-" or pltflg in valid_values, f"pltflg is not a valid value (expects: {valid_values}, got: {pltflg})")

    def _mock_ptarg_SLC_outputs(self, SLC_par: str, SLC: str, r_samp, az_samp, ptr_image: str, r_plot: str, az_plot: str, ptr_par: str = None, osf = None, win = None, pltflg = None):
        if ptr_image is not None and ptr_image != "-":
            Path(ptr_image).touch()
        if r_plot is not None and r_plot != "-":
            Path(r_plot).touch()
        if az_plot is not None and az_plot != "-":
            Path(az_plot).touch()
        if ptr_par is not None and ptr_par != "-":
            Path(ptr_par).touch()

    def ptarg_SLC(self, SLC_par: str, SLC: str, r_samp, az_samp, ptr_image: str, r_plot: str, az_plot: str, ptr_par: str = None, osf = None, win = None, pltflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ptarg_SLC))

        if self.validate_inputs:
            self._validate_ptarg_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_ptarg_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "ptarg_SLC", supplied_args)


    def _validate_par_EORC_PALSAR(self, CEOS_leader: str, SLC_par: str, CEOS_data: str, SLC: str = None):
        if CEOS_leader is not None:
            self._validate("par_EORC_PALSAR", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_data is not None:
            self._validate("par_EORC_PALSAR", CEOS_data == "-" or Path(CEOS_data).exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_EORC_PALSAR_outputs(self, CEOS_leader: str, SLC_par: str, CEOS_data: str, SLC: str = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_EORC_PALSAR(self, CEOS_leader: str, SLC_par: str, CEOS_data: str, SLC: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_EORC_PALSAR))

        if self.validate_inputs:
            self._validate_par_EORC_PALSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_par_EORC_PALSAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_EORC_PALSAR", supplied_args)


    def _validate_S1_burstloc(self, annotation_XML: str):
        if annotation_XML is not None:
            self._validate("S1_burstloc", annotation_XML == "-" or Path(annotation_XML).exists(), f"annotation_XML path does not exist ({annotation_XML})")

    def _mock_S1_burstloc_outputs(self, annotation_XML: str):
        pass

    def S1_burstloc(self, annotation_XML: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.S1_burstloc))

        if self.validate_inputs:
            self._validate_S1_burstloc(*supplied_args)

        if self.mock_outputs:
            self._mock_S1_burstloc_outputs(*supplied_args)

        return self._gamma_call("ISP", "S1_burstloc", supplied_args)


    def _validate_par_GF3_SLC(self, GeoTIFF: str, annotation_XML: str, SLC_par: str, SLC: str = None):
        if GeoTIFF is not None:
            self._validate("par_GF3_SLC", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        if annotation_XML is not None:
            self._validate("par_GF3_SLC", annotation_XML == "-" or Path(annotation_XML).exists(), f"annotation_XML path does not exist ({annotation_XML})")

    def _mock_par_GF3_SLC_outputs(self, GeoTIFF: str, annotation_XML: str, SLC_par: str, SLC: str = None):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_GF3_SLC(self, GeoTIFF: str, annotation_XML: str, SLC_par: str, SLC: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_GF3_SLC))

        if self.validate_inputs:
            self._validate_par_GF3_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_GF3_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_GF3_SLC", supplied_args)


    def _validate_cc_wave(self, interf: str, MLI_1, MLI_2, cc: str, width, bx = None, by = None, wflg = None, xmin = None, xmax = None, ymin = None, ymax = None):
        if interf is not None:
            self._validate("cc_wave", interf == "-" or Path(interf).exists(), f"interf path does not exist ({interf})")

    def _mock_cc_wave_outputs(self, interf: str, MLI_1, MLI_2, cc: str, width, bx = None, by = None, wflg = None, xmin = None, xmax = None, ymin = None, ymax = None):
        if cc is not None and cc != "-":
            Path(cc).touch()

    def cc_wave(self, interf: str, MLI_1, MLI_2, cc: str, width, bx = None, by = None, wflg = None, xmin = None, xmax = None, ymin = None, ymax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cc_wave))

        if self.validate_inputs:
            self._validate_cc_wave(*supplied_args)

        if self.mock_outputs:
            self._mock_cc_wave_outputs(*supplied_args)

        return self._gamma_call("ISP", "cc_wave", supplied_args)


    def _validate_par_RSAT2_SLC(self, product_XML: str, lut_XML: str, GeoTIFF: str, polarization, SLC_par: str, SLC: str):
        if product_XML is not None:
            self._validate("par_RSAT2_SLC", product_XML == "-" or Path(product_XML).exists(), f"product_XML path does not exist ({product_XML})")
        if lut_XML is not None:
            self._validate("par_RSAT2_SLC", lut_XML == "-" or Path(lut_XML).exists(), f"lut_XML path does not exist ({lut_XML})")
        if GeoTIFF is not None:
            self._validate("par_RSAT2_SLC", GeoTIFF == "-" or Path(GeoTIFF).exists(), f"GeoTIFF path does not exist ({GeoTIFF})")

    def _mock_par_RSAT2_SLC_outputs(self, product_XML: str, lut_XML: str, GeoTIFF: str, polarization, SLC_par: str, SLC: str):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()
        if SLC is not None and SLC != "-":
            Path(SLC).touch()

    def par_RSAT2_SLC(self, product_XML: str, lut_XML: str, GeoTIFF: str, polarization, SLC_par: str, SLC: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT2_SLC))

        if self.validate_inputs:
            self._validate_par_RSAT2_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_par_RSAT2_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_RSAT2_SLC", supplied_args)


    def _validate_residue_cc(self, int: str, flag: str, width, xmin = None, xmax = None, ymin = None, ymax = None):
        if int is not None:
            self._validate("residue_cc", int == "-" or Path(int).exists(), f"int path does not exist ({int})")
        if flag is not None:
            self._validate("residue_cc", flag == "-" or Path(flag).exists(), f"flag path does not exist ({flag})")

    def _mock_residue_cc_outputs(self, int: str, flag: str, width, xmin = None, xmax = None, ymin = None, ymax = None):
        pass

    def residue_cc(self, int: str, flag: str, width, xmin = None, xmax = None, ymin = None, ymax = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.residue_cc))

        if self.validate_inputs:
            self._validate_residue_cc(*supplied_args)

        if self.mock_outputs:
            self._mock_residue_cc_outputs(*supplied_args)

        return self._gamma_call("ISP", "residue_cc", supplied_args)


    def _validate_par_PulSAR(self, CEOS_SAR_leader: str, SLC_par: str):
        if CEOS_SAR_leader is not None:
            self._validate("par_PulSAR", CEOS_SAR_leader == "-" or Path(CEOS_SAR_leader).exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")

    def _mock_par_PulSAR_outputs(self, CEOS_SAR_leader: str, SLC_par: str):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()

    def par_PulSAR(self, CEOS_SAR_leader: str, SLC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_PulSAR))

        if self.validate_inputs:
            self._validate_par_PulSAR(*supplied_args)

        if self.mock_outputs:
            self._mock_par_PulSAR_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_PulSAR", supplied_args)


    def _validate_par_ASF_91(self, CEOS_leader: str, CEOS_trailer: str, SLC_par: str):
        if CEOS_leader is not None:
            self._validate("par_ASF_91", CEOS_leader == "-" or Path(CEOS_leader).exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        if CEOS_trailer is not None:
            self._validate("par_ASF_91", CEOS_trailer == "-" or Path(CEOS_trailer).exists(), f"CEOS_trailer path does not exist ({CEOS_trailer})")

    def _mock_par_ASF_91_outputs(self, CEOS_leader: str, CEOS_trailer: str, SLC_par: str):
        if SLC_par is not None and SLC_par != "-":
            Path(SLC_par).touch()

    def par_ASF_91(self, CEOS_leader: str, CEOS_trailer: str, SLC_par: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_91))

        if self.validate_inputs:
            self._validate_par_ASF_91(*supplied_args)

        if self.mock_outputs:
            self._mock_par_ASF_91_outputs(*supplied_args)

        return self._gamma_call("ISP", "par_ASF_91", supplied_args)


    def _validate_fspf(self, data_in: str, data_out: str, width, dtype = None, r_max = None, spf_type = None, MLI_par = None):
        if data_in is not None:
            self._validate("fspf", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        valid_values = [0, 1, 2] + [None]
        self._validate("fspf", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1, 2, 3, 4, 5] + [None]
        self._validate("fspf", spf_type == "-" or spf_type in valid_values, f"spf_type is not a valid value (expects: {valid_values}, got: {spf_type})")

    def _mock_fspf_outputs(self, data_in: str, data_out: str, width, dtype = None, r_max = None, spf_type = None, MLI_par = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def fspf(self, data_in: str, data_out: str, width, dtype = None, r_max = None, spf_type = None, MLI_par = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.fspf))

        if self.validate_inputs:
            self._validate_fspf(*supplied_args)

        if self.mock_outputs:
            self._mock_fspf_outputs(*supplied_args)

        return self._gamma_call("ISP", "fspf", supplied_args)


    def _validate_radcal_SLC(self, SLC: str, SLC_PAR: str, CSLC: str, CSLC_PAR: str, fcase = None, antenna = None, rloss_flag = None, ant_flag = None, refarea_flag = None, sc_dB = None, K_dB = None, pix_area: str = None):
        if SLC is not None:
            self._validate("radcal_SLC", SLC == "-" or Path(SLC).exists(), f"SLC path does not exist ({SLC})")
        if SLC_PAR is not None:
            self._validate("radcal_SLC", SLC_PAR == "-" or Path(SLC_PAR).exists(), f"SLC_PAR path does not exist ({SLC_PAR})")
        valid_values = [1, 2, 3, 4] + [None]
        self._validate("radcal_SLC", fcase == "-" or fcase in valid_values, f"fcase is not a valid value (expects: {valid_values}, got: {fcase})")

    def _mock_radcal_SLC_outputs(self, SLC: str, SLC_PAR: str, CSLC: str, CSLC_PAR: str, fcase = None, antenna = None, rloss_flag = None, ant_flag = None, refarea_flag = None, sc_dB = None, K_dB = None, pix_area: str = None):
        if CSLC is not None and CSLC != "-":
            Path(CSLC).touch()
        if CSLC_PAR is not None and CSLC_PAR != "-":
            Path(CSLC_PAR).touch()
        if pix_area is not None and pix_area != "-":
            Path(pix_area).touch()

    def radcal_SLC(self, SLC: str, SLC_PAR: str, CSLC: str, CSLC_PAR: str, fcase = None, antenna = None, rloss_flag = None, ant_flag = None, refarea_flag = None, sc_dB = None, K_dB = None, pix_area: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.radcal_SLC))

        if self.validate_inputs:
            self._validate_radcal_SLC(*supplied_args)

        if self.mock_outputs:
            self._mock_radcal_SLC_outputs(*supplied_args)

        return self._gamma_call("ISP", "radcal_SLC", supplied_args)


    def _validate_line_interp(self, input = None):
        pass

    def _mock_line_interp_outputs(self, input = None):
        pass

    def line_interp(self, input = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.line_interp))

        if self.validate_inputs:
            self._validate_line_interp(*supplied_args)

        if self.mock_outputs:
            self._mock_line_interp_outputs(*supplied_args)

        return self._gamma_call("LAT", "line_interp", supplied_args)


    def _validate_product_cpx(self, f1: str, f2: str, f_out: str, width, start = None, nlines = None, conjg_flg = None):
        if f1 is not None:
            self._validate("product_cpx", f1 == "-" or Path(f1).exists(), f"f1 path does not exist ({f1})")
        if f2 is not None:
            self._validate("product_cpx", f2 == "-" or Path(f2).exists(), f"f2 path does not exist ({f2})")
        valid_values = [0, 1] + [None]
        self._validate("product_cpx", conjg_flg == "-" or conjg_flg in valid_values, f"conjg_flg is not a valid value (expects: {valid_values}, got: {conjg_flg})")

    def _mock_product_cpx_outputs(self, f1: str, f2: str, f_out: str, width, start = None, nlines = None, conjg_flg = None):
        if f_out is not None and f_out != "-":
            Path(f_out).touch()

    def product_cpx(self, f1: str, f2: str, f_out: str, width, start = None, nlines = None, conjg_flg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.product_cpx))

        if self.validate_inputs:
            self._validate_product_cpx(*supplied_args)

        if self.mock_outputs:
            self._mock_product_cpx_outputs(*supplied_args)

        return self._gamma_call("LAT", "product_cpx", supplied_args)


    def _validate_ras_majority(self, ras_in: str, ras_out: str, filter_width = None, LR = None):
        if ras_in is not None:
            self._validate("ras_majority", ras_in == "-" or Path(ras_in).exists(), f"ras_in path does not exist ({ras_in})")

    def _mock_ras_majority_outputs(self, ras_in: str, ras_out: str, filter_width = None, LR = None):
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()

    def ras_majority(self, ras_in: str, ras_out: str, filter_width = None, LR = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_majority))

        if self.validate_inputs:
            self._validate_ras_majority(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_majority_outputs(*supplied_args)

        return self._gamma_call("LAT", "ras_majority", supplied_args)


    def _validate_average_filter(self, din: str, dout: str, width, bx, by = None, wflg = None, min_pt = None, zflg = None):
        if din is not None:
            self._validate("average_filter", din == "-" or Path(din).exists(), f"din path does not exist ({din})")
        valid_values = [0, 1, 2] + [None]
        self._validate("average_filter", wflg == "-" or wflg in valid_values, f"wflg is not a valid value (expects: {valid_values}, got: {wflg})")
        valid_values = [0, 1] + [None]
        self._validate("average_filter", zflg == "-" or zflg in valid_values, f"zflg is not a valid value (expects: {valid_values}, got: {zflg})")

    def _mock_average_filter_outputs(self, din: str, dout: str, width, bx, by = None, wflg = None, min_pt = None, zflg = None):
        if dout is not None and dout != "-":
            Path(dout).touch()

    def average_filter(self, din: str, dout: str, width, bx, by = None, wflg = None, min_pt = None, zflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.average_filter))

        if self.validate_inputs:
            self._validate_average_filter(*supplied_args)

        if self.mock_outputs:
            self._mock_average_filter_outputs(*supplied_args)

        return self._gamma_call("LAT", "average_filter", supplied_args)


    def _validate_mask_class(self, class_map: str, file_in: str, file_out: str, format_flag, LR, selection_flag, n_class, class_1, class_n = None):
        if class_map is not None:
            self._validate("mask_class", class_map == "-" or Path(class_map).exists(), f"class_map path does not exist ({class_map})")
        if file_in is not None:
            self._validate("mask_class", file_in == "-" or Path(file_in).exists(), f"file_in path does not exist ({file_in})")
        valid_values = [0, 1, 2, 3]
        self._validate("mask_class", format_flag == "-" or format_flag in valid_values, f"format_flag is not a valid value (expects: {valid_values}, got: {format_flag})")

    def _mock_mask_class_outputs(self, class_map: str, file_in: str, file_out: str, format_flag, LR, selection_flag, n_class, class_1, class_n = None):
        if file_out is not None and file_out != "-":
            Path(file_out).touch()

    def mask_class(self, class_map: str, file_in: str, file_out: str, format_flag, LR, selection_flag, n_class, class_1, class_n = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mask_class))

        if self.validate_inputs:
            self._validate_mask_class(*supplied_args)

        if self.mock_outputs:
            self._mock_mask_class_outputs(*supplied_args)

        return self._gamma_call("LAT", "mask_class", supplied_args)


    def _validate_ras_ratio_dB(self, pwr1: str, pwr2: str, width, start_pwr1 = None, start_pwr2 = None, nlines = None, pixavr = None, pixavaz = None, min_cc = None, max_cc = None, scale = None, exp = None, LR = None, rasf: str = None):
        if pwr1 is not None:
            self._validate("ras_ratio_dB", pwr1 == "-" or Path(pwr1).exists(), f"pwr1 path does not exist ({pwr1})")
        if pwr2 is not None:
            self._validate("ras_ratio_dB", pwr2 == "-" or Path(pwr2).exists(), f"pwr2 path does not exist ({pwr2})")

    def _mock_ras_ratio_dB_outputs(self, pwr1: str, pwr2: str, width, start_pwr1 = None, start_pwr2 = None, nlines = None, pixavr = None, pixavaz = None, min_cc = None, max_cc = None, scale = None, exp = None, LR = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras_ratio_dB(self, pwr1: str, pwr2: str, width, start_pwr1 = None, start_pwr2 = None, nlines = None, pixavr = None, pixavaz = None, min_cc = None, max_cc = None, scale = None, exp = None, LR = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_ratio_dB))

        if self.validate_inputs:
            self._validate_ras_ratio_dB(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_ratio_dB_outputs(*supplied_args)

        return self._gamma_call("LAT", "ras_ratio_dB", supplied_args)


    def _validate_linear_to_dB(self, data_in, data_out: str, width, inverse_flag = None, null_value = None):
        valid_values = [0, 1] + [None]
        self._validate("linear_to_dB", inverse_flag == "-" or inverse_flag in valid_values, f"inverse_flag is not a valid value (expects: {valid_values}, got: {inverse_flag})")

    def _mock_linear_to_dB_outputs(self, data_in, data_out: str, width, inverse_flag = None, null_value = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def linear_to_dB(self, data_in, data_out: str, width, inverse_flag = None, null_value = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.linear_to_dB))

        if self.validate_inputs:
            self._validate_linear_to_dB(*supplied_args)

        if self.mock_outputs:
            self._mock_linear_to_dB_outputs(*supplied_args)

        return self._gamma_call("LAT", "linear_to_dB", supplied_args)


    def _validate_histogram(self, data_in, width, polygon: str, hist: str, stat: str, min, max, nbins = None, mode = None, lin_log = None):
        if polygon is not None:
            self._validate("histogram", polygon == "-" or Path(polygon).exists(), f"polygon path does not exist ({polygon})")
        valid_values = [0, 1] + [None]
        self._validate("histogram", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")
        valid_values = [0, 1] + [None]
        self._validate("histogram", lin_log == "-" or lin_log in valid_values, f"lin_log is not a valid value (expects: {valid_values}, got: {lin_log})")

    def _mock_histogram_outputs(self, data_in, width, polygon: str, hist: str, stat: str, min, max, nbins = None, mode = None, lin_log = None):
        if hist is not None and hist != "-":
            Path(hist).touch()
        if stat is not None and stat != "-":
            Path(stat).touch()

    def histogram(self, data_in, width, polygon: str, hist: str, stat: str, min, max, nbins = None, mode = None, lin_log = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.histogram))

        if self.validate_inputs:
            self._validate_histogram(*supplied_args)

        if self.mock_outputs:
            self._mock_histogram_outputs(*supplied_args)

        return self._gamma_call("LAT", "histogram", supplied_args)


    def _validate_gamma_map(self, input_data: str, output_data: str, width, nlooks, bx, by = None):
        if input_data is not None:
            self._validate("gamma_map", input_data == "-" or Path(input_data).exists(), f"input_data path does not exist ({input_data})")

    def _mock_gamma_map_outputs(self, input_data: str, output_data: str, width, nlooks, bx, by = None):
        if output_data is not None and output_data != "-":
            Path(output_data).touch()

    def gamma_map(self, input_data: str, output_data: str, width, nlooks, bx, by = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gamma_map))

        if self.validate_inputs:
            self._validate_gamma_map(*supplied_args)

        if self.mock_outputs:
            self._mock_gamma_map_outputs(*supplied_args)

        return self._gamma_call("LAT", "gamma_map", supplied_args)


    def _validate_m_chi(self, s0, m, s2chi: str, S_par: str, c1: str, c2: str = None):
        if s2chi is not None:
            self._validate("m-chi", s2chi == "-" or Path(s2chi).exists(), f"s2chi path does not exist ({s2chi})")
        if S_par is not None:
            self._validate("m-chi", S_par == "-" or Path(S_par).exists(), f"S_par path does not exist ({S_par})")

    def _mock_m_chi_outputs(self, s0, m, s2chi: str, S_par: str, c1: str, c2: str = None):
        if c1 is not None and c1 != "-":
            Path(c1).touch()
        if c2 is not None and c2 != "-":
            Path(c2).touch()

    def m_chi(self, s0, m, s2chi: str, S_par: str, c1: str, c2: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.m_chi))

        if self.validate_inputs:
            self._validate_m_chi(*supplied_args)

        if self.mock_outputs:
            self._mock_m_chi_outputs(*supplied_args)

        return self._gamma_call("LAT", "m-chi", supplied_args)


    def _validate_reallks(self, image, ML_image: str, width, rlks = None, azlks = None, start = None, nlines = None, r_start = None, nsamp = None):
        pass

    def _mock_reallks_outputs(self, image, ML_image: str, width, rlks = None, azlks = None, start = None, nlines = None, r_start = None, nsamp = None):
        if ML_image is not None and ML_image != "-":
            Path(ML_image).touch()

    def reallks(self, image, ML_image: str, width, rlks = None, azlks = None, start = None, nlines = None, r_start = None, nsamp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.reallks))

        if self.validate_inputs:
            self._validate_reallks(*supplied_args)

        if self.mock_outputs:
            self._mock_reallks_outputs(*supplied_args)

        return self._gamma_call("LAT", "reallks", supplied_args)


    def _validate_frost(self, pwr1, pwr1_frost: str, width, fx = None, sx = None, power = None):
        pass

    def _mock_frost_outputs(self, pwr1, pwr1_frost: str, width, fx = None, sx = None, power = None):
        if pwr1_frost is not None and pwr1_frost != "-":
            Path(pwr1_frost).touch()

    def frost(self, pwr1, pwr1_frost: str, width, fx = None, sx = None, power = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.frost))

        if self.validate_inputs:
            self._validate_frost(*supplied_args)

        if self.mock_outputs:
            self._mock_frost_outputs(*supplied_args)

        return self._gamma_call("LAT", "frost", supplied_args)


    def _validate_mt_lee_filt(self, im_list, ref_image: str, width, winsz, L_ref, L, cthres, out_list: str, ref_out: str = None, b_coeff: str = None, filt_num: str = None, msr: str = None, ctr: str = None):
        if ref_image is not None:
            self._validate("mt_lee_filt", ref_image == "-" or Path(ref_image).exists(), f"ref_image path does not exist ({ref_image})")
        if out_list is not None:
            self._validate("mt_lee_filt", out_list == "-" or Path(out_list).exists(), f"out_list path does not exist ({out_list})")

    def _mock_mt_lee_filt_outputs(self, im_list, ref_image: str, width, winsz, L_ref, L, cthres, out_list: str, ref_out: str = None, b_coeff: str = None, filt_num: str = None, msr: str = None, ctr: str = None):
        if ref_out is not None and ref_out != "-":
            Path(ref_out).touch()
        if b_coeff is not None and b_coeff != "-":
            Path(b_coeff).touch()
        if filt_num is not None and filt_num != "-":
            Path(filt_num).touch()
        if msr is not None and msr != "-":
            Path(msr).touch()
        if ctr is not None and ctr != "-":
            Path(ctr).touch()

    def mt_lee_filt(self, im_list, ref_image: str, width, winsz, L_ref, L, cthres, out_list: str, ref_out: str = None, b_coeff: str = None, filt_num: str = None, msr: str = None, ctr: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mt_lee_filt))

        if self.validate_inputs:
            self._validate_mt_lee_filt(*supplied_args)

        if self.mock_outputs:
            self._mock_mt_lee_filt_outputs(*supplied_args)

        return self._gamma_call("LAT", "mt_lee_filt", supplied_args)


    def _validate_multi_stat(self, im_list, width, im_out: str, mode, rank, nmin = None):
        valid_values = [0, 1, 2, 3, 4]
        self._validate("multi_stat", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_multi_stat_outputs(self, im_list, width, im_out: str, mode, rank, nmin = None):
        if im_out is not None and im_out != "-":
            Path(im_out).touch()

    def multi_stat(self, im_list, width, im_out: str, mode, rank, nmin = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_stat))

        if self.validate_inputs:
            self._validate_multi_stat(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_stat_outputs(*supplied_args)

        return self._gamma_call("LAT", "multi_stat", supplied_args)


    def _validate_trigo(self, data1, func, data2: str, width):
        valid_values = [1]
        self._validate("trigo", func == "-" or func in valid_values, f"func is not a valid value (expects: {valid_values}, got: {func})")

    def _mock_trigo_outputs(self, data1, func, data2: str, width):
        if data2 is not None and data2 != "-":
            Path(data2).touch()

    def trigo(self, data1, func, data2: str, width):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.trigo))

        if self.validate_inputs:
            self._validate_trigo(*supplied_args)

        if self.mock_outputs:
            self._mock_trigo_outputs(*supplied_args)

        return self._gamma_call("LAT", "trigo", supplied_args)


    def _validate_temp_filt(self, data_tab, width, waz = None, wr = None, wt_flag = None, zero_flag = None, loff = None, nlines = None):
        valid_values = [0, 1, 2] + [None]
        self._validate("temp_filt", wt_flag == "-" or wt_flag in valid_values, f"wt_flag is not a valid value (expects: {valid_values}, got: {wt_flag})")
        valid_values = [0, 1] + [None]
        self._validate("temp_filt", zero_flag == "-" or zero_flag in valid_values, f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})")

    def _mock_temp_filt_outputs(self, data_tab, width, waz = None, wr = None, wt_flag = None, zero_flag = None, loff = None, nlines = None):
        pass

    def temp_filt(self, data_tab, width, waz = None, wr = None, wt_flag = None, zero_flag = None, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.temp_filt))

        if self.validate_inputs:
            self._validate_temp_filt(*supplied_args)

        if self.mock_outputs:
            self._mock_temp_filt_outputs(*supplied_args)

        return self._gamma_call("LAT", "temp_filt", supplied_args)


    def _validate_cpxlks(self, CMPLX: str, ML_CMPLX: str, width, rlks = None, azlks = None, start = None, nlines = None, r_start = None, nsamp = None):
        if CMPLX is not None:
            self._validate("cpxlks", CMPLX == "-" or Path(CMPLX).exists(), f"CMPLX path does not exist ({CMPLX})")

    def _mock_cpxlks_outputs(self, CMPLX: str, ML_CMPLX: str, width, rlks = None, azlks = None, start = None, nlines = None, r_start = None, nsamp = None):
        if ML_CMPLX is not None and ML_CMPLX != "-":
            Path(ML_CMPLX).touch()

    def cpxlks(self, CMPLX: str, ML_CMPLX: str, width, rlks = None, azlks = None, start = None, nlines = None, r_start = None, nsamp = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cpxlks))

        if self.validate_inputs:
            self._validate_cpxlks(*supplied_args)

        if self.mock_outputs:
            self._mock_cpxlks_outputs(*supplied_args)

        return self._gamma_call("LAT", "cpxlks", supplied_args)


    def _validate_ras_to_rgb(self, red_channel, green_channel, blue_channel, ras_out: str, LR = None, null_flag = None):
        valid_values = [0, 1] + [None]
        self._validate("ras_to_rgb", null_flag == "-" or null_flag in valid_values, f"null_flag is not a valid value (expects: {valid_values}, got: {null_flag})")

    def _mock_ras_to_rgb_outputs(self, red_channel, green_channel, blue_channel, ras_out: str, LR = None, null_flag = None):
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()

    def ras_to_rgb(self, red_channel, green_channel, blue_channel, ras_out: str, LR = None, null_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_to_rgb))

        if self.validate_inputs:
            self._validate_ras_to_rgb(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_to_rgb_outputs(*supplied_args)

        return self._gamma_call("LAT", "ras_to_rgb", supplied_args)


    def _validate_ave2pwr(self, pwr1, pwr2, pwr_out: str, width, scale_factor = None):
        pass

    def _mock_ave2pwr_outputs(self, pwr1, pwr2, pwr_out: str, width, scale_factor = None):
        if pwr_out is not None and pwr_out != "-":
            Path(pwr_out).touch()

    def ave2pwr(self, pwr1, pwr2, pwr_out: str, width, scale_factor = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ave2pwr))

        if self.validate_inputs:
            self._validate_ave2pwr(*supplied_args)

        if self.mock_outputs:
            self._mock_ave2pwr_outputs(*supplied_args)

        return self._gamma_call("LAT", "ave2pwr", supplied_args)


    def _validate_ras_m_chi(self, s1, c1: str, c2: str, c3: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, rasf: str = None):
        if c1 is not None:
            self._validate("ras_m-chi", c1 == "-" or Path(c1).exists(), f"c1 path does not exist ({c1})")
        if c2 is not None:
            self._validate("ras_m-chi", c2 == "-" or Path(c2).exists(), f"c2 path does not exist ({c2})")
        if c3 is not None:
            self._validate("ras_m-chi", c3 == "-" or Path(c3).exists(), f"c3 path does not exist ({c3})")

    def _mock_ras_m_chi_outputs(self, s1, c1: str, c2: str, c3: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, rasf: str = None):
        if rasf is not None and rasf != "-":
            Path(rasf).touch()

    def ras_m_chi(self, s1, c1: str, c2: str, c3: str, width, start = None, nlines = None, pixavr = None, pixavaz = None, scale = None, exp = None, rasf: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_m_chi))

        if self.validate_inputs:
            self._validate_ras_m_chi(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_m_chi_outputs(*supplied_args)

        return self._gamma_call("LAT", "ras_m-chi", supplied_args)


    def _validate_sigma2gamma(self, pwr1: str, inc: str, gamma: str, width):
        if pwr1 is not None:
            self._validate("sigma2gamma", pwr1 == "-" or Path(pwr1).exists(), f"pwr1 path does not exist ({pwr1})")
        if inc is not None:
            self._validate("sigma2gamma", inc == "-" or Path(inc).exists(), f"inc path does not exist ({inc})")

    def _mock_sigma2gamma_outputs(self, pwr1: str, inc: str, gamma: str, width):
        if gamma is not None and gamma != "-":
            Path(gamma).touch()

    def sigma2gamma(self, pwr1: str, inc: str, gamma: str, width):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sigma2gamma))

        if self.validate_inputs:
            self._validate_sigma2gamma(*supplied_args)

        if self.mock_outputs:
            self._mock_sigma2gamma_outputs(*supplied_args)

        return self._gamma_call("LAT", "sigma2gamma", supplied_args)


    def _validate_hsi_color_scale(self, file_out: str, nval = None, chip_width = None, gap = None, height = None):
        valid_values = [0] + [None]
        self._validate("hsi_color_scale", nval == "-" or nval in valid_values, f"nval is not a valid value (expects: {valid_values}, got: {nval})")

    def _mock_hsi_color_scale_outputs(self, file_out: str, nval = None, chip_width = None, gap = None, height = None):
        if file_out is not None and file_out != "-":
            Path(file_out).touch()

    def hsi_color_scale(self, file_out: str, nval = None, chip_width = None, gap = None, height = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.hsi_color_scale))

        if self.validate_inputs:
            self._validate_hsi_color_scale(*supplied_args)

        if self.mock_outputs:
            self._mock_hsi_color_scale_outputs(*supplied_args)

        return self._gamma_call("LAT", "hsi_color_scale", supplied_args)


    def _validate_unw_to_cpx(self, unw, cpx: str, width):
        pass

    def _mock_unw_to_cpx_outputs(self, unw, cpx: str, width):
        if cpx is not None and cpx != "-":
            Path(cpx).touch()

    def unw_to_cpx(self, unw, cpx: str, width):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.unw_to_cpx))

        if self.validate_inputs:
            self._validate_unw_to_cpx(*supplied_args)

        if self.mock_outputs:
            self._mock_unw_to_cpx_outputs(*supplied_args)

        return self._gamma_call("LAT", "unw_to_cpx", supplied_args)


    def _validate_polyx(self, ):
        pass

    def _mock_polyx_outputs(self, ):
        pass

    def polyx(self, ):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polyx))

        if self.validate_inputs:
            self._validate_polyx(*supplied_args)

        if self.mock_outputs:
            self._mock_polyx_outputs(*supplied_args)

        return self._gamma_call("LAT", "polyx", supplied_args)


    def _validate_pauli(self, SLC_HH: str, SLC_VV: str, SLC_HV: str, SLC_HH_par: str, SLC_VV_par: str, SLC_HV_par: str, P: str):
        if SLC_HH is not None:
            self._validate("pauli", SLC_HH == "-" or Path(SLC_HH).exists(), f"SLC_HH path does not exist ({SLC_HH})")
        if SLC_VV is not None:
            self._validate("pauli", SLC_VV == "-" or Path(SLC_VV).exists(), f"SLC_VV path does not exist ({SLC_VV})")
        if SLC_HV is not None:
            self._validate("pauli", SLC_HV == "-" or Path(SLC_HV).exists(), f"SLC_HV path does not exist ({SLC_HV})")
        if SLC_HH_par is not None:
            self._validate("pauli", SLC_HH_par == "-" or Path(SLC_HH_par).exists(), f"SLC_HH_par path does not exist ({SLC_HH_par})")
        if SLC_VV_par is not None:
            self._validate("pauli", SLC_VV_par == "-" or Path(SLC_VV_par).exists(), f"SLC_VV_par path does not exist ({SLC_VV_par})")
        if SLC_HV_par is not None:
            self._validate("pauli", SLC_HV_par == "-" or Path(SLC_HV_par).exists(), f"SLC_HV_par path does not exist ({SLC_HV_par})")

    def _mock_pauli_outputs(self, SLC_HH: str, SLC_VV: str, SLC_HV: str, SLC_HH_par: str, SLC_VV_par: str, SLC_HV_par: str, P: str):
        if P is not None and P != "-":
            Path(P).touch()

    def pauli(self, SLC_HH: str, SLC_VV: str, SLC_HV: str, SLC_HH_par: str, SLC_VV_par: str, SLC_HV_par: str, P: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pauli))

        if self.validate_inputs:
            self._validate_pauli(*supplied_args)

        if self.mock_outputs:
            self._mock_pauli_outputs(*supplied_args)

        return self._gamma_call("LAT", "pauli", supplied_args)


    def _validate_m_alpha(self, s0, m, alpha: str, S_par: str, c1: str, c2: str = None):
        if alpha is not None:
            self._validate("m-alpha", alpha == "-" or Path(alpha).exists(), f"alpha path does not exist ({alpha})")
        if S_par is not None:
            self._validate("m-alpha", S_par == "-" or Path(S_par).exists(), f"S_par path does not exist ({S_par})")

    def _mock_m_alpha_outputs(self, s0, m, alpha: str, S_par: str, c1: str, c2: str = None):
        if c1 is not None and c1 != "-":
            Path(c1).touch()
        if c2 is not None and c2 != "-":
            Path(c2).touch()

    def m_alpha(self, s0, m, alpha: str, S_par: str, c1: str, c2: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.m_alpha))

        if self.validate_inputs:
            self._validate_m_alpha(*supplied_args)

        if self.mock_outputs:
            self._mock_m_alpha_outputs(*supplied_args)

        return self._gamma_call("LAT", "m-alpha", supplied_args)


    def _validate_stokes(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, S: str, S_par: str, rlks, azlks, loff = None, nlines = None):
        if SLC_1 is not None:
            self._validate("stokes", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("stokes", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("stokes", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("stokes", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_stokes_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, S: str, S_par: str, rlks, azlks, loff = None, nlines = None):
        if S is not None and S != "-":
            Path(S).touch()
        if S_par is not None and S_par != "-":
            Path(S_par).touch()

    def stokes(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, S: str, S_par: str, rlks, azlks, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.stokes))

        if self.validate_inputs:
            self._validate_stokes(*supplied_args)

        if self.mock_outputs:
            self._mock_stokes_outputs(*supplied_args)

        return self._gamma_call("LAT", "stokes", supplied_args)


    def _validate_histogram_ras(self, ras_in: str, polygon, histograms, mean_stdev, percent, lr_flag = None, start = None, stop = None):
        if ras_in is not None:
            self._validate("histogram_ras", ras_in == "-" or Path(ras_in).exists(), f"ras_in path does not exist ({ras_in})")

    def _mock_histogram_ras_outputs(self, ras_in: str, polygon, histograms, mean_stdev, percent, lr_flag = None, start = None, stop = None):
        pass

    def histogram_ras(self, ras_in: str, polygon, histograms, mean_stdev, percent, lr_flag = None, start = None, stop = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.histogram_ras))

        if self.validate_inputs:
            self._validate_histogram_ras(*supplied_args)

        if self.mock_outputs:
            self._mock_histogram_ras_outputs(*supplied_args)

        return self._gamma_call("LAT", "histogram_ras", supplied_args)


    def _validate_product(self, data_1, data_2, product: str, width, bx = None, by = None, wgt_flag = None):
        valid_values = [0, 1, 2] + [None]
        self._validate("product", wgt_flag == "-" or wgt_flag in valid_values, f"wgt_flag is not a valid value (expects: {valid_values}, got: {wgt_flag})")

    def _mock_product_outputs(self, data_1, data_2, product: str, width, bx = None, by = None, wgt_flag = None):
        if product is not None and product != "-":
            Path(product).touch()

    def product(self, data_1, data_2, product: str, width, bx = None, by = None, wgt_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.product))

        if self.validate_inputs:
            self._validate_product(*supplied_args)

        if self.mock_outputs:
            self._mock_product_outputs(*supplied_args)

        return self._gamma_call("LAT", "product", supplied_args)


    def _validate_mt_lee_filt_cpx(self, cpx_list: str, ref_image, width, winsz, L_ref, cthres, out_list: str, ref_out: str = None, b_coeff: str = None, filt_num: str = None, msr: str = None, ctr: str = None):
        if cpx_list is not None:
            self._validate("mt_lee_filt_cpx", cpx_list == "-" or Path(cpx_list).exists(), f"cpx_list path does not exist ({cpx_list})")
        if out_list is not None:
            self._validate("mt_lee_filt_cpx", out_list == "-" or Path(out_list).exists(), f"out_list path does not exist ({out_list})")

    def _mock_mt_lee_filt_cpx_outputs(self, cpx_list: str, ref_image, width, winsz, L_ref, cthres, out_list: str, ref_out: str = None, b_coeff: str = None, filt_num: str = None, msr: str = None, ctr: str = None):
        if ref_out is not None and ref_out != "-":
            Path(ref_out).touch()
        if b_coeff is not None and b_coeff != "-":
            Path(b_coeff).touch()
        if filt_num is not None and filt_num != "-":
            Path(filt_num).touch()
        if msr is not None and msr != "-":
            Path(msr).touch()
        if ctr is not None and ctr != "-":
            Path(ctr).touch()

    def mt_lee_filt_cpx(self, cpx_list: str, ref_image, width, winsz, L_ref, cthres, out_list: str, ref_out: str = None, b_coeff: str = None, filt_num: str = None, msr: str = None, ctr: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mt_lee_filt_cpx))

        if self.validate_inputs:
            self._validate_mt_lee_filt_cpx(*supplied_args)

        if self.mock_outputs:
            self._mock_mt_lee_filt_cpx_outputs(*supplied_args)

        return self._gamma_call("LAT", "mt_lee_filt_cpx", supplied_args)


    def _validate_polcovar(self, SLC_1: str, SLC_2: str, SLC_3: str, SLC1_par: str, SLC2_par: str, SLC3_par: str, C: str, C_par: str, rlks, azlks, loff = None, nlines = None):
        if SLC_1 is not None:
            self._validate("polcovar", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("polcovar", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC_3 is not None:
            self._validate("polcovar", SLC_3 == "-" or Path(SLC_3).exists(), f"SLC_3 path does not exist ({SLC_3})")
        if SLC1_par is not None:
            self._validate("polcovar", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("polcovar", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if SLC3_par is not None:
            self._validate("polcovar", SLC3_par == "-" or Path(SLC3_par).exists(), f"SLC3_par path does not exist ({SLC3_par})")

    def _mock_polcovar_outputs(self, SLC_1: str, SLC_2: str, SLC_3: str, SLC1_par: str, SLC2_par: str, SLC3_par: str, C: str, C_par: str, rlks, azlks, loff = None, nlines = None):
        if C is not None and C != "-":
            Path(C).touch()
        if C_par is not None and C_par != "-":
            Path(C_par).touch()

    def polcovar(self, SLC_1: str, SLC_2: str, SLC_3: str, SLC1_par: str, SLC2_par: str, SLC3_par: str, C: str, C_par: str, rlks, azlks, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polcovar))

        if self.validate_inputs:
            self._validate_polcovar(*supplied_args)

        if self.mock_outputs:
            self._mock_polcovar_outputs(*supplied_args)

        return self._gamma_call("LAT", "polcovar", supplied_args)


    def _validate_stokes_qm(self, S, S_par: str, m: str = None, s2chi: str = None, s2psi: str = None, m_l: str = None, m_c: str = None, lp_ratio: str = None, cp_ratio: str = None, mu: str = None, delta: str = None, alpha: str = None, phi: str = None):
        if S_par is not None:
            self._validate("stokes_qm", S_par == "-" or Path(S_par).exists(), f"S_par path does not exist ({S_par})")

    def _mock_stokes_qm_outputs(self, S, S_par: str, m: str = None, s2chi: str = None, s2psi: str = None, m_l: str = None, m_c: str = None, lp_ratio: str = None, cp_ratio: str = None, mu: str = None, delta: str = None, alpha: str = None, phi: str = None):
        if m is not None and m != "-":
            Path(m).touch()
        if s2chi is not None and s2chi != "-":
            Path(s2chi).touch()
        if s2psi is not None and s2psi != "-":
            Path(s2psi).touch()
        if m_l is not None and m_l != "-":
            Path(m_l).touch()
        if m_c is not None and m_c != "-":
            Path(m_c).touch()
        if lp_ratio is not None and lp_ratio != "-":
            Path(lp_ratio).touch()
        if cp_ratio is not None and cp_ratio != "-":
            Path(cp_ratio).touch()
        if mu is not None and mu != "-":
            Path(mu).touch()
        if delta is not None and delta != "-":
            Path(delta).touch()
        if alpha is not None and alpha != "-":
            Path(alpha).touch()
        if phi is not None and phi != "-":
            Path(phi).touch()

    def stokes_qm(self, S, S_par: str, m: str = None, s2chi: str = None, s2psi: str = None, m_l: str = None, m_c: str = None, lp_ratio: str = None, cp_ratio: str = None, mu: str = None, delta: str = None, alpha: str = None, phi: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.stokes_qm))

        if self.validate_inputs:
            self._validate_stokes_qm(*supplied_args)

        if self.mock_outputs:
            self._mock_stokes_qm_outputs(*supplied_args)

        return self._gamma_call("LAT", "stokes_qm", supplied_args)


    def _validate_frame(self, data_in: str, data_out: str, width, dtype, dx1, dx2, dy1, dy2, null_flag = None, all_flag = None, null_value = None, frame_value = None):
        if data_in is not None:
            self._validate("frame", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        valid_values = [0, 1, 2, 3, 4, 5]
        self._validate("frame", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1] + [None]
        self._validate("frame", null_flag == "-" or null_flag in valid_values, f"null_flag is not a valid value (expects: {valid_values}, got: {null_flag})")
        valid_values = [0, 1] + [None]
        self._validate("frame", all_flag == "-" or all_flag in valid_values, f"all_flag is not a valid value (expects: {valid_values}, got: {all_flag})")

    def _mock_frame_outputs(self, data_in: str, data_out: str, width, dtype, dx1, dx2, dy1, dy2, null_flag = None, all_flag = None, null_value = None, frame_value = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def frame(self, data_in: str, data_out: str, width, dtype, dx1, dx2, dy1, dy2, null_flag = None, all_flag = None, null_value = None, frame_value = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.frame))

        if self.validate_inputs:
            self._validate_frame(*supplied_args)

        if self.mock_outputs:
            self._mock_frame_outputs(*supplied_args)

        return self._gamma_call("LAT", "frame", supplied_args)


    def _validate_looks(self, ):
        pass

    def _mock_looks_outputs(self, ):
        pass

    def looks(self, ):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.looks))

        if self.validate_inputs:
            self._validate_looks(*supplied_args)

        if self.mock_outputs:
            self._mock_looks_outputs(*supplied_args)

        return self._gamma_call("LAT", "looks", supplied_args)


    def _validate_polcoh(self, SLC_1: str, SLC_2: str, SLC_3: str, SLC1_par: str, SLC2_par: str, SLC3_par: str, T: str, T_par: str, rlks, azlks, loff = None, nlines = None):
        if SLC_1 is not None:
            self._validate("polcoh", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("polcoh", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC_3 is not None:
            self._validate("polcoh", SLC_3 == "-" or Path(SLC_3).exists(), f"SLC_3 path does not exist ({SLC_3})")
        if SLC1_par is not None:
            self._validate("polcoh", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("polcoh", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")
        if SLC3_par is not None:
            self._validate("polcoh", SLC3_par == "-" or Path(SLC3_par).exists(), f"SLC3_par path does not exist ({SLC3_par})")

    def _mock_polcoh_outputs(self, SLC_1: str, SLC_2: str, SLC_3: str, SLC1_par: str, SLC2_par: str, SLC3_par: str, T: str, T_par: str, rlks, azlks, loff = None, nlines = None):
        if T is not None and T != "-":
            Path(T).touch()
        if T_par is not None and T_par != "-":
            Path(T_par).touch()

    def polcoh(self, SLC_1: str, SLC_2: str, SLC_3: str, SLC1_par: str, SLC2_par: str, SLC3_par: str, T: str, T_par: str, rlks, azlks, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polcoh))

        if self.validate_inputs:
            self._validate_polcoh(*supplied_args)

        if self.mock_outputs:
            self._mock_polcoh_outputs(*supplied_args)

        return self._gamma_call("LAT", "polcoh", supplied_args)


    def _validate_lin_comb(self, nfiles, f1, f2, constant = None):
        pass

    def _mock_lin_comb_outputs(self, nfiles, f1, f2, constant = None):
        pass

    def lin_comb(self, nfiles, f1, f2, constant = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lin_comb))

        if self.validate_inputs:
            self._validate_lin_comb(*supplied_args)

        if self.mock_outputs:
            self._mock_lin_comb_outputs(*supplied_args)

        return self._gamma_call("LAT", "lin_comb", supplied_args)


    def _validate_multi_class_mapping(self, nfiles, f1, f2, fn = None):
        pass

    def _mock_multi_class_mapping_outputs(self, nfiles, f1, f2, fn = None):
        pass

    def multi_class_mapping(self, nfiles, f1, f2, fn = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_class_mapping))

        if self.validate_inputs:
            self._validate_multi_class_mapping(*supplied_args)

        if self.mock_outputs:
            self._mock_multi_class_mapping_outputs(*supplied_args)

        return self._gamma_call("LAT", "multi_class_mapping", supplied_args)


    def _validate_takecut(self, data_in, width, report: str, mode, pos, pr_flag = None):
        valid_values = [0, 1] + [None]
        self._validate("takecut", pr_flag == "-" or pr_flag in valid_values, f"pr_flag is not a valid value (expects: {valid_values}, got: {pr_flag})")

    def _mock_takecut_outputs(self, data_in, width, report: str, mode, pos, pr_flag = None):
        if report is not None and report != "-":
            Path(report).touch()

    def takecut(self, data_in, width, report: str, mode, pos, pr_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.takecut))

        if self.validate_inputs:
            self._validate_takecut(*supplied_args)

        if self.mock_outputs:
            self._mock_takecut_outputs(*supplied_args)

        return self._gamma_call("LAT", "takecut", supplied_args)


    def _validate_polyx_phase(self, data: str, width, polygon: str, report: str):
        if data is not None:
            self._validate("polyx_phase", data == "-" or Path(data).exists(), f"data path does not exist ({data})")
        if polygon is not None:
            self._validate("polyx_phase", polygon == "-" or Path(polygon).exists(), f"polygon path does not exist ({polygon})")

    def _mock_polyx_phase_outputs(self, data: str, width, polygon: str, report: str):
        if report is not None and report != "-":
            Path(report).touch()

    def polyx_phase(self, data: str, width, polygon: str, report: str):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polyx_phase))

        if self.validate_inputs:
            self._validate_polyx_phase(*supplied_args)

        if self.mock_outputs:
            self._mock_polyx_phase_outputs(*supplied_args)

        return self._gamma_call("LAT", "polyx_phase", supplied_args)


    def _validate_temp_lin_var(self, data_tab, mean: str, stdev: str, width, waz = None, wr = None, wt_flag = None, zero_flag = None, loff = None, nlines = None, norm_pow = None):
        valid_values = [0, 1, 2] + [None]
        self._validate("temp_lin_var", wt_flag == "-" or wt_flag in valid_values, f"wt_flag is not a valid value (expects: {valid_values}, got: {wt_flag})")
        valid_values = [0, 1] + [None]
        self._validate("temp_lin_var", zero_flag == "-" or zero_flag in valid_values, f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})")

    def _mock_temp_lin_var_outputs(self, data_tab, mean: str, stdev: str, width, waz = None, wr = None, wt_flag = None, zero_flag = None, loff = None, nlines = None, norm_pow = None):
        if mean is not None and mean != "-":
            Path(mean).touch()
        if stdev is not None and stdev != "-":
            Path(stdev).touch()

    def temp_lin_var(self, data_tab, mean: str, stdev: str, width, waz = None, wr = None, wt_flag = None, zero_flag = None, loff = None, nlines = None, norm_pow = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.temp_lin_var))

        if self.validate_inputs:
            self._validate_temp_lin_var(*supplied_args)

        if self.mock_outputs:
            self._mock_temp_lin_var_outputs(*supplied_args)

        return self._gamma_call("LAT", "temp_lin_var", supplied_args)


    def _validate_ave_cpx(self, cpx_list: str, width, ave: str, start = None, nlines = None, zflag = None):
        if cpx_list is not None:
            self._validate("ave_cpx", cpx_list == "-" or Path(cpx_list).exists(), f"cpx_list path does not exist ({cpx_list})")
        valid_values = [0, 1] + [None]
        self._validate("ave_cpx", zflag == "-" or zflag in valid_values, f"zflag is not a valid value (expects: {valid_values}, got: {zflag})")

    def _mock_ave_cpx_outputs(self, cpx_list: str, width, ave: str, start = None, nlines = None, zflag = None):
        if ave is not None and ave != "-":
            Path(ave).touch()

    def ave_cpx(self, cpx_list: str, width, ave: str, start = None, nlines = None, zflag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ave_cpx))

        if self.validate_inputs:
            self._validate_ave_cpx(*supplied_args)

        if self.mock_outputs:
            self._mock_ave_cpx_outputs(*supplied_args)

        return self._gamma_call("LAT", "ave_cpx", supplied_args)


    def _validate_mask_op(self, mask_1: str, mask_2: str, mask_out: str, mode):
        if mask_1 is not None:
            self._validate("mask_op", mask_1 == "-" or Path(mask_1).exists(), f"mask_1 path does not exist ({mask_1})")
        if mask_2 is not None:
            self._validate("mask_op", mask_2 == "-" or Path(mask_2).exists(), f"mask_2 path does not exist ({mask_2})")
        valid_values = [0, 1, 2]
        self._validate("mask_op", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")

    def _mock_mask_op_outputs(self, mask_1: str, mask_2: str, mask_out: str, mode):
        if mask_out is not None and mask_out != "-":
            Path(mask_out).touch()

    def mask_op(self, mask_1: str, mask_2: str, mask_out: str, mode):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mask_op))

        if self.validate_inputs:
            self._validate_mask_op(*supplied_args)

        if self.mock_outputs:
            self._mock_mask_op_outputs(*supplied_args)

        return self._gamma_call("LAT", "mask_op", supplied_args)


    def _validate_quad2cp(self, SLC_HH: str, SLC_HV: str, SLC_VH: str, SLC_VV: str, SLC_HH_par: str, SLC_HV_par: str, SLC_VH_par: str, SLC_VV_par: str, CP: str, TX_pol):
        if SLC_HH is not None:
            self._validate("quad2cp", SLC_HH == "-" or Path(SLC_HH).exists(), f"SLC_HH path does not exist ({SLC_HH})")
        if SLC_HV is not None:
            self._validate("quad2cp", SLC_HV == "-" or Path(SLC_HV).exists(), f"SLC_HV path does not exist ({SLC_HV})")
        if SLC_VH is not None:
            self._validate("quad2cp", SLC_VH == "-" or Path(SLC_VH).exists(), f"SLC_VH path does not exist ({SLC_VH})")
        if SLC_VV is not None:
            self._validate("quad2cp", SLC_VV == "-" or Path(SLC_VV).exists(), f"SLC_VV path does not exist ({SLC_VV})")
        if SLC_HH_par is not None:
            self._validate("quad2cp", SLC_HH_par == "-" or Path(SLC_HH_par).exists(), f"SLC_HH_par path does not exist ({SLC_HH_par})")
        if SLC_HV_par is not None:
            self._validate("quad2cp", SLC_HV_par == "-" or Path(SLC_HV_par).exists(), f"SLC_HV_par path does not exist ({SLC_HV_par})")
        if SLC_VH_par is not None:
            self._validate("quad2cp", SLC_VH_par == "-" or Path(SLC_VH_par).exists(), f"SLC_VH_par path does not exist ({SLC_VH_par})")
        if SLC_VV_par is not None:
            self._validate("quad2cp", SLC_VV_par == "-" or Path(SLC_VV_par).exists(), f"SLC_VV_par path does not exist ({SLC_VV_par})")
        valid_values = [0, 1]
        self._validate("quad2cp", TX_pol == "-" or TX_pol in valid_values, f"TX_pol is not a valid value (expects: {valid_values}, got: {TX_pol})")

    def _mock_quad2cp_outputs(self, SLC_HH: str, SLC_HV: str, SLC_VH: str, SLC_VV: str, SLC_HH_par: str, SLC_HV_par: str, SLC_VH_par: str, SLC_VV_par: str, CP: str, TX_pol):
        if CP is not None and CP != "-":
            Path(CP).touch()

    def quad2cp(self, SLC_HH: str, SLC_HV: str, SLC_VH: str, SLC_VV: str, SLC_HH_par: str, SLC_HV_par: str, SLC_VH_par: str, SLC_VV_par: str, CP: str, TX_pol):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.quad2cp))

        if self.validate_inputs:
            self._validate_quad2cp(*supplied_args)

        if self.mock_outputs:
            self._mock_quad2cp_outputs(*supplied_args)

        return self._gamma_call("LAT", "quad2cp", supplied_args)


    def _validate_poly_math(self, ):
        pass

    def _mock_poly_math_outputs(self, ):
        pass

    def poly_math(self, ):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.poly_math))

        if self.validate_inputs:
            self._validate_poly_math(*supplied_args)

        if self.mock_outputs:
            self._mock_poly_math_outputs(*supplied_args)

        return self._gamma_call("LAT", "poly_math", supplied_args)


    def _validate_single_class_mapping(self, nfiles, f1, lt1, ut1, fn = None):
        pass

    def _mock_single_class_mapping_outputs(self, nfiles, f1, lt1, ut1, fn = None):
        pass

    def single_class_mapping(self, nfiles, f1, lt1, ut1, fn = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.single_class_mapping))

        if self.validate_inputs:
            self._validate_single_class_mapping(*supplied_args)

        if self.mock_outputs:
            self._mock_single_class_mapping_outputs(*supplied_args)

        return self._gamma_call("LAT", "single_class_mapping", supplied_args)


    def _validate_drawthat(self, ras_in: str, ras_out: str, pt_list: str, mode = None, r = None, g = None, b = None, xs = None, zflg = None):
        if ras_in is not None:
            self._validate("drawthat", ras_in == "-" or Path(ras_in).exists(), f"ras_in path does not exist ({ras_in})")
        if pt_list is not None:
            self._validate("drawthat", pt_list == "-" or Path(pt_list).exists(), f"pt_list path does not exist ({pt_list})")
        valid_values = [0, 1, 2] + [None]
        self._validate("drawthat", mode == "-" or mode in valid_values, f"mode is not a valid value (expects: {valid_values}, got: {mode})")
        valid_values = [0, 1] + [None]
        self._validate("drawthat", zflg == "-" or zflg in valid_values, f"zflg is not a valid value (expects: {valid_values}, got: {zflg})")

    def _mock_drawthat_outputs(self, ras_in: str, ras_out: str, pt_list: str, mode = None, r = None, g = None, b = None, xs = None, zflg = None):
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()

    def drawthat(self, ras_in: str, ras_out: str, pt_list: str, mode = None, r = None, g = None, b = None, xs = None, zflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.drawthat))

        if self.validate_inputs:
            self._validate_drawthat(*supplied_args)

        if self.mock_outputs:
            self._mock_drawthat_outputs(*supplied_args)

        return self._gamma_call("LAT", "drawthat", supplied_args)


    def _validate_m_delta(self, s0, m, delta: str, S_par: str, c1: str, c2: str = None):
        if delta is not None:
            self._validate("m-delta", delta == "-" or Path(delta).exists(), f"delta path does not exist ({delta})")
        if S_par is not None:
            self._validate("m-delta", S_par == "-" or Path(S_par).exists(), f"S_par path does not exist ({S_par})")

    def _mock_m_delta_outputs(self, s0, m, delta: str, S_par: str, c1: str, c2: str = None):
        if c1 is not None and c1 != "-":
            Path(c1).touch()
        if c2 is not None and c2 != "-":
            Path(c2).touch()

    def m_delta(self, s0, m, delta: str, S_par: str, c1: str, c2: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.m_delta))

        if self.validate_inputs:
            self._validate_m_delta(*supplied_args)

        if self.mock_outputs:
            self._mock_m_delta_outputs(*supplied_args)

        return self._gamma_call("LAT", "m-delta", supplied_args)


    def _validate_temp_filt_ad(self, data_tab, width, zero_flag = None, loffset = None, nlines = None):
        valid_values = [0, 1] + [None]
        self._validate("temp_filt_ad", zero_flag == "-" or zero_flag in valid_values, f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})")

    def _mock_temp_filt_ad_outputs(self, data_tab, width, zero_flag = None, loffset = None, nlines = None):
        pass

    def temp_filt_ad(self, data_tab, width, zero_flag = None, loffset = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.temp_filt_ad))

        if self.validate_inputs:
            self._validate_temp_filt_ad(*supplied_args)

        if self.mock_outputs:
            self._mock_temp_filt_ad_outputs(*supplied_args)

        return self._gamma_call("LAT", "temp_filt_ad", supplied_args)


    def _validate_bm3d(self, data_in: str, width, data_out: str, dtype = None, profile = None, looks = None, sigma = None, block_size = None, s_dist = None, step = None, d_max = None, t1d = None):
        if data_in is not None:
            self._validate("bm3d", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        valid_values = [0, 1, 2] + [None]
        self._validate("bm3d", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1, 2, 3, 4, 5, 6] + [None]
        self._validate("bm3d", profile == "-" or profile in valid_values, f"profile is not a valid value (expects: {valid_values}, got: {profile})")
        valid_values = [0, 1] + [None]
        self._validate("bm3d", d_max == "-" or d_max in valid_values, f"d_max is not a valid value (expects: {valid_values}, got: {d_max})")
        valid_values = [0, 1] + [None]
        self._validate("bm3d", t1d == "-" or t1d in valid_values, f"t1d is not a valid value (expects: {valid_values}, got: {t1d})")

    def _mock_bm3d_outputs(self, data_in: str, width, data_out: str, dtype = None, profile = None, looks = None, sigma = None, block_size = None, s_dist = None, step = None, d_max = None, t1d = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()

    def bm3d(self, data_in: str, width, data_out: str, dtype = None, profile = None, looks = None, sigma = None, block_size = None, s_dist = None, step = None, d_max = None, t1d = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.bm3d))

        if self.validate_inputs:
            self._validate_bm3d(*supplied_args)

        if self.mock_outputs:
            self._mock_bm3d_outputs(*supplied_args)

        return self._gamma_call("LAT", "bm3d", supplied_args)


    def _validate_restore_float(self, input = None):
        pass

    def _mock_restore_float_outputs(self, input = None):
        pass

    def restore_float(self, input = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.restore_float))

        if self.validate_inputs:
            self._validate_restore_float(*supplied_args)

        if self.mock_outputs:
            self._mock_restore_float_outputs(*supplied_args)

        return self._gamma_call("LAT", "restore_float", supplied_args)


    def _validate_haalpha(self, alpha: str, beta: str, gamma: str, SLC_par: str, anisotropy: str, entropy: str, lambda1: str, lambda2: str, lambda3: str, MLI_par: str, rlks, azlks, loff = None, nlines = None):
        if beta is not None:
            self._validate("haalpha", beta == "-" or Path(beta).exists(), f"beta path does not exist ({beta})")
        if gamma is not None:
            self._validate("haalpha", gamma == "-" or Path(gamma).exists(), f"gamma path does not exist ({gamma})")
        if SLC_par is not None:
            self._validate("haalpha", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_haalpha_outputs(self, alpha: str, beta: str, gamma: str, SLC_par: str, anisotropy: str, entropy: str, lambda1: str, lambda2: str, lambda3: str, MLI_par: str, rlks, azlks, loff = None, nlines = None):
        if alpha is not None and alpha != "-":
            Path(alpha).touch()
        if anisotropy is not None and anisotropy != "-":
            Path(anisotropy).touch()
        if entropy is not None and entropy != "-":
            Path(entropy).touch()
        if lambda1 is not None and lambda1 != "-":
            Path(lambda1).touch()
        if lambda2 is not None and lambda2 != "-":
            Path(lambda2).touch()
        if lambda3 is not None and lambda3 != "-":
            Path(lambda3).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()

    def haalpha(self, alpha: str, beta: str, gamma: str, SLC_par: str, anisotropy: str, entropy: str, lambda1: str, lambda2: str, lambda3: str, MLI_par: str, rlks, azlks, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.haalpha))

        if self.validate_inputs:
            self._validate_haalpha(*supplied_args)

        if self.mock_outputs:
            self._mock_haalpha_outputs(*supplied_args)

        return self._gamma_call("LAT", "haalpha", supplied_args)


    def _validate_wolf(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, J: str, J_par: str, rlks, azlks, loff = None, nlines = None):
        if SLC_1 is not None:
            self._validate("wolf", SLC_1 == "-" or Path(SLC_1).exists(), f"SLC_1 path does not exist ({SLC_1})")
        if SLC_2 is not None:
            self._validate("wolf", SLC_2 == "-" or Path(SLC_2).exists(), f"SLC_2 path does not exist ({SLC_2})")
        if SLC1_par is not None:
            self._validate("wolf", SLC1_par == "-" or Path(SLC1_par).exists(), f"SLC1_par path does not exist ({SLC1_par})")
        if SLC2_par is not None:
            self._validate("wolf", SLC2_par == "-" or Path(SLC2_par).exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_wolf_outputs(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, J: str, J_par: str, rlks, azlks, loff = None, nlines = None):
        if J is not None and J != "-":
            Path(J).touch()
        if J_par is not None and J_par != "-":
            Path(J_par).touch()

    def wolf(self, SLC_1: str, SLC_2: str, SLC1_par: str, SLC2_par: str, J: str, J_par: str, rlks, azlks, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.wolf))

        if self.validate_inputs:
            self._validate_wolf(*supplied_args)

        if self.mock_outputs:
            self._mock_wolf_outputs(*supplied_args)

        return self._gamma_call("LAT", "wolf", supplied_args)


    def _validate_takethat_dem_par(self, data_in, width, positions: str, DEM_par: str, report: str, mode = None, zero_flag = None, nn_flag = None, print_flag = None):
        if positions is not None:
            self._validate("takethat_dem_par", positions == "-" or Path(positions).exists(), f"positions path does not exist ({positions})")
        if DEM_par is not None:
            self._validate("takethat_dem_par", DEM_par == "-" or Path(DEM_par).exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_takethat_dem_par_outputs(self, data_in, width, positions: str, DEM_par: str, report: str, mode = None, zero_flag = None, nn_flag = None, print_flag = None):
        if report is not None and report != "-":
            Path(report).touch()

    def takethat_dem_par(self, data_in, width, positions: str, DEM_par: str, report: str, mode = None, zero_flag = None, nn_flag = None, print_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.takethat_dem_par))

        if self.validate_inputs:
            self._validate_takethat_dem_par(*supplied_args)

        if self.mock_outputs:
            self._mock_takethat_dem_par_outputs(*supplied_args)

        return self._gamma_call("LAT", "takethat_dem_par", supplied_args)


    def _validate_lee(self, input_data: str, output_data: str, width, nlooks, bx, by = None):
        if input_data is not None:
            self._validate("lee", input_data == "-" or Path(input_data).exists(), f"input_data path does not exist ({input_data})")

    def _mock_lee_outputs(self, input_data: str, output_data: str, width, nlooks, bx, by = None):
        if output_data is not None and output_data != "-":
            Path(output_data).touch()

    def lee(self, input_data: str, output_data: str, width, nlooks, bx, by = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lee))

        if self.validate_inputs:
            self._validate_lee(*supplied_args)

        if self.mock_outputs:
            self._mock_lee_outputs(*supplied_args)

        return self._gamma_call("LAT", "lee", supplied_args)


    def _validate_enh_lee(self, input_data: str, output_data: str, width, nlooks, damp, bx, by = None):
        if input_data is not None:
            self._validate("enh_lee", input_data == "-" or Path(input_data).exists(), f"input_data path does not exist ({input_data})")

    def _mock_enh_lee_outputs(self, input_data: str, output_data: str, width, nlooks, damp, bx, by = None):
        if output_data is not None and output_data != "-":
            Path(output_data).touch()

    def enh_lee(self, input_data: str, output_data: str, width, nlooks, damp, bx, by = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.enh_lee))

        if self.validate_inputs:
            self._validate_enh_lee(*supplied_args)

        if self.mock_outputs:
            self._mock_enh_lee_outputs(*supplied_args)

        return self._gamma_call("LAT", "enh_lee", supplied_args)


    def _validate_ratio(self, d1, d2, ratio: str, width, bx = None, by = None, wgt_flag = None):
        valid_values = [0, 1, 2] + [None]
        self._validate("ratio", wgt_flag == "-" or wgt_flag in valid_values, f"wgt_flag is not a valid value (expects: {valid_values}, got: {wgt_flag})")

    def _mock_ratio_outputs(self, d1, d2, ratio: str, width, bx = None, by = None, wgt_flag = None):
        if ratio is not None and ratio != "-":
            Path(ratio).touch()

    def ratio(self, d1, d2, ratio: str, width, bx = None, by = None, wgt_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ratio))

        if self.validate_inputs:
            self._validate_ratio(*supplied_args)

        if self.mock_outputs:
            self._mock_ratio_outputs(*supplied_args)

        return self._gamma_call("LAT", "ratio", supplied_args)


    def _validate_cc_ad(self, interf: str, pwr1: str, pwr2: str, slope: str, texture: str, cc_ad: str, width, box_min = None, box_max = None, wgt_flag = None, loff = None, nl = None):
        if interf is not None:
            self._validate("cc_ad", interf == "-" or Path(interf).exists(), f"interf path does not exist ({interf})")
        if pwr1 is not None:
            self._validate("cc_ad", pwr1 == "-" or Path(pwr1).exists(), f"pwr1 path does not exist ({pwr1})")
        if pwr2 is not None:
            self._validate("cc_ad", pwr2 == "-" or Path(pwr2).exists(), f"pwr2 path does not exist ({pwr2})")
        if slope is not None:
            self._validate("cc_ad", slope == "-" or Path(slope).exists(), f"slope path does not exist ({slope})")
        if texture is not None:
            self._validate("cc_ad", texture == "-" or Path(texture).exists(), f"texture path does not exist ({texture})")
        valid_values = [0, 1] + [None]
        self._validate("cc_ad", wgt_flag == "-" or wgt_flag in valid_values, f"wgt_flag is not a valid value (expects: {valid_values}, got: {wgt_flag})")

    def _mock_cc_ad_outputs(self, interf: str, pwr1: str, pwr2: str, slope: str, texture: str, cc_ad: str, width, box_min = None, box_max = None, wgt_flag = None, loff = None, nl = None):
        if cc_ad is not None and cc_ad != "-":
            Path(cc_ad).touch()

    def cc_ad(self, interf: str, pwr1: str, pwr2: str, slope: str, texture: str, cc_ad: str, width, box_min = None, box_max = None, wgt_flag = None, loff = None, nl = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cc_ad))

        if self.validate_inputs:
            self._validate_cc_ad(*supplied_args)

        if self.mock_outputs:
            self._mock_cc_ad_outputs(*supplied_args)

        return self._gamma_call("LAT", "cc_ad", supplied_args)


    def _validate_ras_ras(self, ras_in: str, ras_out: str, col_looks = None, row_looks = None, LR = None, r_lin_log = None, g_lin_log = None, b_lin_log = None, force24 = None):
        if ras_in is not None:
            self._validate("ras_ras", ras_in == "-" or Path(ras_in).exists(), f"ras_in path does not exist ({ras_in})")
        valid_values = [0, 1] + [None]
        self._validate("ras_ras", force24 == "-" or force24 in valid_values, f"force24 is not a valid value (expects: {valid_values}, got: {force24})")

    def _mock_ras_ras_outputs(self, ras_in: str, ras_out: str, col_looks = None, row_looks = None, LR = None, r_lin_log = None, g_lin_log = None, b_lin_log = None, force24 = None):
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()

    def ras_ras(self, ras_in: str, ras_out: str, col_looks = None, row_looks = None, LR = None, r_lin_log = None, g_lin_log = None, b_lin_log = None, force24 = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_ras))

        if self.validate_inputs:
            self._validate_ras_ras(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_ras_outputs(*supplied_args)

        return self._gamma_call("LAT", "ras_ras", supplied_args)


    def _validate_lin_comb_cpx(self, nfiles, f1: str, f2: str, constant_r = None):
        if f1 is not None:
            self._validate("lin_comb_cpx", f1 == "-" or Path(f1).exists(), f"f1 path does not exist ({f1})")
        if f2 is not None:
            self._validate("lin_comb_cpx", f2 == "-" or Path(f2).exists(), f"f2 path does not exist ({f2})")

    def _mock_lin_comb_cpx_outputs(self, nfiles, f1: str, f2: str, constant_r = None):
        pass

    def lin_comb_cpx(self, nfiles, f1: str, f2: str, constant_r = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lin_comb_cpx))

        if self.validate_inputs:
            self._validate_lin_comb_cpx(*supplied_args)

        if self.mock_outputs:
            self._mock_lin_comb_cpx_outputs(*supplied_args)

        return self._gamma_call("LAT", "lin_comb_cpx", supplied_args)


    def _validate_median_filter(self, din: str, dout: str, width, bx, by = None, min_pt = None, zflg = None):
        if din is not None:
            self._validate("median_filter", din == "-" or Path(din).exists(), f"din path does not exist ({din})")
        valid_values = [0, 1] + [None]
        self._validate("median_filter", zflg == "-" or zflg in valid_values, f"zflg is not a valid value (expects: {valid_values}, got: {zflg})")

    def _mock_median_filter_outputs(self, din: str, dout: str, width, bx, by = None, min_pt = None, zflg = None):
        if dout is not None and dout != "-":
            Path(dout).touch()

    def median_filter(self, din: str, dout: str, width, bx, by = None, min_pt = None, zflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.median_filter))

        if self.validate_inputs:
            self._validate_median_filter(*supplied_args)

        if self.mock_outputs:
            self._mock_median_filter_outputs(*supplied_args)

        return self._gamma_call("LAT", "median_filter", supplied_args)


    def _validate_takethat(self, data_in, width, positions: str, report: str, mode = None, zero_flag = None, nn_flag = None, print_flag = None):
        if positions is not None:
            self._validate("takethat", positions == "-" or Path(positions).exists(), f"positions path does not exist ({positions})")

    def _mock_takethat_outputs(self, data_in, width, positions: str, report: str, mode = None, zero_flag = None, nn_flag = None, print_flag = None):
        if report is not None and report != "-":
            Path(report).touch()

    def takethat(self, data_in, width, positions: str, report: str, mode = None, zero_flag = None, nn_flag = None, print_flag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.takethat))

        if self.validate_inputs:
            self._validate_takethat(*supplied_args)

        if self.mock_outputs:
            self._mock_takethat_outputs(*supplied_args)

        return self._gamma_call("LAT", "takethat", supplied_args)


    def _validate_cc_monitoring(self, nfiles, f1, f2, ras_out: str = None):
        pass

    def _mock_cc_monitoring_outputs(self, nfiles, f1, f2, ras_out: str = None):
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()

    def cc_monitoring(self, nfiles, f1, f2, ras_out: str = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cc_monitoring))

        if self.validate_inputs:
            self._validate_cc_monitoring(*supplied_args)

        if self.mock_outputs:
            self._mock_cc_monitoring_outputs(*supplied_args)

        return self._gamma_call("LAT", "cc_monitoring", supplied_args)


    def _validate_temp_log_var(self, data_tab, mean: str, stdev: str, width, waz = None, wr = None, wt_flag = None, zero_flag = None, loff = None, nlines = None):
        valid_values = [0, 1, 2] + [None]
        self._validate("temp_log_var", wt_flag == "-" or wt_flag in valid_values, f"wt_flag is not a valid value (expects: {valid_values}, got: {wt_flag})")
        valid_values = [0, 1] + [None]
        self._validate("temp_log_var", zero_flag == "-" or zero_flag in valid_values, f"zero_flag is not a valid value (expects: {valid_values}, got: {zero_flag})")

    def _mock_temp_log_var_outputs(self, data_tab, mean: str, stdev: str, width, waz = None, wr = None, wt_flag = None, zero_flag = None, loff = None, nlines = None):
        if mean is not None and mean != "-":
            Path(mean).touch()
        if stdev is not None and stdev != "-":
            Path(stdev).touch()

    def temp_log_var(self, data_tab, mean: str, stdev: str, width, waz = None, wr = None, wt_flag = None, zero_flag = None, loff = None, nlines = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.temp_log_var))

        if self.validate_inputs:
            self._validate_temp_log_var(*supplied_args)

        if self.mock_outputs:
            self._mock_temp_log_var_outputs(*supplied_args)

        return self._gamma_call("LAT", "temp_log_var", supplied_args)


    def _validate_ras_to_hsi(self, HUE: str, SATURATION: str, INTENSITY: str, ras_out: str, LR = None, cflg = None):
        if HUE is not None:
            self._validate("ras_to_hsi", HUE == "-" or Path(HUE).exists(), f"HUE path does not exist ({HUE})")
        if SATURATION is not None:
            self._validate("ras_to_hsi", SATURATION == "-" or Path(SATURATION).exists(), f"SATURATION path does not exist ({SATURATION})")
        if INTENSITY is not None:
            self._validate("ras_to_hsi", INTENSITY == "-" or Path(INTENSITY).exists(), f"INTENSITY path does not exist ({INTENSITY})")
        valid_values = [0, 1] + [None]
        self._validate("ras_to_hsi", cflg == "-" or cflg in valid_values, f"cflg is not a valid value (expects: {valid_values}, got: {cflg})")

    def _mock_ras_to_hsi_outputs(self, HUE: str, SATURATION: str, INTENSITY: str, ras_out: str, LR = None, cflg = None):
        if ras_out is not None and ras_out != "-":
            Path(ras_out).touch()

    def ras_to_hsi(self, HUE: str, SATURATION: str, INTENSITY: str, ras_out: str, LR = None, cflg = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_to_hsi))

        if self.validate_inputs:
            self._validate_ras_to_hsi(*supplied_args)

        if self.mock_outputs:
            self._mock_ras_to_hsi_outputs(*supplied_args)

        return self._gamma_call("LAT", "ras_to_hsi", supplied_args)


    def _validate_edge_detection(self, data_in: str, width, data_out: str, dtype = None, op_flg = None, sigma_x = None, sigma_y = None, T1 = None, T2 = None, min_seg_size = None, max_reg_len = None, max_reg_std = None, max_reg_dist = None, seg_out: str = None, line_filt = None, max_line_std = None):
        if data_in is not None:
            self._validate("edge_detection", data_in == "-" or Path(data_in).exists(), f"data_in path does not exist ({data_in})")
        valid_values = [0, 1] + [None]
        self._validate("edge_detection", dtype == "-" or dtype in valid_values, f"dtype is not a valid value (expects: {valid_values}, got: {dtype})")
        valid_values = [0, 1, 2] + [None]
        self._validate("edge_detection", op_flg == "-" or op_flg in valid_values, f"op_flg is not a valid value (expects: {valid_values}, got: {op_flg})")
        valid_values = [0, 1] + [None]
        self._validate("edge_detection", line_filt == "-" or line_filt in valid_values, f"line_filt is not a valid value (expects: {valid_values}, got: {line_filt})")

    def _mock_edge_detection_outputs(self, data_in: str, width, data_out: str, dtype = None, op_flg = None, sigma_x = None, sigma_y = None, T1 = None, T2 = None, min_seg_size = None, max_reg_len = None, max_reg_std = None, max_reg_dist = None, seg_out: str = None, line_filt = None, max_line_std = None):
        if data_out is not None and data_out != "-":
            Path(data_out).touch()
        if seg_out is not None and seg_out != "-":
            Path(seg_out).touch()

    def edge_detection(self, data_in: str, width, data_out: str, dtype = None, op_flg = None, sigma_x = None, sigma_y = None, T1 = None, T2 = None, min_seg_size = None, max_reg_len = None, max_reg_std = None, max_reg_dist = None, seg_out: str = None, line_filt = None, max_line_std = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.edge_detection))

        if self.validate_inputs:
            self._validate_edge_detection(*supplied_args)

        if self.mock_outputs:
            self._mock_edge_detection_outputs(*supplied_args)

        return self._gamma_call("LAT", "edge_detection", supplied_args)


    def _validate_texture(self, data_in, format_flag, texture: str, width, type = None, bx = None, by = None, r_looks = None, az_looks = None, weights_flag = None, data_in_mean = None):
        valid_values = [0, 1] + [None]
        self._validate("texture", type == "-" or type in valid_values, f"type is not a valid value (expects: {valid_values}, got: {type})")
        valid_values = [0, 1, 2] + [None]
        self._validate("texture", weights_flag == "-" or weights_flag in valid_values, f"weights_flag is not a valid value (expects: {valid_values}, got: {weights_flag})")

    def _mock_texture_outputs(self, data_in, format_flag, texture: str, width, type = None, bx = None, by = None, r_looks = None, az_looks = None, weights_flag = None, data_in_mean = None):
        if texture is not None and texture != "-":
            Path(texture).touch()

    def texture(self, data_in, format_flag, texture: str, width, type = None, bx = None, by = None, r_looks = None, az_looks = None, weights_flag = None, data_in_mean = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.texture))

        if self.validate_inputs:
            self._validate_texture(*supplied_args)

        if self.mock_outputs:
            self._mock_texture_outputs(*supplied_args)

        return self._gamma_call("LAT", "texture", supplied_args)


    def _validate_diplane_helix(self, LL: str, RR: str, SLC_par: str, diplane: str, helix: str, MLI_par: str, rlks, azlks, loff = None, nlines = None, scale = None):
        if LL is not None:
            self._validate("diplane_helix", LL == "-" or Path(LL).exists(), f"LL path does not exist ({LL})")
        if RR is not None:
            self._validate("diplane_helix", RR == "-" or Path(RR).exists(), f"RR path does not exist ({RR})")
        if SLC_par is not None:
            self._validate("diplane_helix", SLC_par == "-" or Path(SLC_par).exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_diplane_helix_outputs(self, LL: str, RR: str, SLC_par: str, diplane: str, helix: str, MLI_par: str, rlks, azlks, loff = None, nlines = None, scale = None):
        if diplane is not None and diplane != "-":
            Path(diplane).touch()
        if helix is not None and helix != "-":
            Path(helix).touch()
        if MLI_par is not None and MLI_par != "-":
            Path(MLI_par).touch()

    def diplane_helix(self, LL: str, RR: str, SLC_par: str, diplane: str, helix: str, MLI_par: str, rlks, azlks, loff = None, nlines = None, scale = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.diplane_helix))

        if self.validate_inputs:
            self._validate_diplane_helix(*supplied_args)

        if self.mock_outputs:
            self._mock_diplane_helix_outputs(*supplied_args)

        return self._gamma_call("LAT", "diplane_helix", supplied_args)


    def _validate_lin_comb_ref(self, f1, f2, constant, factor1, factor2, f_out: str, width, roff = None, loff = None, nr = None, nl = None, zflag = None):
        valid_values = [0, 1] + [None]
        self._validate("lin_comb_ref", zflag == "-" or zflag in valid_values, f"zflag is not a valid value (expects: {valid_values}, got: {zflag})")

    def _mock_lin_comb_ref_outputs(self, f1, f2, constant, factor1, factor2, f_out: str, width, roff = None, loff = None, nr = None, nl = None, zflag = None):
        if f_out is not None and f_out != "-":
            Path(f_out).touch()

    def lin_comb_ref(self, f1, f2, constant, factor1, factor2, f_out: str, width, roff = None, loff = None, nr = None, nl = None, zflag = None):
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lin_comb_ref))

        if self.validate_inputs:
            self._validate_lin_comb_ref(*supplied_args)

        if self.mock_outputs:
            self._mock_lin_comb_ref_outputs(*supplied_args)

        return self._gamma_call("LAT", "lin_comb_ref", supplied_args)

