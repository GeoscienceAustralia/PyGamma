from typing import Sequence, NamedTuple, Dict, Optional, Any, Tuple, Union, List
from collections import Counter
from pathlib import Path
from copy import copy
import inspect

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# WARNING: This file is automatically generated !
# See utils/gamma_usage2py.py
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

PyGammaCall = NamedTuple("PyGammaCall", [("module", str), ("program", str), ("parameters", List[str]), ("status", int)])


class SimpleParFile(object):
    values: Dict[str, str] = {}

    def __init__(self, path: Path) -> None:
        with open(path, "r") as file:
            lines = file.read().splitlines()[1:]  # Skip header lines

            for line in lines:
                value_id = line.split(":")[0]
                if len(value_id.strip()) == 0:
                    continue

                value_data = line[len(value_id) + 2 :].strip()

                self.values[value_id] = value_data

    def get_value(self, value_id: str, dtype: Any = str, index: Optional[int] = None) -> Union[Any, List[Any]]:
        def attempt_convert(val: Any) -> Any:
            try:
                return dtype(val)
            except:
                return val

        if index is not None:
            return attempt_convert(self.values[value_id].split()[index])
        else:
            return [attempt_convert(i) for i in self.values[value_id].split()]


class PyGammaProxy(object):
    ParFile = SimpleParFile

    validate_inputs: bool = True
    mock_outputs: bool = False

    call_sequence: List[PyGammaCall]
    call_count: Counter
    error_count: int

    exception_type: Optional[type]
    wraps: Optional[object]
    fail_reason: Optional[str]

    def __init__(self, exception_type: Optional[type] = None, wraps: Optional[object] = None) -> None:
        self.reset_proxy()
        self.exception_type = exception_type
        self.wraps = wraps

    def reset_proxy(self) -> None:
        self.call_sequence = []
        self.call_count = Counter()
        self.error_count = 0
        self.fail_reason = None

    def _validate(self, cmd: str, is_valid: bool, fail_reason: Optional[str]) -> None:
        if not is_valid:
            stat = -1
            self.fail_reason = fail_reason
            raise ValueError(f"Invaid pg.{cmd} parameters ({self.fail_reason})")

    def _on_error(self, cmd: str, params: List[str], status: Optional[int] = None) -> None:
        if status is None or status == 0:
            return

        if self.exception_type is None:
            return

        raise self.exception_type(f"failed to execute pg.{cmd} ({self.fail_reason})")

    def _gamma_call(self, gamma_module: str, gamma_program: str, program_args: List[str]) -> Tuple[int, str, str]:
        result = (0, "", "")

        if self.wraps is not None:
            result = getattr(self.wraps, gamma_program)(*program_args)

        self.call_count[gamma_program] += 1
        self.call_sequence.append(PyGammaCall(gamma_module, gamma_program, program_args, result[0]))
        self._on_error(gamma_program, program_args, result[0])

        return result

    def _clean_call_args(self, values: Dict[str, Any], sig: inspect.Signature) -> List[str]:
        cleaned = []
        for arg in sig.parameters.keys():
            value = copy(values[arg])
            if value is None:
                cleaned.append("-")
            else:
                cleaned.append(str(value))
        while cleaned[-1] == "-":
            cleaned.pop()
        return cleaned

    def _validate_gc_map_fine(
        self, gc_in: Path, width: int, DIFF_par: Path, gc_out: Path, ref_flg: Optional[int] = None
    ) -> None:
        self._validate("gc_map_fine", gc_in.exists(), f"gc_in path does not exist ({gc_in})")

    def _mock_gc_map_fine_outputs(
        self, gc_in: Path, width: int, DIFF_par: Path, gc_out: Path, ref_flg: Optional[int] = None
    ) -> None:
        if gc_out is not None and str(gc_out) != "-":
            gc_out.touch()

    def gc_map_fine(
        self, gc_in: Path, width: int, DIFF_par: Path, gc_out: Path, ref_flg: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Geocoding lookup table refinement using DIFF_par offset polynomials


        input parameters:
          gc_in     (input) geocoding lookup table
          width     width of geocoding lookup table (samples)
          DIFF_par  DIFF/GEO parameter file containing offset polynomial coefficients
          gc_out    (output) refined geocoding lookup table
          ref_flg   reference image flag (offsets are measured relative to the reference image):
                      0: actual SAR image
                      1: simulated SAR image (default)
        """
        if self.validate_inputs:
            self._validate_gc_map_fine(gc_in, width, DIFF_par, gc_out, ref_flg)
        if self.mock_outputs:
            self._mock_gc_map_fine_outputs(gc_in, width, DIFF_par, gc_out, ref_flg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map_fine))
        return self._gamma_call("DIFF", "gc_map_fine", supplied_args)

    def _validate_diff_ls_fit(
        self,
        unw_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
    ) -> None:
        self._validate("diff_ls_fit", unw_1.exists(), f"unw_1 path does not exist ({unw_1})")
        self._validate("diff_ls_fit", unw_2.exists(), f"unw_2 path does not exist ({unw_2})")
        self._validate("diff_ls_fit", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_diff_ls_fit_outputs(
        self,
        unw_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
    ) -> None:
        if plot_data is not None and str(plot_data) != "-":
            plot_data.touch()

    def diff_ls_fit(
        self,
        unw_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Three-pass differential interferometry SVD to solve for the the L.S.offset


        input parameters:
          unw-1      (input) unwrapped interferogram 1
          unw-2      (input) unwrapped interferogram 2
          DIFF_par   (input)) DIFF/GEO parameter file for the scene
          nr         number of range samples (default=32)
          naz        number of azimuth samples (default=32)
          mask       mask (SUN/BMP/TIFF raster format), 0 valued pixels are excluded for fit (enter - for none)
          plot_data  (output) plot data file compatible with xmgr

        """
        if self.validate_inputs:
            self._validate_diff_ls_fit(unw_1, unw_2, DIFF_par, nr, naz, mask, plot_data)
        if self.mock_outputs:
            self._mock_diff_ls_fit_outputs(unw_1, unw_2, DIFF_par, nr, naz, mask, plot_data)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.diff_ls_fit))
        return self._gamma_call("DIFF", "diff_ls_fit", supplied_args)

    def _validate_WSS_mosaic(self, WSS_tab: Path, MLI_par: Path, WSS_data: Path, type: int) -> None:
        self._validate("WSS_mosaic", WSS_tab.exists(), f"WSS_tab path does not exist ({WSS_tab})")

    def _mock_WSS_mosaic_outputs(self, WSS_tab: Path, MLI_par: Path, WSS_data: Path, type: int) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if WSS_data is not None and str(WSS_data) != "-":
            WSS_data.touch()

    def WSS_mosaic(self, WSS_tab: Path, MLI_par: Path, WSS_data: Path, type: int) -> Tuple[int, str, str]:
        """

        Mosaic ASAR WSS interferograms and MLI data


        input parameters:
          WSS_tab   (input) two column list of MLI data files and MLI image parameter files for each sub-swath (including paths)
                            required file order: SS1, SS2, SS3, SS4, SS5
          MLI_par   (output) ISP image parameter file for the mosaicked WSS MLI image or interferogram
          WSS_data  (output) WSS mosaicked MLI image or interferogram
          type      WSS data type:
                      0: FLOAT
                      1: FCOMPLEX

        """
        if self.validate_inputs:
            self._validate_WSS_mosaic(WSS_tab, MLI_par, WSS_data, type)
        if self.mock_outputs:
            self._mock_WSS_mosaic_outputs(WSS_tab, MLI_par, WSS_data, type)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.WSS_mosaic))
        return self._gamma_call("DIFF", "WSS_mosaic", supplied_args)

    def _validate_dispmap_vec_offset(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap_r: Path,
        dispmap_az: Path,
        lv_theta: Path,
        lv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Any] = None,
        mode: Optional[int] = None,
        ax_north: Optional[Any] = None,
        ax_east: Optional[Any] = None,
    ) -> None:
        self._validate("dispmap_vec_offset", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("dispmap_vec_offset", DEM.exists(), f"DEM path does not exist ({DEM})")
        self._validate("dispmap_vec_offset", dispmap_r.exists(), f"dispmap_r path does not exist ({dispmap_r})")
        self._validate("dispmap_vec_offset", dispmap_az.exists(), f"dispmap_az path does not exist ({dispmap_az})")
        self._validate("dispmap_vec_offset", lv_theta.exists(), f"lv_theta path does not exist ({lv_theta})")
        self._validate("dispmap_vec_offset", lv_phi.exists(), f"lv_phi path does not exist ({lv_phi})")

    def _mock_dispmap_vec_offset_outputs(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap_r: Path,
        dispmap_az: Path,
        lv_theta: Path,
        lv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Any] = None,
        mode: Optional[int] = None,
        ax_north: Optional[Any] = None,
        ax_east: Optional[Any] = None,
    ) -> None:
        if dv_norm is not None and str(dv_norm) != "-":
            dv_norm.touch()
        if dv_theta is not None and str(dv_theta) != "-":
            dv_theta.touch()
        if dv_phi is not None and str(dv_phi) != "-":
            dv_phi.touch()
        if dv_x is not None and str(dv_x) != "-":
            dv_x.touch()
        if dv_y is not None and str(dv_y) != "-":
            dv_y.touch()
        if dv_z is not None and str(dv_z) != "-":
            dv_z.touch()

    def dispmap_vec_offset(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap_r: Path,
        dispmap_az: Path,
        lv_theta: Path,
        lv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Any] = None,
        mode: Optional[int] = None,
        ax_north: Optional[Any] = None,
        ax_east: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculation of displacement vector field from slant-range/azimuth offsets (slant-range/azimuth)


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          DEM         (input) DEM data file (or constant height value)
          dispmap_r   (input) slant-range displacement map (m) (float)
          dispmap_az  (input) azimuth displacement map (m) (float)
          lv_theta    (input) look-vector elevation angle file or constant value in deg. (float)
          lv_phi      (input) look-vector orientation angle file or constant value in deg. (float)
          dv_norm     (output) norm of 3-dim displacement vector (float)
          dv_theta    (output) elevation angle of 3-dim displacement vector (float)
          dv_phi      (output) orientation angle of 3-dim displacement vector file or constant value deg. (float)
          dv_x        (output) easting  component of 3-dim displacement vector (float)
          dv_y        (output) northing component of 3-dim displacement vector (float)
          dv_z        (output) vertical component of 3-dim displacement vector (float)
          mask_angle  cutoff angle in degrees between the look and normal vectors to mask inaccurate results (default: 2)
          mode        displacement model mode (default=0):
                        0: displacement along terrain surface
                        1: displacement towards center axis
          ax_north    displacement center axis northing or latitude S
          ax_east     displacement center axis easting or longitude S

          NOTE: select - to avoid creation of the corresponding output file

        """
        if self.validate_inputs:
            self._validate_dispmap_vec_offset(
                DEM_par,
                DEM,
                dispmap_r,
                dispmap_az,
                lv_theta,
                lv_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
                mode,
                ax_north,
                ax_east,
            )
        if self.mock_outputs:
            self._mock_dispmap_vec_offset_outputs(
                DEM_par,
                DEM,
                dispmap_r,
                dispmap_az,
                lv_theta,
                lv_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
                mode,
                ax_north,
                ax_east,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_vec_offset))
        return self._gamma_call("DIFF", "dispmap_vec_offset", supplied_args)

    def _validate_create_diff_par(
        self,
        PAR_1: Path,
        PAR_2: Optional[Path],
        DIFF_par: Path,
        PAR_type: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        self._validate("create_diff_par", PAR_1.exists(), f"PAR_1 path does not exist ({PAR_1})")
        if PAR_2 is not None:
            self._validate("create_diff_par", PAR_2.exists(), f"PAR_2 path does not exist ({PAR_2})")

    def _mock_create_diff_par_outputs(
        self,
        PAR_1: Path,
        PAR_2: Optional[Path],
        DIFF_par: Path,
        PAR_type: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        if not DIFF_par.exists():
            DIFF_par.touch()

    def create_diff_par(
        self,
        PAR_1: Path,
        PAR_2: Optional[Path],
        DIFF_par: Path,
        PAR_type: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Create DIFF/GEO parameter file for geocoding and differential interferometry


        input parameters:
          PAR-1     (input) image parameter file 1 (see PAR_type option)
          PAR-2     (input) image parameter file 2 (or - if not provided)
          DIFF_par  (input/output) DIFF/GEO parameter file
          PAR_type  PAR-1 and PAR-2 parameter file type (enter - for default):
                      0: OFF_par     ISP offset and interferogram parameters  (default)
                      1: SLC/MLI_par ISP SLC/MLI parameters
                      2: DEM_par     DIFF/GEO DEM parameters
          iflg      interactive mode flag (enter -  for default)
                      0: non-interactive
                      1: interactive (default)

        """
        if self.validate_inputs:
            self._validate_create_diff_par(PAR_1, PAR_2, DIFF_par, PAR_type, iflg)
        if self.mock_outputs:
            self._mock_create_diff_par_outputs(PAR_1, PAR_2, DIFF_par, PAR_type, iflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_diff_par))
        return self._gamma_call("DIFF", "create_diff_par", supplied_args)

    def _validate_gc_map_grd(self, MLI_par: Path, DEM_par: Path, DEM: Path, DEM_seg_par: Path) -> None:
        self._validate("gc_map_grd", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("gc_map_grd", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("gc_map_grd", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_gc_map_grd_outputs(self, MLI_par: Path, DEM_par: Path, DEM: Path, DEM_seg_par: Path) -> None:
        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

    def gc_map_grd(self, MLI_par: Path, DEM_par: Path, DEM: Path, DEM_seg_par: Path) -> Tuple[int, str, str]:
        """

        Calculate lookup table and DEM related products for terrain-corrected geocoding of ground range images
        Derive DEM products in DEM/MAP geometry:
                   local normal spherical angles, u, v
                   simulated SAR intensity (in map geometry), simsar
                   local incidence angle, linc
                   projection angle, psi
                   pixel area normalization factor, pix
                   layover / shadow map, ls_map


        input parameters:
          GRD_par         (input) ground-range image ISP parameter file (format as SLC/MLI_par)
          DEM_par         (input) DEM/MAP parameter file
          DEM             (input) DEM data file (or constant height value)
          DEM_seg_par     (input/output) DEM/MAP segment parameter file used for output products

          NOTE: If the DEM_seg_par already exists, then the output DEM parameters will be read from this file
                otherwise they are estimated from the image data.

          DEM_seg         (output) DEM segment used for output products, interpolated if lat_ovr > 1.0  or lon_ovr > 1.0
          lookup_table    (output) geocoding lookup table (fcomplex)
          lat_ovr         latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr         longitude or easting output DEM oversampling factor (enter - for default: 1.0)
          sim_sar         (output) simulated SAR backscatter image in DEM geometry
          u               (output) zenith angle of surface normal vector n (angle between z and n)
          v               (output) orientation angle of n (between x and projection of n in xy plane)
          inc             (output) local incidence angle (between surface normal and look vector)
          psi             (output) projection angle (between surface normal and image plane normal)
          pix             (output) pixel area normalization factor
          ls_map          (output) layover and shadow map (in map projection)
          frame           number of DEM pixels to add around area covered by SAR image (enter - for default = 8)
          ls_mode         output lookup table values in regions of layover, shadow, or DEM gaps (enter - for default)
                            0: set to (0.,0.)
                            1: linear interpolation across these regions (default)
                            2: actual value
                            3: nn-thinned
          r_ovr           range over-sampling factor for nn-thinned layover/shadow mode(enter - for default: 2.0)

        NOTE: enter - as output filename to avoid creating the corresponding output file

        """
        if self.validate_inputs:
            self._validate_gc_map_grd(MLI_par, DEM_par, DEM, DEM_seg_par)
        if self.mock_outputs:
            self._mock_gc_map_grd_outputs(MLI_par, DEM_par, DEM, DEM_seg_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map_grd))
        return self._gamma_call("DIFF", "gc_map_grd", supplied_args)

    def _validate_coord_trans_list(
        self,
        c_in_list: Path,
        c_out_list: Path,
        DEM1_par: Path,
        DEM2_par: Path,
        geoid1: Optional[Path] = None,
        geoid1_par: Optional[Path] = None,
        geoid1_type: Optional[int] = None,
        geoid2: Optional[Path] = None,
        geoid2_par: Optional[Path] = None,
        geoid2_type: Optional[int] = None,
        c_xyz_list: Optional[Path] = None,
    ) -> None:
        self._validate("coord_trans_list", c_in_list.exists(), f"c_in_list path does not exist ({c_in_list})")
        self._validate("coord_trans_list", DEM1_par.exists(), f"DEM1_par path does not exist ({DEM1_par})")
        self._validate("coord_trans_list", DEM2_par.exists(), f"DEM2_par path does not exist ({DEM2_par})")
        if geoid1 is not None:
            self._validate("coord_trans_list", geoid1.exists(), f"geoid1 path does not exist ({geoid1})")
        if geoid1_par is not None:
            self._validate("coord_trans_list", geoid1_par.exists(), f"geoid1_par path does not exist ({geoid1_par})")
        if geoid2 is not None:
            self._validate("coord_trans_list", geoid2.exists(), f"geoid2 path does not exist ({geoid2})")
        if geoid2_par is not None:
            self._validate("coord_trans_list", geoid2_par.exists(), f"geoid2_par path does not exist ({geoid2_par})")

    def _mock_coord_trans_list_outputs(
        self,
        c_in_list: Path,
        c_out_list: Path,
        DEM1_par: Path,
        DEM2_par: Path,
        geoid1: Optional[Path] = None,
        geoid1_par: Optional[Path] = None,
        geoid1_type: Optional[int] = None,
        geoid2: Optional[Path] = None,
        geoid2_par: Optional[Path] = None,
        geoid2_type: Optional[int] = None,
        c_xyz_list: Optional[Path] = None,
    ) -> None:
        if c_out_list is not None and str(c_out_list) != "-":
            c_out_list.touch()
        if c_xyz_list is not None and str(c_xyz_list) != "-":
            c_xyz_list.touch()

    def coord_trans_list(
        self,
        c_in_list: Path,
        c_out_list: Path,
        DEM1_par: Path,
        DEM2_par: Path,
        geoid1: Optional[Path] = None,
        geoid1_par: Optional[Path] = None,
        geoid1_type: Optional[int] = None,
        geoid2: Optional[Path] = None,
        geoid2_par: Optional[Path] = None,
        geoid2_type: Optional[int] = None,
        c_xyz_list: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Coordinate transformation between map projections for list of points


        input parameters:
          c_in_list     (input) list of map coordinates and heights with 3 columns:
                          northing/latitude  easting/longitude  height
          c_out_list    (output) list of map coordinates and heights with 3 columns:
                          northing/latitude  easting/longitude  height
          DEM1_par      (input) DIFF/GEO DEM parameter file with definition of input coordinate system
          DEM2_par      (input) DIFF/GEO DEM parameter file with definition of output coordinate system
          geoid1        (input) geoid or constant geoid height value of input coordinate system (enter - for none)
          geoid1_par    (input) geoid DEM_par file of input coordinate system (enter - for none)
          geoid1_type   geoid1 type (enter - for default)
                          0: global geoid in EQA coordinates (default)
                          1: local geoid in the same coordinate system as the input coordinates (DEM1_par)
          geoid2        (input) geoid or constant geoid height value of output coordinate system (enter - for none)
          geoid2_par    (input) geoid DEM_par file of output coordinate system (enter - for none)
          geoid2_type   geoid2 type (enter - for default)
                          0: global geoid in EQA coordinates (default)
                          1: local geoid in the same coordinate system as the output coordinates (DEM2_par)
          c_xyz_list    (output) list of global (WGS84) Cartesian coordinates with 3 columns:
                          X  Y  Z (enter - for none)
          NOTE: geoid1 and geoid2 are used to transform the height from an altitude relative to the sea level
                (i.e. above the geoid) to an altitude relative to the ellipsoid of the coordinate system and vice versa
                EGM96 global geoid is available as "$DIFF_HOME/scripts/egm96.dem" and "$DIFF_HOME/scripts/egm96.dem_par"
                EGM2008 global geoid is available as "$DIFF_HOME/scripts/egm2008-5.dem" and "$DIFF_HOME/scripts/egm2008-5.dem_par"

        """
        if self.validate_inputs:
            self._validate_coord_trans_list(
                c_in_list,
                c_out_list,
                DEM1_par,
                DEM2_par,
                geoid1,
                geoid1_par,
                geoid1_type,
                geoid2,
                geoid2_par,
                geoid2_type,
                c_xyz_list,
            )
        if self.mock_outputs:
            self._mock_coord_trans_list_outputs(
                c_in_list,
                c_out_list,
                DEM1_par,
                DEM2_par,
                geoid1,
                geoid1_par,
                geoid1_type,
                geoid2,
                geoid2_par,
                geoid2_type,
                c_xyz_list,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.coord_trans_list))
        return self._gamma_call("DIFF", "coord_trans_list", supplied_args)

    def _validate_multi_mosaic(
        self, data_tab: Path, data_out: Path, DEM_par_out: Path, mode: int, format_flag: int
    ) -> None:
        self._validate("multi_mosaic", data_tab.exists(), f"data_tab path does not exist ({data_tab})")

    def _mock_multi_mosaic_outputs(
        self, data_tab: Path, data_out: Path, DEM_par_out: Path, mode: int, format_flag: int
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()
        if DEM_par_out is not None and str(DEM_par_out) != "-":
            DEM_par_out.touch()

    def multi_mosaic(
        self, data_tab: Path, data_out: Path, DEM_par_out: Path, mode: int, format_flag: int
    ) -> Tuple[int, str, str]:
        """

        Mosaic geocoded images or DEM data with same format, map projection, and pixel spacing parameters
        Supported formats: float, fcomplex, int, short, unsigned char, SUN raster, and BMP image files


        input parameters:
          data_tab     (input) list of data to mosaic (2 columns), one line for each input data file (text format):
                         data   DEM_par
          data_out     (output) output data file
          DEM_par_out  (output) DEM parameter file of output data file
                         NOTE: If this file exists, then the bounds of the mosaic are read from the parameter file,
                         otherwise bounds including all input data will be computed and written to the parameter file
          mode         mosaic processing mode
                         0: value of prior image preferred in the case of multiple valid input values
                         1: average of multiple valid input values calculated
          format_flag  input/output data format flag
                         0: FLOAT (REAL*4)
                         1: FCOMPLEX (pairs of float)
                         2: INTEGER (INTEGER*4)
                         3: SHORT (INTEGER*2)
                         4: UNSIGNED CHAR
                         5: SUN raster, BMP, or TIFF image files (8 or 24 bit)

        """
        if self.validate_inputs:
            self._validate_multi_mosaic(data_tab, data_out, DEM_par_out, mode, format_flag)
        if self.mock_outputs:
            self._mock_multi_mosaic_outputs(data_tab, data_out, DEM_par_out, mode, format_flag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_mosaic))
        return self._gamma_call("DIFF", "multi_mosaic", supplied_args)

    def _validate_gc_map1(self, MLI_par: Path, OFF_par: Path, DEM_par: Path, DEM: Path, DEM_seg_par: Path) -> None:
        self._validate("gc_map1", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("gc_map1", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("gc_map1", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("gc_map1", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_gc_map1_outputs(self, MLI_par: Path, OFF_par: Path, DEM_par: Path, DEM: Path, DEM_seg_par: Path) -> None:
        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

    def gc_map1(
        self, MLI_par: Path, OFF_par: Path, DEM_par: Path, DEM: Path, DEM_seg_par: Path
    ) -> Tuple[int, str, str]:
        """

        Calculate terrain-geocoding lookup table and DEM derived data products


        input parameters:
          MLI_par         (input) ISP MLI or SLC image parameter file (slant range geometry)
          OFF_par         (input) ISP offset/interferogram parameter file (enter - if geocoding SLC or MLI data)
          DEM_par         (input) DEM/MAP parameter file
          DEM             (input) DEM data file (or constant height value)
          DEM_seg_par     (input/output) DEM/MAP segment parameter file used for output products

          NOTE: If <DEM_seg_par> already exists, then the output DEM parameters will be read
                from this file, otherwise they are estimated from the image data.
                If <DEM_par> and <DEM_seg_par> are the same file, <DEM_seg> is ignored.

          DEM_seg         (output) DEM segment used for output products, interpolated if lat_ovr > 1.0 or lon_ovr > 1.0
          lookup_table    (output) geocoding lookup table (fcomplex)
          lat_ovr         latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr         longitude or easting output DEM oversampling factor (enter - for default: 1.0)
          sim_sar         (output) simulated SAR backscatter image in DEM geometry
          u               (output) zenith angle of surface normal vector n (angle between z and n)
          v               (output) orientation angle of n (between x and projection of n in xy plane)
          inc             (output) local incidence angle (between surface normal and look vector)
          psi             (output) projection angle (between surface normal and image plane normal)
          pix             (output) pixel area normalization factor
          ls_map          (output) layover and shadow map (in map projection)
          frame           number of DEM pixels to add around area covered by SAR image (enter - for default = 8)
          ls_mode         output lookup table values in regions of layover, shadow, or DEM gaps (enter - for default)
                            0: set to (0.,0.)
                            1: linear interpolation across these regions
                            2: actual value (default)
                            3: nn-thinned
          r_ovr           range over-sampling factor for nn-thinned layover/shadow mode(enter - for default: 2.0)

        NOTE: enter - as output filename to avoid creating the corresponding output file

        """
        if self.validate_inputs:
            self._validate_gc_map1(MLI_par, OFF_par, DEM_par, DEM, DEM_seg_par)
        if self.mock_outputs:
            self._mock_gc_map1_outputs(MLI_par, OFF_par, DEM_par, DEM, DEM_seg_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map1))
        return self._gamma_call("DIFF", "gc_map1", supplied_args)

    def _validate_SLC_diff_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        sim_unw: Path,
        diff_int: Path,
        rlks: int,
        azlks: int,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rbw_min: Optional[int] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
    ) -> None:
        self._validate("SLC_diff_intf", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("SLC_diff_intf", SLC_2R.exists(), f"SLC_2R path does not exist ({SLC_2R})")
        self._validate("SLC_diff_intf", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("SLC_diff_intf", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        self._validate("SLC_diff_intf", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("SLC_diff_intf", sim_unw.exists(), f"sim_unw path does not exist ({sim_unw})")

    def _mock_SLC_diff_intf_outputs(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        sim_unw: Path,
        diff_int: Path,
        rlks: int,
        azlks: int,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rbw_min: Optional[int] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
    ) -> None:
        if diff_int is not None and str(diff_int) != "-":
            diff_int.touch()

    def SLC_diff_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        sim_unw: Path,
        diff_int: Path,
        rlks: int,
        azlks: int,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rbw_min: Optional[int] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Differential interferogram generation from co-registered SLCs and a simulated interferogram


        input parameters:
          SLC-1      (input) single-look complex image 1 (reference)
          SLC-2R     (input) single-look complex image 2 coregistered to SLC-1
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2R_par  (input) SLC-2R ISP image parameter file for the co-registered image
          OFF_par    (input) ISP offset/interferogram parameter file
          sim_unw    (input) simulated unflattened and unwrapped interferogram, same width as output interferogram (float)
          diff_int   (output) differential interferogram (complex)
          rlks       number of range looks for the output interferogram
          azlks      number of azimuth looks for the simulated and output interferogram
          sps_flg    range spectral shift flag (enter - for default)
                       1: apply range spectral shift filter (default)
                       0: do not apply range spectral shift filter
          azf_flg    azimuth common band filter flag (enter - for default)
                       1: apply azimuth common band filter (default)
                       0: do not apply azimuth common band filter
          rbw_min    minimum range bandwidth fraction (0.1 --> 1.0) (enter - for default:  0.250)
          rp1_flg    SLC-1 range phase mode (enter - for default)
                       0: nearest approach (0-Doppler) phase
                       1: ref. function center (Doppler centroid) (default)
          rp2_flg    SLC-2 range phase mode (enter - for default)
                       0: nearest approach (0-Doppler) phase
                       1: ref. function center (Doppler centroid) (default)

        """
        if self.validate_inputs:
            self._validate_SLC_diff_intf(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                sim_unw,
                diff_int,
                rlks,
                azlks,
                sps_flg,
                azf_flg,
                rbw_min,
                rp1_flg,
                rp2_flg,
            )
        if self.mock_outputs:
            self._mock_SLC_diff_intf_outputs(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                sim_unw,
                diff_int,
                rlks,
                azlks,
                sps_flg,
                azf_flg,
                rbw_min,
                rp1_flg,
                rp2_flg,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_diff_intf))
        return self._gamma_call("DIFF", "SLC_diff_intf", supplied_args)

    def _validate_pixel_area(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lookup_table: Path,
        ls_map: Path,
        inc_map: Path,
        pix_sigma0: Path,
        pix_gamma0: Optional[Path] = None,
        nstep: Optional[Path] = None,
        area_fact: Optional[Any] = None,
        sigma0_ratio: Optional[Path] = None,
        gamma0_ratio: Optional[Path] = None,
        sig2gam_ratio: Optional[Path] = None,
        hgt: Optional[Path] = None,
    ) -> None:
        self._validate("pixel_area", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("pixel_area", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("pixel_area", DEM.exists(), f"DEM path does not exist ({DEM})")
        self._validate("pixel_area", lookup_table.exists(), f"lookup_table path does not exist ({lookup_table})")
        self._validate("pixel_area", ls_map.exists(), f"ls_map path does not exist ({ls_map})")
        self._validate("pixel_area", inc_map.exists(), f"inc_map path does not exist ({inc_map})")

    def _mock_pixel_area_outputs(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lookup_table: Path,
        ls_map: Path,
        inc_map: Path,
        pix_sigma0: Path,
        pix_gamma0: Optional[Path] = None,
        nstep: Optional[Path] = None,
        area_fact: Optional[Any] = None,
        sigma0_ratio: Optional[Path] = None,
        gamma0_ratio: Optional[Path] = None,
        sig2gam_ratio: Optional[Path] = None,
        hgt: Optional[Path] = None,
    ) -> None:
        if pix_sigma0 is not None and str(pix_sigma0) != "-":
            pix_sigma0.touch()
        if pix_gamma0 is not None and str(pix_gamma0) != "-":
            pix_gamma0.touch()
        if sigma0_ratio is not None and str(sigma0_ratio) != "-":
            sigma0_ratio.touch()
        if gamma0_ratio is not None and str(gamma0_ratio) != "-":
            gamma0_ratio.touch()
        if sig2gam_ratio is not None and str(sig2gam_ratio) != "-":
            sig2gam_ratio.touch()
        if hgt is not None and str(hgt) != "-":
            hgt.touch()

    def pixel_area(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lookup_table: Path,
        ls_map: Path,
        inc_map: Path,
        pix_sigma0: Path,
        pix_gamma0: Optional[Path] = None,
        nstep: Optional[Path] = None,
        area_fact: Optional[Any] = None,
        sigma0_ratio: Optional[Path] = None,
        gamma0_ratio: Optional[Path] = None,
        sig2gam_ratio: Optional[Path] = None,
        hgt: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate terrain-based sigma0 and gammma0 normalization area in slant-range geometry


        input parameters:
          MLI_par       (input) ISP MLI or SLC image parameter file (slant-range geometry)
          DEM_par       (input) DEM/MAP parameter file
          DEM           (input) DEM data file (or constant height value)
          lookup_table  (input) geocoding lookup table (FCOMPLEX)
          ls_map        (input) layover and shadow map in map geometry
          inc_map       (input) local incidence angle map in map geometry (enter - for none)
                        NOTE: required for calculation of pix_gamma0, gamma0_ratio, and sig2gam_ratio
          pix_sigma0    (output) sigma0 normalization area in RDC geometry (enter - for none)
          pix_gamma0    (output) gamma0 normalization area in RDC geometry (enter - for none)
          nstep         number of steps to divide each dimension of the map pixels (enter - for default: 16)
          area_fact     area factor that is multiplied with the rg/az pixel size to set a lower
                        threshold for the minimal pixel area that is accepted (enter - for default: 1.00)
          sigma0_ratio  (output) ratio between ellipsoid and DEM-based sigma0 normalization areas (enter - for none)
          gamma0_ratio  (output) ratio between ellipsoid and DEM-based gamma0 normalization areas (enter - for none)
          sig2gam_ratio (output) ratio of ellipsoid sigma0 and DEM-based gamma0 normalization areas (enter - for none)
          hgt           (output) height map in RDC geometry (enter - for none)

        """
        if self.validate_inputs:
            self._validate_pixel_area(
                MLI_par,
                DEM_par,
                DEM,
                lookup_table,
                ls_map,
                inc_map,
                pix_sigma0,
                pix_gamma0,
                nstep,
                area_fact,
                sigma0_ratio,
                gamma0_ratio,
                sig2gam_ratio,
                hgt,
            )
        if self.mock_outputs:
            self._mock_pixel_area_outputs(
                MLI_par,
                DEM_par,
                DEM,
                lookup_table,
                ls_map,
                inc_map,
                pix_sigma0,
                pix_gamma0,
                nstep,
                area_fact,
                sigma0_ratio,
                gamma0_ratio,
                sig2gam_ratio,
                hgt,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pixel_area))
        return self._gamma_call("DIFF", "pixel_area", supplied_args)

    def _validate_extract_gcp(
        self, DEM_rdc: Path, OFF_par: Path, GCP: Path, nr: int, naz: int, mask: Optional[Path] = None
    ) -> None:
        self._validate("extract_gcp", DEM_rdc.exists(), f"DEM_rdc path does not exist ({DEM_rdc})")
        self._validate("extract_gcp", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        if mask is not None:
            self._validate("extract_gcp", mask.exists(), f"mask path does not exist ({mask})")

    def _mock_extract_gcp_outputs(
        self, DEM_rdc: Path, OFF_par: Path, GCP: Path, nr: int, naz: int, mask: Optional[Path] = None
    ) -> None:
        if GCP is not None and str(GCP) != "-":
            GCP.touch()

    def extract_gcp(
        self, DEM_rdc: Path, OFF_par: Path, GCP: Path, nr: int, naz: int, mask: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Extract GCPs from a DEM in range-Doppler coordinates


        input parameters:
          DEM_rdc  (input) DEM in range-Doppler coordinates
          OFF_par  (input) ISP offset/interferogram parameter file
          GCP      (output) GCP height data file (text format)
          nr       number of GCP locations in range (default: 32)
          naz      number of GCP azimuth locations (default: 32)
          mask     (input) GCP selection mask (SUN raster, BMP, or TIFF format)
                   NOTE: GCPs are excluded from regions where the mask = 0

        """
        if self.validate_inputs:
            self._validate_extract_gcp(DEM_rdc, OFF_par, GCP, nr, naz, mask)
        if self.mock_outputs:
            self._mock_extract_gcp_outputs(DEM_rdc, OFF_par, GCP, nr, naz, mask)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.extract_gcp))
        return self._gamma_call("DIFF", "extract_gcp", supplied_args)

    def _validate_gc_map2(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Optional[Path] = None,
        DEM_seg: Optional[Path] = None,
        lookup_table: Optional[Path] = None,
        lat_ovr: Optional[Any] = None,
        lon_ovr: Optional[Any] = None,
        ls_map: Optional[Path] = None,
        ls_map_rdc: Optional[Path] = None,
        inc: Optional[Path] = None,
        res: Optional[Path] = None,
        offnadir: Optional[Path] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        r_ovr: Optional[Any] = None,
        az_dec: Optional[Any] = None,
        mask: Optional[int] = None,
        frame: Optional[int] = None,
        ls_scaling: Optional[int] = None,
        DIFF_par: Optional[Path] = None,
        ref_flg: Optional[int] = None,
        inc_flg: Optional[int] = None,
    ) -> None:
        self._validate("gc_map2", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("gc_map2", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("gc_map2", DEM.exists(), f"DEM path does not exist ({DEM})")
        if DIFF_par is not None:
            self._validate("gc_map2", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_gc_map2_outputs(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Optional[Path] = None,
        DEM_seg: Optional[Path] = None,
        lookup_table: Optional[Path] = None,
        lat_ovr: Optional[Any] = None,
        lon_ovr: Optional[Any] = None,
        ls_map: Optional[Path] = None,
        ls_map_rdc: Optional[Path] = None,
        inc: Optional[Path] = None,
        res: Optional[Path] = None,
        offnadir: Optional[Path] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        r_ovr: Optional[Any] = None,
        az_dec: Optional[Any] = None,
        mask: Optional[int] = None,
        frame: Optional[int] = None,
        ls_scaling: Optional[int] = None,
        DIFF_par: Optional[Path] = None,
        ref_flg: Optional[int] = None,
        inc_flg: Optional[int] = None,
    ) -> None:
        if DEM_seg_par is not None and str(DEM_seg_par) != "-":
            DEM_seg_par.touch()
        if DEM_seg is not None and str(DEM_seg) != "-":
            DEM_seg.touch()
        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()
        if ls_map is not None and str(ls_map) != "-":
            ls_map.touch()
        if ls_map_rdc is not None and str(ls_map_rdc) != "-":
            ls_map_rdc.touch()
        if inc is not None and str(inc) != "-":
            inc.touch()
        if res is not None and str(res) != "-":
            res.touch()
        if offnadir is not None and str(offnadir) != "-":
            offnadir.touch()
        if sim_sar is not None and str(sim_sar) != "-":
            sim_sar.touch()
        if u is not None and str(u) != "-":
            u.touch()
        if v is not None and str(v) != "-":
            v.touch()
        if psi is not None and str(psi) != "-":
            psi.touch()
        if pix is not None and str(pix) != "-":
            pix.touch()

    def gc_map2(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        DEM_seg_par: Optional[Path] = None,
        DEM_seg: Optional[Path] = None,
        lookup_table: Optional[Path] = None,
        lat_ovr: Optional[Any] = None,
        lon_ovr: Optional[Any] = None,
        ls_map: Optional[Path] = None,
        ls_map_rdc: Optional[Path] = None,
        inc: Optional[Path] = None,
        res: Optional[Path] = None,
        offnadir: Optional[Path] = None,
        sim_sar: Optional[Path] = None,
        u: Optional[Path] = None,
        v: Optional[Path] = None,
        psi: Optional[Path] = None,
        pix: Optional[Path] = None,
        r_ovr: Optional[Any] = None,
        az_dec: Optional[Any] = None,
        mask: Optional[int] = None,
        frame: Optional[int] = None,
        ls_scaling: Optional[int] = None,
        DIFF_par: Optional[Path] = None,
        ref_flg: Optional[int] = None,
        inc_flg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate lookup table and DEM related products (layover and shadow, incidence angle, local resolution, offnadir angle)
        Generate accurate layover and shadow map for any platform heading


        input parameters:
          MLI_par         (input) MLI or SLC image parameter file (slant range geometry)
          DEM_par         (input) DEM/MAP parameter file
          DEM             (input) DEM data file (or constant height value)
          DEM_seg_par     (output) DEM segment parameter file (enter - for none)
          DEM_seg         (output) DEM segment file (FLOAT, enter - for none)
          lookup_table    (output) geocoding lookup table (FCOMPLEX, original DEM geometry) (enter - for none)
          lat_ovr         latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr         longitude or easting output DEM oversampling factor (enter - for default: 1.0)
          ls_map          (output) layover and shadow map (UCHAR, original DEM geometry) (enter - for none)
          ls_map_rdc      (output) layover and shadow map (UCHAR, slant range geometry) (enter - for none)
          inc             (output) local incidence angle map (FLOAT, between surface normal and look vector, original DEM geometry) (enter - for none)
          res             (output) local resolution map (FCOMPLEX, original DEM geometry) (enter - for none)
          offnadir        (output) local offnadir (or look) angle map (FLOAT, original DEM geometry) (enter - for none)
          sim_sar         (output) simulated SAR backscatter image (FLOAT, original DEM geometry) (enter - for none)
          u               (output) zenith angle map of surface normal vector n (FLOAT, angle between z and n, original DEM geometry) (enter - for none)
          v               (output) orientation angle map of n (FLOAT, between x and projection of n in xy plane, original DEM geometry) (enter - for none)
          psi             (output) projection angle map (FLOAT, between surface normal and image plane normal, original DEM geometry) (enter - for none)
          pix             (output) pixel area normalization factor map (FLOAT, enter - for none)
          r_ovr           range oversampling factor (for layover-shadow calculations, enter - for default: automatic value)
          az_dec          azimuth decimation factor (for layover-shadow calculations, enter - for default: automatic value)
          mask            mask values outside swath, use layover and shadow map as a mask (enter - for default)
                            0: no masking (default)
                            1: masking values outside swath
                            2: masking shadow and values outside swath
                            3: masking layover, shadow and values outside swath
          frame           number of DEM pixels to add around area covered by SAR image (enter - for default: 8)
          ls_scaling      scaling of the layover and shadow maps (enter - for default)
                            0: standard values for further processing (default)
                            1: scaling optimized for visualization
          DIFF_par        (input) DIFF/GEO parameter file containing offset polynomial coefficients, for LUT and ls_map_rdc refinement (enter - for none)
          ref_flg         reference image flag (offsets are measured relative to the reference image) (enter - for default)
                            0: reference image is the actual SAR image
                            1: reference image is the simulated SAR image (default)
          inc_flg         incidence angle flag (enter - for default)
                            0: [inc] defined as local incidence angle (angle between surface normal and look vector) (default)
                            1: [inc] defined as incidence angle (angle between ellipsoid normal and look vector)

        """
        if self.validate_inputs:
            self._validate_gc_map2(
                MLI_par,
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                ls_map,
                ls_map_rdc,
                inc,
                res,
                offnadir,
                sim_sar,
                u,
                v,
                psi,
                pix,
                r_ovr,
                az_dec,
                mask,
                frame,
                ls_scaling,
                DIFF_par,
                ref_flg,
                inc_flg,
            )
        if self.mock_outputs:
            self._mock_gc_map2_outputs(
                MLI_par,
                DEM_par,
                DEM,
                DEM_seg_par,
                DEM_seg,
                lookup_table,
                lat_ovr,
                lon_ovr,
                ls_map,
                ls_map_rdc,
                inc,
                res,
                offnadir,
                sim_sar,
                u,
                v,
                psi,
                pix,
                r_ovr,
                az_dec,
                mask,
                frame,
                ls_scaling,
                DIFF_par,
                ref_flg,
                inc_flg,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map2))
        return self._gamma_call("DIFF", "gc_map2", supplied_args)

    def _validate_dem_trans(
        self,
        DEM1_par: Path,
        DEM1: Path,
        DEM2_par: Path,
        DEM2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Any] = None,
        datum_shift: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        self._validate("dem_trans", DEM1_par.exists(), f"DEM1_par path does not exist ({DEM1_par})")
        self._validate("dem_trans", DEM1.exists(), f"DEM1 path does not exist ({DEM1})")

    def _mock_dem_trans_outputs(
        self,
        DEM1_par: Path,
        DEM1: Path,
        DEM2_par: Path,
        DEM2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Any] = None,
        datum_shift: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        if not DEM2_par.exists():
            DEM2_par.touch()
        if DEM2 is not None and str(DEM2) != "-":
            DEM2.touch()
        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

    def dem_trans(
        self,
        DEM1_par: Path,
        DEM1: Path,
        DEM2_par: Path,
        DEM2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Any] = None,
        datum_shift: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DEM resampling from one map projection to another map projection


        input parameters:
          DEM1_par      (input) DEM parameter file of the input DEM
          DEM1          (input) input DEM data
          DEM2_par      (input/output) DEM parameter file of the resampled input DEM
                        NOTE: if DEM2_par does not exist, it is created using the projection parameters from DEM1_par
          DEM2          (output) DEM in transformed coordinates specified by DEM2_par
          lat_ovr       lat, northing, or S map projection oversampling factor (enter - for default: 2.0)
          lon_ovr       lon, easting, or C map projection oversampling factor (enter - for default: 2.0)
                        NOTE: lat_ovr and lon_ovr are only considered if DEM2_par does not exist
          datum_shift   vertical datum shift flag, enter - for default:
                          0: output DEM heights not corrected for datum shift between projections (default)
                          1: output DEM heights corrected for datum shift between projections
          bflg          output DEM bounds flag (enter - for default):
                          0: use DEM bounds specified by DEM2_par (default)
                          1: determine bounds from DEM1_par in the projection specified by DEM2_par
          lookup_table  (output) complex-valued lookup table (DEM2 -> DEM1) (enter - for none)
          interp_mode   interpolation mode (enter - for default):
                          0: nearest neighbor
                          1: bicubic spline (default)
                          2: B-spline interpolation (default B-spline degree: 3)
          order         B-spline degree (2->5) (enter - for default: 3)

        """
        if self.validate_inputs:
            self._validate_dem_trans(
                DEM1_par, DEM1, DEM2_par, DEM2, lat_ovr, lon_ovr, datum_shift, bflg, lookup_table, interp_mode, order
            )
        if self.mock_outputs:
            self._mock_dem_trans_outputs(
                DEM1_par, DEM1, DEM2_par, DEM2, lat_ovr, lon_ovr, datum_shift, bflg, lookup_table, interp_mode, order
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_trans))
        return self._gamma_call("DIFF", "dem_trans", supplied_args)

    def _validate_quad_sub(
        self, int_1: Path, DIFF_par: Path, int_2: Path, int_type: int, mode: Optional[int] = None
    ) -> None:
        self._validate("quad_sub", int_1.exists(), f"int_1 path does not exist ({int_1})")
        self._validate("quad_sub", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")
        self._validate("quad_sub", int_2.exists(), f"int_2 path does not exist ({int_2})")

    def _mock_quad_sub_outputs(
        self, int_1: Path, DIFF_par: Path, int_2: Path, int_type: int, mode: Optional[int] = None
    ) -> None:
        pass

    def quad_sub(
        self, int_1: Path, DIFF_par: Path, int_2: Path, int_type: int, mode: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Add or subtract quadratic polynomial phase model from a differential interferogram


        input parameters:
          int-1     (input) differential interferogram (float or fcomplex)
          DIFF_par  (input) DIFF parameter file
          int-2     (output) output interferogram
          int_type  interferogam type:
                      0: unwrapped interferometric phase (float)
                      1: fcomplex interferogram
          mode      add or subtract phase model:
                      0: subtract phase model (default)
                      1: add phase model
        """
        if self.validate_inputs:
            self._validate_quad_sub(int_1, DIFF_par, int_2, int_type, mode)
        if self.mock_outputs:
            self._mock_quad_sub_outputs(int_1, DIFF_par, int_2, int_type, mode)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.quad_sub))
        return self._gamma_call("DIFF", "quad_sub", supplied_args)

    def _validate_phase_sum(
        self,
        im_list: Path,
        width: int,
        sum: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        self._validate("phase_sum", im_list.exists(), f"im_list path does not exist ({im_list})")

    def _mock_phase_sum_outputs(
        self,
        im_list: Path,
        width: int,
        sum: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        if sum is not None and str(sum) != "-":
            sum.touch()

    def phase_sum(
        self,
        im_list: Path,
        width: int,
        sum: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate sum of a stack of images (FLOAT format)


        input parameters:
          im_list  (input) list of coregistered images (FLOAT)
          width    number of samples/line
          sum      (output) sum of input image data files (FLOAT)
          start    starting line (enter - for default: 1)
          nlines   number of lines to process (enter -  for default: entire file)
          pixav_x  number of pixels to average in width (enter - for default: 1)
          pixav_y  number of pixels to average in height (enter - for default: 1)
          zflag    zero flag (enter - for default)
                     0: interpret 0.0 as missing data value (default)
                        NOTE: output pixels are set to 0.0 if any of the corresponding input pixels has 0.0
                     1: interpret 0.0 as valid data

        """
        if self.validate_inputs:
            self._validate_phase_sum(im_list, width, sum, start, nlines, pixav_x, pixav_y, zflag)
        if self.mock_outputs:
            self._mock_phase_sum_outputs(im_list, width, sum, start, nlines, pixav_x, pixav_y, zflag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.phase_sum))
        return self._gamma_call("DIFF", "phase_sum", supplied_args)

    def _validate_base_add(self, base_1: Path, base_2: Path, base_out: Path, mode: Optional[Any] = None) -> None:
        self._validate("base_add", base_1.exists(), f"base_1 path does not exist ({base_1})")
        self._validate("base_add", base_2.exists(), f"base_2 path does not exist ({base_2})")

    def _mock_base_add_outputs(self, base_1: Path, base_2: Path, base_out: Path, mode: Optional[Any] = None) -> None:
        if base_out is not None and str(base_out) != "-":
            base_out.touch()

    def base_add(self, base_1: Path, base_2: Path, base_out: Path, mode: Optional[Any] = None) -> Tuple[int, str, str]:
        """

        Addition/subtraction of 2 baseline files


        input parameters:
          base_1    (input) input baseline file 1
          base_2    (input) input baseline file 2
          base_out  (output) output baseline file
          mode      add/subtract mode (default=1: add, -1: subtract (base_1-base_2))

        """
        if self.validate_inputs:
            self._validate_base_add(base_1, base_2, base_out, mode)
        if self.mock_outputs:
            self._mock_base_add_outputs(base_1, base_2, base_out, mode)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_add))
        return self._gamma_call("DIFF", "base_add", supplied_args)

    def _validate_gec_map_grd(self, GRD_par: Path, DEM_par: Path, href: Path, DEM_seg_par: Path) -> None:
        self._validate("gec_map_grd", GRD_par.exists(), f"GRD_par path does not exist ({GRD_par})")
        self._validate("gec_map_grd", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("gec_map_grd", href.exists(), f"href path does not exist ({href})")

    def _mock_gec_map_grd_outputs(self, GRD_par: Path, DEM_par: Path, href: Path, DEM_seg_par: Path) -> None:
        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

    def gec_map_grd(self, GRD_par: Path, DEM_par: Path, href: Path, DEM_seg_par: Path) -> Tuple[int, str, str]:
        """

        Calculate geocoding lookup table for ellipsoid correction of ground-range images


        input parameters:
          GRD_par       (input) ground-range ISP image parameter file
          DEM_par       (input) DEM parameter file
          href          (input) elevation reference [m]
          DEM_seg_par   (input/output) DEM segment parameter file used for geocoding

          NOTE: If the DEM_seg_par already exists, then the output DEM parameters will be read from this file
                otherwise they are estimated from the image data.

          lookup_table  (output) geocoding lookup table
          lat_ovr       latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr       longitude or easting output DEM oversampling factor (enter - for default: 1.0)
        """
        if self.validate_inputs:
            self._validate_gec_map_grd(GRD_par, DEM_par, href, DEM_seg_par)
        if self.mock_outputs:
            self._mock_gec_map_grd_outputs(GRD_par, DEM_par, href, DEM_seg_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gec_map_grd))
        return self._gamma_call("DIFF", "gec_map_grd", supplied_args)

    def _validate_sarpix_coord_list(
        self, SLC_par: Path, OFF_par: Path, DEM_par: Path, SAR_coord: Path, MAP_coord: Path
    ) -> None:
        self._validate("sarpix_coord_list", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("sarpix_coord_list", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("sarpix_coord_list", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("sarpix_coord_list", SAR_coord.exists(), f"SAR_coord path does not exist ({SAR_coord})")

    def _mock_sarpix_coord_list_outputs(
        self, SLC_par: Path, OFF_par: Path, DEM_par: Path, SAR_coord: Path, MAP_coord: Path
    ) -> None:
        if MAP_coord is not None and str(MAP_coord) != "-":
            MAP_coord.touch()

    def sarpix_coord_list(
        self, SLC_par: Path, OFF_par: Path, DEM_par: Path, SAR_coord: Path, MAP_coord: Path
    ) -> Tuple[int, str, str]:
        """

        Transform SAR image coordinates to map projection and geographic (lat/lon) coordinates for a list of points


        input parameters:
          SLC_par    (input) ISP SLC/MLI parameter file
          OFF_par    (input) ISP offset/interferogram parameter file, enter - for SLC or MLI data
          DEM_par    (input) DEM parameter file, enter - for WGS84 lat/lon
          SAR_coord  (input) list of pixel and line coordinates in the geometry defined by the SLC_par:
                       azimuth_line  range_pixel   height (m) in the desired datum defined in the DEM_par
          MAP_coord  (output) list of map coordinates and heights with 5 columns:
                       north/lat/S   east/lon/C   height (m)   map_line   map_pixel

        """
        if self.validate_inputs:
            self._validate_sarpix_coord_list(SLC_par, OFF_par, DEM_par, SAR_coord, MAP_coord)
        if self.mock_outputs:
            self._mock_sarpix_coord_list_outputs(SLC_par, OFF_par, DEM_par, SAR_coord, MAP_coord)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sarpix_coord_list))
        return self._gamma_call("DIFF", "sarpix_coord_list", supplied_args)

    def _validate_dispmap_vec(
        self,
        DEM_par: Path,
        dispmap: Path,
        lv_theta: Path,
        lv_phi: Path,
        fv_theta: Path,
        fv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Any] = None,
    ) -> None:
        self._validate("dispmap_vec", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("dispmap_vec", dispmap.exists(), f"dispmap path does not exist ({dispmap})")
        self._validate("dispmap_vec", lv_theta.exists(), f"lv_theta path does not exist ({lv_theta})")
        self._validate("dispmap_vec", lv_phi.exists(), f"lv_phi path does not exist ({lv_phi})")
        self._validate("dispmap_vec", fv_theta.exists(), f"fv_theta path does not exist ({fv_theta})")
        self._validate("dispmap_vec", fv_phi.exists(), f"fv_phi path does not exist ({fv_phi})")

    def _mock_dispmap_vec_outputs(
        self,
        DEM_par: Path,
        dispmap: Path,
        lv_theta: Path,
        lv_phi: Path,
        fv_theta: Path,
        fv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Any] = None,
    ) -> None:
        if dv_norm is not None and str(dv_norm) != "-":
            dv_norm.touch()
        if dv_theta is not None and str(dv_theta) != "-":
            dv_theta.touch()
        if dv_phi is not None and str(dv_phi) != "-":
            dv_phi.touch()
        if dv_x is not None and str(dv_x) != "-":
            dv_x.touch()
        if dv_y is not None and str(dv_y) != "-":
            dv_y.touch()
        if dv_z is not None and str(dv_z) != "-":
            dv_z.touch()

    def dispmap_vec(
        self,
        DEM_par: Path,
        dispmap: Path,
        lv_theta: Path,
        lv_phi: Path,
        fv_theta: Path,
        fv_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculation of displacement vector field from displacement direction and measured component


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          dispmap     (input) displacement observation (along look-vector) (float)
          lv_theta    (input) look-vector elevation angle (file  or constant value in deg.)
          lv_phi      (input) look-vector orientation angle (file or constant value in deg.)
          fv_theta    (input) flow-vector elevation angle (file or constant value in deg.)
          fv_phi      (input) flow-vector orientation angle (file or constant value in deg.)
          dv_norm     (output) norm of 3-dim displacement vector (float)
          dv_theta    (output) elevation angle of 3-dim displacement vector (float)
          dv_phi      (output) orientation angle of 3-dim displacement vector (float)
          dv_x        (output) easting  component of 3-dim displacement vector (float)
          dv_y        (output) northing component of 3-dim displacement vector (float)
          dv_z        (output) vertical component of 3-dim displacement vector (float)
          mask_angle  cutoff angle in degrees between the look and normal vector to mask instable results (default=5)

          NOTE: select - to avoid creation of the corresponding output file
          NOTE: In the case where the dv_theta file is not specified, the sign of the displacement is conserved

        """
        if self.validate_inputs:
            self._validate_dispmap_vec(
                DEM_par,
                dispmap,
                lv_theta,
                lv_phi,
                fv_theta,
                fv_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
            )
        if self.mock_outputs:
            self._mock_dispmap_vec_outputs(
                DEM_par,
                dispmap,
                lv_theta,
                lv_phi,
                fv_theta,
                fv_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_vec))
        return self._gamma_call("DIFF", "dispmap_vec", supplied_args)

    def _validate_scale_base(
        self,
        unw_2: Path,
        scaled_unw_2: Path,
        baseline_1: Path,
        SLC1_par_1: Path,
        OFF_par_1: Path,
        baseline_2: Path,
        SLC_1_par_2: Path,
        OFF_par_2: Path,
        int_type: int,
    ) -> None:
        self._validate("scale_base", unw_2.exists(), f"unw_2 path does not exist ({unw_2})")
        self._validate("scale_base", baseline_1.exists(), f"baseline_1 path does not exist ({baseline_1})")
        self._validate("scale_base", SLC1_par_1.exists(), f"SLC1_par_1 path does not exist ({SLC1_par_1})")
        self._validate("scale_base", OFF_par_1.exists(), f"OFF_par_1 path does not exist ({OFF_par_1})")
        self._validate("scale_base", baseline_2.exists(), f"baseline_2 path does not exist ({baseline_2})")
        self._validate("scale_base", SLC_1_par_2.exists(), f"SLC_1_par_2 path does not exist ({SLC_1_par_2})")
        self._validate("scale_base", OFF_par_2.exists(), f"OFF_par_2 path does not exist ({OFF_par_2})")

    def _mock_scale_base_outputs(
        self,
        unw_2: Path,
        scaled_unw_2: Path,
        baseline_1: Path,
        SLC1_par_1: Path,
        OFF_par_1: Path,
        baseline_2: Path,
        SLC_1_par_2: Path,
        OFF_par_2: Path,
        int_type: int,
    ) -> None:
        if scaled_unw_2 is not None and str(scaled_unw_2) != "-":
            scaled_unw_2.touch()

    def scale_base(
        self,
        unw_2: Path,
        scaled_unw_2: Path,
        baseline_1: Path,
        SLC1_par_1: Path,
        OFF_par_1: Path,
        baseline_2: Path,
        SLC_1_par_2: Path,
        OFF_par_2: Path,
        int_type: int,
    ) -> Tuple[int, str, str]:
        """

        Scale unwrapped phase according to baseline ratio


        input parameters:
          unw-2         (input) unwrapped interferogram file (to be scaled)
          scaled_unw-2  (output) scaled unwrapped interferogram 2
          baseline-1    (input) baseline file of interferogram 1
          SLC1_par-1    (input) parameter file of SLC-1 in interferogram 1
          OFF_par-1     (input) ISP interferogram/offset parameters of interferogram 1
          baseline-2    (input) baseline file of interferogram 2 (to be scaled)
          SLC1_par-2    (input) parameter file of SLC-1 in interferogram 2 (to be scaled)
          OFF_par-2     (input) ISP interferogram/offset parameters of interferogram 2 (to be scaled)
          int_type      interferogram type 0: unflattened (default)  1: flattened (*.flt)

        """
        if self.validate_inputs:
            self._validate_scale_base(
                unw_2, scaled_unw_2, baseline_1, SLC1_par_1, OFF_par_1, baseline_2, SLC_1_par_2, OFF_par_2, int_type
            )
        if self.mock_outputs:
            self._mock_scale_base_outputs(
                unw_2, scaled_unw_2, baseline_1, SLC1_par_1, OFF_par_1, baseline_2, SLC_1_par_2, OFF_par_2, int_type
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.scale_base))
        return self._gamma_call("DIFF", "scale_base", supplied_args)

    def _validate_par_EORC_PALSAR_geo(
        self,
        CEOS_leader: Path,
        MLI_par: Path,
        DEM_par: Path,
        CEOS_data: Path,
        MLI: Optional[Path] = None,
        cal: Optional[Any] = None,
    ) -> None:
        self._validate("par_EORC_PALSAR_geo", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_EORC_PALSAR_geo", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_EORC_PALSAR_geo_outputs(
        self,
        CEOS_leader: Path,
        MLI_par: Path,
        DEM_par: Path,
        CEOS_data: Path,
        MLI: Optional[Path] = None,
        cal: Optional[Any] = None,
    ) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()
        if MLI is not None and str(MLI) != "-":
            MLI.touch()

    def par_EORC_PALSAR_geo(
        self,
        CEOS_leader: Path,
        MLI_par: Path,
        DEM_par: Path,
        CEOS_data: Path,
        MLI: Optional[Path] = None,
        cal: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Process EORC PALSAR + PALSAR2 Level 1.5 CEOS Ellipsoid Geocoded (GEC) data


        input parameters:
          CEOS_leader  (input) CEOS leader file for PALSAR Level 1.5 ellipsoid geocoded (GEC) data (LED...P1.5GUA)
          MLI_par      (output) ISP image parameter file (example: yyyymmdd_map.mli.par)
          DEM_par      (output) DIFF/GEO DEM parameter file (example: yyyymmdd_map.dem_par)
          CEOS_data    (input) PALSAR CEOS format Level 1.5 GEC MLI data (IMG...P1.5GUA)
          MLI          (output) reformatted PALSAR GEC MLI image (example: yyyymmdd_map.mli, enter - for none)
          cal          radiometric calibration factor in dB (enter - for default: read from CEOS data)

        """
        if self.validate_inputs:
            self._validate_par_EORC_PALSAR_geo(CEOS_leader, MLI_par, DEM_par, CEOS_data, MLI, cal)
        if self.mock_outputs:
            self._mock_par_EORC_PALSAR_geo_outputs(CEOS_leader, MLI_par, DEM_par, CEOS_data, MLI, cal)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_EORC_PALSAR_geo))
        return self._gamma_call("DIFF", "par_EORC_PALSAR_geo", supplied_args)

    def _validate_SLC_intf_geo(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        MLI_1: Optional[Path] = None,
        MLI_2: Optional[Path] = None,
    ) -> None:
        self._validate("SLC_intf_geo", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("SLC_intf_geo", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("SLC_intf_geo", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_SLC_intf_geo_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        MLI_1: Optional[Path] = None,
        MLI_2: Optional[Path] = None,
    ) -> None:
        if interf is not None and str(interf) != "-":
            interf.touch()
        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()
        if MLI_1 is not None and str(MLI_1) != "-":
            MLI_1.touch()
        if MLI_2 is not None and str(MLI_2) != "-":
            MLI_2.touch()

    def SLC_intf_geo(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        MLI_1: Optional[Path] = None,
        MLI_2: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate a multi-look interferogram from geocoded and co-registered SLC images


        input parameters:
          SLC-1      (input) single-look complex geocoded image 1 (FCOMPLEX format, reference scene)
          SLC-2      (input) single-look complex geocoded image 2 coregistered to SLC-1 (FCOMPLEX format)
          DEM_par    (input) DEM parameter file describing the input geocoded and coregistered SLC images
          interf     (output) multi-look interferogram from SLC-1 and SLC-2
          DEM_par2   (output) DEM parameter file for the output interferogram and MLI files
          e_lks      number of easting looks (longitude, cross-track)
          n_lks      number of northing looks (latitude, along-track)
          MLI-1      (output) multi-look intensity image from SLC-1 (enter - for none)
          MLI-2      (output) multi-look intensity image from SLC-2 (enter - for none)

        """
        if self.validate_inputs:
            self._validate_SLC_intf_geo(SLC_1, SLC_2, DEM_par, interf, DEM_par2, e_lks, n_lks, MLI_1, MLI_2)
        if self.mock_outputs:
            self._mock_SLC_intf_geo_outputs(SLC_1, SLC_2, DEM_par, interf, DEM_par2, e_lks, n_lks, MLI_1, MLI_2)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_intf_geo))
        return self._gamma_call("DIFF", "SLC_intf_geo", supplied_args)

    def _validate_map_trans(
        self,
        DEM1_par: Path,
        data1: Path,
        DEM2_par: Path,
        data2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Any] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        order: Optional[int] = None,
    ) -> None:
        self._validate("map_trans", DEM1_par.exists(), f"DEM1_par path does not exist ({DEM1_par})")
        self._validate("map_trans", data1.exists(), f"data1 path does not exist ({data1})")

    def _mock_map_trans_outputs(
        self,
        DEM1_par: Path,
        data1: Path,
        DEM2_par: Path,
        data2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Any] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        order: Optional[int] = None,
    ) -> None:
        if not DEM2_par.exists():
            DEM2_par.touch()
        if data2 is not None and str(data2) != "-":
            data2.touch()
        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

    def map_trans(
        self,
        DEM1_par: Path,
        data1: Path,
        DEM2_par: Path,
        data2: Path,
        lat_ovr: Optional[Path] = None,
        lon_ovr: Optional[Any] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        bflg: Optional[int] = None,
        lookup_table: Optional[Path] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Data resampling from one map projection to another map projection


        input parameters:
          DEM1_par      (input) DEM parameter file of input data
          data1         (input) input data in the geometry of DEM1_par
          DEM2_par      (input/output) DEM parameter file of the output data
                        NOTE: if DEM2_par does not exist, it is created using the map projection parameters from DEM1_par
          data2         (output) input data1 resampled into the geometry of DEM2_par
          lat_ovr       lat, northing, or S map projection oversampling factor (enter - for default: 2.0)
          lon_ovr       lon, easting, or C map projection oversampling factor (enter - for default: 2.0)
                        NOTE: lat_ovr and lon_ovr are only considered if DEM2_par does not exist
          interp_mode   interpolation mode (enter - for default):
                          0: nearest neighbor
                          1: bicubic spline (default)
                          2: bicubic spline log(x)
                          3: bicubic spline sqrt(x)
                          4: B-spline interpolation (default B-spline degree: 5)
                          5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                          6: Lanczos interpolation (default Lanczos function order: 5)
                          7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                        NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype         data format (enter - for default):
                          0: FLOAT (default)
                          1: FCOMPLEX or geocoding lookup table
                          2: SUN/BMP/TIFF raster file
                          3: UNSIGNED CHAR
                          4: SHORT INTEGER
                          5: DOUBLE
          bflg          output DEM bounds flag (enter - for default):
                          0: use DEM bounds specified by DEM2_par (default)
                          1: determine bounds from DEM1_par in the projection specified by DEM2_par
          lookup_table  (output) complex-valued lookup table (enter - for none, DEM2 -> DEM1)
          order         Lanczos function order or B-spline degree (2->9) (enter - default: 5)

        """
        if self.validate_inputs:
            self._validate_map_trans(
                DEM1_par, data1, DEM2_par, data2, lat_ovr, lon_ovr, interp_mode, dtype, bflg, lookup_table, order
            )
        if self.mock_outputs:
            self._mock_map_trans_outputs(
                DEM1_par, data1, DEM2_par, data2, lat_ovr, lon_ovr, interp_mode, dtype, bflg, lookup_table, order
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.map_trans))
        return self._gamma_call("DIFF", "map_trans", supplied_args)

    def _validate_gc_map_inversion(
        self,
        gc_map: Path,
        width_in: int,
        gc_map_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        rad_max: Optional[Any] = None,
        nintr: Optional[int] = None,
    ) -> None:
        self._validate("gc_map_inversion", gc_map.exists(), f"gc_map path does not exist ({gc_map})")

    def _mock_gc_map_inversion_outputs(
        self,
        gc_map: Path,
        width_in: int,
        gc_map_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        rad_max: Optional[Any] = None,
        nintr: Optional[int] = None,
    ) -> None:
        if gc_map_out is not None and str(gc_map_out) != "-":
            gc_map_out.touch()

    def gc_map_inversion(
        self,
        gc_map: Path,
        width_in: int,
        gc_map_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        rad_max: Optional[Any] = None,
        nintr: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Invert geocoding lookup table


        input parameters:
          gc_map         lookup table containing pairs of real-valued coordinates (fcomplex)
          width_in       width of input lookup table lines
          gc_map_out     inverted geocoding lookup table
          width_out      width of output data file
          nlines_out     number of lines of output data file (enter - or 0 for default: all lines up to highest value)
          interp_mode    resampling interpolation mode (enter - for default)
                           0: 1/dist (default)
                           1: nearest-neighbor
                           2: 1/dist**2
                           3: constant
                           4: Gaussian
          n_ovr          interpolation oversampling factor (enter - for default: 2)
          rad_max        maximum interpolation search radius (enter - for default: 4*n_ovr = 8)
          nintr          number of points required for interpolation when not nearest-neighbor (enter - for default: 4)

        """
        if self.validate_inputs:
            self._validate_gc_map_inversion(
                gc_map, width_in, gc_map_out, width_out, nlines_out, interp_mode, n_ovr, rad_max, nintr
            )
        if self.mock_outputs:
            self._mock_gc_map_inversion_outputs(
                gc_map, width_in, gc_map_out, width_out, nlines_out, interp_mode, n_ovr, rad_max, nintr
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map_inversion))
        return self._gamma_call("DIFF", "gc_map_inversion", supplied_args)

    def _validate_par_JERS_geo(
        self, CEOS_leader: Path, CEOS_data: Path, MLI_par: Path, DEM_par: Path, GEO: Optional[Path] = None
    ) -> None:
        self._validate("par_JERS_geo", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_JERS_geo", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_JERS_geo_outputs(
        self, CEOS_leader: Path, CEOS_data: Path, MLI_par: Path, DEM_par: Path, GEO: Optional[Path] = None
    ) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()
        if GEO is not None and str(GEO) != "-":
            GEO.touch()

    def par_JERS_geo(
        self, CEOS_leader: Path, CEOS_data: Path, MLI_par: Path, DEM_par: Path, GEO: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Import JERS-1 L2.1 CEOS data (geocoded)


        input parameters:
        CEOS_leader  (input) CEOS leader file for JERS-1 L2 geocoded data (SARL_*.DAT)
        CEOS_data    (input) JERS-1 CEOS format L2 terrain-geocoded MLI data (IMOP_*.DAT)
        MLI_par      (output) ISP image parameter file (example: yyyymmdd_map.mli.par)
        DEM_par      (output) DIFF/GEO DEM parameter file (example: yyyymmdd.dem_par)
        GEO          (output) calibrated and geocoded JERS-1 image (example: yyyymmdd_map.mli, enter - for none)

        """
        if self.validate_inputs:
            self._validate_par_JERS_geo(CEOS_leader, CEOS_data, MLI_par, DEM_par, GEO)
        if self.mock_outputs:
            self._mock_par_JERS_geo_outputs(CEOS_leader, CEOS_data, MLI_par, DEM_par, GEO)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_JERS_geo))
        return self._gamma_call("DIFF", "par_JERS_geo", supplied_args)

    def _validate_interp_data(
        self,
        data2: Path,
        DIFF_par: Path,
        data2_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        self._validate("interp_data", data2.exists(), f"data2 path does not exist ({data2})")
        self._validate("interp_data", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_interp_data_outputs(
        self,
        data2: Path,
        DIFF_par: Path,
        data2_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        if data2_out is not None and str(data2_out) != "-":
            data2_out.touch()

    def interp_data(
        self,
        data2: Path,
        DIFF_par: Path,
        data2_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Resample 2D data using DIFF_par polynomials


        input parameters:
          data2        (input) input data file (format as specified by format_flag parameter)
          DIFF_par     (input) DIFF/GEO parameter file containing range and azimuth offset polynomial coefficients
          data2_out    (output) resampled data2, dimensions determined by data1 in the DIFF_par
          interp_mode  interpolation mode:
                         0: nearest-neighbor
                         1: bicubic spline (default)
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 5)
                         5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                         6: Lanczos interpolation (default Lanczos function order: 5)
                         7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype        input and output data format
                         0: FLOAT (default)
                         1: FCOMPLEX
                         2: SUN/BMP/TIFF format raster image
                         3: UNSIGNED CHAR
                         4: SHORT
                         5: DOUBLE
                         6: SCOMPLEX
          order        Lanczos function order or B-spline degree (2->9) (enter - default: 5)

          NOTE: see documentation for information on recommended interpolation modes for different data types

        """
        if self.validate_inputs:
            self._validate_interp_data(data2, DIFF_par, data2_out, interp_mode, dtype, order)
        if self.mock_outputs:
            self._mock_interp_data_outputs(data2, DIFF_par, data2_out, interp_mode, dtype, order)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.interp_data))
        return self._gamma_call("DIFF", "interp_data", supplied_args)

    def _validate_rdc_trans(self, MLI1_par: Path, DEM_RDC: Path, MLI2_par: Path, lt: Path) -> None:
        self._validate("rdc_trans", MLI1_par.exists(), f"MLI1_par path does not exist ({MLI1_par})")
        self._validate("rdc_trans", DEM_RDC.exists(), f"DEM_RDC path does not exist ({DEM_RDC})")
        self._validate("rdc_trans", MLI2_par.exists(), f"MLI2_par path does not exist ({MLI2_par})")

    def _mock_rdc_trans_outputs(self, MLI1_par: Path, DEM_RDC: Path, MLI2_par: Path, lt: Path) -> None:
        if lt is not None and str(lt) != "-":
            lt.touch()

    def rdc_trans(self, MLI1_par: Path, DEM_RDC: Path, MLI2_par: Path, lt: Path) -> Tuple[int, str, str]:
        """

        Derive lookup table for SLC/MLI coregistration (considering terrain heights)


        input parameters:
          MLI1_par  (input) SLC/MLI ISP image parameter file of the reference scene (lookup table and DEM_RDC dimensions)
          DEM_RDC   (input) height map in RDC of MLI-1 (float, or constant height value)
                    NOTE: The terrain heights must be referenced to the WGS84 datum
          MLI2_par  (input) SLC/MLI ISP image parameter file of MLI-2
          lt        (output) lookup table to resample MLI-2 to the geometry of MLI-1 (FCOMPLEX)

        """
        if self.validate_inputs:
            self._validate_rdc_trans(MLI1_par, DEM_RDC, MLI2_par, lt)
        if self.mock_outputs:
            self._mock_rdc_trans_outputs(MLI1_par, DEM_RDC, MLI2_par, lt)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rdc_trans))
        return self._gamma_call("DIFF", "rdc_trans", supplied_args)

    def _validate_SLC_interp_lt_ScanSAR(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Path,
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[Any] = None,
    ) -> None:
        self._validate("SLC_interp_lt_ScanSAR", SLC2_tab.exists(), f"SLC2_tab path does not exist ({SLC2_tab})")
        self._validate("SLC_interp_lt_ScanSAR", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("SLC_interp_lt_ScanSAR", SLC1_tab.exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        self._validate("SLC_interp_lt_ScanSAR", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate(
            "SLC_interp_lt_ScanSAR", lookup_table.exists(), f"lookup_table path does not exist ({lookup_table})"
        )
        self._validate("SLC_interp_lt_ScanSAR", MLI1_par.exists(), f"MLI1_par path does not exist ({MLI1_par})")
        self._validate("SLC_interp_lt_ScanSAR", MLI2_par.exists(), f"MLI2_par path does not exist ({MLI2_par})")
        self._validate("SLC_interp_lt_ScanSAR", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_SLC_interp_lt_ScanSAR_outputs(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Path,
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[Any] = None,
    ) -> None:
        if not SLC2R_tab.exists():
            SLC2R_tab.touch()
        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()
        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp_lt_ScanSAR(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Path,
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Resample ScanSAR burst mode SLC using a lookup table and SLC offset polynomials for refinement


        input parameters:
          SLC2_tab      (input) 3 column list of ScanSAR SLC-2 swaths to be resampled into the geometry of SLC-1 listed in order from near to far range
                        SLC2_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_par      (input) SLC parameter file of the mosaic of the ScanSAR SLC-2 data, SLC-2 is generated from the ScanSAR swaths listed in SLC2_tab
          SLC1_tab      (input) 3 column list of the reference ScanSAR SLC-1 swaths listed in order from near to far range
          SLC1_par      (input) SLC parameter file of the mosaic of the reference ScanSAR SLC-1 data, SLC-1 is generated from the ScanSAR swaths listed in SLC1_tab
          lookup_table  (input) lookup table relating the mosaic image coordinates of MLI-1 to MLI-2
          MLI1_par      (input) SLC/MLI ISP image parameter file of reference MLI-1 (lookup table dimension)
          MLI2_par      (input) SLC/MLI ISP image parameter file of MLI12 (lookup table values)
          OFF_par       (input) ISP offset and interferogram parameter file determined from the ScanSAR SLC mosaics (enter - for none)
          SLC2R_tab     (input/output) 3 column list of the resampled ScanSAR SLC-2R swaths listed in order from near to far range
                        NOTES: 1. If the SLC2R_tab does not yet exist, the file entries will be created with names derived from the SLC2_tab entries and the SLC2R_dir
                               2. The file extensions of the new entries are rslc, rslc.par, and rslc.tops_par
          SLC-2R        (output) mosaic generated from the resampled swaths listed in SLC2R_tab, coregisted to the reference SLC-1 mosaic (enter - for none)
          SLC2R_par     (output) SLC parameter file associated with the mosaic of the resampled ScanSAR SLC-2R data (enter - for none)
          mode          interpolation mode (enter - for default)
                          0: Lanczos (default)
                          1: B-spline
          order         Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)
          SLC2R_dir     directory for resampled burst SLC2R data, ignored if the DIFF_tab already exists (enter - for default: current directory)

        """
        if self.validate_inputs:
            self._validate_SLC_interp_lt_ScanSAR(
                SLC2_tab,
                SLC2_par,
                SLC1_tab,
                SLC1_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                OFF_par,
                SLC2R_tab,
                SLC_2R,
                SLC2R_par,
                mode,
                order,
                SLC2R_dir,
            )
        if self.mock_outputs:
            self._mock_SLC_interp_lt_ScanSAR_outputs(
                SLC2_tab,
                SLC2_par,
                SLC1_tab,
                SLC1_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                OFF_par,
                SLC2R_tab,
                SLC_2R,
                SLC2R_par,
                mode,
                order,
                SLC2R_dir,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp_lt_ScanSAR))
        return self._gamma_call("DIFF", "SLC_interp_lt_ScanSAR", supplied_args)

    def _validate_par_CS_geo(
        self,
    ) -> None:
        pass

    def _mock_par_CS_geo_outputs(
        self,
    ) -> None:
        pass

    def par_CS_geo(
        self,
    ) -> Tuple[int, str, str]:
        """

        dyld[46596]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/par_CS_geo'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)
        """
        if self.validate_inputs:
            self._validate_par_CS_geo()
        if self.mock_outputs:
            self._mock_par_CS_geo_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_CS_geo))
        return self._gamma_call("DIFF", "par_CS_geo", supplied_args)

    def _validate_offset_pwr_trackingm2(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        DIFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[Any] = None,
    ) -> None:
        self._validate("offset_pwr_trackingm2", MLI_1.exists(), f"MLI_1 path does not exist ({MLI_1})")
        self._validate("offset_pwr_trackingm2", MLI_2.exists(), f"MLI_2 path does not exist ({MLI_2})")
        self._validate("offset_pwr_trackingm2", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")
        if DIFF_par2 is not None:
            self._validate("offset_pwr_trackingm2", DIFF_par2.exists(), f"DIFF_par2 path does not exist ({DIFF_par2})")
        if offs2 is not None:
            self._validate("offset_pwr_trackingm2", offs2.exists(), f"offs2 path does not exist ({offs2})")

    def _mock_offset_pwr_trackingm2_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        DIFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[Any] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if ccp is not None and str(ccp) != "-":
            ccp.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()
        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_trackingm2(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        DIFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Offset tracking between MLI images using intensity cross-correlation with the initial offset for each patch determined from an input offset map


        input parameters:
          MLI-1      (input) real valued intensity image 1 (reference)
          MLI-2      (input) real valued intensity image 2
          DIFF_par   (input) DIFF/GEO parameter file
          offs       (output) offset estimates in range and azimuth (fcomplex)
          ccp        (output) cross-correlation of each patch (0.0->1.0) (float)
          DIFF_par2  (input) DIFF/GEO parameter file of the offset map to determine initial offsets (enter - for none)
          offs2      (input) input range and azimuth offset map to determine initial offsets (enter - for none)
          rwin       range patch size (range pixels, enter - for default from offset parameter file)
          azwin      azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets    (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr      MLI oversampling factor (integer 2**N (1,2,4), enter - for default: 1)
          thres      cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep      step in range pixels (enter - for default: rwin/2)
          azstep     step in azimuth pixels (enter - for default: azwin/2)
          rstart     offset to starting range pixel (enter - for default: 0)
          rstop      offset to ending range pixel (enter - for default: nr-1)
          azstart    offset to starting azimuth line (enter - for default: 0)
          azstop     offset to ending azimuth line  (enter - for default: nlines-1)
          bw_frac    bandwidth fraction of low-pass filter on intensity data (0.0->1.0) (enter - for default: 0.8)
          pflag      print flag (enter - for default)
                       0: print offset summary (default)
                       1: print all offset data
          pltflg     plotting flag (enter - for default)
                       0: none (default)
                       1: screen output
                       2: screen output and PNG format plots
                       3: output plots in PDF format
          ccs        (output) cross-correlation standard deviation of each patch (float)
          std_mean   patch minimum standard deviation/mean ratio (enter - for default: 0.01)

        """
        if self.validate_inputs:
            self._validate_offset_pwr_trackingm2(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                DIFF_par2,
                offs2,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )
        if self.mock_outputs:
            self._mock_offset_pwr_trackingm2_outputs(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                DIFF_par2,
                offs2,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_trackingm2))
        return self._gamma_call("DIFF", "offset_pwr_trackingm2", supplied_args)

    def _validate_init_offset_orbitm(
        self,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par: Path,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        cflag: Optional[int] = None,
    ) -> None:
        self._validate("init_offset_orbitm", MLI1_par.exists(), f"MLI1_par path does not exist ({MLI1_par})")
        self._validate("init_offset_orbitm", MLI2_par.exists(), f"MLI2_par path does not exist ({MLI2_par})")

    def _mock_init_offset_orbitm_outputs(
        self,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par: Path,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        cflag: Optional[int] = None,
    ) -> None:
        if not DIFF_par.exists():
            DIFF_par.touch()

    def init_offset_orbitm(
        self,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par: Path,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        cflag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Initial image offset estimation using orbit state-vectors and image parameters


        input parameters:
          MLI1_par  (input) MLI-1 image parameter file
          MLI2_par  (input) MLI-2 image parameter file
          DIFF_par  (input/output) DIFF/GEO parameter file
          rpos      range position for offset estimation (enter - for default: center of MLI-1)
          azpos     azimuth position for offset estimation (enter - for default: center of MLI-1)
          cflag     copy offsets to the range and azimuth offset polynomials in the DIFF_par
                      0: do not copy
                      1: copy constant range and azimuth offsets (default)

        """
        if self.validate_inputs:
            self._validate_init_offset_orbitm(MLI1_par, MLI2_par, DIFF_par, rpos, azpos, cflag)
        if self.mock_outputs:
            self._mock_init_offset_orbitm_outputs(MLI1_par, MLI2_par, DIFF_par, rpos, azpos, cflag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.init_offset_orbitm))
        return self._gamma_call("DIFF", "init_offset_orbitm", supplied_args)

    def _validate_quad_fit(
        self,
        unw: Path,
        DIFF_par: Path,
        dr: Optional[int] = None,
        daz: Optional[Any] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
        model: Optional[int] = None,
        pmodel: Optional[Path] = None,
    ) -> None:
        self._validate("quad_fit", unw.exists(), f"unw path does not exist ({unw})")
        self._validate("quad_fit", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_quad_fit_outputs(
        self,
        unw: Path,
        DIFF_par: Path,
        dr: Optional[int] = None,
        daz: Optional[Any] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
        model: Optional[int] = None,
        pmodel: Optional[Path] = None,
    ) -> None:
        if plot_data is not None and str(plot_data) != "-":
            plot_data.touch()
        if pmodel is not None and str(pmodel) != "-":
            pmodel.touch()

    def quad_fit(
        self,
        unw: Path,
        DIFF_par: Path,
        dr: Optional[int] = None,
        daz: Optional[Any] = None,
        mask: Optional[Path] = None,
        plot_data: Optional[Path] = None,
        model: Optional[int] = None,
        pmodel: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Estimate L.S quadratic polynomial model from unwrapped phase


        input parameters:
          unw        (input) unwrapped differential interferogram (float)
          DIFF_par   (input) differential interferogram parameters
          dr         range spacing in pixels between phase samples (enter - for default: 4)
          daz        azimuth spacing in lines between phase samples (enter - for default: 4)
          mask       mask (SUN/BMP/TIFF raster format), 0 valued pixels are excluded from being included in the model fit (enter - for none)
          plot_data  (output) plot data file (enter - for none)
          model      polynomial phase model (x->range, y->azimuth):
                       0: a0 + a1*y + a2*x + a3*x*y + a4*x^2 + a5*y^2 (default)
                       1: a0 + a4*x^2 + a5*y^2
                       2: a0 + a1*y + a2*x + a3*x*y
                       3: a0 + a1*y + a2*x
                       4: a0 + a2*x + a4*x^2
                       5: a0 + a2*x
                       6: a0 + a1*y + a5*y^2
                       7: a0 + a1*y
          pmodel     (output) 2D phase calculated using the model (float)

        """
        if self.validate_inputs:
            self._validate_quad_fit(unw, DIFF_par, dr, daz, mask, plot_data, model, pmodel)
        if self.mock_outputs:
            self._mock_quad_fit_outputs(unw, DIFF_par, dr, daz, mask, plot_data, model, pmodel)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.quad_fit))
        return self._gamma_call("DIFF", "quad_fit", supplied_args)

    def _validate_stacking(
        self,
        DIFF_tab: Path,
        width: int,
        ph_rate: Path,
        sig_ph_rate: Path,
        sig_ph: Path,
        xoff: int,
        yoff: int,
        nx: Optional[int] = None,
        ny: Optional[Any] = None,
        np_min: Optional[int] = None,
        tscale: Optional[int] = None,
    ) -> None:
        self._validate("stacking", DIFF_tab.exists(), f"DIFF_tab path does not exist ({DIFF_tab})")

    def _mock_stacking_outputs(
        self,
        DIFF_tab: Path,
        width: int,
        ph_rate: Path,
        sig_ph_rate: Path,
        sig_ph: Path,
        xoff: int,
        yoff: int,
        nx: Optional[int] = None,
        ny: Optional[Any] = None,
        np_min: Optional[int] = None,
        tscale: Optional[int] = None,
    ) -> None:
        if ph_rate is not None and str(ph_rate) != "-":
            ph_rate.touch()
        if sig_ph_rate is not None and str(sig_ph_rate) != "-":
            sig_ph_rate.touch()
        if sig_ph is not None and str(sig_ph) != "-":
            sig_ph.touch()

    def stacking(
        self,
        DIFF_tab: Path,
        width: int,
        ph_rate: Path,
        sig_ph_rate: Path,
        sig_ph: Path,
        xoff: int,
        yoff: int,
        nx: Optional[int] = None,
        ny: Optional[Any] = None,
        np_min: Optional[int] = None,
        tscale: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DIFF: Program stacking.c
        Estimate phase rate by stacking of multiple unwrapped differential interferograms


        input parameters:
          DIFF_tab    (input) 2 column list of unwrapped differential interferograms and delta_T values in days (text)
          width       number of sample/line for the unwrapped interferograms in the stack
          ph_rate     (output) average phase rate determined from a weighted sum of phases (radians/year, float)
          sig_ph_rate (output) standard deviation of the estimated phase rate (radians/year, float)
          sig_ph      (output) standard deviation of the residual phases (enter - for none, radians, float)
          xoff        x-offset (across) samples to the center of the phase reference region
          yoff        y-offset (down) lines to the center of the phase reference region
          nx          width (samples) of the phase reference region (enter - for default: 15)
          ny          height (lines) of the phase reference region (enter - for default: 15)
          np_min      min. number of phase values required to accept phase rate estimate (enter - for default: all files)
          tscale      time scale used for calculation of the phase rate:
                        0: radians/day
                        1: radians/year (default)

        """
        if self.validate_inputs:
            self._validate_stacking(DIFF_tab, width, ph_rate, sig_ph_rate, sig_ph, xoff, yoff, nx, ny, np_min, tscale)
        if self.mock_outputs:
            self._mock_stacking_outputs(
                DIFF_tab, width, ph_rate, sig_ph_rate, sig_ph, xoff, yoff, nx, ny, np_min, tscale
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.stacking))
        return self._gamma_call("DIFF", "stacking", supplied_args)

    def _validate_atm_mod2(
        self,
        diff_unw: Path,
        hgt: Path,
        MLI_par: Path,
        atm_phase: Path,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[Any] = None,
        loff: Optional[Any] = None,
    ) -> None:
        self._validate("atm_mod2", diff_unw.exists(), f"diff_unw path does not exist ({diff_unw})")
        self._validate("atm_mod2", hgt.exists(), f"hgt path does not exist ({hgt})")
        self._validate("atm_mod2", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        if mask is not None:
            self._validate("atm_mod2", mask.exists(), f"mask path does not exist ({mask})")

    def _mock_atm_mod2_outputs(
        self,
        diff_unw: Path,
        hgt: Path,
        MLI_par: Path,
        atm_phase: Path,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[Any] = None,
        loff: Optional[Any] = None,
    ) -> None:
        if atm_phase is not None and str(atm_phase) != "-":
            atm_phase.touch()

    def atm_mod2(
        self,
        diff_unw: Path,
        hgt: Path,
        MLI_par: Path,
        atm_phase: Path,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[Any] = None,
        loff: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Estimate atmospheric phase trend with respect to height, slant-range, and incidence angle


        input parameters:
          diff_unw  (input) unwrapped differential interferogram including atmospheric phase signal (FLOAT)
          hgt       (input) height coregistered to the interferogram in Range-Doppler Coordinates (enter - for none)
          MLI_par   (input) MLI image parameter file with same dimensions as the interferogram
          atm_phase (output) estimated atmospheric phase (FLOAT)
          dr        range sample increment (enter - for default: 1)
          daz       azimuth sample increment (enter - for default: 1)
          mask      (input) 8-bit raster image (SUN raster, BMP, or TIFF), (enter - for default: none)
                    NOTE: regions with (R,G,B)=0 in the mask are excluded
          model     atmospheric phase model (enter - for default)
                      0: height (default)
                      1: slant range (GPRI)
                      2: height and cosine(inc_ang) for wide swath data, e.g. Sentinel-1
                      3: slant range and height (GPRI)
          roff      reference point range sample offset (enter - for none)
          loff      reference point line offset (enter - for none)

          NOTE: unwrapped phase and height data must provided in range-doppler coordinates (RDC) as specified in the MLI parameter file

        """
        if self.validate_inputs:
            self._validate_atm_mod2(diff_unw, hgt, MLI_par, atm_phase, dr, daz, mask, model, roff, loff)
        if self.mock_outputs:
            self._mock_atm_mod2_outputs(diff_unw, hgt, MLI_par, atm_phase, dr, daz, mask, model, roff, loff)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.atm_mod2))
        return self._gamma_call("DIFF", "atm_mod2", supplied_args)

    def _validate_par_UAVSAR_geo(self, ann: Path, SLC_or_MLI_par: Path, DEM_par: Path) -> None:
        self._validate("par_UAVSAR_geo", ann.exists(), f"ann path does not exist ({ann})")

    def _mock_par_UAVSAR_geo_outputs(self, ann: Path, SLC_or_MLI_par: Path, DEM_par: Path) -> None:
        if SLC_or_MLI_par is not None and str(SLC_or_MLI_par) != "-":
            SLC_or_MLI_par.touch()
        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()

    def par_UAVSAR_geo(self, ann: Path, SLC_or_MLI_par: Path, DEM_par: Path) -> Tuple[int, str, str]:
        """

        Generate DEM parameter file for GRD products from UAVSAR annotation file (ann)


        input parameters:
          ann           (input) UAVSAR annotation file (*ann.txt)
          SLC/MLI_par   (output) ISP image parameter file for FLOAT format MLC products
          DEM_par       (output) DIFF/GEO DEM parameter file
        """
        if self.validate_inputs:
            self._validate_par_UAVSAR_geo(ann, SLC_or_MLI_par, DEM_par)
        if self.mock_outputs:
            self._mock_par_UAVSAR_geo_outputs(ann, SLC_or_MLI_par, DEM_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_UAVSAR_geo))
        return self._gamma_call("DIFF", "par_UAVSAR_geo", supplied_args)

    def _validate_multi_look_geo2(
        self,
        SLC: Path,
        DEM_par: Path,
        MLI: Path,
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        self._validate("multi_look_geo2", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("multi_look_geo2", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_multi_look_geo2_outputs(
        self,
        SLC: Path,
        DEM_par: Path,
        MLI: Path,
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

    def multi_look_geo2(
        self,
        SLC: Path,
        DEM_par: Path,
        MLI: Path,
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate a geocoded MLI image from a geocoded SLC with separate averaging window dimensions and decimation factors


        input parameters:
          SLC       (input) geocoded SLC image (SCOMPLEX or FCOMPLEX)
          DEM_par   (input) geocoded SLC DEM parameter file
          MLI       (output) geocoded MLI image
          DEM_par2  (output) MLI DEM parameter file
          e_dec      easting decimation factor (int)
          n_dec      northing decimation factor (int)
          e_win      easting averaging window width (int) (enter - for default: e_dec)
          n_win      northing averaging window height (int)(enter - for default: n_dec)
          wflg       window weighting function (enter - for default):
                       0: rectangular (default)
                       1: Kaiser
                       2: circular Gaussian
          n_ovr      oversampling factor 1 -> 2 (enter - for default: 1)
          lanczos    Lanczos interpolator order 5 -> 9 (enter - for default: 7)
          beta       Gaussian or Kaiser window parameter (enter - for default: 2.0)
          scale      scale factor for output MLI (enter - for default: 1.0)
          exp        exponent for the output MLI (enter - for default: 1.0)

        """
        if self.validate_inputs:
            self._validate_multi_look_geo2(
                SLC, DEM_par, MLI, DEM_par2, e_dec, n_dec, e_win, n_win, wflg, n_ovr, lanczos, beta, scale, exp
            )
        if self.mock_outputs:
            self._mock_multi_look_geo2_outputs(
                SLC, DEM_par, MLI, DEM_par2, e_dec, n_dec, e_win, n_win, wflg, n_ovr, lanczos, beta, scale, exp
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look_geo2))
        return self._gamma_call("DIFF", "multi_look_geo2", supplied_args)

    def _validate_dem_import(self, input_DEM: Path, DEM: Path, DEM_par: Path) -> None:
        self._validate("dem_import", input_DEM.exists(), f"input_DEM path does not exist ({input_DEM})")

    def _mock_dem_import_outputs(self, input_DEM: Path, DEM: Path, DEM_par: Path) -> None:
        if DEM is not None and str(DEM) != "-":
            DEM.touch()
        if not DEM_par.exists():
            DEM_par.touch()

    def dem_import(self, input_DEM: Path, DEM: Path, DEM_par: Path) -> Tuple[int, str, str]:
        """

        Convert original DEM file format into Gamma format, transform geoid heights into ellipsoid heights


        input parameters:
          input_DEM   (input) input DEM in original file format
          DEM         (output) DEM in binary format (float, enter - for none)
          DEM_par     (input/output) DEM parameter file corresponding to output DEM

          NOTE: if the DEM_par file does not exist and input_type is 0, 1, or 2, dem_import will try to
                automatically extract the ellipsoid, datum, and map projection parameters.

          input_type  input DEM type: (enter - for default)
                        0: GeoTIFF or any other GDAL supported raster format (default)
                        1: xyz triplets
                        2: ascii grid (ESRI)
                        3: UZH RSL (a pair of *.dem and *.dem.hdr files, only write the *.dem file in the command line)
                        4: Gamma binary file (to be used for converting the DEM height from a geoid height into an ellipsoid height)
          priority    priority flag: (enter - for default)
                        0: DEM_par parameters have priority
                        1: input DEM parameters have priority (default)

          NOTE: flexible parameters are the origin, size and pixel spacing. The other parameters must be consistent
                in both input_DEM and DEM_par files.

          geoid       (input) geoid or constant geoid height value (enter - for none)
          geoid_par   (input) geoid DEM_par file (enter - for none)
          geoid_type  geoid type: (enter - for default)
                        0: global geoid in EQA coordinates (default)
                        1: local geoid in the same coordinate system as the DEM

          NOTE: the geoid is used to transform the DEM height from an altitude above sea level (i.e. above the geoid) to an altitude
                above the ellipsoid. EGM96 global geoid is available as "$DIFF_HOME/scripts/egm96.dem" and "$DIFF_HOME/scripts/egm96.dem_par"
                EGM2008 global geoid is available as "$DIFF_HOME/scripts/egm2008-5.dem" and "$DIFF_HOME/scripts/egm2008-5.dem_par"

          latN_shift  latitude or Northing constant shift to apply on the input data (in degree / meter, enter - for default: 0.0)
          lonE_shift  longitude or Easting constant shift to apply on the input data (in degree / meter, enter - for default: 0.0)
          zflg        interpretation of no_data values in real data (enter - for default)
                        0: no_data values in the input file are kept as no_data values (0.0) in the output file (default)
                        1: no_data values in the input file are converted to valid near-zero values in the output file
          no_data     no_data value in the input file (enter - for default: value either defined in the input metadata or 0.0 if not found)
          GTF_direct  direction of GeoTIFF / GDAL supported raster format reading (enter - for default)
                        0: vertically
                        1: horizontally (default)

        """
        if self.validate_inputs:
            self._validate_dem_import(input_DEM, DEM, DEM_par)
        if self.mock_outputs:
            self._mock_dem_import_outputs(input_DEM, DEM, DEM_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_import))
        return self._gamma_call("DIFF", "dem_import", supplied_args)

    def _validate_SLC_interp_lt(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        blk_size: Optional[int],
        mode: int,
    ) -> None:
        self._validate("SLC_interp_lt", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("SLC_interp_lt", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("SLC_interp_lt", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("SLC_interp_lt", lookup_table.exists(), f"lookup_table path does not exist ({lookup_table})")
        self._validate("SLC_interp_lt", MLI1_par.exists(), f"MLI1_par path does not exist ({MLI1_par})")
        self._validate("SLC_interp_lt", MLI2_par.exists(), f"MLI2_par path does not exist ({MLI2_par})")
        self._validate("SLC_interp_lt", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_SLC_interp_lt_outputs(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        blk_size: Optional[int],
        mode: int,
    ) -> None:
        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()
        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp_lt(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        blk_size: Optional[int],
        mode: int,
    ) -> Tuple[int, str, str]:
        """

        Resample SLC image using a lookup table and a refinement offset polynomial if available


        input parameters:
          SLC2          (input) SLC-2 image to be resampled to the geometry of the SLC-1 reference image
          SLC1_par      (input) SLC/MLI ISP image parameter file of the SLC-1 reference
          SLC2_par      (input) SLC/MLI ISP image parameter file of SLC-2
          lookup_table  (input) lookup_table relating SLC-2 to SLC-1
          MLI1_par      (input) SLC/MLI ISP image parameter file of reference MLI (lookup table dimension)
          MLI2_par      (input) SLC/MLI ISP image parameter file of MLI2 (lookup table values)
          OFF_par       (input) ISP offset/interferogram parameter file used for refinement (enter - for none)
          SLC-2R        (output) single-look complex image 2 coregistered to SLC-1
          SLC2R_par     (output) SLC-2R ISP image parameter file for coregistered image
          blksz         number of lines/block (enter - for default, minimum value: 128)
          mode          interpolation mode (enter - for default)
                          0: Lanczos (default)
                          1: B-spline
          order         Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)

        """
        if self.validate_inputs:
            self._validate_SLC_interp_lt(
                SLC_2, SLC1_par, SLC2_par, lookup_table, MLI1_par, MLI2_par, OFF_par, SLC_2R, SLC2R_par, blk_size, mode
            )
        if self.mock_outputs:
            self._mock_SLC_interp_lt_outputs(
                SLC_2, SLC1_par, SLC2_par, lookup_table, MLI1_par, MLI2_par, OFF_par, SLC_2R, SLC2R_par, blk_size, mode
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp_lt))
        return self._gamma_call("DIFF", "SLC_interp_lt", supplied_args)

    def _validate_dispmap(
        self,
        unw: Path,
        hgt: Path,
        MLI_par: Path,
        OFF_par: Path,
        disp_map: Path,
        mode: Optional[Any] = None,
        sflg: Optional[int] = None,
    ) -> None:
        self._validate("dispmap", unw.exists(), f"unw path does not exist ({unw})")
        self._validate("dispmap", hgt.exists(), f"hgt path does not exist ({hgt})")
        self._validate("dispmap", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("dispmap", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_dispmap_outputs(
        self,
        unw: Path,
        hgt: Path,
        MLI_par: Path,
        OFF_par: Path,
        disp_map: Path,
        mode: Optional[Any] = None,
        sflg: Optional[int] = None,
    ) -> None:
        if disp_map is not None and str(disp_map) != "-":
            disp_map.touch()

    def dispmap(
        self,
        unw: Path,
        hgt: Path,
        MLI_par: Path,
        OFF_par: Path,
        disp_map: Path,
        mode: Optional[Any] = None,
        sflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Conversion of unwrapped differential phase to displacement (m)


        input parameters:
          unw       (input) unwrapped phase (radians), (float)
          hgt       (input) height map (enter - for none, reference height set to 0.0) (float)
          MLI_par   (input) SLC/MLI image parameter file of the reference scene
                    NOTE: use the SLC_par if the OFF_par is provided, otherwise use the MLI_par
          OFF_par   (input) ISP offset/interferogram parameter file (enter - for none)
                    NOTE: geometry and pixel spacing are determined from the MLI_par, if the OFF_par is not provided
          disp_map  (output) displacement map (float)
          mode      displacement mode (enter - for default):
                      0: calculate line of sight (LOS) deformation by scaling the unwrapped phase (default)
                      1: calculate the vertical displacement assuming that all the displacement is vertical
                      2: calculate the horizontal displacement assuming that all displacement is in the direction
                         of the look vector projected on the ground
          sflg      sign flag (enter - for default):
                      0: motion away from the radar is negative: unwrapped phase and deformation have opposite sign (default)
                      1: motion away from the radar is positive: unwrapped phase and deformation have the same sign
                         This is consistent with the look vector that points from the radar to the target on the ground

        """
        if self.validate_inputs:
            self._validate_dispmap(unw, hgt, MLI_par, OFF_par, disp_map, mode, sflg)
        if self.mock_outputs:
            self._mock_dispmap_outputs(unw, hgt, MLI_par, OFF_par, disp_map, mode, sflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap))
        return self._gamma_call("DIFF", "dispmap", supplied_args)

    def _validate_atm_mod(
        self,
        diff_unw: Path,
        hgt: Path,
        DIFF_par: Path,
        atm_phase: Path,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[Any] = None,
        loff: Optional[Any] = None,
    ) -> None:
        self._validate("atm_mod", diff_unw.exists(), f"diff_unw path does not exist ({diff_unw})")
        self._validate("atm_mod", hgt.exists(), f"hgt path does not exist ({hgt})")
        self._validate("atm_mod", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")
        if mask is not None:
            self._validate("atm_mod", mask.exists(), f"mask path does not exist ({mask})")

    def _mock_atm_mod_outputs(
        self,
        diff_unw: Path,
        hgt: Path,
        DIFF_par: Path,
        atm_phase: Path,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[Any] = None,
        loff: Optional[Any] = None,
    ) -> None:
        if atm_phase is not None and str(atm_phase) != "-":
            atm_phase.touch()

    def atm_mod(
        self,
        diff_unw: Path,
        hgt: Path,
        DIFF_par: Path,
        atm_phase: Path,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        mask: Optional[Path] = None,
        model: Optional[int] = None,
        roff: Optional[Any] = None,
        loff: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Estimate atmospheric phase trend with respect to height, and slant range


        input parameters:
          diff_unw  (input) unwrapped differential interferogram including atmospheric phase signal (float)
          hgt       (input) height coregistered to the interferogram (enter - for none)
          DIFF_par  (input) differential interferogram parameters
          atm_phase (output) estimated atmospheric phase (float)
          dr        range sample increment (enter - for default: 1)
          daz       azimuth sample increment (enter - for default: 1)
          mask      (input) 8-bit raster image (SUN raster, BMP, or TIFF) (enter - for default: none)
                    NOTE: regions with (R,G,B)=0 in the mask are excluded
          model     atmospheric phase model:
                      0: height (default)
                      1: slant range pixel number (GPRI mode)
          roff      reference point range sample offset
          loff      reference point line offset

        """
        if self.validate_inputs:
            self._validate_atm_mod(diff_unw, hgt, DIFF_par, atm_phase, dr, daz, mask, model, roff, loff)
        if self.mock_outputs:
            self._mock_atm_mod_outputs(diff_unw, hgt, DIFF_par, atm_phase, dr, daz, mask, model, roff, loff)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.atm_mod))
        return self._gamma_call("DIFF", "atm_mod", supplied_args)

    def _validate_ls_map_mask(
        self,
        ls_map: Path,
        width: int,
        mask: Path,
        outside_swath: Optional[int] = None,
        regular: Optional[int] = None,
        layover: Optional[int] = None,
        shadow: Optional[int] = None,
        shadow_in_layover: Optional[int] = None,
    ) -> None:
        self._validate("ls_map_mask", ls_map.exists(), f"ls_map path does not exist ({ls_map})")

    def _mock_ls_map_mask_outputs(
        self,
        ls_map: Path,
        width: int,
        mask: Path,
        outside_swath: Optional[int] = None,
        regular: Optional[int] = None,
        layover: Optional[int] = None,
        shadow: Optional[int] = None,
        shadow_in_layover: Optional[int] = None,
    ) -> None:
        if mask is not None and str(mask) != "-":
            mask.touch()

    def ls_map_mask(
        self,
        ls_map: Path,
        width: int,
        mask: Path,
        outside_swath: Optional[int] = None,
        regular: Optional[int] = None,
        layover: Optional[int] = None,
        shadow: Optional[int] = None,
        shadow_in_layover: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate a mask file from a layover and shadow map


        input parameters:
          ls_map              (input) layover and shadow map (UNSIGNED CHAR)
          width               width of input data
          mask                (output) output mask in SUN raster *.ras, BMP *.bmp, or TIFF *.tif format
          outside_swath       flag for data outside of the swath (enter - for default)
                                0: do not mask areas outside of the swath
                                1: mask areas outside of the swath (default)
          regular             flag for areas within the swath and unaffected by layover or shadow (enter - for default)
                                0: do not mask areas within the swath and unaffected by layover or shadow (default)
                                1: mask areas within the swath and unaffected by layover or shadow
          layover             flag for layover areas (enter - for default)
                                0: do not mask layover areas
                                1: mask layover areas (default)
          shadow              flag for shadow areas (enter - for default)
                                0: do not mask shadow areas
                                1: mask shadow areas (default)
          shadow_in_layover   flag for "shadow in layover" areas (enter - for default)
                                0: do not mask "shadow in layover" areas
                                1: mask "shadow in layover" areas (default)

        """
        if self.validate_inputs:
            self._validate_ls_map_mask(ls_map, width, mask, outside_swath, regular, layover, shadow, shadow_in_layover)
        if self.mock_outputs:
            self._mock_ls_map_mask_outputs(
                ls_map, width, mask, outside_swath, regular, layover, shadow, shadow_in_layover
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ls_map_mask))
        return self._gamma_call("DIFF", "ls_map_mask", supplied_args)

    def _validate_dispmap_LOS(
        self, unw: Path, width: int, freq: float, disp_map: Path, sflg: Optional[int] = None
    ) -> None:
        self._validate("dispmap_LOS", unw.exists(), f"unw path does not exist ({unw})")

    def _mock_dispmap_LOS_outputs(
        self, unw: Path, width: int, freq: float, disp_map: Path, sflg: Optional[int] = None
    ) -> None:
        if disp_map is not None and str(disp_map) != "-":
            disp_map.touch()

    def dispmap_LOS(
        self, unw: Path, width: int, freq: float, disp_map: Path, sflg: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Conversion of unwrapped differential phase to displacement along the LOS (m)


        input parameters:
          unw       (input) unwrapped phase (radians), (float)
          width     data samples/line
          freq      radar center frequency (GHz)
          disp_map  (output) displacement map along the Line of Sight (LOS) (float)
          sflg      displacement sign flag (enter - for default):
                      0: motion away from the radar is negative: unwrapped phase and deformation have opposite sign (default)
                      1: motion away from the radar is positive: unwrapped phase and deformation have the same sign
                         This is consistent with the look vector pointing from the radar to the target on the ground

        """
        if self.validate_inputs:
            self._validate_dispmap_LOS(unw, width, freq, disp_map, sflg)
        if self.mock_outputs:
            self._mock_dispmap_LOS_outputs(unw, width, freq, disp_map, sflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_LOS))
        return self._gamma_call("DIFF", "dispmap_LOS", supplied_args)

    def _validate_sub_phase(
        self,
        d1: Path,
        d2: Path,
        DIFF_par: Path,
        diff: Path,
        dtype1: int,
        mode: Optional[int] = None,
        dtype2: Optional[int] = None,
    ) -> None:
        self._validate("sub_phase", d1.exists(), f"d1 path does not exist ({d1})")
        self._validate("sub_phase", d2.exists(), f"d2 path does not exist ({d2})")
        self._validate("sub_phase", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_sub_phase_outputs(
        self,
        d1: Path,
        d2: Path,
        DIFF_par: Path,
        diff: Path,
        dtype1: int,
        mode: Optional[int] = None,
        dtype2: Optional[int] = None,
    ) -> None:
        if diff is not None and str(diff) != "-":
            diff.touch()

    def sub_phase(
        self,
        d1: Path,
        d2: Path,
        DIFF_par: Path,
        diff: Path,
        dtype1: int,
        mode: Optional[int] = None,
        dtype2: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Subtract or add phase from an SLC or interferogram


        input parameters:
          d1        (input) SLC, interferogram, or unwrapped phase (SCOMPLEX, FCOMPLEX, FLOAT format)
          d2        (input) SLC, interferogram, or unwrapped phase (SCOMPLEX, FCOMPLEX, FLOAT format)
          DIFF_par  (input) DIFF/GEO parameter file
          diff      (output) output data file, with the same data format as d1
          dtype1    d1 data type:
                      0: unwrapped phase (FLOAT)
                      1: interferogram or SLC (FCOMPLEX)
                      2: SLC (SCOMPLEX)
          mode      subtract or add phase of d2 (enter - for default)
                      0: subtract d2 phase from d1 data (default)
                      1: add d2 phase to d1 data
          dtype2    d2 data type (enter - for default)
                      0: unwrapped phase (FLOAT) (default)
                      1: interferogram or SLC (FCOMPLEX)
                      2: SLC (SCOMPLEX)
        NOTES:
          1. When d2 is SCOMPLEX or FCOMPLEX format, the phase of d2 is used
          2. When d1 is unwrapped phase, then d2 must also be unwrapped phase

        """
        if self.validate_inputs:
            self._validate_sub_phase(d1, d2, DIFF_par, diff, dtype1, mode, dtype2)
        if self.mock_outputs:
            self._mock_sub_phase_outputs(d1, d2, DIFF_par, diff, dtype1, mode, dtype2)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sub_phase))
        return self._gamma_call("DIFF", "sub_phase", supplied_args)

    def _validate_phase_sim(
        self,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        sim_unw: Path,
        ph_flag: Optional[int] = None,
        bflag: Optional[int] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
        ph_mode: Optional[int] = None,
    ) -> None:
        self._validate("phase_sim", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("phase_sim", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("phase_sim", baseline.exists(), f"baseline path does not exist ({baseline})")
        self._validate("phase_sim", hgt.exists(), f"hgt path does not exist ({hgt})")
        if def_ is not None:
            self._validate("phase_sim", def_.exists(), f"def_ path does not exist ({def_})")
        if delta_t is not None:
            self._validate("phase_sim", delta_t.exists(), f"delta_t path does not exist ({delta_t})")
        if SLC2R_par is not None:
            self._validate("phase_sim", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")

    def _mock_phase_sim_outputs(
        self,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        sim_unw: Path,
        ph_flag: Optional[int] = None,
        bflag: Optional[int] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
        ph_mode: Optional[int] = None,
    ) -> None:
        if sim_unw is not None and str(sim_unw) != "-":
            sim_unw.touch()

    def phase_sim(
        self,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        sim_unw: Path,
        ph_flag: Optional[int] = None,
        bflag: Optional[int] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
        ph_mode: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Simulate unwrapped interferometric phase using DEM height and deformation rate


        input parameters:
          SLC1_par  (input) parameter file of reference SLC-1
          OFF_par   (input) ISP offset/interferogram parameter file
          baseline  (input) baseline parameter file
          hgt       (input) height relative to the WGS-84 elliposid in the same geometry as the mosaic (m) (FLOAT, enter - for none)
          sim       (output) simulated interferometric phase (FLOAT, unwrapped)
          ph_flag   range phase trend selection:
                      0: unflattened interferogram (default)
                      1: flattened interferogram
          bflag     baseline selection:
                      0: initial baseline (default)
                      1: precision baseline
          def       (input) LOS deformation rate map (meters/yr, float, enter - for none)
          delta_t   (input) interferogram time interval (days, required for deformation modeling, enter - for none)
          int_mode  (input) interferometric acquisition mode  (enter - for default):
                      0: single-pass mode (Tandem-X)
                      1: repeat-pass mode (default)
          SLC2R_par (input) parameter file of resampled SLC, required if SLC-2 frequency differs from SLC-1, (enter - for none)
          ph_mode   phase offset mode:
                      0: absolute phase (default)
                      1: subtract phase at image center (height = 0.0) rounded to the nearest multiple of 2PI

        """
        if self.validate_inputs:
            self._validate_phase_sim(
                SLC1_par, OFF_par, baseline, hgt, sim_unw, ph_flag, bflag, def_, delta_t, int_mode, SLC2R_par, ph_mode
            )
        if self.mock_outputs:
            self._mock_phase_sim_outputs(
                SLC1_par, OFF_par, baseline, hgt, sim_unw, ph_flag, bflag, def_, delta_t, int_mode, SLC2R_par, ph_mode
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.phase_sim))
        return self._gamma_call("DIFF", "phase_sim", supplied_args)

    def _validate_offset_pwr_geo(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        self._validate("offset_pwr_geo", SLC1.exists(), f"SLC1 path does not exist ({SLC1})")
        self._validate("offset_pwr_geo", SLC2.exists(), f"SLC2 path does not exist ({SLC2})")
        self._validate("offset_pwr_geo", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_offset_pwr_geo_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if ccp is not None and str(ccp) != "-":
            ccp.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()
        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_geo(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Offset estimation between geocoded SLC images using intensity cross-correlation


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          DIFF_par  (input) DIFF parameter file created from DEM_par files
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          nr        number of offset estimates in range direction (enter - for default from offset parameter file)
          naz       number of offset estimates in azimuth direction (enter - for default from offset parameter file)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          format    SLC data format (enter - for default)
                      0: FCOMPLEX (default)
                      1: SCOMPLEX
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)

        """
        if self.validate_inputs:
            self._validate_offset_pwr_geo(
                SLC1,
                SLC2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                format,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        if self.mock_outputs:
            self._mock_offset_pwr_geo_outputs(
                SLC1,
                SLC2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                format,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_geo))
        return self._gamma_call("DIFF", "offset_pwr_geo", supplied_args)

    def _validate_par_RISAT_geo(
        self, annotation_XML: Path, GeoTIFF: Path, polarization: Path, DEM_par: Path, MLI_par: Path, MLI: Path
    ) -> None:
        self._validate(
            "par_RISAT_geo", annotation_XML.exists(), f"annotation_XML path does not exist ({annotation_XML})"
        )
        self._validate("par_RISAT_geo", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_RISAT_geo", polarization.exists(), f"polarization path does not exist ({polarization})")

    def _mock_par_RISAT_geo_outputs(
        self, annotation_XML: Path, GeoTIFF: Path, polarization: Path, DEM_par: Path, MLI_par: Path, MLI: Path
    ) -> None:
        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if MLI is not None and str(MLI) != "-":
            MLI.touch()

    def par_RISAT_geo(
        self, annotation_XML: Path, GeoTIFF: Path, polarization: Path, DEM_par: Path, MLI_par: Path, MLI: Path
    ) -> Tuple[int, str, str]:
        """

        Generate DEM parameter file, MLI image, and MLI parameter file for RISAT-1 GeoTIFF products


        input parameters:
          annotation_XML (input) RISAT-1 product annotation XML file (product.xml)
          GeoTIFF        (input) image data file in GeoTIFF format (imagery_pp.tif)
          polarization   (input) polarization RV, RH of the GeoTIFF image data
          DEM_par        (output) DIFF/GEO DEM parameter file
          MLI_par        (output) ISP image parameter file (example: yyyymmdd_pp.mli.par)
          MLI            (output) SLC data file (example: yyyymmdd_pp.mli)
        """
        if self.validate_inputs:
            self._validate_par_RISAT_geo(annotation_XML, GeoTIFF, polarization, DEM_par, MLI_par, MLI)
        if self.mock_outputs:
            self._mock_par_RISAT_geo_outputs(annotation_XML, GeoTIFF, polarization, DEM_par, MLI_par, MLI)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RISAT_geo))
        return self._gamma_call("DIFF", "par_RISAT_geo", supplied_args)

    def _validate_MLI_interp_lt(
        self,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        lookup_table: Path,
        MLI3_par: Path,
        MLI4_par: Path,
        DIFF_par: Path,
        MLI_2R: Path,
        MLI2R_par: Path,
        order: Optional[int] = None,
    ) -> None:
        self._validate("MLI_interp_lt", MLI_2.exists(), f"MLI_2 path does not exist ({MLI_2})")
        self._validate("MLI_interp_lt", MLI1_par.exists(), f"MLI1_par path does not exist ({MLI1_par})")
        self._validate("MLI_interp_lt", MLI2_par.exists(), f"MLI2_par path does not exist ({MLI2_par})")
        self._validate("MLI_interp_lt", lookup_table.exists(), f"lookup_table path does not exist ({lookup_table})")
        self._validate("MLI_interp_lt", MLI3_par.exists(), f"MLI3_par path does not exist ({MLI3_par})")
        self._validate("MLI_interp_lt", MLI4_par.exists(), f"MLI4_par path does not exist ({MLI4_par})")
        self._validate("MLI_interp_lt", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_MLI_interp_lt_outputs(
        self,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        lookup_table: Path,
        MLI3_par: Path,
        MLI4_par: Path,
        DIFF_par: Path,
        MLI_2R: Path,
        MLI2R_par: Path,
        order: Optional[int] = None,
    ) -> None:
        if MLI_2R is not None and str(MLI_2R) != "-":
            MLI_2R.touch()
        if MLI2R_par is not None and str(MLI2R_par) != "-":
            MLI2R_par.touch()

    def MLI_interp_lt(
        self,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        lookup_table: Path,
        MLI3_par: Path,
        MLI4_par: Path,
        DIFF_par: Path,
        MLI_2R: Path,
        MLI2R_par: Path,
        order: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        MLI image resampling via a lookup table and B-spline interpolation


        input parameters:
          MLI-2         (input) MLI-2 image to be resampled to the geometry of the MLI-1 reference image
          MLI1_par      (input) ISP image parameter file of the MLI-1 reference
          MLI2_par      (input) ISP image parameter file of MLI-2
          lookup_table  (input) lookup_table relating MLI-2 to MLI-1
          MLI3_par      (input) ISP image parameter file of reference scene MLI-3 (lookup table dimension)
          MLI4_par      (input) ISP image parameter file of MLI-4 (lookup table values)
          DIFF_par      (input) DIFF parameter file used for refinement (enter - for none)
          MLI-2R        (output) MLI-2 coregistered to MLI-1
          MLI2R_par     (output) MLI-2R ISP image parameter file for coregistered image
          order         B-Spline interpolation degree (2->9) (enter - default: 3)

        """
        if self.validate_inputs:
            self._validate_MLI_interp_lt(
                MLI_2, MLI1_par, MLI2_par, lookup_table, MLI3_par, MLI4_par, DIFF_par, MLI_2R, MLI2R_par, order
            )
        if self.mock_outputs:
            self._mock_MLI_interp_lt_outputs(
                MLI_2, MLI1_par, MLI2_par, lookup_table, MLI3_par, MLI4_par, DIFF_par, MLI_2R, MLI2R_par, order
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.MLI_interp_lt))
        return self._gamma_call("DIFF", "MLI_interp_lt", supplied_args)

    def _validate_lk_vec_lt(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lt: Path,
        lv_theta: Path,
        lv_phi: Path,
        lv_ENU: Optional[Path] = None,
        azv_ENU: Optional[Path] = None,
    ) -> None:
        self._validate("lk_vec_lt", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("lk_vec_lt", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("lk_vec_lt", DEM.exists(), f"DEM path does not exist ({DEM})")
        self._validate("lk_vec_lt", lt.exists(), f"lt path does not exist ({lt})")

    def _mock_lk_vec_lt_outputs(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lt: Path,
        lv_theta: Path,
        lv_phi: Path,
        lv_ENU: Optional[Path] = None,
        azv_ENU: Optional[Path] = None,
    ) -> None:
        if lv_theta is not None and str(lv_theta) != "-":
            lv_theta.touch()
        if lv_phi is not None and str(lv_phi) != "-":
            lv_phi.touch()
        if lv_ENU is not None and str(lv_ENU) != "-":
            lv_ENU.touch()
        if azv_ENU is not None and str(azv_ENU) != "-":
            azv_ENU.touch()

    def lk_vec_lt(
        self,
        MLI_par: Path,
        DEM_par: Path,
        DEM: Path,
        lt: Path,
        lv_theta: Path,
        lv_phi: Path,
        lv_ENU: Optional[Path] = None,
        azv_ENU: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate look-vector elevation and orientation angles using the geocoding lookup-table


        input parameters:
          MLI_par   (input) ISP MLI/SLC image parameter file
                    NOTE: MLI_par must have the same dimensions and number of looks as the image used to calculate the geocoding lookup table
          DEM_par   (input) DEM/MAP parameter file
          DEM       (input) DEM data file or constant height value
          lt        (input) geocoding lookup table with same dimensions as DEM
          lv_theta  (output) SAR look-vector elevation angle with respect to the topocentric horizontal plane at each map pixel (enter - for none)
                      lv_theta: PI/2 -> up  -PI/2 -> down
                      The elevation angle is measured between the local topocentric horizontal plane and the look vector pointing at the radar
          lv_phi    (output) SAR look-vector orientation angle in the topocentric horizontal plane at each map pixel (enter - for none)
                      lv_phi: 0 -> East  PI/2 -> North
          lv_ENU    (output) unit look vector (pointing from SAR sensor to ground) given in East, North, Up (ENU) topocentric coordinates at each map pixel (float) (enter - for none)
          azv_ENU   (output) unit vector in the positive azimuth direction, East, North, Up (ENU) topocentric coordinates (float) (enter - for none)

        """
        if self.validate_inputs:
            self._validate_lk_vec_lt(MLI_par, DEM_par, DEM, lt, lv_theta, lv_phi, lv_ENU, azv_ENU)
        if self.mock_outputs:
            self._mock_lk_vec_lt_outputs(MLI_par, DEM_par, DEM, lt, lv_theta, lv_phi, lv_ENU, azv_ENU)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lk_vec_lt))
        return self._gamma_call("DIFF", "lk_vec_lt", supplied_args)

    def _validate_offset_pwr_tracking_geo(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        self._validate("offset_pwr_tracking_geo", SLC1.exists(), f"SLC1 path does not exist ({SLC1})")
        self._validate("offset_pwr_tracking_geo", SLC2.exists(), f"SLC2 path does not exist ({SLC2})")
        self._validate("offset_pwr_tracking_geo", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_offset_pwr_tracking_geo_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if ccp is not None and str(ccp) != "-":
            ccp.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()
        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_tracking_geo(
        self,
        SLC1: Path,
        SLC2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        format: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Offset estimation between geocoded SLC images using intensity cross-correlation***


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          DIFF_par  (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          format    SLC data format (enter - for default)
                      0: FCOMPLEX (default)
                      1: SCOMPLEX
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)

        """
        if self.validate_inputs:
            self._validate_offset_pwr_tracking_geo(
                SLC1,
                SLC2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                format,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        if self.mock_outputs:
            self._mock_offset_pwr_tracking_geo_outputs(
                SLC1,
                SLC2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                format,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_tracking_geo))
        return self._gamma_call("DIFF", "offset_pwr_tracking_geo", supplied_args)

    def _validate_coord_to_sarpix(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Optional[Path],
        north_or_lat: float,
        east_or_lon: float,
        hgt: float,
        DIFF_par: Optional[Path] = None,
    ) -> None:
        self._validate("coord_to_sarpix", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("coord_to_sarpix", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        if DEM_par is not None:
            self._validate("coord_to_sarpix", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        if DIFF_par is not None:
            self._validate("coord_to_sarpix", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_coord_to_sarpix_outputs(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Optional[Path],
        north_or_lat: float,
        east_or_lon: float,
        hgt: float,
        DIFF_par: Optional[Path] = None,
    ) -> None:
        pass

    def coord_to_sarpix(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path],
        DEM_par: Optional[Path],
        north_or_lat: float,
        east_or_lon: float,
        hgt: float,
        DIFF_par: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate the SAR image pixel coordinates of a point specified in map coordinates


        input parameters:
          SLC/MLI_par  (input) ISP SLC/MLI image parameter file
          OFF_par      (input) ISP offset/interferogram parameter file, enter - for SLC or MLI data
                         NOTE: it should not be necessary to enter this parameter file. The SLC/MLI parameter file should describe
                       the scene dimensions including the number of range and azimuth looks
          DEM_par      (input) DEM parameter file defining geometry of input coordinates (enter - for none)
                         NOTE: when no DEM parameter file is provided, then the input coordinates are interpreted as latitude and longitude in the WGS84 datum
          north/lat    (input) northing (m) or latitude (deg.)
          east/lon     (input) easting (m) or longitude (deg.)
          hgt          (input) height (m) of the point in the map datum
          DIFF_par     (input) DIFF/GEO parameter file containing refinement polynomial coefficients (default: none)

          NOTE: When the DIFF_par is specified, it is assumed that the simulated image was the reference for determining the geocoding correction

        """
        if self.validate_inputs:
            self._validate_coord_to_sarpix(SLC_par, OFF_par, DEM_par, north_or_lat, east_or_lon, hgt, DIFF_par)
        if self.mock_outputs:
            self._mock_coord_to_sarpix_outputs(SLC_par, OFF_par, DEM_par, north_or_lat, east_or_lon, hgt, DIFF_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.coord_to_sarpix))
        return self._gamma_call("DIFF", "coord_to_sarpix", supplied_args)

    def _validate_WSS_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        m_flg: Optional[int] = None,
        boff: Optional[int] = None,
        bstep: Optional[Any] = None,
        bmax: Optional[Any] = None,
    ) -> None:
        self._validate("WSS_intf", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("WSS_intf", SLC_2R.exists(), f"SLC_2R path does not exist ({SLC_2R})")
        self._validate("WSS_intf", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("WSS_intf", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")

    def _mock_WSS_intf_outputs(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        m_flg: Optional[int] = None,
        boff: Optional[int] = None,
        bstep: Optional[Any] = None,
        bmax: Optional[Any] = None,
    ) -> None:
        if OFF_par is not None and str(OFF_par) != "-":
            OFF_par.touch()
        if interf is not None and str(interf) != "-":
            interf.touch()

    def WSS_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        m_flg: Optional[int] = None,
        boff: Optional[int] = None,
        bstep: Optional[Any] = None,
        bmax: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate multi-look interferogram from ASAR Wide-Swath SLC images


        input parameters:
          SLC-1     (input) reference ASAR Wide-Swath SLC image
          SLC-2R    (input) resampled ASAR Wide-Swath SLC image coregistered to SLC-1
          SLC1_par  (input) ASAR Wide-Swath SLC image parameter file
          SLC2R_par (input) co-registered ASAR Wide-Swath SLC-2R image parameter file
          OFF_par   (output) ISP offset/interferogram parameter file
          interf    (output) interferogram from SLC-1 and SLC-2R
          rlks      number of range looks (enter - for default: 1)
          sps_flg   range spectral shift flag:
                      1: apply range spectral shift filter (default)
                      0: do not apply range spectral shift filter
          azf_flg   azimuth common band filter flag:
                      1: apply azimuth common band filter (default)
                      0: do not apply azimuth common band filter
          m_flg     output magnitude flag:
                      0: set output interferogram magnitude to 1.0 for non-zero samples (default)
                      1: retain multi-burst interferometric magnitude
          boff      offset to first burst to interfere (default = 0)
          bstep     burst step (default = 1)
          bmax      last burst to interfere (default = to end of SLC-1)

        """
        if self.validate_inputs:
            self._validate_WSS_intf(
                SLC_1, SLC_2R, SLC1_par, SLC2R_par, OFF_par, interf, rlks, sps_flg, azf_flg, m_flg, boff, bstep, bmax
            )
        if self.mock_outputs:
            self._mock_WSS_intf_outputs(
                SLC_1, SLC_2R, SLC1_par, SLC2R_par, OFF_par, interf, rlks, sps_flg, azf_flg, m_flg, boff, bstep, bmax
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.WSS_intf))
        return self._gamma_call("DIFF", "WSS_intf", supplied_args)

    def _validate_map_section(
        self,
        DEM_par: Path,
        n1: Path,
        e1: Path,
        n2: Path,
        e2: Any,
        post_north: Any,
        post_east: Any,
        DEM_par2: Path,
        lt: Optional[Path] = None,
        ISP_par1: Optional[Path] = None,
        ISP_par2: Optional[Path] = None,
        cflg: Optional[Any] = None,
        lt2: Optional[Path] = None,
        coord: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("map_section", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        if lt is not None:
            self._validate("map_section", lt.exists(), f"lt path does not exist ({lt})")
        if ISP_par1 is not None:
            self._validate("map_section", ISP_par1.exists(), f"ISP_par1 path does not exist ({ISP_par1})")
        if ISP_par2 is not None:
            self._validate("map_section", ISP_par2.exists(), f"ISP_par2 path does not exist ({ISP_par2})")

    def _mock_map_section_outputs(
        self,
        DEM_par: Path,
        n1: Path,
        e1: Path,
        n2: Path,
        e2: Any,
        post_north: Any,
        post_east: Any,
        DEM_par2: Path,
        lt: Optional[Path] = None,
        ISP_par1: Optional[Path] = None,
        ISP_par2: Optional[Path] = None,
        cflg: Optional[Any] = None,
        lt2: Optional[Path] = None,
        coord: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()
        if lt2 is not None and str(lt2) != "-":
            lt2.touch()
        if coord is not None and str(coord) != "-":
            coord.touch()

    def map_section(
        self,
        DEM_par: Path,
        n1: Path,
        e1: Path,
        n2: Path,
        e2: Any,
        post_north: Any,
        post_east: Any,
        DEM_par2: Path,
        lt: Optional[Path] = None,
        ISP_par1: Optional[Path] = None,
        ISP_par2: Optional[Path] = None,
        cflg: Optional[Any] = None,
        lt2: Optional[Path] = None,
        coord: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate the DEM parameter file of a specfied region and extract this region from a geocoding lookup table


        input parameters:
          DEM_par     (input) DEM parameter file describing the input map geometry
          north1      northing map coordinate of the upper-left corner of the map segment (enter - to use the value in the DEM_par)
          east1       easting  map coordinate of the upper-left corner of the map segment (enter - to use the value in the DEM_par)
          north2      northing map coordinate of the lower-right corner of the map segment (enter - to use the value in the DEM_par)
          east2       easting  map coordinate of the lower-right corner of the map segment (enter - to use the value in the DEM_par)
                      NOTE: units for the corner coordinates depend on the projection specified in the DEM_par
          post_north  posting of the output lookup table for map samples in northing (enter - to keep the posting in the DEM_par)
                      NOTE: post_north must be a negative number to prevent the DEM from flipping north/south when displayed
          post_east   posting of the output lookup table in map coordinates in easting  (enter - to keep the posting in the DEM_par)
                      NOTE: post_east must be a positive number to prevent the DEM from flipping east/west when displayed
          DEM_par2    (output) DEM parameter file describing the output lookup table
          lt          (input) geocoding lookup table for the transformation from map geometry to radar Range-Doppler Coordinates (RDC) (enter - for none)
                      NOTE: The lookup table has the dimensions described by the DEM_par
          ISP_par1    (input) image parameter file (MLI_par or SLC_par) of the data used for calculation of the input lookup table values (enter - for none)
          ISP_par2    (input) image parameter file (MLI_par or SLC_par) of the data that will be terrain geocoded with the new lookup table lt2 (enter - to be the same as ISP_par1)
                      NOTE: Must be generated from the same SLC image as MLI_par but differs in the number of range and azimuth looks
          cflg        lookup table coordinate shift flag (enter - for default):
                        0: leave output lookup table values unchanged (default)
                           The output lookup table values are coordinates defined by the ISP_par1 parameters
                        1: subtract range and azimuth offsets from the output lookup table values
                           The output lookup table values are coordinates defined by the bounding box of the specified region (coords)
          lt2         (output) resampled geocoding lookup table with the specified bounds and map posting (enter - for none)
          coords      (output) rectangular region coordinates covering the region of the lt2 lookup table (text format, enter - for none)
                        ISP_par1 geometry: range_offset  range samples   azimuth_offset  azimuth_lines
                        ISP_par2 geometry: range_offset  range samples   azimuth_offset  azimuth_lines
          width       number of samples per line of lt2, (enter - for default, calculated from (east1 - east2))
          nlines      number of lines in the output lt2, (enter - for default, calculated from (north1 - north2))

        """
        if self.validate_inputs:
            self._validate_map_section(
                DEM_par,
                n1,
                e1,
                n2,
                e2,
                post_north,
                post_east,
                DEM_par2,
                lt,
                ISP_par1,
                ISP_par2,
                cflg,
                lt2,
                coord,
                width,
                nlines,
            )
        if self.mock_outputs:
            self._mock_map_section_outputs(
                DEM_par,
                n1,
                e1,
                n2,
                e2,
                post_north,
                post_east,
                DEM_par2,
                lt,
                ISP_par1,
                ISP_par2,
                cflg,
                lt2,
                coord,
                width,
                nlines,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.map_section))
        return self._gamma_call("DIFF", "map_section", supplied_args)

    def _validate_offset_list_fitm(
        self,
        cp_list: Path,
        DIFF_par: Path,
        DEM_par: Path,
        lookup_table: Optional[Path] = None,
        lt_type: Optional[int] = None,
        type1: Optional[int] = None,
        type2: Optional[int] = None,
        coffsets: Optional[Path] = None,
        poly_order: Optional[Any] = None,
        interact_flag: Optional[Any] = None,
        trans_list: Optional[Any] = None,
    ) -> None:
        self._validate("offset_list_fitm", cp_list.exists(), f"cp_list path does not exist ({cp_list})")
        self._validate("offset_list_fitm", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        if lookup_table is not None:
            self._validate(
                "offset_list_fitm", lookup_table.exists(), f"lookup_table path does not exist ({lookup_table})"
            )

    def _mock_offset_list_fitm_outputs(
        self,
        cp_list: Path,
        DIFF_par: Path,
        DEM_par: Path,
        lookup_table: Optional[Path] = None,
        lt_type: Optional[int] = None,
        type1: Optional[int] = None,
        type2: Optional[int] = None,
        coffsets: Optional[Path] = None,
        poly_order: Optional[Any] = None,
        interact_flag: Optional[Any] = None,
        trans_list: Optional[Any] = None,
    ) -> None:
        if not DIFF_par.exists():
            DIFF_par.touch()
        if coffsets is not None and str(coffsets) != "-":
            coffsets.touch()

    def offset_list_fitm(
        self,
        cp_list: Path,
        DIFF_par: Path,
        DEM_par: Path,
        lookup_table: Optional[Path] = None,
        lt_type: Optional[int] = None,
        type1: Optional[int] = None,
        type2: Optional[int] = None,
        coffsets: Optional[Path] = None,
        poly_order: Optional[Any] = None,
        interact_flag: Optional[Any] = None,
        trans_list: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate fine registration polynomial for geocoding from control point list


        input parameters:
          cp_list        (input) list with registration control point (CP) coordinates:
                           CP_nr  ref_col  ref_row  col2  row2
          DIFF_par       (input/output) DIFF&GEO parameter file (for output of fine registration polynomial)
          DEM_par        (input)DEM/MAP parameter file (enter - for none)
          lookup_table   (input)geocoding lookup table (required to convert between map pixel numbers and SAR pixel numbers)
          lt_type        lookup table type (enter - for default)
                           1: map_to_rdc (default)
                           2: rdc_to_map
          type1          reference coordinate type (enter - for default):
                           1: SAR (col,row) pixel numbers (default):
                           2: map (col,row) pixel numbers
                           3: map (easting, northing) coordinates)
          type2          image 2 coordinate type (enter - for default):
                           1: SAR (col,row) pixel numbers (default)
                           2: map (col,row) pixel numbers
                           3: map (easting, northing) coordinates)
          coffsets       (output) list of culled registration offsets (text file)
          poly_order     polynomial order parameter (1, 3, 4, 6, default: 4)
          interact_flag  interactive culling of input data (1=YES, 0=NO, default: NO)
          trans_list     transformed coordinate list using model

        """
        if self.validate_inputs:
            self._validate_offset_list_fitm(
                cp_list,
                DIFF_par,
                DEM_par,
                lookup_table,
                lt_type,
                type1,
                type2,
                coffsets,
                poly_order,
                interact_flag,
                trans_list,
            )
        if self.mock_outputs:
            self._mock_offset_list_fitm_outputs(
                cp_list,
                DIFF_par,
                DEM_par,
                lookup_table,
                lt_type,
                type1,
                type2,
                coffsets,
                poly_order,
                interact_flag,
                trans_list,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_list_fitm))
        return self._gamma_call("DIFF", "offset_list_fitm", supplied_args)

    def _validate_dem_RDC_list(
        self,
        DEM_par1: Path,
        gc_map: Path,
        MLI_par: Path,
        mask: Path,
        clist_RDC: Path,
        clist_MAP: Path,
        DEM_par2: Path,
        s_north: Any,
        s_east: Any,
    ) -> None:
        self._validate("dem_RDC_list", DEM_par1.exists(), f"DEM_par1 path does not exist ({DEM_par1})")
        self._validate("dem_RDC_list", gc_map.exists(), f"gc_map path does not exist ({gc_map})")
        self._validate("dem_RDC_list", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("dem_RDC_list", mask.exists(), f"mask path does not exist ({mask})")

    def _mock_dem_RDC_list_outputs(
        self,
        DEM_par1: Path,
        gc_map: Path,
        MLI_par: Path,
        mask: Path,
        clist_RDC: Path,
        clist_MAP: Path,
        DEM_par2: Path,
        s_north: Any,
        s_east: Any,
    ) -> None:
        if clist_RDC is not None and str(clist_RDC) != "-":
            clist_RDC.touch()
        if clist_MAP is not None and str(clist_MAP) != "-":
            clist_MAP.touch()
        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

    def dem_RDC_list(
        self,
        DEM_par1: Path,
        gc_map: Path,
        MLI_par: Path,
        mask: Path,
        clist_RDC: Path,
        clist_MAP: Path,
        DEM_par2: Path,
        s_north: Any,
        s_east: Any,
    ) -> Tuple[int, str, str]:
        """

        Generate coordinate lists in Range-Doppler Coordinates (RDC) and DEM coordinates using a lookup table


        input parameters:
          DEM_par1   (input) DEM parameter file describing region covered by the geocoding lookup table
          gc_map     (input) geocoding lookup table containing RDC coordinates defined by DEM_par1
          MLI_par    (input) ISP image parameter file of MLI image associated with the geocoding lookup table
          mask       (input) mask file in 8-bit raster mask to exclude regions in the map geometry (enter - for none)
                     NOTE: pixels with (R,G,B)=0 are excluded from the clist_RDC and clist_MAP
          clist_RDC  (output) list of x,y pixel coordinates in the reference SLC image geometry (Range-Doppler Coordinates) (text format)
          clist_MAP  (output) list of x,y pixel coordinates in the map projection geometry (text format)
          DEM_par2   (output) DEM parameter file associated with clist_MAP
          s_north    DEM latitude, S, or northing subsampling factor for patch locations (integer >= 1) (nominal: 10)
          s_east     DEM longitude, C, or easting subsampling factor (integer >= 1) (nominal: 10)
        """
        if self.validate_inputs:
            self._validate_dem_RDC_list(
                DEM_par1, gc_map, MLI_par, mask, clist_RDC, clist_MAP, DEM_par2, s_north, s_east
            )
        if self.mock_outputs:
            self._mock_dem_RDC_list_outputs(
                DEM_par1, gc_map, MLI_par, mask, clist_RDC, clist_MAP, DEM_par2, s_north, s_east
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_RDC_list))
        return self._gamma_call("DIFF", "dem_RDC_list", supplied_args)

    def _validate_multi_look_geo(
        self,
        SLC_or_MLI: Path,
        DEM_par1: Path,
        MLI: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        dtype: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        self._validate("multi_look_geo", SLC_or_MLI.exists(), f"SLC_or_MLI path does not exist ({SLC_or_MLI})")
        self._validate("multi_look_geo", DEM_par1.exists(), f"DEM_par1 path does not exist ({DEM_par1})")

    def _mock_multi_look_geo_outputs(
        self,
        SLC_or_MLI: Path,
        DEM_par1: Path,
        MLI: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        dtype: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

    def multi_look_geo(
        self,
        SLC_or_MLI: Path,
        DEM_par1: Path,
        MLI: Path,
        DEM_par2: Path,
        e_lks: int,
        n_lks: int,
        dtype: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate a multi-look geocoded MLI image from a geocoded SLC or MLI image


        input parameters:
          SLC/MLI      (input) geocoded SLC or MLI image (FCOMPLEX, SCOMPLEX, or FLOAT)
          DEM_par1     (input) DEM parameter file of the input image
          MLI          (output) geocoded MLI image (FLOAT)
          DEM_par2     (output) DEM parameter file of the output image
          e_lks        number of easting looks (longitude, cross-track)
          n_lks        number of northing looks (latitude, along-track)
          dtype        input data type:
                         0: FCOMPLEX (default)
                         1: SCOMPLEX
                         2: FLOAT
          scale        scale factor for output MLI (enter - for default: 1.0)
          exp          exponent for the output MLI (enter - for default: 1.0)

        """
        if self.validate_inputs:
            self._validate_multi_look_geo(SLC_or_MLI, DEM_par1, MLI, DEM_par2, e_lks, n_lks, dtype, scale, exp)
        if self.mock_outputs:
            self._mock_multi_look_geo_outputs(SLC_or_MLI, DEM_par1, MLI, DEM_par2, e_lks, n_lks, dtype, scale, exp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look_geo))
        return self._gamma_call("DIFF", "multi_look_geo", supplied_args)

    def _validate_atm_mod_2d(
        self,
        diff_unw: Path,
        hgt: Path,
        cc: Path,
        DIFF_par: Path,
        mask: Path,
        model: int,
        a0: Path,
        a1: Path,
        sigma: Path,
        sigma_h: Path,
        s1: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        h0: Optional[Any] = None,
        alpha: Optional[Any] = None,
        cc_min: Optional[Any] = None,
        mfrac: Optional[Any] = None,
        xref: Optional[Any] = None,
        yref: Optional[Any] = None,
        sflg: Optional[int] = None,
        svd_tol: Optional[Any] = None,
        w0: Optional[Any] = None,
        w1: Optional[Any] = None,
    ) -> None:
        self._validate("atm_mod_2d", diff_unw.exists(), f"diff_unw path does not exist ({diff_unw})")
        self._validate("atm_mod_2d", hgt.exists(), f"hgt path does not exist ({hgt})")
        self._validate("atm_mod_2d", cc.exists(), f"cc path does not exist ({cc})")
        self._validate("atm_mod_2d", mask.exists(), f"mask path does not exist ({mask})")

    def _mock_atm_mod_2d_outputs(
        self,
        diff_unw: Path,
        hgt: Path,
        cc: Path,
        DIFF_par: Path,
        mask: Path,
        model: int,
        a0: Path,
        a1: Path,
        sigma: Path,
        sigma_h: Path,
        s1: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        h0: Optional[Any] = None,
        alpha: Optional[Any] = None,
        cc_min: Optional[Any] = None,
        mfrac: Optional[Any] = None,
        xref: Optional[Any] = None,
        yref: Optional[Any] = None,
        sflg: Optional[int] = None,
        svd_tol: Optional[Any] = None,
        w0: Optional[Any] = None,
        w1: Optional[Any] = None,
    ) -> None:
        if not DIFF_par.exists():
            DIFF_par.touch()
        if a0 is not None and str(a0) != "-":
            a0.touch()
        if a1 is not None and str(a1) != "-":
            a1.touch()
        if sigma is not None and str(sigma) != "-":
            sigma.touch()
        if sigma_h is not None and str(sigma_h) != "-":
            sigma_h.touch()
        if s1 is not None and str(s1) != "-":
            s1.touch()

    def atm_mod_2d(
        self,
        diff_unw: Path,
        hgt: Path,
        cc: Path,
        DIFF_par: Path,
        mask: Path,
        model: int,
        a0: Path,
        a1: Path,
        sigma: Path,
        sigma_h: Path,
        s1: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        h0: Optional[Any] = None,
        alpha: Optional[Any] = None,
        cc_min: Optional[Any] = None,
        mfrac: Optional[Any] = None,
        xref: Optional[Any] = None,
        yref: Optional[Any] = None,
        sflg: Optional[int] = None,
        svd_tol: Optional[Any] = None,
        w0: Optional[Any] = None,
        w1: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Estimate atmospheric phase model parameters on a 2D grid


        input parameters:
          diff_unw  (input) list of unwrapped phase interferograms including the atmospheric phase (FLOAT)
          hgt       (input) height coregistered to the interferogram (FLOAT)
          cc        (input) correlation coefficient (enter - for none) (FLOAT)
          DIFF_par  (input/output) DIFF/GEO parameter file
                    NOTE: contains patch coordinates and dimensions used to used to estimate the local atmosphere phase model
          mask      (input) 8-bit raster image (SUN raster, BMP, or TIFF format)
                    regions with (R,G,B)=0 in the mask are excluded (enter - for none)
          model     atmospheric phase model (enter - for default):
                      0: linear:      atm_phase = a0 + a1*h
                      1: power-law:   atm_phase = a0 + a1*(h0 - h)**alpha
          a0        (output) constant model parameter file (enter - for none) (FLOAT)
                    NOTE: if a0 is set to -, then a0 is not included in the phase model
          a1        (output) slope model parameter file (enter - for none) (FLOAT)
                    NOTE: if a1 is set to -, then a1 is not included in the phase model
          sigma     (output) standard deviation of the atmospheric phase model (enter - for none) (FLOAT)
          sigma_h   (output) standard deviation of the DEM height (enter - for none) (FLOAT)
          s1        (output) a1 quality measure sigma/(a1*sigma_h) (enter - for none) (FLOAT)
          rwin      range (across) patch size samples (enter - for default: 512)
          azwin     azimuth (down) patch size lines (enter - for default: 512)
          rstep     range (across) step (enter - for default: 64)
          azstep    azimuth (down) step (enter - for default: 64)
          h0        power-law model scale reference height (enter - for default: 7000.0 m)
          alpha     power-law model exponent (enter - for default: 1.350)
          cc_min    minimum correlation coefficient threshold to use a point: (enter - for default: 0.150)
          mfrac     minimum fraction of points in a patch required to evaluate coefficients: (enter - for default: 0.200
          rref      reference point range (across) samples (enter - for default: none))
          azref     reference point azimuth (down) lines (enter - for default: none)
          sflg      linear regression solver flag:
                      0: use Gauss-Jorden to solve linear regression (default)
                      1: use SVD to solve linear regression
          svd_tol   SVD tolerance threshold, singular values w[i] < svd_tol * max(w[]) are set to 0.0, (enter - for default: 1.0e-12)
          w0        2D array of the singular value w[0] for each patch (FLOAT), (enter - for default: none)
          w1        2D array of the singular value w[1] for each patch (FLOAT), (enter - for default: none)

        """
        if self.validate_inputs:
            self._validate_atm_mod_2d(
                diff_unw,
                hgt,
                cc,
                DIFF_par,
                mask,
                model,
                a0,
                a1,
                sigma,
                sigma_h,
                s1,
                rwin,
                azwin,
                rstep,
                azstep,
                h0,
                alpha,
                cc_min,
                mfrac,
                xref,
                yref,
                sflg,
                svd_tol,
                w0,
                w1,
            )
        if self.mock_outputs:
            self._mock_atm_mod_2d_outputs(
                diff_unw,
                hgt,
                cc,
                DIFF_par,
                mask,
                model,
                a0,
                a1,
                sigma,
                sigma_h,
                s1,
                rwin,
                azwin,
                rstep,
                azstep,
                h0,
                alpha,
                cc_min,
                mfrac,
                xref,
                yref,
                sflg,
                svd_tol,
                w0,
                w1,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.atm_mod_2d))
        return self._gamma_call("DIFF", "atm_mod_2d", supplied_args)

    def _validate_WSS_interp_lt(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par1: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        DIFF_par2: Path,
    ) -> None:
        self._validate("WSS_interp_lt", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("WSS_interp_lt", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("WSS_interp_lt", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("WSS_interp_lt", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("WSS_interp_lt", lookup_table.exists(), f"lookup_table path does not exist ({lookup_table})")
        self._validate("WSS_interp_lt", MLI1_par.exists(), f"MLI1_par path does not exist ({MLI1_par})")
        self._validate("WSS_interp_lt", MLI2_par.exists(), f"MLI2_par path does not exist ({MLI2_par})")
        self._validate("WSS_interp_lt", DIFF_par1.exists(), f"DIFF_par1 path does not exist ({DIFF_par1})")

    def _mock_WSS_interp_lt_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par1: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        DIFF_par2: Path,
    ) -> None:
        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()
        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()
        if DIFF_par2 is not None and str(DIFF_par2) != "-":
            DIFF_par2.touch()

    def WSS_interp_lt(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        lookup_table: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        DIFF_par1: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        DIFF_par2: Path,
    ) -> Tuple[int, str, str]:
        """

        ASAR Wide-Swath SLC complex image resampling via a lookup table and  2-D SINC interpolation


        input parameters:
          SLC-1         (input) ASAR Wide-Swath SLC_1 reference image
          SLC-2         (input) ASAR Wide-Swath SLC-2 image to be resampled to the geometry of the WSS SLC-1 reference image
          SLC1_par      (input) ASAR Wide-Swath SLC-1 image parameter file
          SLC2_par      (input) ASAR Wide-Swath SLC-2 image parameter file
          lookup_table  (input) lookup_table relating MLI-2 to MLI-1 created from SLC-2 and SLC-1
          MLI1_par      (input) SLC/MLI ISP image parameter file of reference MLI-1 (lookup table dimension)
          MLI2_par      (input) SLC/MLI ISP image parameter file of MLI-2 (lookup table values)
          DIFF_par1     (input) DIFF/GEO offset parameter file used for lookup table refinement MLI-1, MLI-2R (enter - for none)
          SLC-2R        (output) ASAR Wide-Swath SLC-2 resampled and co-registered to SLC-1
          SLC2R_par     (output) ASAR Wide-Swath image parameter file for the co-registered resampled image
          DIFF_par2     (output) DIFF/GEO offset parameter file for MLI-1, MLI-2 (enter - for none)

        """
        if self.validate_inputs:
            self._validate_WSS_interp_lt(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                DIFF_par1,
                SLC_2R,
                SLC2R_par,
                DIFF_par2,
            )
        if self.mock_outputs:
            self._mock_WSS_interp_lt_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                lookup_table,
                MLI1_par,
                MLI2_par,
                DIFF_par1,
                SLC_2R,
                SLC2R_par,
                DIFF_par2,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.WSS_interp_lt))
        return self._gamma_call("DIFF", "WSS_interp_lt", supplied_args)

    def _validate_dispmap_vec2(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap1: Path,
        lv1_theta: Path,
        lv1_phi: Path,
        dispmap2: Path,
        lv2_theta: Path,
        lv2_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Any] = None,
        mode: Optional[int] = None,
        ax_north: Optional[Any] = None,
        ax_east: Optional[Any] = None,
    ) -> None:
        self._validate("dispmap_vec2", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("dispmap_vec2", DEM.exists(), f"DEM path does not exist ({DEM})")
        self._validate("dispmap_vec2", dispmap1.exists(), f"dispmap1 path does not exist ({dispmap1})")
        self._validate("dispmap_vec2", lv1_theta.exists(), f"lv1_theta path does not exist ({lv1_theta})")
        self._validate("dispmap_vec2", lv1_phi.exists(), f"lv1_phi path does not exist ({lv1_phi})")
        self._validate("dispmap_vec2", dispmap2.exists(), f"dispmap2 path does not exist ({dispmap2})")
        self._validate("dispmap_vec2", lv2_theta.exists(), f"lv2_theta path does not exist ({lv2_theta})")
        self._validate("dispmap_vec2", lv2_phi.exists(), f"lv2_phi path does not exist ({lv2_phi})")

    def _mock_dispmap_vec2_outputs(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap1: Path,
        lv1_theta: Path,
        lv1_phi: Path,
        dispmap2: Path,
        lv2_theta: Path,
        lv2_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Any] = None,
        mode: Optional[int] = None,
        ax_north: Optional[Any] = None,
        ax_east: Optional[Any] = None,
    ) -> None:
        if dv_norm is not None and str(dv_norm) != "-":
            dv_norm.touch()
        if dv_theta is not None and str(dv_theta) != "-":
            dv_theta.touch()
        if dv_phi is not None and str(dv_phi) != "-":
            dv_phi.touch()
        if dv_x is not None and str(dv_x) != "-":
            dv_x.touch()
        if dv_y is not None and str(dv_y) != "-":
            dv_y.touch()
        if dv_z is not None and str(dv_z) != "-":
            dv_z.touch()

    def dispmap_vec2(
        self,
        DEM_par: Path,
        DEM: Path,
        dispmap1: Path,
        lv1_theta: Path,
        lv1_phi: Path,
        dispmap2: Path,
        lv2_theta: Path,
        lv2_phi: Path,
        dv_norm: Path,
        dv_theta: Optional[Path] = None,
        dv_phi: Optional[Path] = None,
        dv_x: Optional[Path] = None,
        dv_y: Optional[Path] = None,
        dv_z: Optional[Path] = None,
        mask_angle: Optional[Any] = None,
        mode: Optional[int] = None,
        ax_north: Optional[Any] = None,
        ax_east: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculation of displacement vector field from 2 measured components (asc./desc.)


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          DEM         (input) DEM data file (or constant height value)
          dispmap1    (input) 1. displacement observation (along look-vector 1) (float)
          lv1_theta   (input) look-vector 1 elevation angle (file or constant value in deg.)
          lv1_phi     (input) look-vector 1 orientation angle (file or constant value in deg.)
          dispmap2    (input) 2. displacement observation (along look-vector 2) (float)
          lv2_theta   (input) look-vector 2 elevation angle (file or constant value in deg.)
          lv2_phi     (input) look-vector 2 orientation angle (file or constant value in deg.)
          dv_norm     (output) norm of 3-dim displacement vector (float)
          dv_theta    (output) elevation angle of 3-dim displacement vector (float)
          dv_phi      (output) orientation angle of 3-dim displacement vector (file of float)
          dv_x        (output) easting  component of 3-dim displacement vector (float)
          dv_y        (output) northing component of 3-dim displacement vector (float)
          dv_z        (output) vertical component of 3-dim displacement vector (float)
          mask_angle  cutoff angle in degrees between the look and normal vectors to mask inaccurate results (default=2)
          mode        displacement model mode (default=0):
                        0: displacement along terrain surface
                        1: displacement towards center axis
                        2: east-west and up-down components (north-south assumed zero)
          ax_north    displacement center axis northing/latitude
          ax_east     displacement center axis easting/longitude

          NOTE: select - to avoid creation of the corresponding output file

        """
        if self.validate_inputs:
            self._validate_dispmap_vec2(
                DEM_par,
                DEM,
                dispmap1,
                lv1_theta,
                lv1_phi,
                dispmap2,
                lv2_theta,
                lv2_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
                mode,
                ax_north,
                ax_east,
            )
        if self.mock_outputs:
            self._mock_dispmap_vec2_outputs(
                DEM_par,
                DEM,
                dispmap1,
                lv1_theta,
                lv1_phi,
                dispmap2,
                lv2_theta,
                lv2_phi,
                dv_norm,
                dv_theta,
                dv_phi,
                dv_x,
                dv_y,
                dv_z,
                mask_angle,
                mode,
                ax_north,
                ax_east,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_vec2))
        return self._gamma_call("DIFF", "dispmap_vec2", supplied_args)

    def _validate_diff_ls_unw(
        self,
        int_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        diff_int: Path,
        int_type: Optional[int] = None,
        ph_flag: Optional[Any] = None,
    ) -> None:
        self._validate("diff_ls_unw", int_1.exists(), f"int_1 path does not exist ({int_1})")
        self._validate("diff_ls_unw", unw_2.exists(), f"unw_2 path does not exist ({unw_2})")
        self._validate("diff_ls_unw", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_diff_ls_unw_outputs(
        self,
        int_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        diff_int: Path,
        int_type: Optional[int] = None,
        ph_flag: Optional[Any] = None,
    ) -> None:
        if diff_int is not None and str(diff_int) != "-":
            diff_int.touch()

    def diff_ls_unw(
        self,
        int_1: Path,
        unw_2: Path,
        DIFF_par: Path,
        diff_int: Path,
        int_type: Optional[int] = None,
        ph_flag: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Three-pass differential interferometry


        input parameters:
          int-1     (input) complex or unwrapped interferogram 1 file name
          unw-2     (input) unwrapped interferogram 2 file name
          DIFF_par  (input) interferogram/offset processing parameters
          diff_int  (output)  phase difference of interferograms: (int-1 - scaled(unw-2)) file name
          int_type  int-1 type: 0: unwrapped phase, 1:complex interferogram (default: 0)
          ph_flag   phase conjugation flag: 0:normal, 1:conjugate phase (default: 0)

        """
        if self.validate_inputs:
            self._validate_diff_ls_unw(int_1, unw_2, DIFF_par, diff_int, int_type, ph_flag)
        if self.mock_outputs:
            self._mock_diff_ls_unw_outputs(int_1, unw_2, DIFF_par, diff_int, int_type, ph_flag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.diff_ls_unw))
        return self._gamma_call("DIFF", "diff_ls_unw", supplied_args)

    def _validate_offset_pwr_list(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        clist_RDC: Path,
        clist_MAP: Path,
        offs: Path,
        ccp: Path,
        nx: Path,
        ny: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[Any] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        self._validate("offset_pwr_list", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("offset_pwr_list", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("offset_pwr_list", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("offset_pwr_list", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("offset_pwr_list", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("offset_pwr_list", clist_RDC.exists(), f"clist_RDC path does not exist ({clist_RDC})")
        self._validate("offset_pwr_list", clist_MAP.exists(), f"clist_MAP path does not exist ({clist_MAP})")

    def _mock_offset_pwr_list_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        clist_RDC: Path,
        clist_MAP: Path,
        offs: Path,
        ccp: Path,
        nx: Path,
        ny: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[Any] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if ccp is not None and str(ccp) != "-":
            ccp.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()
        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_list(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        clist_RDC: Path,
        clist_MAP: Path,
        offs: Path,
        ccp: Path,
        nx: Path,
        ny: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[Any] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Offsets between SLC images at positions specified by a list using intensity cross-correlation


        input parameters:
          SLC-1      (input) single-look complex image 1 (reference)
          SLC-2      (input) single-look complex image 2
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2_par   (input) SLC-2 ISP image parameter file
          OFF_par    (input) ISP offset/interferogram parameter file
          clist_RDC  (input) list of x,y pixel coordinates in the reference SLC image geometry (Range-Doppler Coordinates) (text format)
          clist_MAP  (input) list of x,y pixel coordinates in the map projection geometry (text format)
          offs       (output) offset estimate 2D map (fcomplex)
          ccp        (output) cross-correlation of each patch (0.0->1.0) in map coordinates (float)
          nx         width of 2D offset map in MAP geometry
          ny         height of 2D offset map in MAP geometry
          rwin       range patch size (range pixels, enter - for default from offset parameter file))
          azwin      azimuth patch size (azimuth lines, enter - for default from offset parameter file))
          offsets    (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr      SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          thres      cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          bw_frac    bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          deramp     deramp SLC phase flag (enter - for default)
          int_filt   intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag      print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg     plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs        (output) cross-correlation standard deviation of each patch in map coordinates (float)

        NOTE: ScanSAR and TOPS data need to be previously deramped

        """
        if self.validate_inputs:
            self._validate_offset_pwr_list(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                clist_RDC,
                clist_MAP,
                offs,
                ccp,
                nx,
                ny,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        if self.mock_outputs:
            self._mock_offset_pwr_list_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                clist_RDC,
                clist_MAP,
                offs,
                ccp,
                nx,
                ny,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_list))
        return self._gamma_call("DIFF", "offset_pwr_list", supplied_args)

    def _validate_geocode(
        self,
        lookup_table: Path,
        data_in: Path,
        width_in: Path,
        data_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        rad_max: Optional[Any] = None,
        nintr: Optional[int] = None,
    ) -> None:
        self._validate("geocode", lookup_table.exists(), f"lookup_table path does not exist ({lookup_table})")
        self._validate("geocode", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_geocode_outputs(
        self,
        lookup_table: Path,
        data_in: Path,
        width_in: Path,
        data_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        rad_max: Optional[Any] = None,
        nintr: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def geocode(
        self,
        lookup_table: Path,
        data_in: Path,
        width_in: Path,
        data_out: Path,
        width_out: int,
        nlines_out: Optional[int] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        rad_max: Optional[Any] = None,
        nintr: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Forward geocoding transformation using a lookup table


        input parameters:
          lookup_table  (input) lookup table containing pairs of real-valued output data coordinates
          data_in       (input) data file (format as specified by format_flag parameter)
          width_in      width of input data file and gc_map lookup table
          data_out      (output) output data file
          width_out     width of output data file
          nlines_out    number of lines for the output data file (enter - or 0 for default: all lines)
          interp_mode   resampling interpolation mode (enter - for default)
                          0: 1/dist (default)
                          1: nearest neighbor
                          2: SQR(1/dist)
                          3: constant
                          4: Gauss weighting
          dtype        input/output data type (enter - for default)
                          0: FLOAT (default)
                          1: FCOMPLEX
                          2: Sun/BMP/TIFF 8 or 24-bit raster image
                          3: UNSIGNED CHAR
                          4: SHORT
                          5: SCOMPLEX
                          6: DOUBLE
          lr_in         input  Sun/BMP/TIFF raster image flipped left/right (enter - for default: 1: not flipped (default), -1: flipped)
          lr_out        output Sun/BMP/TIFF raster image flipped left/right (enter - for default: 1: not flipped (default), -1: flipped)
          n_ovr         interpolation oversampling factor (enter - for default: 2)
          rad_max       maximum interpolation search radius (enter - for default 4*n_ovr: 8)
          nintr         number of points required for interpolation when not nearest neighbor (enter - for default: 4)

        """
        if self.validate_inputs:
            self._validate_geocode(
                lookup_table,
                data_in,
                width_in,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                lr_in,
                lr_out,
                n_ovr,
                rad_max,
                nintr,
            )
        if self.mock_outputs:
            self._mock_geocode_outputs(
                lookup_table,
                data_in,
                width_in,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                lr_in,
                lr_out,
                n_ovr,
                rad_max,
                nintr,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.geocode))
        return self._gamma_call("DIFF", "geocode", supplied_args)

    def _validate_par_TX_geo(
        self, annotation_XML: Path, GeoTIFF: Path, MLI_par: Path, DEM_par: Path, GEO: Path, pol: Optional[Any] = None
    ) -> None:
        self._validate("par_TX_geo", annotation_XML.exists(), f"annotation_XML path does not exist ({annotation_XML})")
        self._validate("par_TX_geo", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")

    def _mock_par_TX_geo_outputs(
        self, annotation_XML: Path, GeoTIFF: Path, MLI_par: Path, DEM_par: Path, GEO: Path, pol: Optional[Any] = None
    ) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if DEM_par is not None and str(DEM_par) != "-":
            DEM_par.touch()
        if GEO is not None and str(GEO) != "-":
            GEO.touch()

    def par_TX_geo(
        self, annotation_XML: Path, GeoTIFF: Path, MLI_par: Path, DEM_par: Path, GEO: Path, pol: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        Generate DEM parameter and image files for Terrasar-X GEC and EEC data


        input parameters:
          annotation_XML (input) Terrasar-X product annotation XML file
          GeoTIFF        (input) image data file in GeoTIFF format
          MLI_par        (output) ISP image parameter file (example: yyyymmdd.mli.par)
          DEM_par        (output) DIFF/GEO DEM parameter file (example: yyyymmdd.dem_par)
          GEO            (output) geocoded and calibrated image data file (example: yyyymmdd.geo)
          pol            polarisation HH, HV, VH, VV (default: first polarisation found in the annotation_XML)

        """
        if self.validate_inputs:
            self._validate_par_TX_geo(annotation_XML, GeoTIFF, MLI_par, DEM_par, GEO, pol)
        if self.mock_outputs:
            self._mock_par_TX_geo_outputs(annotation_XML, GeoTIFF, MLI_par, DEM_par, GEO, pol)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_TX_geo))
        return self._gamma_call("DIFF", "par_TX_geo", supplied_args)

    def _validate_data2xyz(self, DEM_par: Path, data: Path, data_xyz: Path, dflg: Optional[int] = None) -> None:
        self._validate("data2xyz", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("data2xyz", data.exists(), f"data path does not exist ({data})")

    def _mock_data2xyz_outputs(self, DEM_par: Path, data: Path, data_xyz: Path, dflg: Optional[int] = None) -> None:
        if data_xyz is not None and str(data_xyz) != "-":
            data_xyz.touch()

    def data2xyz(self, DEM_par: Path, data: Path, data_xyz: Path, dflg: Optional[int] = None) -> Tuple[int, str, str]:
        """

        Convert geocoded float data to triplets of float: (northing, easting, data_value) as binary or text format

        input parameters:
          DEM_par  (input) DEM parameter file
          data     (input) float format data with same dimensions as given in the DEM_par
          data_xyz (output) triplets (northing, easting, data_value) in 8-byte double-precision or text format
          dflg     output format:
                     0: little-endian double precision (default)
                     1: text, comma separated values (csv)
        """
        if self.validate_inputs:
            self._validate_data2xyz(DEM_par, data, data_xyz, dflg)
        if self.mock_outputs:
            self._mock_data2xyz_outputs(DEM_par, data, data_xyz, dflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.data2xyz))
        return self._gamma_call("DIFF", "data2xyz", supplied_args)

    def _validate_multi_cpx(
        self,
        data_in: Path,
        PAR_in: Path,
        data_out: Path,
        PAR_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        self._validate("multi_cpx", data_in.exists(), f"data_in path does not exist ({data_in})")
        self._validate("multi_cpx", PAR_in.exists(), f"PAR_in path does not exist ({PAR_in})")

    def _mock_multi_cpx_outputs(
        self,
        data_in: Path,
        PAR_in: Path,
        data_out: Path,
        PAR_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()
        if not PAR_out.exists():
            PAR_out.touch()

    def multi_cpx(
        self,
        data_in: Path,
        PAR_in: Path,
        data_out: Path,
        PAR_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate multi-look averaged or interpolated 2D image (complex data)

        input parameters:
          data_in      (input) input complex image file (FCOMPLEX or SCOMPLEX)
          PAR_in       (input) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for input image
          data_out     (output) output multi-look or interpolated complex data file (FCOMPLEX or SCOMPLEX)
          PAR_out      (input/output) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for output, used as input if already exists
          rlks         number of range looks, values < -1 interpreted as an image oversampling factor (enter - for default: 1)
          azlks        number of azimuth looks, values < -1 interpreted as an image oversampling factor (enter - for default: 1)
          loff         line offset to starting line (enter - for default: 0)
          nlines       number of lines (enter - or 0 for default: to end of file)
          roff         offset to starting range sample (enter - for default: 0)
          nsamp        number of range samples to extract (enter - or 0 for default: to end of line)

        """
        if self.validate_inputs:
            self._validate_multi_cpx(data_in, PAR_in, data_out, PAR_out, rlks, azlks, loff, nlines, roff, nsamp)
        if self.mock_outputs:
            self._mock_multi_cpx_outputs(data_in, PAR_in, data_out, PAR_out, rlks, azlks, loff, nlines, roff, nsamp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_cpx))
        return self._gamma_call("DIFF", "multi_cpx", supplied_args)

    def _validate_ScanSAR_burst_diff_intf(
        self,
        SLC1_tab: Path,
        SLC2R_tab: Path,
        SIM_tab: Path,
        DIFF_tab: Path,
        SLCR_tab: Optional[Path] = None,
        DIFF_dir: Optional[Any] = None,
    ) -> None:
        self._validate("ScanSAR_burst_diff_intf", SLC1_tab.exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        self._validate("ScanSAR_burst_diff_intf", SLC2R_tab.exists(), f"SLC2R_tab path does not exist ({SLC2R_tab})")
        self._validate("ScanSAR_burst_diff_intf", SIM_tab.exists(), f"SIM_tab path does not exist ({SIM_tab})")
        if SLCR_tab is not None:
            self._validate("ScanSAR_burst_diff_intf", SLCR_tab.exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_ScanSAR_burst_diff_intf_outputs(
        self,
        SLC1_tab: Path,
        SLC2R_tab: Path,
        SIM_tab: Path,
        DIFF_tab: Path,
        SLCR_tab: Optional[Path] = None,
        DIFF_dir: Optional[Any] = None,
    ) -> None:
        if not DIFF_tab.exists():
            DIFF_tab.touch()

    def ScanSAR_burst_diff_intf(
        self,
        SLC1_tab: Path,
        SLC2R_tab: Path,
        SIM_tab: Path,
        DIFF_tab: Path,
        SLCR_tab: Optional[Path] = None,
        DIFF_dir: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate Differential Interferogram bursts from SLC ScanSAR data (Sentinel-1, RCM, and TSX)


        input parameters:
          SLC1_tab    (input) 3 column list of the reference ScanSAR SLC swaths listed in order from near to far range
                        SLC1_tab line entries:  SLC  SLC_par  TOPS_par
          SLC2R_tab   (input) 3 column list of ScanSAR SLC swaths listed in order from near to far range, coregistered with SLC1
                        SLC2R_tab line entries:  SLC  SLC_par  TOPS_par
          SIM_tab     (input) 3 column list of simulated multilook interferometric phase in burst format listed in order from near to far range
                        SIM_tab line entries:  SIM_UNW   MLI_par  TOPS_par
          DIFF_tab    (input/output) 3 column list of the DIFF swaths listed in order from near to far range
                        DIFF_tab line entries:  DIFF  MLI_par  TOPS_par
                      NOTES: 1. If the DIFF_tab does not yet exist, the file entries will be created with names derived from the SLC1_tab and SLC2R_tab entries
                             2. The DIFF data are FCOMPLEX format as documented in the MLI_par (Multi-Look Interferogram), and also in the TOPS_par
          SLCR_tab    (input) 3 column list of the scene used for coregistration of SLC1 and SLC2 with the swaths, listed in order from near to far range (enter - for none)
                        SLCR_tab line entries:  SLC  SLC_par  TOPS_par
                      NOTE: This is is only necessary if SLC1 is not the scene used for the coregistration of SLC2R with SLC1
          DIFF_dir    directory for output burst differential interferogram data, ignored if the DIFF_tab already exists (default: current directory)

        """
        if self.validate_inputs:
            self._validate_ScanSAR_burst_diff_intf(SLC1_tab, SLC2R_tab, SIM_tab, DIFF_tab, SLCR_tab, DIFF_dir)
        if self.mock_outputs:
            self._mock_ScanSAR_burst_diff_intf_outputs(SLC1_tab, SLC2R_tab, SIM_tab, DIFF_tab, SLCR_tab, DIFF_dir)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_diff_intf))
        return self._gamma_call("DIFF", "ScanSAR_burst_diff_intf", supplied_args)

    def _validate_dem_xyz(self, DEM_par: Path, DEM: Path, DEM_XYZ: Path) -> None:
        self._validate("dem_xyz", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("dem_xyz", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_dem_xyz_outputs(self, DEM_par: Path, DEM: Path, DEM_XYZ: Path) -> None:
        if DEM_XYZ is not None and str(DEM_XYZ) != "-":
            DEM_XYZ.touch()

    def dem_xyz(self, DEM_par: Path, DEM: Path, DEM_XYZ: Path) -> Tuple[int, str, str]:
        """

        DEM transformation to Cartesian XYZ coordinates

        input parameters:
          DEM_par  (input) DEM parameter file DEM
          DEM      (input) input DEM file or constant height value
          DEM_XYZ  (output) DEM samples in Cartesian XYZ coordinates (float)
        """
        if self.validate_inputs:
            self._validate_dem_xyz(DEM_par, DEM, DEM_XYZ)
        if self.mock_outputs:
            self._mock_dem_xyz_outputs(DEM_par, DEM, DEM_XYZ)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_xyz))
        return self._gamma_call("DIFF", "dem_xyz", supplied_args)

    def _validate_look_vector(
        self, SLC_par: Path, OFF_par: Path, DEM_par: Path, DEM: Path, lv_theta: Path, lv_phi: Path
    ) -> None:
        self._validate("look_vector", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("look_vector", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("look_vector", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("look_vector", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_look_vector_outputs(
        self, SLC_par: Path, OFF_par: Path, DEM_par: Path, DEM: Path, lv_theta: Path, lv_phi: Path
    ) -> None:
        if lv_theta is not None and str(lv_theta) != "-":
            lv_theta.touch()
        if lv_phi is not None and str(lv_phi) != "-":
            lv_phi.touch()

    def look_vector(
        self, SLC_par: Path, OFF_par: Path, DEM_par: Path, DEM: Path, lv_theta: Path, lv_phi: Path
    ) -> Tuple[int, str, str]:
        """

        Calculate SAR look-vector orientation and elevation angles in map geometry


        input parameters:
          SLC_par   (input) ISP SLC or MLI image parameter file (slant range geometry
          OFF_par   (input) ISP offset/interferogram parameter file (enter - for SLC or MLI data)
          DEM_par   (input) DEM/MAP parameter file
          DEM       (input) DEM data file or constant height value
          lv_theta  (output) SAR look vector elevation angle at each map pixel
                      lv_theta: PI/2 -> up  -PI/2 -> down
                      The elevation angle is measured between the surface and the look vector pointing at the radar
          lv_phi    (output) SAR look vector orientation angle at each map pixel
                      lv_phi: 0 -> East  PI/2 -> North

        """
        if self.validate_inputs:
            self._validate_look_vector(SLC_par, OFF_par, DEM_par, DEM, lv_theta, lv_phi)
        if self.mock_outputs:
            self._mock_look_vector_outputs(SLC_par, OFF_par, DEM_par, DEM, lv_theta, lv_phi)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.look_vector))
        return self._gamma_call("DIFF", "look_vector", supplied_args)

    def _validate_create_dem_par(
        self,
        DEM_par: Path,
        SLC_par: Optional[Path] = None,
        terra_alt: Optional[Any] = None,
        delta_y: Optional[Path] = None,
        delta_x: Optional[Path] = None,
        EPSG: Optional[Any] = None,
        iflg: Optional[int] = None,
    ) -> None:
        if SLC_par is not None:
            self._validate("create_dem_par", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_create_dem_par_outputs(
        self,
        DEM_par: Path,
        SLC_par: Optional[Path] = None,
        terra_alt: Optional[Any] = None,
        delta_y: Optional[Path] = None,
        delta_x: Optional[Path] = None,
        EPSG: Optional[Any] = None,
        iflg: Optional[int] = None,
    ) -> None:
        if not DEM_par.exists():
            DEM_par.touch()

    def create_dem_par(
        self,
        DEM_par: Path,
        SLC_par: Optional[Path] = None,
        terra_alt: Optional[Any] = None,
        delta_y: Optional[Path] = None,
        delta_x: Optional[Path] = None,
        EPSG: Optional[Any] = None,
        iflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DEM/MAP parameter file creation/modification


        input parameters:
          DEM_par    (input/output) DIFF/GEO DEM parameter file
          SLC_par    (input) ISP SLC or MLI image parameter file automatic calculation of DEM bounds (enter - for none)
          terra_alt  nominal terrain altitude used to calculate bounds of the radar image (enter - for default: 0.0 m)
                       ignored when no SLC_par is provided
          delta_y    DEM y line spacing for new DEM_par file (enter - for default)
                       geographical coordinates (EQA projection latitude) default: -2.777778e-04 deg.
                       all other map projections default: -25.0000 m.
          delta_x    DEM x sample spacing for new DEM_par file (enter - for default)
                       geographical coordinates (EQA projection longitude) default: 2.777778e-04 deg.
                       all other map projections default: 25.0000 m.
          EPSG       EPSG number of the geographical coordinate system or map projection (enter - for none)
                       EPSG numbers can be retrieved from the http://epsg.io database. EPSG number for WGS84 lat/lon: 4326
          iflg       interactive mode flag (enter - for default)
                       0: non-interactive (requires an existing <DEM_par> or an [EPSG] number)
                       1: interactive (default)
                       2: non-interactive, grid-aligned (pixel center) (requires an [SLC_par], and an existing <DEM_par> or an [EPSG] number)
                       3: non-interactive, grid-aligned (pixel edge) (requires an [SLC_par], and an existing <DEM_par> or an [EPSG] number)

        """
        if self.validate_inputs:
            self._validate_create_dem_par(DEM_par, SLC_par, terra_alt, delta_y, delta_x, EPSG, iflg)
        if self.mock_outputs:
            self._mock_create_dem_par_outputs(DEM_par, SLC_par, terra_alt, delta_y, delta_x, EPSG, iflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_dem_par))
        return self._gamma_call("DIFF", "create_dem_par", supplied_args)

    def _validate_atm_sim_2d(
        self, DIFF_par: Path, hgt: Path, a0: Path, a1: Path, atm_phase: Path, mask: Optional[Path] = None
    ) -> None:
        self._validate("atm_sim_2d", hgt.exists(), f"hgt path does not exist ({hgt})")
        self._validate("atm_sim_2d", a0.exists(), f"a0 path does not exist ({a0})")
        self._validate("atm_sim_2d", a1.exists(), f"a1 path does not exist ({a1})")
        if mask is not None:
            self._validate("atm_sim_2d", mask.exists(), f"mask path does not exist ({mask})")

    def _mock_atm_sim_2d_outputs(
        self, DIFF_par: Path, hgt: Path, a0: Path, a1: Path, atm_phase: Path, mask: Optional[Path] = None
    ) -> None:
        if not DIFF_par.exists():
            DIFF_par.touch()
        if atm_phase is not None and str(atm_phase) != "-":
            atm_phase.touch()

    def atm_sim_2d(
        self, DIFF_par: Path, hgt: Path, a0: Path, a1: Path, atm_phase: Path, mask: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Simulate atmospheric phase based on a 2D grid of model parameters


        input parameters:
          DIFF_par   (input/output) DIFF/GEO parameter file
          hgt        (input) height coregistered to the interferogram (enter - for none) (FLOAT)
          a0         (input) constant phase model parameter file (enter - for none) (FLOAT)
          a1         (input) slope phase model parameter file (enter - for none) (FLOAT)
          atm_phase  (output) simulated atmospheric phase (FLOAT)
          mask       (input) 8-bit raster image (SUN raster, BMP, or TIFF format)
                     regions with (R,G,B)=0 in the mask are set to 0.0 in the output phase (enter - for none)
        """
        if self.validate_inputs:
            self._validate_atm_sim_2d(DIFF_par, hgt, a0, a1, atm_phase, mask)
        if self.mock_outputs:
            self._mock_atm_sim_2d_outputs(DIFF_par, hgt, a0, a1, atm_phase, mask)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.atm_sim_2d))
        return self._gamma_call("DIFF", "atm_sim_2d", supplied_args)

    def _validate_dem_x_y_z(
        self, DEM_par: Path, DEM: Path, DEM_X: Path, DEM_Y: Path, DEM_Z: Path, format_flag: Optional[int] = None
    ) -> None:
        self._validate("dem_x_y_z", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("dem_x_y_z", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_dem_x_y_z_outputs(
        self, DEM_par: Path, DEM: Path, DEM_X: Path, DEM_Y: Path, DEM_Z: Path, format_flag: Optional[int] = None
    ) -> None:
        if DEM_X is not None and str(DEM_X) != "-":
            DEM_X.touch()
        if DEM_Y is not None and str(DEM_Y) != "-":
            DEM_Y.touch()
        if DEM_Z is not None and str(DEM_Z) != "-":
            DEM_Z.touch()

    def dem_x_y_z(
        self, DEM_par: Path, DEM: Path, DEM_X: Path, DEM_Y: Path, DEM_Z: Path, format_flag: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        DEM transformation to WGS84 Cartesian X, Y, and Z coordinates (3 files)

        input parameters:
          DEM_par      (input) DEM parameter file
          DEM          (input) DEM file or constant height value
          DEM_X        (output) X coordinates of grid points of the DEM
          DEM_Y        (output) Y coordinates of grid points of the DEM
          DEM_Z        (output) Z coordinates of grid points of the DEM
          format_flag   output data format
                          0: FLOAT (default)
                          1: DOUBLE
        """
        if self.validate_inputs:
            self._validate_dem_x_y_z(DEM_par, DEM, DEM_X, DEM_Y, DEM_Z, format_flag)
        if self.mock_outputs:
            self._mock_dem_x_y_z_outputs(DEM_par, DEM, DEM_X, DEM_Y, DEM_Z, format_flag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_x_y_z))
        return self._gamma_call("DIFF", "dem_x_y_z", supplied_args)

    def _validate_SLC_intf_geo2(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Path,
        MLI_1: Path,
        MLI_2: Path,
        CC: Path,
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
    ) -> None:
        self._validate("SLC_intf_geo2", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("SLC_intf_geo2", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("SLC_intf_geo2", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        if sim_phase is not None:
            self._validate("SLC_intf_geo2", sim_phase.exists(), f"sim_phase path does not exist ({sim_phase})")

    def _mock_SLC_intf_geo2_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Path,
        MLI_1: Path,
        MLI_2: Path,
        CC: Path,
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
    ) -> None:
        if interf is not None and str(interf) != "-":
            interf.touch()
        if MLI_1 is not None and str(MLI_1) != "-":
            MLI_1.touch()
        if MLI_2 is not None and str(MLI_2) != "-":
            MLI_2.touch()
        if CC is not None and str(CC) != "-":
            CC.touch()
        if DEM_par2 is not None and str(DEM_par2) != "-":
            DEM_par2.touch()

    def SLC_intf_geo2(
        self,
        SLC_1: Path,
        SLC_2: Path,
        DEM_par: Path,
        interf: Path,
        MLI_1: Path,
        MLI_2: Path,
        CC: Path,
        DEM_par2: Path,
        e_dec: int,
        n_dec: int,
        e_win: Optional[int] = None,
        n_win: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate a geocoded differential interferogram and MLI images from geocoded SLCs with separate averaging window dimensions and decimation factors


        input parameters:
          SLC-1     (input) geocoded single-look complex image (SCOMPLEX or FCOMPLEX)
          SLC-2     (input) geocoded single-look complex image 2, coregistered to SLC-1 (same format as SLC-1)
          DEM_par   (input) SLC DEM parameter file
          interf    (output) multi-look interferogram from SLC-1 and SLC-2 (enter - for none)
          MLI-1     (output) multi-look intensity image from SLC-1 (enter - for none)
          MLI-2     (output) multi-look intensity image from SLC-2 (enter - for none)
          CC        (output) interferometric correlation magnitude of SLC-1 and SLC-2R (enter - for none)
          DEM_par2  (output) DEM parameter file for the output interferogram, correlation, and MLI files
          e_dec     easting decimation factor (int)
          n_dec     northing decimation factor (int)
          e_win     easting averaging window width (int) (enter - for default: e_dec)
          n_win     northing averaging window height (int)(enter - for default: n_dec)
          wflg      window weighting function (enter - for default):
                      0: rectangular (default)
                      1: Kaiser
                      2: circular Gaussian
          n_ovr     oversampling factor 1 -> 2 (enter - for default: 1)
          sim_phase (input) geocoded simulated interferometric phase, coregistered to SLC-1 (FLOAT, enter - for none)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 7)
          beta      Gaussian or Kaiser window parameter (enter - for default: 2.0)

        """
        if self.validate_inputs:
            self._validate_SLC_intf_geo2(
                SLC_1,
                SLC_2,
                DEM_par,
                interf,
                MLI_1,
                MLI_2,
                CC,
                DEM_par2,
                e_dec,
                n_dec,
                e_win,
                n_win,
                wflg,
                n_ovr,
                sim_phase,
                lanczos,
                beta,
            )
        if self.mock_outputs:
            self._mock_SLC_intf_geo2_outputs(
                SLC_1,
                SLC_2,
                DEM_par,
                interf,
                MLI_1,
                MLI_2,
                CC,
                DEM_par2,
                e_dec,
                n_dec,
                e_win,
                n_win,
                wflg,
                n_ovr,
                sim_phase,
                lanczos,
                beta,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_intf_geo2))
        return self._gamma_call("DIFF", "SLC_intf_geo2", supplied_args)

    def _validate_ras_clist(
        self,
        clist: Path,
        ras_in: Path,
        ras_out: Path,
        xsf: Optional[Path] = None,
        ysf: Optional[Path] = None,
        r: Optional[Any] = None,
        g: Optional[Any] = None,
        b: Optional[Any] = None,
        xs: Optional[int] = None,
        zflg: Optional[Any] = None,
    ) -> None:
        self._validate("ras_clist", clist.exists(), f"clist path does not exist ({clist})")
        self._validate("ras_clist", ras_in.exists(), f"ras_in path does not exist ({ras_in})")

    def _mock_ras_clist_outputs(
        self,
        clist: Path,
        ras_in: Path,
        ras_out: Path,
        xsf: Optional[Path] = None,
        ysf: Optional[Path] = None,
        r: Optional[Any] = None,
        g: Optional[Any] = None,
        b: Optional[Any] = None,
        xs: Optional[int] = None,
        zflg: Optional[Any] = None,
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_clist(
        self,
        clist: Path,
        ras_in: Path,
        ras_out: Path,
        xsf: Optional[Path] = None,
        ysf: Optional[Path] = None,
        r: Optional[Any] = None,
        g: Optional[Any] = None,
        b: Optional[Any] = None,
        xs: Optional[int] = None,
        zflg: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DIFF Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/ras_clist.c
        Draw point list locations on a SUN/BMP raster image


        input parameters:
          clist    (input) list of x,y pixel coordinates (text format)
          ras_in   (input) raster image (SUN/BMP/TIFF format)
          ras_out  (output) raster image with crosses drawn at points (SUN/BMP/TIFF format)
          xsf      number of range looks for the raster image relative to the SLC geometry (default: 1.0)
          ysf      number azimuth looks for the raster image relative to the SLC geometry (default: 1.0)
          r        line color value red   (0 --> 255) default: 255
          g        line color value green (0 --> 255) default: 255
          b        line color value blue  (0 --> 255) default: 0
          xs       size of cross in pixels, set to 1 for single points (default: 3)
          zflg     zero image flag (default=0:retain image values  1:set all image values to 0 except crosses)
        """
        if self.validate_inputs:
            self._validate_ras_clist(clist, ras_in, ras_out, xsf, ysf, r, g, b, xs, zflg)
        if self.mock_outputs:
            self._mock_ras_clist_outputs(clist, ras_in, ras_out, xsf, ysf, r, g, b, xs, zflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_clist))
        return self._gamma_call("DIFF", "ras_clist", supplied_args)

    def _validate_dispmap_sim(
        self, LV: Path, DEM_par: Path, disp_east: Path, disp_north: Path, disp_up: Path, disp_LOS: Path
    ) -> None:
        self._validate("dispmap_sim", LV.exists(), f"LV path does not exist ({LV})")
        self._validate("dispmap_sim", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("dispmap_sim", disp_east.exists(), f"disp_east path does not exist ({disp_east})")
        self._validate("dispmap_sim", disp_north.exists(), f"disp_north path does not exist ({disp_north})")
        self._validate("dispmap_sim", disp_up.exists(), f"disp_up path does not exist ({disp_up})")

    def _mock_dispmap_sim_outputs(
        self, LV: Path, DEM_par: Path, disp_east: Path, disp_north: Path, disp_up: Path, disp_LOS: Path
    ) -> None:
        if disp_LOS is not None and str(disp_LOS) != "-":
            disp_LOS.touch()

    def dispmap_sim(
        self, LV: Path, DEM_par: Path, disp_east: Path, disp_north: Path, disp_up: Path, disp_LOS: Path
    ) -> Tuple[int, str, str]:
        """

        DIFF Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/dispmap_sim
        Calculate radar LOS displacement given ENU displacement and the radar look vectors for each point in the DEM geometry


        input parameters:
          LV          (input) look vector in East, North, Up (ENU) coordinates for each map grid position
          DEM_par     (input) DEM parameter file describing the map geometry
          disp_east   (input) displacement in the East direction for each map grid position
          disp_north  (input) displacement in the North direction for each map grid position
          disp_up     (input) displacement in the Up direction for each map grid position
          disp_LOS    (output) displacement in the line of sight (LOS) for each map grid position

        NOTE: positive displacement in the LOS is towards the radar and negative displacement is away from the radar!

        """
        if self.validate_inputs:
            self._validate_dispmap_sim(LV, DEM_par, disp_east, disp_north, disp_up, disp_LOS)
        if self.mock_outputs:
            self._mock_dispmap_sim_outputs(LV, DEM_par, disp_east, disp_north, disp_up, disp_LOS)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_sim))
        return self._gamma_call("DIFF", "dispmap_sim", supplied_args)

    def _validate_dem_gradient(
        self, DEM_par: Path, DEM: Path, theta: Path, phi: Path, mag: Path, type: Optional[int], sharpness: Any
    ) -> None:
        self._validate("dem_gradient", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("dem_gradient", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_dem_gradient_outputs(
        self, DEM_par: Path, DEM: Path, theta: Path, phi: Path, mag: Path, type: Optional[int], sharpness: Any
    ) -> None:
        if theta is not None and str(theta) != "-":
            theta.touch()
        if phi is not None and str(phi) != "-":
            phi.touch()
        if mag is not None and str(mag) != "-":
            mag.touch()

    def dem_gradient(
        self, DEM_par: Path, DEM: Path, theta: Path, phi: Path, mag: Path, type: Optional[int], sharpness: Any
    ) -> Tuple[int, str, str]:
        """

        Calculate elevation and orientation angles of the DEM normal or gradient vector magnitude


        input parameters:
          DEM_par     (input) DEM parameter file
          DEM         (input) DEM data file (or constant height value)
          theta       (output) elevation angle of DEM normal or gradient vector (float)
          phi         (output) orientation angle of DEM normal or gradient vector (float)
          mag         (output) magnitude of the gradient vector (float)
          type        vector type selection (enter - for default)
                        0: normal vector
                        1: gradient vector (default)
          sharpness   gradient sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes

        """
        if self.validate_inputs:
            self._validate_dem_gradient(DEM_par, DEM, theta, phi, mag, type, sharpness)
        if self.mock_outputs:
            self._mock_dem_gradient_outputs(DEM_par, DEM, theta, phi, mag, type, sharpness)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_gradient))
        return self._gamma_call("DIFF", "dem_gradient", supplied_args)

    def _validate_offset_pwr_trackingm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[Any] = None,
    ) -> None:
        self._validate("offset_pwr_trackingm", MLI_1.exists(), f"MLI_1 path does not exist ({MLI_1})")
        self._validate("offset_pwr_trackingm", MLI_2.exists(), f"MLI_2 path does not exist ({MLI_2})")
        self._validate("offset_pwr_trackingm", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_offset_pwr_trackingm_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[Any] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if ccp is not None and str(ccp) != "-":
            ccp.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()
        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_trackingm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Offset tracking between MLI images using intensity cross-correlation


        input parameters:
          MLI-1     (input) real valued intensity image 1 (reference)
          MLI-2     (input) real valued intensity image 2
          DIFF_par  (input) DIFF/GEO parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     MLI oversampling factor (integer 2**N (1,2,4), enter - for default: 1)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on intensity data (0.0->1.0) (enter - for default: 0.8)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)
          std_mean  patch minimum standard deviation/mean ratio (enter - for default: 0.01)

        """
        if self.validate_inputs:
            self._validate_offset_pwr_trackingm(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )
        if self.mock_outputs:
            self._mock_offset_pwr_trackingm_outputs(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_trackingm))
        return self._gamma_call("DIFF", "offset_pwr_trackingm", supplied_args)

    def _validate_init_offsetm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        offr: Optional[Any] = None,
        offaz: Optional[Any] = None,
        thres: Optional[Any] = None,
        patch: Optional[Any] = None,
        cflag: Optional[int] = None,
    ) -> None:
        self._validate("init_offsetm", MLI_1.exists(), f"MLI_1 path does not exist ({MLI_1})")
        self._validate("init_offsetm", MLI_2.exists(), f"MLI_2 path does not exist ({MLI_2})")

    def _mock_init_offsetm_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        offr: Optional[Any] = None,
        offaz: Optional[Any] = None,
        thres: Optional[Any] = None,
        patch: Optional[Any] = None,
        cflag: Optional[int] = None,
    ) -> None:
        pass

    def init_offsetm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        offr: Optional[Any] = None,
        offaz: Optional[Any] = None,
        thres: Optional[Any] = None,
        patch: Optional[Any] = None,
        cflag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Initial offset estimation for multi-look intensity images


        input parameters:
          MLI-1     (input) intensity image 1 (float) (reference)
          MLI-2     (input) intensity image 2 (float)
          DIFF_par  DIFF/GEO parameter file
          rlks      number of range looks (enter - for default: 1)
          azlks     number of azimuth looks (enter - for default: 1)
          rpos      center of region for comparison in range (enter - for default: image center)
          azpos     center of region for comparison in azimuth (enter - for default: image center)
          offr      initial range offset (enter - for default from DIFF_par)
          offaz     initial azimuth offset (enter - for default from DIFF_par)
          thres     correlation SNR threshold (enter -  for default:  0.150)
          patch     correlation patch size (enter - for default: 512)
          cflag     copy offsets to the range and azimuth offset polynomials in DIFF_par (enter - for default)
                      0: do not copy
                      1: copy constant range and azimuth offsets (default)

        """
        if self.validate_inputs:
            self._validate_init_offsetm(
                MLI_1, MLI_2, DIFF_par, rlks, azlks, rpos, azpos, offr, offaz, thres, patch, cflag
            )
        if self.mock_outputs:
            self._mock_init_offsetm_outputs(
                MLI_1, MLI_2, DIFF_par, rlks, azlks, rpos, azpos, offr, offaz, thres, patch, cflag
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.init_offsetm))
        return self._gamma_call("DIFF", "init_offsetm", supplied_args)

    def _validate_gc_map_fd(self, MLI_par: Path, fd_tab: Path, DEM_par: Path, DEM: Path, DEM_seg_par: Path) -> None:
        self._validate("gc_map_fd", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("gc_map_fd", fd_tab.exists(), f"fd_tab path does not exist ({fd_tab})")
        self._validate("gc_map_fd", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("gc_map_fd", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_gc_map_fd_outputs(self, MLI_par: Path, fd_tab: Path, DEM_par: Path, DEM: Path, DEM_seg_par: Path) -> None:
        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

    def gc_map_fd(
        self, MLI_par: Path, fd_tab: Path, DEM_par: Path, DEM: Path, DEM_seg_par: Path
    ) -> Tuple[int, str, str]:
        """

        Calculate lookup table and DEM related products for terrain-corrected geocoding using a doppler polynomial table


        input parameters:
          MLI_par         (input) ISP MLI or SLC image parameter file (slant range geometry)
          fdtab           (input)table of doppler polynomials at uniform azimuth time steps
          DEM_par         (input) DEM/MAP parameter file
          DEM             (input) DEM data file (or constant height value)
          DEM_seg_par     (input/output) DEM/MAP segment parameter file used for output products

          NOTE: If the DEM_seg_par already exists, then the output DEM parameters will be read from this file
                otherwise they are estimated from the image data.

          DEM_seg         (output) DEM segment used for output products, interpolated if lat_ovr > 1.0  or lon_ovr > 1.0
          lookup_table    (output) geocoding lookup table (fcomplex)
          lat_ovr         latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr         longitude or easting output DEM oversampling factor (enter - for default: 1.0)
          sim_sar         (output) simulated SAR backscatter image in DEM geometry
          u               (output) zenith angle of surface normal vector n (angle between z and n)
          v               (output) orientation angle of n (between x and projection of n in xy plane)
          inc             (output) local incidence angle (between surface normal and look vector)
          psi             (output) projection angle (between surface normal and image plane normal)
          pix             (output) pixel area normalization factor
          ls_map          (output) layover and shadow map (in map projection)
          frame           number of DEM pixels to add around area covered by SAR image (enter - for default = 8)
          ls_mode         output lookup table values in regions of layover, shadow, or DEM gaps (enter - for default)
                            0: set to (0.,0.)
                            1: linear interpolation across these regions (default)
                            2: actual value
                            3: nn-thinned
          r_ovr           range over-sampling factor for nn-thinned layover/shadow mode(enter - for default: 2.0)

        NOTE: enter - as output filename to avoid creating the corresponding output file

        """
        if self.validate_inputs:
            self._validate_gc_map_fd(MLI_par, fd_tab, DEM_par, DEM, DEM_seg_par)
        if self.mock_outputs:
            self._mock_gc_map_fd_outputs(MLI_par, fd_tab, DEM_par, DEM, DEM_seg_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_map_fd))
        return self._gamma_call("DIFF", "gc_map_fd", supplied_args)

    def _validate_resamp_image_par(
        self,
        data_in: Path,
        PAR_1: Path,
        PAR_2: Path,
        data_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
        off_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> None:
        self._validate("resamp_image_par", data_in.exists(), f"data_in path does not exist ({data_in})")
        self._validate("resamp_image_par", PAR_1.exists(), f"PAR_1 path does not exist ({PAR_1})")
        self._validate("resamp_image_par", PAR_2.exists(), f"PAR_2 path does not exist ({PAR_2})")

    def _mock_resamp_image_par_outputs(
        self,
        data_in: Path,
        PAR_1: Path,
        PAR_2: Path,
        data_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
        off_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def resamp_image_par(
        self,
        data_in: Path,
        PAR_1: Path,
        PAR_2: Path,
        data_out: Path,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
        off_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> Tuple[int, str, str]:
        """

        Resample 2D data with geometry of the input image parameter file to the geometry of a second image parameter file of the same scene


        input parameters:
          data_in      (input) input data file (format as specified by dtype parameter)
          PAR-1        (input) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for data_in
          PAR-2        (input) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for data_out
          data_out     (output) resampled output data file
          interp_mode  interpolation mode (enter - for default)
                         0: nearest-neighbor
                         1: bicubic spline (default)
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 5)
                         5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                         6: Lanczos interpolation (default Lanczos function order: 5)
                         7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype        input and output data format (enter - for default)
                         0: FLOAT (default)
                         1: FCOMPLEX
                         2: SUN/BMP/TIFF format raster image
                         3: UNSIGNED CHAR
                         4: SHORT
                         5: DOUBLE
                         6: SCOMPLEX
          order        Lanczos function order or B-spline degree (2->9) (enter - for default: 5)
          e_flag       extrapolation flag (enter - for default)
                         0: do not extrapolate (default)
                         1: extrapolate up to 0.5 pixels beyond input edges
          off_flag     offset flag when using OFF_par or DIFF_par files (enter - for default)
                         0: image mode (resample image (e.g. interferogram / SLC / MLI) to a different multi-looking geometry) (default)
                         1: offsets mode 1 (resample input offsets to image frame)
                         2: offsets mode 2 (resample input image to offsets frame)
                         3: offsets mode 3 (resample input offsets to different offsets frame)
          lpf          low-pass filter amount when downsampling data (0.0 -> no filter, 1.0 -> ensure output is not aliased, enter - for default: 0.0)

          NOTES:
            1. The parameter files PAR-1 and PAR-2 must be from the same scene or DEM and must be the same type
            2. See documentation for information on recommended interpolation modes for different data types
            3. When resampling complex data, the data should either have been deramped, or have their spectrum centered around 0

        """
        if self.validate_inputs:
            self._validate_resamp_image_par(
                data_in, PAR_1, PAR_2, data_out, interp_mode, dtype, order, e_flag, off_flag, lpf
            )
        if self.mock_outputs:
            self._mock_resamp_image_par_outputs(
                data_in, PAR_1, PAR_2, data_out, interp_mode, dtype, order, e_flag, off_flag, lpf
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.resamp_image_par))
        return self._gamma_call("DIFF", "resamp_image_par", supplied_args)

    def _validate_phase_sim_orb(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Optional[float],
        sim_orb: Path,
        SLC_ref_par: Optional[Path] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[int] = None,
        ph_mode: Optional[int] = None,
    ) -> None:
        self._validate("phase_sim_orb", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("phase_sim_orb", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        self._validate("phase_sim_orb", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        if SLC_ref_par is not None:
            self._validate("phase_sim_orb", SLC_ref_par.exists(), f"SLC_ref_par path does not exist ({SLC_ref_par})")
        if def_ is not None:
            self._validate("phase_sim_orb", def_.exists(), f"def_ path does not exist ({def_})")
        if delta_t is not None:
            self._validate("phase_sim_orb", delta_t.exists(), f"delta_t path does not exist ({delta_t})")

    def _mock_phase_sim_orb_outputs(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Optional[float],
        sim_orb: Path,
        SLC_ref_par: Optional[Path] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[int] = None,
        ph_mode: Optional[int] = None,
    ) -> None:
        if sim_orb is not None and str(sim_orb) != "-":
            sim_orb.touch()

    def phase_sim_orb(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Optional[float],
        sim_orb: Path,
        SLC_ref_par: Optional[Path] = None,
        def_: Optional[Path] = None,
        delta_t: Optional[Path] = None,
        int_mode: Optional[int] = None,
        ph_mode: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Simulate unwrapped interferometric phase using DEM height and deformation rate using orbit state vectors


        input parameters:
          SLC1_par    (input) SLC parameter file of reference SLC-1
          SLC2R_par   (input) SLC parameter file of resampled SLC-2
          OFF_par     (input) ISP offset/interferogram parameter file
          hgt         (input) height relative to the WGS-84 elliposid in the same geometry as the mosaic (m) (FLOAT, enter - for none)
          sim_orb     (output) simulated interferometric phase (FLOAT, unwrapped)
          SLC_ref_par (input) SLC parameter file of the image used for geometric coregistration (enter - for none)
          def         (input) LOS deformation rate map (meters/yr, float, enter - for none)
          delta_t     (input) interferogram time interval (days, required for deformation modeling, enter - for none)
          int_mode    interferometric acquisition mode (enter - for default)
                        0: single-pass mode (Tandem-X)
                        1: repeat-pass mode (default)
          ph_mode     phase offset mode (enter - for default)
                        0: absolute phase (default)
                        1: subtract phase offset that is a multiple of 2PI to improve precision

        """
        if self.validate_inputs:
            self._validate_phase_sim_orb(
                SLC1_par, SLC2R_par, OFF_par, hgt, sim_orb, SLC_ref_par, def_, delta_t, int_mode, ph_mode
            )
        if self.mock_outputs:
            self._mock_phase_sim_orb_outputs(
                SLC1_par, SLC2R_par, OFF_par, hgt, sim_orb, SLC_ref_par, def_, delta_t, int_mode, ph_mode
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.phase_sim_orb))
        return self._gamma_call("DIFF", "phase_sim_orb", supplied_args)

    def _validate_gec_map(self, SLC_par: Path, OFF_par: Path, DEM_par: Path, href: Path, DEM_seg_par: Path) -> None:
        self._validate("gec_map", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("gec_map", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("gec_map", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("gec_map", href.exists(), f"href path does not exist ({href})")

    def _mock_gec_map_outputs(self, SLC_par: Path, OFF_par: Path, DEM_par: Path, href: Path, DEM_seg_par: Path) -> None:
        if not DEM_seg_par.exists():
            DEM_seg_par.touch()

    def gec_map(
        self, SLC_par: Path, OFF_par: Path, DEM_par: Path, href: Path, DEM_seg_par: Path
    ) -> Tuple[int, str, str]:
        """

        Calculate geocoding lookup table for ellipsoid correction of slant-range images


        input parameters:
          SLC_par       (input) ISP SLC-1/MLI parameter file
          OFF_par       (input) ISP offset/interferogram parameter file, enter - if geocoding SLC or MLI data
          DEM_par       (input) DEM parameter file
          href          (input) elevation reference [m]
          DEM_seg_par   (input/output) DEM segment parameter file used for geocoding

          NOTE: If the DEM_seg_par already exists, then the output DEM parameters will be read from this file
                otherwise they are estimated from the image data.

          lookup_table  (output) geocoding lookup table
          lat_ovr       latitude or northing output DEM oversampling factor (enter - for default: 1.0)
          lon_ovr       longitude or easting output DEM oversampling factor (enter - for default: 1.0)
        """
        if self.validate_inputs:
            self._validate_gec_map(SLC_par, OFF_par, DEM_par, href, DEM_seg_par)
        if self.mock_outputs:
            self._mock_gec_map_outputs(SLC_par, OFF_par, DEM_par, href, DEM_seg_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gec_map))
        return self._gamma_call("DIFF", "gec_map", supplied_args)

    def _validate_dh_map_orb(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Path,
        dp: Path,
        dpdh: Path,
        dh: Path,
        SLC_ref_par: Optional[Path] = None,
        int_mode: Optional[int] = None,
    ) -> None:
        self._validate("dh_map_orb", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("dh_map_orb", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        self._validate("dh_map_orb", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("dh_map_orb", hgt.exists(), f"hgt path does not exist ({hgt})")
        self._validate("dh_map_orb", dp.exists(), f"dp path does not exist ({dp})")
        if SLC_ref_par is not None:
            self._validate("dh_map_orb", SLC_ref_par.exists(), f"SLC_ref_par path does not exist ({SLC_ref_par})")

    def _mock_dh_map_orb_outputs(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Path,
        dp: Path,
        dpdh: Path,
        dh: Path,
        SLC_ref_par: Optional[Path] = None,
        int_mode: Optional[int] = None,
    ) -> None:
        if dpdh is not None and str(dpdh) != "-":
            dpdh.touch()
        if dh is not None and str(dh) != "-":
            dh.touch()

    def dh_map_orb(
        self,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        hgt: Path,
        dp: Path,
        dpdh: Path,
        dh: Path,
        SLC_ref_par: Optional[Path] = None,
        int_mode: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate delta height from differential interferometric phase using state vectors for baseline calculation


        input parameters:
          SLC1_par    (input) SLC parameter file of reference SLC-1
          SLC2R_par   (input) SLC parameter file of resampled SLC-2
          OFF_par     (input) ISP offset/interferogram parameter file
          hgt         (input) height map in the same geometry as the interferogram, or constant value (m) (float, enter - for none))
          dp          (input) interferogram phase - simulated phase (radians) (float, enter - for none)
          dpdh        (output) sensitivity of interf. phase with respect to height calculated using state vectors and hgt (rad/m) (float, enter - for none)
          dh          (output) height difference calculated from dp using dpdh (m) (float, enter - for none)
          SLC_ref_par (input) SLC parameter file of the image used for geometric coregistration (enter - for none)
          int_mode    (input) interferometric acquisition mode:
                        0: single-pass mode (Tandem-X)
                        1: repeat-pass mode (default)

        """
        if self.validate_inputs:
            self._validate_dh_map_orb(SLC1_par, SLC2R_par, OFF_par, hgt, dp, dpdh, dh, SLC_ref_par, int_mode)
        if self.mock_outputs:
            self._mock_dh_map_orb_outputs(SLC1_par, SLC2R_par, OFF_par, hgt, dp, dpdh, dh, SLC_ref_par, int_mode)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dh_map_orb))
        return self._gamma_call("DIFF", "dh_map_orb", supplied_args)

    def _validate_offset_subm(self, offs: Path, DIFF_par: Path, offs_sub: Path) -> None:
        self._validate("offset_subm", offs.exists(), f"offs path does not exist ({offs})")
        self._validate("offset_subm", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_offset_subm_outputs(self, offs: Path, DIFF_par: Path, offs_sub: Path) -> None:
        if offs_sub is not None and str(offs_sub) != "-":
            offs_sub.touch()

    def offset_subm(self, offs: Path, DIFF_par: Path, offs_sub: Path) -> Tuple[int, str, str]:
        """

        Subtraction of polynomial from range and azimuth offset estimates


        input parameters:
          offs      (input) range and azimuth offset estimates (fcomplex)
          DIFF_par  (input) DIFF/GEO parameter file for the scene
          offs_sub  (output) range and azimuth offset estimates after polynomial subtraction (fcomplex)
        """
        if self.validate_inputs:
            self._validate_offset_subm(offs, DIFF_par, offs_sub)
        if self.mock_outputs:
            self._mock_offset_subm_outputs(offs, DIFF_par, offs_sub)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_subm))
        return self._gamma_call("DIFF", "offset_subm", supplied_args)

    def _validate_offset_trackingm(
        self,
        offs: Path,
        snr: Path,
        MLI_par: Path,
        DIFF_par: Path,
        coffs_map: Path,
        coffsets: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[Any] = None,
        poly_flag: Optional[int] = None,
    ) -> None:
        self._validate("offset_trackingm", offs.exists(), f"offs path does not exist ({offs})")
        self._validate("offset_trackingm", snr.exists(), f"snr path does not exist ({snr})")
        self._validate("offset_trackingm", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("offset_trackingm", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_offset_trackingm_outputs(
        self,
        offs: Path,
        snr: Path,
        MLI_par: Path,
        DIFF_par: Path,
        coffs_map: Path,
        coffsets: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[Any] = None,
        poly_flag: Optional[int] = None,
    ) -> None:
        if coffs_map is not None and str(coffs_map) != "-":
            coffs_map.touch()
        if coffsets is not None and str(coffsets) != "-":
            coffsets.touch()

    def offset_trackingm(
        self,
        offs: Path,
        snr: Path,
        MLI_par: Path,
        DIFF_par: Path,
        coffs_map: Path,
        coffsets: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[Any] = None,
        poly_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Conversion of range and azimuth offsets files to displacement map for intensity offsets


        input parameters:
          offs       (input) range and azimuth offset estimates (fcomplex)
          snr        (input) cross-correlation of the offset estimates (float)
          MLI_par    (input) MLI parameter file of reference MLI
          DIFF_par   (input) offset parameter file used in the offset tracking
          coffs_map  (output) range and azimuth displacement estimates (fcomplex)
          coffsets   (output) range and azimuth displacement estimates and cross-correlation values (enter - for none) (text)
          mode       flag indicating displacement mode:
                       0: displacement in range and azimuth pixels
                       1: displacement in meters in slant range and azimuth directions
                       2: displacement in meters in ground range and azimuth directions (default)
          thres      cross-correlation threshold to accept offset value (0.0-> 1.0, default from DIFF_par)
          poly_flag  flag indicating if trend calculated using offset polynomials from DIFF_par is subtracted:
                       0: do not subtract polynomial trend from offset data
                       1: subtract polynomial trend from offset data (default)

        """
        if self.validate_inputs:
            self._validate_offset_trackingm(offs, snr, MLI_par, DIFF_par, coffs_map, coffsets, mode, thres, poly_flag)
        if self.mock_outputs:
            self._mock_offset_trackingm_outputs(
                offs, snr, MLI_par, DIFF_par, coffs_map, coffsets, mode, thres, poly_flag
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_trackingm))
        return self._gamma_call("DIFF", "offset_trackingm", supplied_args)

    def _validate_comb_interfs(
        self,
        int_1: Path,
        int_2: Path,
        base_1: Path,
        base_2: Path,
        factor_1: int,
        factor_2: int,
        width: int,
        combi_out: Path,
        combi_base: Path,
        sm: Optional[float] = None,
    ) -> None:
        self._validate("comb_interfs", int_1.exists(), f"int_1 path does not exist ({int_1})")
        self._validate("comb_interfs", int_2.exists(), f"int_2 path does not exist ({int_2})")
        self._validate("comb_interfs", base_1.exists(), f"base_1 path does not exist ({base_1})")
        self._validate("comb_interfs", base_2.exists(), f"base_2 path does not exist ({base_2})")

    def _mock_comb_interfs_outputs(
        self,
        int_1: Path,
        int_2: Path,
        base_1: Path,
        base_2: Path,
        factor_1: int,
        factor_2: int,
        width: int,
        combi_out: Path,
        combi_base: Path,
        sm: Optional[float] = None,
    ) -> None:
        if combi_out is not None and str(combi_out) != "-":
            combi_out.touch()
        if combi_base is not None and str(combi_base) != "-":
            combi_base.touch()

    def comb_interfs(
        self,
        int_1: Path,
        int_2: Path,
        base_1: Path,
        base_2: Path,
        factor_1: int,
        factor_2: int,
        width: int,
        combi_out: Path,
        combi_base: Path,
        sm: Optional[float] = None,
    ) -> Tuple[int, str, str]:
        """

        Complex interferogram combination


        input parameters:
          int-1       complex interferogram 1
          int-2       complex interferogram 2
          base-1      baseline file 1
          base-2      baseline file 2
          factor-1    phase scaling factor 1
          factor-2    phase scaling factor 2
          width       width of interferograms (samples)
          combi_int   output combined interferogram
          combi_base  output combined interferogram baseline file
          sm          magnitude scale factor (default=1.0)

          Remarks:
          Only the use of integer phase scaling factors (positive and negative) seems reasonable
            for the scaling and summing of wrapped phase images
          The coherence of the combined interferogram is estimated from the magnitude scale factor
            and the summed phase noise.

        """
        if self.validate_inputs:
            self._validate_comb_interfs(
                int_1, int_2, base_1, base_2, factor_1, factor_2, width, combi_out, combi_base, sm
            )
        if self.mock_outputs:
            self._mock_comb_interfs_outputs(
                int_1, int_2, base_1, base_2, factor_1, factor_2, width, combi_out, combi_base, sm
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.comb_interfs))
        return self._gamma_call("DIFF", "comb_interfs", supplied_args)

    def _validate_gc_insar(self, SLC_par: Path, OFF_par: Path, hgt: Path, DEM_par: Path, lookup_table: Path) -> None:
        self._validate("gc_insar", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("gc_insar", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("gc_insar", hgt.exists(), f"hgt path does not exist ({hgt})")
        self._validate("gc_insar", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_gc_insar_outputs(
        self, SLC_par: Path, OFF_par: Path, hgt: Path, DEM_par: Path, lookup_table: Path
    ) -> None:
        if lookup_table is not None and str(lookup_table) != "-":
            lookup_table.touch()

    def gc_insar(
        self, SLC_par: Path, OFF_par: Path, hgt: Path, DEM_par: Path, lookup_table: Path
    ) -> Tuple[int, str, str]:
        """

        Derive complex valued lookup table for terrain corrected geocoding (based on heights in SAR geometry)


        input parameters:
          SLC_par       (input) SLC parameter file of reference SLC
          OFF_par       (input) ISP offset/interferogram parameter file
          hgt           (input) height map in SAR geometry (float format)
          DEM_par       (input) DEM parameters (characterizing map projection)
          lookup_table  (output) geocoding lookup table (fcomplex format)

        """
        if self.validate_inputs:
            self._validate_gc_insar(SLC_par, OFF_par, hgt, DEM_par, lookup_table)
        if self.mock_outputs:
            self._mock_gc_insar_outputs(SLC_par, OFF_par, hgt, DEM_par, lookup_table)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gc_insar))
        return self._gamma_call("DIFF", "gc_insar", supplied_args)

    def _validate_par_KS_geo(
        self,
    ) -> None:
        pass

    def _mock_par_KS_geo_outputs(
        self,
    ) -> None:
        pass

    def par_KS_geo(
        self,
    ) -> Tuple[int, str, str]:
        """

        dyld[46602]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/par_KS_geo'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)
        """
        if self.validate_inputs:
            self._validate_par_KS_geo()
        if self.mock_outputs:
            self._mock_par_KS_geo_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_KS_geo))
        return self._gamma_call("DIFF", "par_KS_geo", supplied_args)

    def _validate_offset_pwrm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[Any] = None,
    ) -> None:
        self._validate("offset_pwrm", MLI_1.exists(), f"MLI_1 path does not exist ({MLI_1})")
        self._validate("offset_pwrm", MLI_2.exists(), f"MLI_2 path does not exist ({MLI_2})")
        self._validate("offset_pwrm", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_offset_pwrm_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[Any] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if ccp is not None and str(ccp) != "-":
            ccp.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()
        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwrm(
        self,
        MLI_1: Path,
        MLI_2: Path,
        DIFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
        std_mean: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Offset estimation between MLI images using intensity cross-correlation


        input parameters:
          MLI-1     (input) real valued intensity image 1 (reference)
          MLI-2     (input) real valued intensity image 2
          DIFF_par  (input) DIFF/GEO parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     MLI oversampling factor (integer 2**N (1,2,4), enter - for default: 1)
          nr        number of offset estimates in range direction (enter - for default from offset parameter file)
          naz       number of offset estimates in azimuth direction (enter - for default from offset parameter file)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on intensity data (0.0->1.0) (enter - for default: 0.8)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)
          std_mean  patch minimum standard deviation/mean ratio (enter - for default: 0.01)

        """
        if self.validate_inputs:
            self._validate_offset_pwrm(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )
        if self.mock_outputs:
            self._mock_offset_pwrm_outputs(
                MLI_1,
                MLI_2,
                DIFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                pflag,
                pltflg,
                ccs,
                std_mean,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwrm))
        return self._gamma_call("DIFF", "offset_pwrm", supplied_args)

    def _validate_coord_to_sarpix_list(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Path,
        MAP_coord: Path,
        SAR_coord: Path,
        DIFF_par: Optional[Path] = None,
    ) -> None:
        self._validate("coord_to_sarpix_list", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("coord_to_sarpix_list", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("coord_to_sarpix_list", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("coord_to_sarpix_list", MAP_coord.exists(), f"MAP_coord path does not exist ({MAP_coord})")
        if DIFF_par is not None:
            self._validate("coord_to_sarpix_list", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_coord_to_sarpix_list_outputs(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Path,
        MAP_coord: Path,
        SAR_coord: Path,
        DIFF_par: Optional[Path] = None,
    ) -> None:
        if SAR_coord is not None and str(SAR_coord) != "-":
            SAR_coord.touch()

    def coord_to_sarpix_list(
        self,
        SLC_par: Path,
        OFF_par: Path,
        DEM_par: Path,
        MAP_coord: Path,
        SAR_coord: Path,
        DIFF_par: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate SAR pixel coordinates for each set of map coordinates in a list


        input parameters:
          SLC_par    (input) ISP SLC/MLI parameter file
          OFF_par    (input) ISP offset/interferogram parameter file, enter - for SLC or MLI data
          DEM_par    (input) DEM parameter file defining the map projection, datum, and coverage (enter - for none)
                       NOTE: if there is no DEM_par, then the coordinate data are interpreted as latitude and longitude in the WG84 datum
          MAP_coord  (input) list of map coordinates and heights with 3 columns:
                       north/lat/S   east/lon/C    height (m) in the map datum
          SAR_coord  (output) list of pixel and line coordinates in the geometry defined by the SLC_par:
                       azimuth_line  range_pixel   height (m) in the map datum
          DIFF_par   (input) DIFF/GEO parameter file containing refinement polynomial coefficients (enter - for none)

          NOTE: When the DIFF_par is specified, the refinement polynomial correction is applied to the SAR pixel and line coordinates

        """
        if self.validate_inputs:
            self._validate_coord_to_sarpix_list(SLC_par, OFF_par, DEM_par, MAP_coord, SAR_coord, DIFF_par)
        if self.mock_outputs:
            self._mock_coord_to_sarpix_list_outputs(SLC_par, OFF_par, DEM_par, MAP_coord, SAR_coord, DIFF_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.coord_to_sarpix_list))
        return self._gamma_call("DIFF", "coord_to_sarpix_list", supplied_args)

    def _validate_offset_fitm(
        self,
        offs: Path,
        ccp: Path,
        DIFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[Any] = None,
        npoly: Optional[int] = None,
        interact_mode: Optional[int] = None,
    ) -> None:
        self._validate("offset_fitm", offs.exists(), f"offs path does not exist ({offs})")
        self._validate("offset_fitm", ccp.exists(), f"ccp path does not exist ({ccp})")
        self._validate("offset_fitm", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_offset_fitm_outputs(
        self,
        offs: Path,
        ccp: Path,
        DIFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[Any] = None,
        npoly: Optional[int] = None,
        interact_mode: Optional[int] = None,
    ) -> None:
        if coffs is not None and str(coffs) != "-":
            coffs.touch()
        if coffsets is not None and str(coffsets) != "-":
            coffsets.touch()

    def offset_fitm(
        self,
        offs: Path,
        ccp: Path,
        DIFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[Any] = None,
        npoly: Optional[int] = None,
        interact_mode: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Range and azimuth offset polynomial estimation using SVD


        input parameters:
          offs          (input) range and azimuth offset estimates (fcomplex)
          ccp           (input) cross-correlation of each patch (float)
          DIFF_par      (input) DIFF/GEO parameter file for the scene
          coffs         (output) culled range and azimuth offset estimates (fcomplex, enter - for none)
          coffsets      (output) culled offset estimates and cross-correlation values (text format, enter - for none)
          thres         cross-correlation threshold (enter - for default from DIFF_par)
          npoly         number of model polynomial parameters (enter - for default, 1, 3, 4, 6, default: 4)
          interact_mode interactive culling of input data:
                          0: off (default)
                          1: on

        """
        if self.validate_inputs:
            self._validate_offset_fitm(offs, ccp, DIFF_par, coffs, coffsets, thres, npoly, interact_mode)
        if self.mock_outputs:
            self._mock_offset_fitm_outputs(offs, ccp, DIFF_par, coffs, coffsets, thres, npoly, interact_mode)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_fitm))
        return self._gamma_call("DIFF", "offset_fitm", supplied_args)

    def _validate_dispmap_ENU(
        self,
        LV_tab: Path,
        DISP_tab: Path,
        SIGMA_tab: Path,
        DEM_par: Path,
        disp_east: Path,
        disp_north: Path,
        disp_up: Path,
        sigma_east: Optional[Path] = None,
        sigma_north: Optional[Path] = None,
        sigma_up: Optional[Path] = None,
        chi2: Optional[Path] = None,
        min_obs: Optional[int] = None,
        tol: Optional[Any] = None,
    ) -> None:
        self._validate("dispmap_ENU", LV_tab.exists(), f"LV_tab path does not exist ({LV_tab})")
        self._validate("dispmap_ENU", DISP_tab.exists(), f"DISP_tab path does not exist ({DISP_tab})")
        self._validate("dispmap_ENU", SIGMA_tab.exists(), f"SIGMA_tab path does not exist ({SIGMA_tab})")
        self._validate("dispmap_ENU", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_dispmap_ENU_outputs(
        self,
        LV_tab: Path,
        DISP_tab: Path,
        SIGMA_tab: Path,
        DEM_par: Path,
        disp_east: Path,
        disp_north: Path,
        disp_up: Path,
        sigma_east: Optional[Path] = None,
        sigma_north: Optional[Path] = None,
        sigma_up: Optional[Path] = None,
        chi2: Optional[Path] = None,
        min_obs: Optional[int] = None,
        tol: Optional[Any] = None,
    ) -> None:
        if disp_east is not None and str(disp_east) != "-":
            disp_east.touch()
        if disp_north is not None and str(disp_north) != "-":
            disp_north.touch()
        if disp_up is not None and str(disp_up) != "-":
            disp_up.touch()
        if sigma_east is not None and str(sigma_east) != "-":
            sigma_east.touch()
        if sigma_north is not None and str(sigma_north) != "-":
            sigma_north.touch()
        if sigma_up is not None and str(sigma_up) != "-":
            sigma_up.touch()
        if chi2 is not None and str(chi2) != "-":
            chi2.touch()

    def dispmap_ENU(
        self,
        LV_tab: Path,
        DISP_tab: Path,
        SIGMA_tab: Path,
        DEM_par: Path,
        disp_east: Path,
        disp_north: Path,
        disp_up: Path,
        sigma_east: Optional[Path] = None,
        sigma_north: Optional[Path] = None,
        sigma_up: Optional[Path] = None,
        chi2: Optional[Path] = None,
        min_obs: Optional[int] = None,
        tol: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DIFF Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DIFF/bin/dispmap_ENU
        Solve for deformation in East, North, Up (ENU) given measurements of deformation along different vector directions


        input parameters:
          LV_tab       (input) list of look vector files in ENU coordinates for each map grid position
          DISP_tab     (input) list of displacement files containing LOS displacement for each map grid position (text)
                       NOTE: displacement sign must be consistent with the look vector pointing from the radar to the ground
          SIGMA_tab    (input) standard deviation of displacement for each map grid position  (enter - for all equal)
          DEM_par      (input) DEM parameter file describing the map geometry
          disp_east    (output) displacement in the East direction for each map grid position
          disp_north   (output) displacement in the North direction for each map grid position
          disp_up      (output) displacement in the Up direction for each map grid position
          sigma_east   (output) standard deviation in the East direction for each map grid position
          sigma_north  (output) standard deviation in the North direction for each map grid position
          sigma_up     (output) standard deviation in the Up direction for each map grid position
          chi2         (output) chi-square for each map grid position
          min_obs      minimum number of observations (default: 3)
          tol          threshold for accepting SVD singular values w_i, when (w_i < tol*wmax), w_i is set to 0.0: 1.0000e-05

        """
        if self.validate_inputs:
            self._validate_dispmap_ENU(
                LV_tab,
                DISP_tab,
                SIGMA_tab,
                DEM_par,
                disp_east,
                disp_north,
                disp_up,
                sigma_east,
                sigma_north,
                sigma_up,
                chi2,
                min_obs,
                tol,
            )
        if self.mock_outputs:
            self._mock_dispmap_ENU_outputs(
                LV_tab,
                DISP_tab,
                SIGMA_tab,
                DEM_par,
                disp_east,
                disp_north,
                disp_up,
                sigma_east,
                sigma_north,
                sigma_up,
                chi2,
                min_obs,
                tol,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispmap_ENU))
        return self._gamma_call("DIFF", "dispmap_ENU", supplied_args)

    def _validate_dem_coord(self, DEM_par: Path, east: Path, north: Path, dtype: Optional[int] = None) -> None:
        self._validate("dem_coord", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_dem_coord_outputs(self, DEM_par: Path, east: Path, north: Path, dtype: Optional[int] = None) -> None:
        if east is not None and str(east) != "-":
            east.touch()
        if north is not None and str(north) != "-":
            north.touch()

    def dem_coord(self, DEM_par: Path, east: Path, north: Path, dtype: Optional[int] = None) -> Tuple[int, str, str]:
        """

        Generate a 2D map of the east and north coordinates (FLOAT or DOUBLE format)


        input parameters:
          DEM_par (input) DEM parameter file
          east    (output) easting coordinate map, meters or longitude degrees (enter - for none)
          north   (output) northing coordinate map, meters or latitude degrees (enter - for none)
          dtype   data type:
                    0: FLOAT (default)
                    1: DOUBLE
        NOTE: the output maps have the dimensions of the DEM as specified in the DEM parameter file

        """
        if self.validate_inputs:
            self._validate_dem_coord(DEM_par, east, north, dtype)
        if self.mock_outputs:
            self._mock_dem_coord_outputs(DEM_par, east, north, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dem_coord))
        return self._gamma_call("DIFF", "dem_coord", supplied_args)

    def _validate_rotate_image(
        self,
        data_in: Path,
        width_in: int,
        angle: float,
        data_out: Path,
        width_out: int,
        nlines_out: int,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        self._validate("rotate_image", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_rotate_image_outputs(
        self,
        data_in: Path,
        width_in: int,
        angle: float,
        data_out: Path,
        width_out: int,
        nlines_out: int,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def rotate_image(
        self,
        data_in: Path,
        width_in: int,
        angle: float,
        data_out: Path,
        width_out: int,
        nlines_out: int,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Rotate an image about the image center by a specifed angle


        input parameters:
          data_in      (input) input data file (format as specified by format_flag parameter)
          width_in     width of input data
          angle        rotation angle, angle > 0: counter-clockwise rotation (deg.)
          data_out     (output) output data file
          width_out    output image width, (enter - for default)
          nlines_out   number of lines in the output image, (enter - for default)
          interp_mode  interpolation mode (enter - for default):
                         0: nearest-neighbor
                         1: bicubic spline (default)
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 5)
                         5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                         6: Lanczos interpolation (default Lanczos function order: 5)
                         7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
          dtype        input and output data format (enter - for default)
                         0: FLOAT (default)
                         1: FCOMPLEX
                         2: SUN/BMP/TIFF format
                         3: UNSIGNED CHAR
                         4: SHORT
                         5: DOUBLE
          order        Lanczos function order or B-spline degree (2->9) (enter - default: 5)

          NOTE: see documentation for information on recommended interpolation modes for different data types

        """
        if self.validate_inputs:
            self._validate_rotate_image(
                data_in, width_in, angle, data_out, width_out, nlines_out, interp_mode, dtype, order
            )
        if self.mock_outputs:
            self._mock_rotate_image_outputs(
                data_in, width_in, angle, data_out, width_out, nlines_out, interp_mode, dtype, order
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rotate_image))
        return self._gamma_call("DIFF", "rotate_image", supplied_args)

    def _validate_geocode_back(
        self,
        data_in: Path,
        width_in: int,
        lookup_table: Path,
        data_out: Path,
        width_out: Path,
        nlines_out: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
    ) -> None:
        self._validate("geocode_back", data_in.exists(), f"data_in path does not exist ({data_in})")
        self._validate("geocode_back", lookup_table.exists(), f"lookup_table path does not exist ({lookup_table})")

    def _mock_geocode_back_outputs(
        self,
        data_in: Path,
        width_in: int,
        lookup_table: Path,
        data_out: Path,
        width_out: Path,
        nlines_out: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def geocode_back(
        self,
        data_in: Path,
        width_in: int,
        lookup_table: Path,
        data_out: Path,
        width_out: Path,
        nlines_out: Optional[Path] = None,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        lr_in: Optional[Path] = None,
        lr_out: Optional[Path] = None,
        order: Optional[int] = None,
        e_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Geocoding of image data using a geocoding lookup table


        input parameters:
          data_in       (input) data file (format as specified by format_flag parameter)
          width_in      width of input data file
          lookup_table  (input) lookup table containing pairs of real-valued input data coordinates
          data_out      (output) output data file
          width_out     width of gc_map lookup table, output file has the same width
          nlines_out    number of lines of output data file (enter - or 0 for default: number of lines in gc_map)
          interp_mode   interpolation mode (enter - for default)
                          0: nearest-neighbor
                          1: bicubic spline (default)
                          2: bicubic-log spline, interpolates log(data)
                          3: bicubic-sqrt spline, interpolates sqrt(data)
                          4: B-spline interpolation (default B-spline degree: 5)
                          5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                          6: Lanczos interpolation (default Lanczos function order: 5)
                          7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                        NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype         input/output data type (enter - for default)
                          0: FLOAT (default)
                          1: FCOMPLEX
                          2: SUN/BMP/TIFF 8 or 24-bit raster image
                          3: UNSIGNED CHAR
                          4: SHORT
                          5: DOUBLE
          lr_in         input  SUN/BMP/TIFF raster image flipped left/right (enter - for default: 1: not flipped (default), -1: flipped)
          lr_out        output SUN/BMP/TIFF raster image flipped left/right (enter - for default: 1: not flipped (default), -1: flipped)
          order         Lanczos function order or B-spline degree (2->9) (enter - default: 5)
          e_flag        extrapolation flag (enter - for default)
                          0: do not extrapolate (default)
                          1: extrapolate up to 0.5 pixels beyond input edges

          NOTE: see documentation for information on recommended interpolation modes for different data types

        """
        if self.validate_inputs:
            self._validate_geocode_back(
                data_in,
                width_in,
                lookup_table,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                lr_in,
                lr_out,
                order,
                e_flag,
            )
        if self.mock_outputs:
            self._mock_geocode_back_outputs(
                data_in,
                width_in,
                lookup_table,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                lr_in,
                lr_out,
                order,
                e_flag,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.geocode_back))
        return self._gamma_call("DIFF", "geocode_back", supplied_args)

    def _validate_sarpix_coord(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path] = None,
        DEM_par: Optional[Path] = None,
        azlin: Optional[Any] = None,
        rpix: Optional[Any] = None,
        ref_hgt: Optional[Path] = None,
    ) -> None:
        self._validate("sarpix_coord", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        if OFF_par is not None:
            self._validate("sarpix_coord", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        if DEM_par is not None:
            self._validate("sarpix_coord", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_sarpix_coord_outputs(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path] = None,
        DEM_par: Optional[Path] = None,
        azlin: Optional[Any] = None,
        rpix: Optional[Any] = None,
        ref_hgt: Optional[Path] = None,
    ) -> None:
        pass

    def sarpix_coord(
        self,
        SLC_par: Path,
        OFF_par: Optional[Path] = None,
        DEM_par: Optional[Path] = None,
        azlin: Optional[Any] = None,
        rpix: Optional[Any] = None,
        ref_hgt: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Transform SAR image coordinates to map projection or geographic (lat/lon) coordinates


        input parameters:
          SLC_par  (input) ISP SLC/MLI parameter file
          OFF_par  (input) ISP offset/interferogram parameter file, enter - for SLC or MLI data
          DEM_par  (input) DEM parameter file, enter - for WGS84 lat/lon
          azlin    SAR image azimuth line
          rpix     SAR image slant range pixel number
          ref_hgt  reference height (m) in map datum

        """
        if self.validate_inputs:
            self._validate_sarpix_coord(SLC_par, OFF_par, DEM_par, azlin, rpix, ref_hgt)
        if self.mock_outputs:
            self._mock_sarpix_coord_outputs(SLC_par, OFF_par, DEM_par, azlin, rpix, ref_hgt)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sarpix_coord))
        return self._gamma_call("DIFF", "sarpix_coord", supplied_args)

    def _validate_resamp_image(
        self,
        data_in: Path,
        width_in: int,
        xscale: int,
        yscale: int,
        data_out: Path,
        width_out: int,
        nlines_out: int,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        e_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> None:
        self._validate("resamp_image", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_resamp_image_outputs(
        self,
        data_in: Path,
        width_in: int,
        xscale: int,
        yscale: int,
        data_out: Path,
        width_out: int,
        nlines_out: int,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        e_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def resamp_image(
        self,
        data_in: Path,
        width_in: int,
        xscale: int,
        yscale: int,
        data_out: Path,
        width_out: int,
        nlines_out: int,
        interp_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        order: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        e_flag: Optional[int] = None,
        lpf: Optional[float] = None,
    ) -> Tuple[int, str, str]:
        """

        Resample 2D data by linear scale factors and offset in x and y


        input parameters:
          data_in      (input) input data file (format as specified by dtype parameter)
          width_in     width of input data
          xscale       x coordinate (across) scaling factor (0 < xscale <= 100)
          yscale       y coordinate (down) scaling factor (0 < yscale <= 100)
          data_out     (output) output data file
          width_out    output image width, (enter - for default)
          nlines_out   number of lines in the output image, (enter - for default)
          interp_mode  interpolation mode:
                         0: nearest-neighbor
                         1: bicubic spline (default)
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 5)
                         5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                         6: Lanczos interpolation (default Lanczos function order: 5)
                         7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          dtype        input and output data format
                         0: FLOAT (default)
                         1: FCOMPLEX
                         2: SUN/BMP/TIFF format raster image
                         3: UNSIGNED CHAR
                         4: SHORT
                         5: DOUBLE
                         6: SCOMPLEX
          order        Lanczos function order or B-spline degree (2->9) (enter - default: 5)
          xoff         x coordinate (across) offset samples (enter - for default: 0.0)
          yoff         y coordinate (down) offset lines (enter - for default: 0.0)
          e_flag       extrapolation flag (enter - for default)
                         0: do not extrapolate (default)
                         1: extrapolate up to 0.5 pixels beyond input edges
          lpf          low-pass filter amount when downsampling data (0.0 -> no filter, 1.0 -> ensure output is not aliased, enter - for default: 0.0)

          NOTES:
            1. See documentation for information on recommended interpolation modes for different data types
            2. When resampling complex data, the data should either have been deramped, or have their spectrum centered around 0

        """
        if self.validate_inputs:
            self._validate_resamp_image(
                data_in,
                width_in,
                xscale,
                yscale,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                order,
                xoff,
                yoff,
                e_flag,
                lpf,
            )
        if self.mock_outputs:
            self._mock_resamp_image_outputs(
                data_in,
                width_in,
                xscale,
                yscale,
                data_out,
                width_out,
                nlines_out,
                interp_mode,
                dtype,
                order,
                xoff,
                yoff,
                e_flag,
                lpf,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.resamp_image))
        return self._gamma_call("DIFF", "resamp_image", supplied_args)

    def _validate_pol2rec(
        self,
        data1: Path,
        SLC_par1: Path,
        data2: Path,
        SLC_par2: Path,
        pix_size: Path,
        dtype: int,
        imode: Optional[Any] = None,
        xmin: Optional[int] = None,
        nx: Optional[int] = None,
        ymin: Optional[int] = None,
        ny: Optional[int] = None,
        rmax: Optional[Any] = None,
        order: Optional[int] = None,
    ) -> None:
        self._validate("pol2rec", data1.exists(), f"data1 path does not exist ({data1})")
        self._validate("pol2rec", SLC_par1.exists(), f"SLC_par1 path does not exist ({SLC_par1})")

    def _mock_pol2rec_outputs(
        self,
        data1: Path,
        SLC_par1: Path,
        data2: Path,
        SLC_par2: Path,
        pix_size: Path,
        dtype: int,
        imode: Optional[Any] = None,
        xmin: Optional[int] = None,
        nx: Optional[int] = None,
        ymin: Optional[int] = None,
        ny: Optional[int] = None,
        rmax: Optional[Any] = None,
        order: Optional[int] = None,
    ) -> None:
        if data2 is not None and str(data2) != "-":
            data2.touch()
        if SLC_par2 is not None and str(SLC_par2) != "-":
            SLC_par2.touch()
        if pix_size is not None and str(pix_size) != "-":
            pix_size.touch()

    def pol2rec(
        self,
        data1: Path,
        SLC_par1: Path,
        data2: Path,
        SLC_par2: Path,
        pix_size: Path,
        dtype: int,
        imode: Optional[Any] = None,
        xmin: Optional[int] = None,
        nx: Optional[int] = None,
        ymin: Optional[int] = None,
        ny: Optional[int] = None,
        rmax: Optional[Any] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Polar to rectangular coordinate conversion for GPRI SLC, interferogram, coherence, and MLI images


        input parameters:
          data1    (input) GPRI data in polar format
          SLC_par1 (input) SLC/MLI image parameter file describing the GPRI image geometry
          data2    (output) GPRI image in rectangular format
          SLC_par2 (output) SLC/MLI image parameter file for the output image
          pix_size (output) output pixel size (meters)
          dtype    input data type:
                     0: FLOAT
                     1: FCOMPLEX
          imode    interpolation algorithm (enter - for default)
                     0: nearest-neighbor
                     1: bicubic spline (default for FCOMPLEX data)
                     2: bicubic-log spline
                     3: bicubic-sqrt spline (default for FLOAT data)
                     4: B-spline interpolation (default B-spline degree: 5)
                     5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                     6: Lanczos interpolation (default Lanczos function order: 5)
                     7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                   NOTE: log and sqrt interpolation modes should only be used with non-negative FLOAT data!
          xmin     starting x coordinate (enter - for default: calculated from image)
          nx       number of x samples in the output image (enter - for default: calculated from image
          ymin     starting y coordinate (enter - for default: calculated from image)
          ny       number of y samples in the output image (enter - for default: calculated from image
          rmax     maximum slant range in the GPRI image to resample (enter - for default: maximum slant range of the input image)
          order    Lanczos function order or B-spline degree (2->9) (enter - for default: 5)
                   NOTE: center image line of the scan defines the direction of the X axis

        """
        if self.validate_inputs:
            self._validate_pol2rec(
                data1, SLC_par1, data2, SLC_par2, pix_size, dtype, imode, xmin, nx, ymin, ny, rmax, order
            )
        if self.mock_outputs:
            self._mock_pol2rec_outputs(
                data1, SLC_par1, data2, SLC_par2, pix_size, dtype, imode, xmin, nx, ymin, ny, rmax, order
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pol2rec))
        return self._gamma_call("DIFF", "pol2rec", supplied_args)

    def _validate_WSS_interp(
        self, SLC_1: Path, SLC_2: Path, SLC1_par: Path, SLC2_par: Path, DIFF_par: Path, SLC_2R: Path, SLC2R_par: Path
    ) -> None:
        self._validate("WSS_interp", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("WSS_interp", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("WSS_interp", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("WSS_interp", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("WSS_interp", DIFF_par.exists(), f"DIFF_par path does not exist ({DIFF_par})")

    def _mock_WSS_interp_outputs(
        self, SLC_1: Path, SLC_2: Path, SLC1_par: Path, SLC2_par: Path, DIFF_par: Path, SLC_2R: Path, SLC2R_par: Path
    ) -> None:
        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()
        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def WSS_interp(
        self, SLC_1: Path, SLC_2: Path, SLC1_par: Path, SLC2_par: Path, DIFF_par: Path, SLC_2R: Path, SLC2R_par: Path
    ) -> Tuple[int, str, str]:
        """

        ASAR Wide-Swath complex image resampling using 2-D SINC interpolation


        input parameters:
          SLC-1      (input) ASAR Wide-Swath SLC_1 reference image
          SLC-2      (input) ASAR Wide-Swath SLC-2 image to be resampled to the geometry of the SLC-1 reference image
          SLC1_par   (input) ASAR Wide-Swath SLC-1 image parameter file
          SLC2_par   (input) ASAR Wide-Swath SLC-2 image parameter file
          DIFF_par   (input) DIFF/GEO offset parameter file with offset model
          SLC-2R     (output) ASAR Wide-Swath SLC-2R coregistered to SLC-1
          SLC2R_par  (output) ASAR Wide-Swath SLC-2R image parameter file for coregistered image

        """
        if self.validate_inputs:
            self._validate_WSS_interp(SLC_1, SLC_2, SLC1_par, SLC2_par, DIFF_par, SLC_2R, SLC2R_par)
        if self.mock_outputs:
            self._mock_WSS_interp_outputs(SLC_1, SLC_2, SLC1_par, SLC2_par, DIFF_par, SLC_2R, SLC2R_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.WSS_interp))
        return self._gamma_call("DIFF", "WSS_interp", supplied_args)

    def _validate_dop_mlcc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        plot_data: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("dop_mlcc", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("dop_mlcc", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("dop_mlcc", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_dop_mlcc_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        plot_data: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        pass

    def dop_mlcc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        plot_data: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Doppler ambiguity estimation for IQ SAR data using the MLCC algorithm


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data (I/Q complex)
          plot_data    (output) plot file, correlation phase for MLCC (text format)
                         1: range pixel number
                         2: upper spectrum half mlcc phase (radians)
                         3: lower spectrum half mlcc phase (radians)
                         4: mlcc phase difference between uppler and lower spectrum half (radians)
          loff         number of lines offset (enter - for default=parameter file value)
          nlines       number of range lines to process (default=proc. parameters)

        """
        if self.validate_inputs:
            self._validate_dop_mlcc(SAR_par, PROC_par, signal_data, plot_data, loff, nlines)
        if self.mock_outputs:
            self._mock_dop_mlcc_outputs(SAR_par, PROC_par, signal_data, plot_data, loff, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dop_mlcc))
        return self._gamma_call("MSP", "dop_mlcc", supplied_args)

    def _validate_ERS_proc_ASF_2000(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_ASF_2000", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_ASF_2000_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ASF_2000(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        ERS SAR processing parameters from ASF Level 0 (SKY) CEOS leader after 2000


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par

        NOTE: the SAR sensor parameter files ERS1_ESA.par or ERS2_ESA.par have to be used in the next steps

        """
        if self.validate_inputs:
            self._validate_ERS_proc_ASF_2000(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_ASF_2000_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ASF_2000))
        return self._gamma_call("MSP", "ERS_proc_ASF_2000", supplied_args)

    def _validate_ERS_proc_ASF(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_ASF", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_ASF_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ASF(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        ERS SAR processing parameters (ASF PAF facility)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader
        PROC_par         (output) MSP processing parameters, example p<date>.slc.par

        """
        if self.validate_inputs:
            self._validate_ERS_proc_ASF(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_ASF_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ASF))
        return self._gamma_call("MSP", "ERS_proc_ASF", supplied_args)

    def _validate_doppler_2d(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        dop2d: Path,
        loff: Optional[int] = None,
        blsz: Optional[Any] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        ambig_flag: Optional[Any] = None,
        namb: Optional[int] = None,
    ) -> None:
        self._validate("doppler_2d", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("doppler_2d", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("doppler_2d", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_doppler_2d_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        dop2d: Path,
        loff: Optional[int] = None,
        blsz: Optional[Any] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        ambig_flag: Optional[Any] = None,
        namb: Optional[int] = None,
    ) -> None:
        if dop2d is not None and str(dop2d) != "-":
            dop2d.touch()

    def doppler_2d(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        dop2d: Path,
        loff: Optional[int] = None,
        blsz: Optional[Any] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        ambig_flag: Optional[Any] = None,
        namb: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        2-D Doppler centroid estimation for IQ SAR data


        input parameters:
          SAR_par      (input) SAR sensor parameter file
          PROC_par     (input) processing parameter file
          signal_data  (input) uncompressed IQ raw SAR data file
          dop2d        (output) Doppler centroid as a function of range for each block
          loff         number of lines offset (enter - for default=parameter file value)
          blsz         block size lines (enter - for default = 4096)
          nbl          number of blocks (enter - for default)
          a2_flg       fit a2 for second derivative of the Doppler centroid w.r.t.range (Hz/m/m) (default=0: no  1: yes)
          b0_flg       fit b0 for first derivative of the Doppler centroid w.r.t. along-track time  (Hz/sec) (0: no  default=1: yes)
          b1_flg       fit b1 for along-track rate of the change in slope of Doppler w.r.t. range (Hz/sec/m)(0: no  default=1: yes)
          c0_flg       fit c0 for second derivative of the Doppler centroid w.r.t. along-track time (Hz/sec/sec) (default=0: no 1: yes)
          ambig_flag   Doppler ambiguity resolution flag
                         0 = use unambiguous Doppler Ambiguity Resolver (DAR) estimate (default)
                         1 = command line entry for the Doppler ambiguity number
          namb         user defined number of Doppler ambiguities to add to the Doppler function

        """
        if self.validate_inputs:
            self._validate_doppler_2d(
                SAR_par, PROC_par, signal_data, dop2d, loff, blsz, nbl, a2_flg, b0_flg, b1_flg, c0_flg, ambig_flag, namb
            )
        if self.mock_outputs:
            self._mock_doppler_2d_outputs(
                SAR_par, PROC_par, signal_data, dop2d, loff, blsz, nbl, a2_flg, b0_flg, b1_flg, c0_flg, ambig_flag, namb
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.doppler_2d))
        return self._gamma_call("MSP", "doppler_2d", supplied_args)

    def _validate_ERS_proc_ESA(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_ESA", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_ESA_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ESA(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        ERS SAR processing parameters from ESA-ESRIN VMP and PGS CEOS format leader files


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file (VMP or PGS CEOS format)
        PROC_par         (output) MSP processing parameter file, (example: p<date>.slc.par)

        """
        if self.validate_inputs:
            self._validate_ERS_proc_ESA(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_ESA_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ESA))
        return self._gamma_call("MSP", "ERS_proc_ESA", supplied_args)

    def _validate_az_proc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        SLC: Path,
        az_patch: Optional[Any] = None,
        SLC_format: Optional[int] = None,
        cal_fact: Optional[Any] = None,
        SLC_type: Optional[int] = None,
        kaiser: Optional[Any] = None,
        npatch: Optional[int] = None,
    ) -> None:
        self._validate("az_proc", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("az_proc", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("az_proc", rc_data.exists(), f"rc_data path does not exist ({rc_data})")

    def _mock_az_proc_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        SLC: Path,
        az_patch: Optional[Any] = None,
        SLC_format: Optional[int] = None,
        cal_fact: Optional[Any] = None,
        SLC_type: Optional[int] = None,
        kaiser: Optional[Any] = None,
        npatch: Optional[int] = None,
    ) -> None:
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def az_proc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        SLC: Path,
        az_patch: Optional[Any] = None,
        SLC_format: Optional[int] = None,
        cal_fact: Optional[Any] = None,
        SLC_type: Optional[int] = None,
        kaiser: Optional[Any] = None,
        npatch: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        SAR Range-Doppler azimuth compression of range-compressed data


        input parameters:
          SAR_par     (input) MSP SAR sensor parameter file
          PROC_par    (input) MSP processing parameter file
          rc_data     (input) input range compressed data file
          SLC         (output) single look complex image file
          az_patch    along-track azimuth patch size (range lines): (N*1024)
          SLC_format  SLC output format (enter - for default, from PROC_par):
                        0: FCOMPLEX, pairs of 4-byte float values
                        1: SCOMPLEX, pairs of 2-byte short integers
          cal_fact    processor radiometric calibration factor (dB), (enter - for default, from PROC_par)
                      NOTE: absolute calibration factors (dB) are listed in sensor_cal_MSP.dat
                            add 60.0 dB to the value from sensor_cal_MSP.dat if SLC_format is SCOMPLEX
          SLC_type    output SLC data type:
                        0: sigma0 = (SQR(re) + SQR(im) (default)
                        1: gamma0 = (SQR(re) + SQR(im)/cos(inc)
          kaiser      Kaiser window parameter for azimuth reference function weighting (enter - for default: 2.120)
          npatch      number of along-track patches to process (default: sufficient for entire file)

        """
        if self.validate_inputs:
            self._validate_az_proc(
                SAR_par, PROC_par, rc_data, SLC, az_patch, SLC_format, cal_fact, SLC_type, kaiser, npatch
            )
        if self.mock_outputs:
            self._mock_az_proc_outputs(
                SAR_par, PROC_par, rc_data, SLC, az_patch, SLC_format, cal_fact, SLC_type, kaiser, npatch
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.az_proc))
        return self._gamma_call("MSP", "az_proc", supplied_args)

    def _validate_dop_interf(
        self, SAR_par1: Path, PROC_par1: Path, PROC_par2: Path, PROC_par1_out: Path, PROC_par2_out: Path, dop: Path
    ) -> None:
        self._validate("dop_interf", SAR_par1.exists(), f"SAR_par1 path does not exist ({SAR_par1})")
        self._validate("dop_interf", PROC_par1.exists(), f"PROC_par1 path does not exist ({PROC_par1})")
        self._validate("dop_interf", PROC_par2.exists(), f"PROC_par2 path does not exist ({PROC_par2})")

    def _mock_dop_interf_outputs(
        self, SAR_par1: Path, PROC_par1: Path, PROC_par2: Path, PROC_par1_out: Path, PROC_par2_out: Path, dop: Path
    ) -> None:
        if PROC_par1_out is not None and str(PROC_par1_out) != "-":
            PROC_par1_out.touch()
        if PROC_par2_out is not None and str(PROC_par2_out) != "-":
            PROC_par2_out.touch()
        if dop is not None and str(dop) != "-":
            dop.touch()

    def dop_interf(
        self, SAR_par1: Path, PROC_par1: Path, PROC_par2: Path, PROC_par1_out: Path, PROC_par2_out: Path, dop: Path
    ) -> Tuple[int, str, str]:
        """

        Doppler parameter optimization for Repeat Track Interferometry v2.2 26-Nov-2003 clw


        input parameters:
          SAR_par1_in      (input) SAR sensor/raw data parameter file for scene 1
          PROC_par1_in     (input) MSP processing parameter file for scene 1
          PROC_par2_in     (input) MSP processing parameter file for scene 2
          PROC_par1_out    (output) MSP processing parameter file for scene 1
          PROC_par2_out    (output) MSP processing parameter file for scene 2
          dop              (output) doppler function as a function of range sample number (plot file)

        """
        if self.validate_inputs:
            self._validate_dop_interf(SAR_par1, PROC_par1, PROC_par2, PROC_par1_out, PROC_par2_out, dop)
        if self.mock_outputs:
            self._mock_dop_interf_outputs(SAR_par1, PROC_par1, PROC_par2, PROC_par1_out, PROC_par2_out, dop)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dop_interf))
        return self._gamma_call("MSP", "dop_interf", supplied_args)

    def _validate_CS_proc(
        self,
    ) -> None:
        pass

    def _mock_CS_proc_outputs(
        self,
    ) -> None:
        pass

    def CS_proc(
        self,
    ) -> Tuple[int, str, str]:
        """

        dyld[47318]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/MSP/bin/CS_proc'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)
        """
        if self.validate_inputs:
            self._validate_CS_proc()
        if self.mock_outputs:
            self._mock_CS_proc_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.CS_proc))
        return self._gamma_call("MSP", "CS_proc", supplied_args)

    def _validate_azsp_SLC(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SAR_data: Path,
        spectrum: Any,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        data_format: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        self._validate("azsp_SLC", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("azsp_SLC", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("azsp_SLC", SAR_data.exists(), f"SAR_data path does not exist ({SAR_data})")

    def _mock_azsp_SLC_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SAR_data: Path,
        spectrum: Any,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        data_format: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        pass

    def azsp_SLC(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SAR_data: Path,
        spectrum: Any,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        data_format: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        SAR azimuth spectrum from range compressed or SLC data***


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          SAR_data     (input) input SLC or range compressed data file
          spectrum     output azimuth spectrum
          loff         number of lines offset to start of estimation window (enter - for default:0)
          roff         range samples offset to center of estimation window (enter - for default: center_swath)
          nsub         number of sub-apertures to sum (default: 8)
          data_format  input data format flag (enter - for default: from MSP processing parameter file)
                         0: FCOMPLEX (pairs of 4-byte float)
                         1: SCOMPLEX (pairs of 2-byte short integer)
          pltflg       azimuth spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format

        """
        if self.validate_inputs:
            self._validate_azsp_SLC(SAR_par, PROC_par, SAR_data, spectrum, loff, roff, nsub, data_format, pltflg)
        if self.mock_outputs:
            self._mock_azsp_SLC_outputs(SAR_par, PROC_par, SAR_data, spectrum, loff, roff, nsub, data_format, pltflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.azsp_SLC))
        return self._gamma_call("MSP", "azsp_SLC", supplied_args)

    def _validate_pre_rc_JERS(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rspec: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[Any] = None,
        kaiser: Optional[Any] = None,
        filt_lm: Optional[Any] = None,
    ) -> None:
        self._validate("pre_rc_JERS", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("pre_rc_JERS", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("pre_rc_JERS", rspec.exists(), f"rspec path does not exist ({rspec})")
        self._validate("pre_rc_JERS", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_pre_rc_JERS_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rspec: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[Any] = None,
        kaiser: Optional[Any] = None,
        filt_lm: Optional[Any] = None,
    ) -> None:
        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def pre_rc_JERS(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rspec: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[Any] = None,
        kaiser: Optional[Any] = None,
        filt_lm: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Prefilter/SAR range compression for JERS-1/PALSAR complex IQ SAR data (swath extension)


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          rspec        (input) range spectra data file for RFI suppression
          signal_data  (input) uncompressed raw SAR signal data filename
          rc_data      (output) range compressed data filename
          prefilt_dec  prefilter decimation factor (enter - for default from PROC_par)
          kaiser       range chirp Kaiser window parameter beta (enter - for default: 2.120, -30 dB sidelobes)
          filt_lm      filter length multiplier, FIR length = FIR_lm * prefilt_dec + 1 (enter - for default: 8)

          NOTE: Updates for the number of range samples, number of offset lines, number of lines to process,
                and the swath extension parameter values must occur when running program rspec_JERS.

        """
        if self.validate_inputs:
            self._validate_pre_rc_JERS(SAR_par, PROC_par, rspec, signal_data, rc_data, prefilt_dec, kaiser, filt_lm)
        if self.mock_outputs:
            self._mock_pre_rc_JERS_outputs(SAR_par, PROC_par, rspec, signal_data, rc_data, prefilt_dec, kaiser, filt_lm)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pre_rc_JERS))
        return self._gamma_call("MSP", "pre_rc_JERS", supplied_args)

    def _validate_ERS_proc_NASDA(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_NASDA", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_NASDA_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_NASDA(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        SAR processing parameters (Japan NASDA PAF)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par

        """
        if self.validate_inputs:
            self._validate_ERS_proc_NASDA(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_NASDA_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_NASDA))
        return self._gamma_call("MSP", "ERS_proc_NASDA", supplied_args)

    def _validate_ERS_proc_ARG(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_ARG", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_ARG_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ARG(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        ERS SAR processing parameters from CEOS leader produced by the Argentina PAF ACS processor


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file Argentina PAF
        PROC_par         (output) MSP processing parameter file, (example p<date>.slc.par)

        """
        if self.validate_inputs:
            self._validate_ERS_proc_ARG(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_ARG_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ARG))
        return self._gamma_call("MSP", "ERS_proc_ARG", supplied_args)

    def _validate_PALSAR_proc(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        raw_out: Path,
        TX_POL: Optional[int] = None,
        RX_POL: Optional[int] = None,
    ) -> None:
        self._validate(
            "PALSAR_proc", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )
        self._validate("PALSAR_proc", CEOS_raw_data.exists(), f"CEOS_raw_data path does not exist ({CEOS_raw_data})")

    def _mock_PALSAR_proc_outputs(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        raw_out: Path,
        TX_POL: Optional[int] = None,
        RX_POL: Optional[int] = None,
    ) -> None:
        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()
        if raw_out is not None and str(raw_out) != "-":
            raw_out.touch()

    def PALSAR_proc(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        raw_out: Path,
        TX_POL: Optional[int] = None,
        RX_POL: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        PALSAR raw data pre-processing and generation of the MSP processing parameter file


        input parameters:
          CEOS_SAR_leader  (input) CEOS SAR leader file for PALSAR (LED...)
          SAR_par          (output) MSP sensor parameter file
          PROC_par         (output) MSP processing parameter file
          CEOS_raw_data    (input)  PALSAR CEOS format raw data file (IMG...)
          raw_out          (output) PALSAR range aligned raw data output (enter - for none)
          TX_POL           extracted channel transmit polarization:
                             0: H (default)
                             1: V
          RX_POL           extracted channel receive polarization:
                             0: H (default)
                             1: V

        NOTE: For EORC data, TX_POL and RX_POL are used to document the polarization in the MSP PROC_par file.
              For ERSDAC data, these parameters are used to extract the specified raw data channel. In dual-pol
              mode, the value of TX_POL is derived from the SAR metadata and the command line value is ignored.
              In single-pol mode, the TX_POL and RX_POL values are derived from the SAR metadata alone and
              the command line values are ignored.

        """
        if self.validate_inputs:
            self._validate_PALSAR_proc(CEOS_SAR_leader, SAR_par, PROC_par, CEOS_raw_data, raw_out, TX_POL, RX_POL)
        if self.mock_outputs:
            self._mock_PALSAR_proc_outputs(CEOS_SAR_leader, SAR_par, PROC_par, CEOS_raw_data, raw_out, TX_POL, RX_POL)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PALSAR_proc))
        return self._gamma_call("MSP", "PALSAR_proc", supplied_args)

    def _validate_rspec_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[Any] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        self._validate("rspec_real", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("rspec_real", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("rspec_real", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_rspec_real_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[Any] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        if range_spec is not None and str(range_spec) != "-":
            range_spec.touch()

    def rspec_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[Any] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Range spectrum estimation for offset video raw data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          range_spec   (output) range spectrum
          loff         offset echoes from start of raw data file (enter - for default from PROC_par file)
          nlspec       number of lines to estimate spectrum (enter - for default: 1024)
          nrfft        range FFT size (enter - for default: 4096)
          pltflg       range spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format
        """
        if self.validate_inputs:
            self._validate_rspec_real(SAR_par, PROC_par, signal_data, range_spec, loff, nlspec, nrfft, pltflg)
        if self.mock_outputs:
            self._mock_rspec_real_outputs(SAR_par, PROC_par, signal_data, range_spec, loff, nlspec, nrfft, pltflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rspec_real))
        return self._gamma_call("MSP", "rspec_real", supplied_args)

    def _validate_rspec_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[Any] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[Any] = None,
        roff: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        self._validate("rspec_IQ", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("rspec_IQ", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("rspec_IQ", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_rspec_IQ_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[Any] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[Any] = None,
        roff: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        if range_spec is not None and str(range_spec) != "-":
            range_spec.touch()

    def rspec_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        loff: Optional[Any] = None,
        nlspec: Optional[int] = None,
        nrfft: Optional[Any] = None,
        roff: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Range spectrum estimation for IQ raw SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data
          range_spec   (output) range spectrum plot file (text)
          loff         offset echoes from start of raw data file (enter - for default: PROC_par)
          nlspec       number of lines to estimate spectrum (enter - for default: 4096)
          nrfft        range FFT size (enter - for default: 4096)
          roff         range offset in samples (enter - for default: PROC_par)
          pltflg       range spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format
        """
        if self.validate_inputs:
            self._validate_rspec_IQ(SAR_par, PROC_par, signal_data, range_spec, loff, nlspec, nrfft, roff, pltflg)
        if self.mock_outputs:
            self._mock_rspec_IQ_outputs(SAR_par, PROC_par, signal_data, range_spec, loff, nlspec, nrfft, roff, pltflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rspec_IQ))
        return self._gamma_call("MSP", "rspec_IQ", supplied_args)

    def _validate_af(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SLC: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        thres: Optional[Any] = None,
        update_flg: Optional[int] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        dac_flg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        roff: Optional[Any] = None,
        azoff: Optional[Any] = None,
    ) -> None:
        self._validate("af", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("af", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("af", SLC.exists(), f"SLC path does not exist ({SLC})")

    def _mock_af_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SLC: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        thres: Optional[Any] = None,
        update_flg: Optional[int] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        dac_flg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        roff: Optional[Any] = None,
        azoff: Optional[Any] = None,
    ) -> None:
        if offsets is not None and str(offsets) != "-":
            offsets.touch()

    def af(
        self,
        SAR_par: Path,
        PROC_par: Path,
        SLC: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        thres: Optional[Any] = None,
        update_flg: Optional[int] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        dac_flg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        roff: Optional[Any] = None,
        azoff: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Autofocus estimation of effective velocity for SAR processing


        input parameters:
          SAR_par    (input) MSP SAR sensor parameter file
          PROC_par   (input) MSP processing parameter file
          SLC        (input) single-look complex image
          rwin       range window size (enter - for default: 1024)
          azwin      azimuth window size (enter - for default: 4096)
          dr         range sample increment (enter - for default: 1024,  enter 0 for single patch)
          daz        azimuth line increment (enter - for default: 8192,  enter 0 for single patch)
          thres      offset estimation SNR threshold (enter - for default:   10.000)
          update_flg update effective velocity flag (enter - for default: 1)
                       0: no update of effective velocity in PROC_par file
                       1: update effective velocity in PROC_par (default)
          a1_flg     fit a1 for first derivative of the effective velocity w.r.t.range
                       0: no (default)
                       1: yes
          b0_flg     fit b0 for first derivative of the effective velocity w.r.t. along-track time
                       0: no (default)
                       1: yes
          offsets    (output) range and azimuth offsets and SNR data in text format, enter - for no output
          dac_flg    Doppler ambiguity correction flag
                       0: Doppler centroid remains unchanged: exit if Doppler ambiguity error detected
                       1: Doppler centroid ambiguity corrected (default)
          n_ovr      SLC oversampling factor (1,2,4: enter - for default: 1)
          roff       range offset for single patch center
          azoff      azimuth offset for single patch center
        """
        if self.validate_inputs:
            self._validate_af(
                SAR_par,
                PROC_par,
                SLC,
                rwin,
                azwin,
                dr,
                daz,
                thres,
                update_flg,
                a1_flg,
                b0_flg,
                offsets,
                dac_flg,
                n_ovr,
                roff,
                azoff,
            )
        if self.mock_outputs:
            self._mock_af_outputs(
                SAR_par,
                PROC_par,
                SLC,
                rwin,
                azwin,
                dr,
                daz,
                thres,
                update_flg,
                a1_flg,
                b0_flg,
                offsets,
                dac_flg,
                n_ovr,
                roff,
                azoff,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.af))
        return self._gamma_call("MSP", "af", supplied_args)

    def _validate_hist_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        historgram: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        self._validate("hist_IQ", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("hist_IQ", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("hist_IQ", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_hist_IQ_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        historgram: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        if historgram is not None and str(historgram) != "-":
            historgram.touch()

    def hist_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        historgram: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        IQ histogram estimation of raw SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          histogram    (output) histogram (text format)
          loff         number of lines offset (default = parameter file value)
          nl           number of lines to estimate historgram (default=1024)

        """
        if self.validate_inputs:
            self._validate_hist_IQ(SAR_par, PROC_par, signal_data, historgram, loff, nl)
        if self.mock_outputs:
            self._mock_hist_IQ_outputs(SAR_par, PROC_par, signal_data, historgram, loff, nl)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.hist_IQ))
        return self._gamma_call("MSP", "hist_IQ", supplied_args)

    def _validate_PALSAR_burst_sync(
        self,
        SAR_par1: Path,
        PROC_par1: Path,
        raw1: Path,
        SAR_par2: Path,
        PROC_par2: Path,
        raw2: Path,
        PROC_par1_out: Path,
        raw1_out: Path,
        PROC_par2_out: Path,
        raw2_out: Path,
    ) -> None:
        self._validate("PALSAR_burst_sync", SAR_par1.exists(), f"SAR_par1 path does not exist ({SAR_par1})")
        self._validate("PALSAR_burst_sync", PROC_par1.exists(), f"PROC_par1 path does not exist ({PROC_par1})")
        self._validate("PALSAR_burst_sync", raw1.exists(), f"raw1 path does not exist ({raw1})")
        self._validate("PALSAR_burst_sync", SAR_par2.exists(), f"SAR_par2 path does not exist ({SAR_par2})")
        self._validate("PALSAR_burst_sync", PROC_par2.exists(), f"PROC_par2 path does not exist ({PROC_par2})")
        self._validate("PALSAR_burst_sync", raw2.exists(), f"raw2 path does not exist ({raw2})")

    def _mock_PALSAR_burst_sync_outputs(
        self,
        SAR_par1: Path,
        PROC_par1: Path,
        raw1: Path,
        SAR_par2: Path,
        PROC_par2: Path,
        raw2: Path,
        PROC_par1_out: Path,
        raw1_out: Path,
        PROC_par2_out: Path,
        raw2_out: Path,
    ) -> None:
        if PROC_par1_out is not None and str(PROC_par1_out) != "-":
            PROC_par1_out.touch()
        if raw1_out is not None and str(raw1_out) != "-":
            raw1_out.touch()
        if PROC_par2_out is not None and str(PROC_par2_out) != "-":
            PROC_par2_out.touch()
        if raw2_out is not None and str(raw2_out) != "-":
            raw2_out.touch()

    def PALSAR_burst_sync(
        self,
        SAR_par1: Path,
        PROC_par1: Path,
        raw1: Path,
        SAR_par2: Path,
        PROC_par2: Path,
        raw2: Path,
        PROC_par1_out: Path,
        raw1_out: Path,
        PROC_par2_out: Path,
        raw2_out: Path,
    ) -> Tuple[int, str, str]:
        """

        PALSAR ScanSAR azimuth burst synchronization


        input parameters:
          SAR_par1      (input) MSP sensor parameter file for track-1 (reference)
          PROC_par1     (input) MSP processing parameter file for track-1 (reference)
          raw1         (input) WB ScanSAR data track-1
          SAR_par2      (input) MSP sensor parameter file for track-2
          PROC_par2     (input) MSP processing parameter file for track-2
          raw2         (input) WB ScanSAR or FBS raw data track-2
          PROC_par1_out (output) MSP processing parameter file for burst sync. track-1
          raw1_out      (output) WB ScanSAR data for burst sync. track-1
          PROC_par2_out (output) MSP processing parameter file for burst sync. track-2
          raw2_out      (output) WB ScanSAR data for burst sync. track-2
        """
        if self.validate_inputs:
            self._validate_PALSAR_burst_sync(
                SAR_par1, PROC_par1, raw1, SAR_par2, PROC_par2, raw2, PROC_par1_out, raw1_out, PROC_par2_out, raw2_out
            )
        if self.mock_outputs:
            self._mock_PALSAR_burst_sync_outputs(
                SAR_par1, PROC_par1, raw1, SAR_par2, PROC_par2, raw2, PROC_par1_out, raw1_out, PROC_par2_out, raw2_out
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PALSAR_burst_sync))
        return self._gamma_call("MSP", "PALSAR_burst_sync", supplied_args)

    def _validate_swap_IQ(self, SAR_par: Path, raw_IQ: Path, raw_IQ_swap: Path) -> None:
        self._validate("swap_IQ", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("swap_IQ", raw_IQ.exists(), f"raw_IQ path does not exist ({raw_IQ})")

    def _mock_swap_IQ_outputs(self, SAR_par: Path, raw_IQ: Path, raw_IQ_swap: Path) -> None:
        if raw_IQ_swap is not None and str(raw_IQ_swap) != "-":
            raw_IQ_swap.touch()

    def swap_IQ(self, SAR_par: Path, raw_IQ: Path, raw_IQ_swap: Path) -> Tuple[int, str, str]:
        """

        Swap IQ of complex raw SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          raw_IQ       (input) input uncompressed SAR data
          raw_IQ_swap  (output) output raw data with IQ swapped

        """
        if self.validate_inputs:
            self._validate_swap_IQ(SAR_par, raw_IQ, raw_IQ_swap)
        if self.mock_outputs:
            self._mock_swap_IQ_outputs(SAR_par, raw_IQ, raw_IQ_swap)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.swap_IQ))
        return self._gamma_call("MSP", "swap_IQ", supplied_args)

    def _validate_dop_ambig(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        algorithm: Optional[int] = None,
        loff: Optional[int] = None,
        output_plot: Optional[Path] = None,
    ) -> None:
        self._validate("dop_ambig", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("dop_ambig", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("dop_ambig", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_dop_ambig_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        algorithm: Optional[int] = None,
        loff: Optional[int] = None,
        output_plot: Optional[Path] = None,
    ) -> None:
        if output_plot is not None and str(output_plot) != "-":
            output_plot.touch()

    def dop_ambig(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        algorithm: Optional[int] = None,
        loff: Optional[int] = None,
        output_plot: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Doppler ambiguity estimation for IQ SAR raw data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data (I/Q complex)
          algorithm    algorithm selection:
                         1: Multi-Look Cross Correlation (MLCC)
                         2: Multi-Look Beat Frequency (MLBF) (default)
          loff         number of lines offset (enter - for default: parameter file value)
          output_plot  (output) plot file: correlation phase for MLCC, azimuth spectrum for MLBF
        """
        if self.validate_inputs:
            self._validate_dop_ambig(SAR_par, PROC_par, signal_data, algorithm, loff, output_plot)
        if self.mock_outputs:
            self._mock_dop_ambig_outputs(SAR_par, PROC_par, signal_data, algorithm, loff, output_plot)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dop_ambig))
        return self._gamma_call("MSP", "dop_ambig", supplied_args)

    def _validate_PRC_proc(self, PROC_par: Path, PRC: Any, nstate: Optional[int] = None) -> None:
        self._validate("PRC_proc", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")

    def _mock_PRC_proc_outputs(self, PROC_par: Path, PRC: Any, nstate: Optional[int] = None) -> None:
        pass

    def PRC_proc(self, PROC_par: Path, PRC: Any, nstate: Optional[int] = None) -> Tuple[int, str, str]:
        """

        State vectors  from ERS PRC orbit data for MSP processing


        input parameters:
          PROC_par  (input) MSP processing parameter file
          PRC       PRC state vector file
          nstate    number of state vectors (default=5, maximum=64)

        """
        if self.validate_inputs:
            self._validate_PRC_proc(PROC_par, PRC, nstate)
        if self.mock_outputs:
            self._mock_PRC_proc_outputs(PROC_par, PRC, nstate)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PRC_proc))
        return self._gamma_call("MSP", "PRC_proc", supplied_args)

    def _validate_rc_fmcw(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        nrc_off: int,
        nrc_samp: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[Any] = None,
    ) -> None:
        self._validate("rc_fmcw", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("rc_fmcw", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("rc_fmcw", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_rc_fmcw_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        nrc_off: int,
        nrc_samp: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[Any] = None,
    ) -> None:
        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def rc_fmcw(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        nrc_off: int,
        nrc_samp: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        SAR range compression for offset-video FMCW radar data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          rc_data      (output) output range compressed data filename
          nrc_off      offset to the first sample of the output range-compressed data (samples)
          nrc_samp     number of samples in the output range-compressed data (enter - for default)
          loff         number of lines offset (enter - for default)
          nl           number of lines to range compress (enter - for default)
          kaiser       range chirp Kaiser window parameter beta (enter - for default)
        """
        if self.validate_inputs:
            self._validate_rc_fmcw(SAR_par, PROC_par, signal_data, rc_data, nrc_off, nrc_samp, loff, nl, kaiser)
        if self.mock_outputs:
            self._mock_rc_fmcw_outputs(SAR_par, PROC_par, signal_data, rc_data, nrc_off, nrc_samp, loff, nl, kaiser)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rc_fmcw))
        return self._gamma_call("MSP", "rc_fmcw", supplied_args)

    def _validate_RSAT_lks(
        self, SLC_PROC_par: Path, MLI_PROC_par: Path, SLC_image: Path, ML_image: Path, kaiser: Optional[Any] = None
    ) -> None:
        self._validate("RSAT_lks", SLC_PROC_par.exists(), f"SLC_PROC_par path does not exist ({SLC_PROC_par})")
        self._validate("RSAT_lks", SLC_image.exists(), f"SLC_image path does not exist ({SLC_image})")

    def _mock_RSAT_lks_outputs(
        self, SLC_PROC_par: Path, MLI_PROC_par: Path, SLC_image: Path, ML_image: Path, kaiser: Optional[Any] = None
    ) -> None:
        if MLI_PROC_par is not None and str(MLI_PROC_par) != "-":
            MLI_PROC_par.touch()
        if ML_image is not None and str(ML_image) != "-":
            ML_image.touch()

    def RSAT_lks(
        self, SLC_PROC_par: Path, MLI_PROC_par: Path, SLC_image: Path, ML_image: Path, kaiser: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        RADARSAT SLC --> RADARSAT multilook image calculation


        input parameters:
          SLC_PROC_par  (input) MSP SLC processing parameter file
          MLI_PROC_par  (output) MLI processing parameter file
          SLC_image     (input) SLC image file
          MLI_image     (output) MLI image
          kaiser        Kaiser window parameter (default=2.9)

        """
        if self.validate_inputs:
            self._validate_RSAT_lks(SLC_PROC_par, MLI_PROC_par, SLC_image, ML_image, kaiser)
        if self.mock_outputs:
            self._mock_RSAT_lks_outputs(SLC_PROC_par, MLI_PROC_par, SLC_image, ML_image, kaiser)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.RSAT_lks))
        return self._gamma_call("MSP", "RSAT_lks", supplied_args)

    def _validate_extract_psd(self, spectra: Any, num: Any, output_spectrum: Any) -> None:
        pass

    def _mock_extract_psd_outputs(self, spectra: Any, num: Any, output_spectrum: Any) -> None:
        pass

    def extract_psd(self, spectra: Any, num: Any, output_spectrum: Any) -> Tuple[int, str, str]:
        """

        Extract single spectrum from binary format range spectra file


        input parameters:
          range_spec    range spectra data file (binary format from rspec_JERS.c)
          num           spectrum number (1 --> rsp.nspec)
          output        output spectrum (text format for plotting)

        """
        if self.validate_inputs:
            self._validate_extract_psd(spectra, num, output_spectrum)
        if self.mock_outputs:
            self._mock_extract_psd_outputs(spectra, num, output_spectrum)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.extract_psd))
        return self._gamma_call("MSP", "extract_psd", supplied_args)

    def _validate_doppler_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[Any] = None,
        namb: Optional[int] = None,
    ) -> None:
        self._validate("doppler_real", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("doppler_real", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("doppler_real", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_doppler_real_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[Any] = None,
        namb: Optional[int] = None,
    ) -> None:
        if doppler is not None and str(doppler) != "-":
            doppler.touch()

    def doppler_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[Any] = None,
        namb: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Doppler centroid estimation (offset_video real valued data)


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed IQ raw SAR data file
          doppler      (output) Doppler as a function of slant range (text format)
          loff         number of lines offset (enter - for default=parameter file value)
          nsub         number of azimuth subapertures (default = 12)
          ambig_flag   Doppler ambiguity resolution flag
                         0 = use unambiguous Doppler Ambiguity Resolver (DAR) estimate (default)
                         1 = estimate Doppler ambiguity number from the Doppler slope
                         2 = command line entry for the Doppler ambiguity number
          namb         User defined number of Doppler ambiguities to add to the Doppler function

        """
        if self.validate_inputs:
            self._validate_doppler_real(SAR_par, PROC_par, signal_data, doppler, loff, nsub, ambig_flag, namb)
        if self.mock_outputs:
            self._mock_doppler_real_outputs(SAR_par, PROC_par, signal_data, doppler, loff, nsub, ambig_flag, namb)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.doppler_real))
        return self._gamma_call("MSP", "doppler_real", supplied_args)

    def _validate_pre_rc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[Any] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[Any] = None,
        filt_lm: Optional[Any] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
        pre_ext: Optional[Any] = None,
        post_ext: Optional[Any] = None,
        RFI_filt: Optional[int] = None,
        RFI_thres: Optional[Any] = None,
        fc_offset: Optional[int] = None,
        win_bw: Optional[int] = None,
    ) -> None:
        self._validate("pre_rc", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("pre_rc", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("pre_rc", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_pre_rc_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[Any] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[Any] = None,
        filt_lm: Optional[Any] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
        pre_ext: Optional[Any] = None,
        post_ext: Optional[Any] = None,
        RFI_filt: Optional[int] = None,
        RFI_thres: Optional[Any] = None,
        fc_offset: Optional[int] = None,
        win_bw: Optional[int] = None,
    ) -> None:
        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def pre_rc(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[Any] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[Any] = None,
        filt_lm: Optional[Any] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
        pre_ext: Optional[Any] = None,
        post_ext: Optional[Any] = None,
        RFI_filt: Optional[int] = None,
        RFI_thres: Optional[Any] = None,
        fc_offset: Optional[int] = None,
        win_bw: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        SAR data prefilter and range compression for complex IQ data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw IQ SAR signal data
          rc_data      (output) range compressed data filename
          prefilt_dec  prefilter decimation factor (enter - for default from PROC_par)
          loff         number of lines offset from start of file (enter - for default from PROC_par)
          nl           number of lines to range compress (enter - for default from PROC_par)
          nr_samp      number of range samples (enter - for default from PROC_par)
          kaiser       range chirp Kaiser window parameter beta (enter - for default: 2.120)
          filt_lm      filter length multiplier, FIR length = FIR_lm * prefilt_dec + 1 (enter - for default: 8)
          nr_ext       near-range swath extension in samples (enter - for default from PROC_par)
          fr_ext       far-range swath extension in samples  (enter - for default from PROC_par)
          pre_ext      pre-azimuth data extension in echoes  (enter - for default from PROC_par)
          post_ext     post-azimuth data extension in echoes (enter - for default from PROC_par)
          RFI_filt     RFI suppression filtering (enter - for default):
                         0:OFF (default)
                         1:ON
          RFI_thres    RFI detection threshold, nominal range 1.1-->1.6 (enter - for default= 1.500)
          fc_offset    offset of the center of the chirp window as a fraction of the chirp bandwidth, range -0.5 to 0.5 (enter - for default: 0.0)
          win_bw       chirp window bandwidth as a fraction of chirp bandwidth, range: 0.0 to 1.0 (enter - for default: 1.0)

        """
        if self.validate_inputs:
            self._validate_pre_rc(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                prefilt_dec,
                loff,
                nl,
                nr_samp,
                kaiser,
                filt_lm,
                nr_ext,
                fr_ext,
                pre_ext,
                post_ext,
                RFI_filt,
                RFI_thres,
                fc_offset,
                win_bw,
            )
        if self.mock_outputs:
            self._mock_pre_rc_outputs(
                SAR_par,
                PROC_par,
                signal_data,
                rc_data,
                prefilt_dec,
                loff,
                nl,
                nr_samp,
                kaiser,
                filt_lm,
                nr_ext,
                fr_ext,
                pre_ext,
                post_ext,
                RFI_filt,
                RFI_thres,
                fc_offset,
                win_bw,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pre_rc))
        return self._gamma_call("MSP", "pre_rc", supplied_args)

    def _validate_PALSAR_proc_WB(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        beam: Path,
        raw_out: Path,
        prf: Optional[Path] = None,
        wflg: Optional[int] = None,
    ) -> None:
        self._validate(
            "PALSAR_proc_WB", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )
        self._validate("PALSAR_proc_WB", CEOS_raw_data.exists(), f"CEOS_raw_data path does not exist ({CEOS_raw_data})")
        self._validate("PALSAR_proc_WB", beam.exists(), f"beam path does not exist ({beam})")
        if prf is not None:
            self._validate("PALSAR_proc_WB", prf.exists(), f"prf path does not exist ({prf})")

    def _mock_PALSAR_proc_WB_outputs(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        beam: Path,
        raw_out: Path,
        prf: Optional[Path] = None,
        wflg: Optional[int] = None,
    ) -> None:
        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()
        if raw_out is not None and str(raw_out) != "-":
            raw_out.touch()

    def PALSAR_proc_WB(
        self,
        CEOS_SAR_leader: Path,
        SAR_par: Path,
        PROC_par: Path,
        CEOS_raw_data: Path,
        beam: Path,
        raw_out: Path,
        prf: Optional[Path] = None,
        wflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        PALSAR ScanSAR raw data pre-processing and generation of the MSP processing parameters


        input parameters:
          CEOS_SAR_leader  (input) CEOS SAR leader file for PALSAR (LED...)
          SAR_par          (output) MSP sensor parameter file
          PROC_par         (output) MSP processing parameter file
          CEOS_raw_data    (input)  PALSAR CEOS format raw data file (IMG...)
          beam             (input)  beam number (1 --> 5)
          raw_out          (output) PALSAR range aligned raw data output (enter - for none)
          prf              (input)  PRF of the resampled data, (enter - for default: beam 4 PRF)
          wflg             (input) burst window weighting flag (enter - for default):
                             0: no window applied to bursts (default)
                             1: apply Kaiser window to each burst
        """
        if self.validate_inputs:
            self._validate_PALSAR_proc_WB(CEOS_SAR_leader, SAR_par, PROC_par, CEOS_raw_data, beam, raw_out, prf, wflg)
        if self.mock_outputs:
            self._mock_PALSAR_proc_WB_outputs(
                CEOS_SAR_leader, SAR_par, PROC_par, CEOS_raw_data, beam, raw_out, prf, wflg
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PALSAR_proc_WB))
        return self._gamma_call("MSP", "PALSAR_proc_WB", supplied_args)

    def _validate_ORRM_proc(self, PROC_par: Path, ORRM: Path, nstate: Optional[int] = None) -> None:
        self._validate("ORRM_proc", ORRM.exists(), f"ORRM path does not exist ({ORRM})")

    def _mock_ORRM_proc_outputs(self, PROC_par: Path, ORRM: Path, nstate: Optional[int] = None) -> None:
        if not PROC_par.exists():
            PROC_par.touch()

    def ORRM_proc(self, PROC_par: Path, ORRM: Path, nstate: Optional[int] = None) -> Tuple[int, str, str]:
        """

        Extract state vectors from ORRM file for processing parameter file


        input parameters:
          PROC_par  (input/output) MSP processing parameter file
          ORRM      (input) ORRM state vector file
          nstate    number of state vectors (default=5, maximum=64)

        """
        if self.validate_inputs:
            self._validate_ORRM_proc(PROC_par, ORRM, nstate)
        if self.mock_outputs:
            self._mock_ORRM_proc_outputs(PROC_par, ORRM, nstate)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORRM_proc))
        return self._gamma_call("MSP", "ORRM_proc", supplied_args)

    def _validate_ERS_proc_UK(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_UK", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_UK_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_UK(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        ERS SAR processing parameters (UK-PAF, QinetiQ)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par)

        """
        if self.validate_inputs:
            self._validate_ERS_proc_UK(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_UK_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_UK))
        return self._gamma_call("MSP", "ERS_proc_UK", supplied_args)

    def _validate_RSAT_raw(
        self, CEOS_leader: Path, SAR_par: Path, PROC_par: Path, raw_data_files: Path, raw_out: Path
    ) -> None:
        self._validate("RSAT_raw", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("RSAT_raw", raw_data_files.exists(), f"raw_data_files path does not exist ({raw_data_files})")

    def _mock_RSAT_raw_outputs(
        self, CEOS_leader: Path, SAR_par: Path, PROC_par: Path, raw_data_files: Path, raw_out: Path
    ) -> None:
        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()
        if raw_out is not None and str(raw_out) != "-":
            raw_out.touch()

    def RSAT_raw(
        self, CEOS_leader: Path, SAR_par: Path, PROC_par: Path, raw_data_files: Path, raw_out: Path
    ) -> Tuple[int, str, str]:
        """

        RADARSAT raw data reformatting + generation of MSP processing parameter files


        input parameters:
          CEOS_ldr        (input) CEOS leader file
          SAR_par         (output) MSP SAR sensor parameter file
          PROC_par        (output) MSP processing parameter file
          raw_data_files  (input) Radarsat raw data file(s) to condition and concatenate
          raw_out         (output) Radarsat conditioned raw output data file

        """
        if self.validate_inputs:
            self._validate_RSAT_raw(CEOS_leader, SAR_par, PROC_par, raw_data_files, raw_out)
        if self.mock_outputs:
            self._mock_RSAT_raw_outputs(CEOS_leader, SAR_par, PROC_par, raw_data_files, raw_out)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.RSAT_raw))
        return self._gamma_call("MSP", "RSAT_raw", supplied_args)

    def _validate_ERS_ENVISAT_proc(
        self,
        L0: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swst_flg: Optional[int] = None,
    ) -> None:
        self._validate("ERS_ENVISAT_proc", L0.exists(), f"L0 path does not exist ({L0})")

    def _mock_ERS_ENVISAT_proc_outputs(
        self,
        L0: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swst_flg: Optional[int] = None,
    ) -> None:
        if not SAR_par.exists():
            SAR_par.touch()
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()
        if raw is not None and str(raw) != "-":
            raw.touch()

    def ERS_ENVISAT_proc(
        self,
        L0: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swst_flg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        MSP preprocessing for ERS raw data in ENVISAT format


        input parameters:
          L0       (input) Level 0 Image Mode ERS data file in Envisat format (SAR_IM__0P*.E*)
          SAR_par  (input/output) MSP SAR sensor parameter file (ERS*_ESA.par)
          PROC_par (output) MSP processing parameter file, (example p<orbit>.slc.par)
          raw      (output) byte aligned 8-bit I/Q raw data
          loff     number of lines offset from start of raw data file (enter - for default: 0)
          nl       number of lines to extract (enter - for default: to end of input raw data
          swst_flg SWST data window position processing flag:
                     0: ignore changes in the data window position (only for corrupted data)
                     1: track changes in the data window position (default)

        """
        if self.validate_inputs:
            self._validate_ERS_ENVISAT_proc(L0, SAR_par, PROC_par, raw, loff, nl, swst_flg)
        if self.mock_outputs:
            self._mock_ERS_ENVISAT_proc_outputs(L0, SAR_par, PROC_par, raw, loff, nl, swst_flg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_ENVISAT_proc))
        return self._gamma_call("MSP", "ERS_ENVISAT_proc", supplied_args)

    def _validate_multi_SLC(
        self,
        SLC_PROC_par: Path,
        MLI_PROC_par: Path,
        SLC: Path,
        MLI: Path,
        rlks: int,
        azlks: int,
        slc_format: Optional[int] = None,
    ) -> None:
        self._validate("multi_SLC", SLC_PROC_par.exists(), f"SLC_PROC_par path does not exist ({SLC_PROC_par})")
        self._validate("multi_SLC", SLC.exists(), f"SLC path does not exist ({SLC})")

    def _mock_multi_SLC_outputs(
        self,
        SLC_PROC_par: Path,
        MLI_PROC_par: Path,
        SLC: Path,
        MLI: Path,
        rlks: int,
        azlks: int,
        slc_format: Optional[int] = None,
    ) -> None:
        if MLI_PROC_par is not None and str(MLI_PROC_par) != "-":
            MLI_PROC_par.touch()
        if MLI is not None and str(MLI) != "-":
            MLI.touch()

    def multi_SLC(
        self,
        SLC_PROC_par: Path,
        MLI_PROC_par: Path,
        SLC: Path,
        MLI: Path,
        rlks: int,
        azlks: int,
        slc_format: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate a multilook intensity image (MLI) from an SLC


        input parameters:
          SLC_PROC_par  (input) SLC MSP processing parameter file
          MLI_PROC_par  (output) MLI MSP processing parameter file
          SLC           (input) single look complex image
          MLI           (output) multilook intensity image derived from SLC
          rlks          number of range looks
          azlks         number of azimuth looks
          slc_format    input SLC format flag (default: from SLC_PROC_par)
                        0: FCOMPLEX (pairs of 4-byte float)
                        1: SCOMPLEX (pairs of 2-byte short integer)

        """
        if self.validate_inputs:
            self._validate_multi_SLC(SLC_PROC_par, MLI_PROC_par, SLC, MLI, rlks, azlks, slc_format)
        if self.mock_outputs:
            self._mock_multi_SLC_outputs(SLC_PROC_par, MLI_PROC_par, SLC, MLI, rlks, azlks, slc_format)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_SLC))
        return self._gamma_call("MSP", "multi_SLC", supplied_args)

    def _validate_JERS_acs(
        self,
        USER_HEADER: Path,
        SEG_DESCR: Path,
        ORBIT_DATA: Path,
        SENSOR_DATA: Path,
        track: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw_out: Path,
        loff: int,
        nl: int,
        nsx: Optional[Any] = None,
        fsx: Optional[Any] = None,
        deskew: Optional[Any] = None,
        terra_alt: Optional[Any] = None,
    ) -> None:
        self._validate("JERS_acs", USER_HEADER.exists(), f"USER_HEADER path does not exist ({USER_HEADER})")
        self._validate("JERS_acs", SEG_DESCR.exists(), f"SEG_DESCR path does not exist ({SEG_DESCR})")
        self._validate("JERS_acs", ORBIT_DATA.exists(), f"ORBIT_DATA path does not exist ({ORBIT_DATA})")
        self._validate("JERS_acs", SENSOR_DATA.exists(), f"SENSOR_DATA path does not exist ({SENSOR_DATA})")

    def _mock_JERS_acs_outputs(
        self,
        USER_HEADER: Path,
        SEG_DESCR: Path,
        ORBIT_DATA: Path,
        SENSOR_DATA: Path,
        track: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw_out: Path,
        loff: int,
        nl: int,
        nsx: Optional[Any] = None,
        fsx: Optional[Any] = None,
        deskew: Optional[Any] = None,
        terra_alt: Optional[Any] = None,
    ) -> None:
        if track is not None and str(track) != "-":
            track.touch()
        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()
        if raw_out is not None and str(raw_out) != "-":
            raw_out.touch()

    def JERS_acs(
        self,
        USER_HEADER: Path,
        SEG_DESCR: Path,
        ORBIT_DATA: Path,
        SENSOR_DATA: Path,
        track: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw_out: Path,
        loff: int,
        nl: int,
        nsx: Optional[Any] = None,
        fsx: Optional[Any] = None,
        deskew: Optional[Any] = None,
        terra_alt: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Read JERS raw data recorded by the ACS ground system


        input parameters:
        USER_HEADER  (input) ACS user header file
        SEG_DESCR    (input) ACS segment descriptor file
        ORBIT_DATA   (input) ACS orbit data file
        SENSOR_DATA  (input) ACS JERS sensor data
        track        (output) track file containing near, center, far lat/lon vs. time (enter - for none, text format)
        SAR_par      (output) JERS SAR Sensor parameter file
        PROC_par     (output) MSP processing parameter file
        raw_out      (output) reformatted raw data file
        loff         offset to first line to reformat (lines)
        nl           number of lines to reformat (enter - for all)
        nsx          near swath extension (samples default: 0)
        fsx          far swath extension  (samples default: 0)
        terra_alt    nominal terrain altitude (m default = 0.0)
        deskew       deskew flag (default:ON  OFF)
        """
        if self.validate_inputs:
            self._validate_JERS_acs(
                USER_HEADER,
                SEG_DESCR,
                ORBIT_DATA,
                SENSOR_DATA,
                track,
                SAR_par,
                PROC_par,
                raw_out,
                loff,
                nl,
                nsx,
                fsx,
                deskew,
                terra_alt,
            )
        if self.mock_outputs:
            self._mock_JERS_acs_outputs(
                USER_HEADER,
                SEG_DESCR,
                ORBIT_DATA,
                SENSOR_DATA,
                track,
                SAR_par,
                PROC_par,
                raw_out,
                loff,
                nl,
                nsx,
                fsx,
                deskew,
                terra_alt,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.JERS_acs))
        return self._gamma_call("MSP", "JERS_acs", supplied_args)

    def _validate_DORIS_proc(self, PROC_par: Path, DOR: Path, nstate: Optional[int] = None) -> None:
        self._validate("DORIS_proc", DOR.exists(), f"DOR path does not exist ({DOR})")

    def _mock_DORIS_proc_outputs(self, PROC_par: Path, DOR: Path, nstate: Optional[int] = None) -> None:
        if not PROC_par.exists():
            PROC_par.touch()

    def DORIS_proc(self, PROC_par: Path, DOR: Path, nstate: Optional[int] = None) -> Tuple[int, str, str]:
        """

        extract ENVISAT DORIS state vectors and write to an MSP processing parameter file


        input parameters:
          PROC_par (input/output) MSP processing parameter file, (example p<orbit>.slc.par)
          DOR      (input) ASAR DORIS data file (DOR_VOR_AXVF)
          nstate   number of state vectors to extract (enter - for default: 11)
        """
        if self.validate_inputs:
            self._validate_DORIS_proc(PROC_par, DOR, nstate)
        if self.mock_outputs:
            self._mock_DORIS_proc_outputs(PROC_par, DOR, nstate)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.DORIS_proc))
        return self._gamma_call("MSP", "DORIS_proc", supplied_args)

    def _validate_ASAR_AP_proc(
        self,
        L0: Path,
        INS: Path,
        SAR_par1: Path,
        SAR_par2: Path,
        PROC_par1: Path,
        PROC_par2: Path,
        raw1: Path,
        raw2: Path,
        ant_gain1: Path,
        ant_gain2: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
    ) -> None:
        self._validate("ASAR_AP_proc", L0.exists(), f"L0 path does not exist ({L0})")
        self._validate("ASAR_AP_proc", INS.exists(), f"INS path does not exist ({INS})")
        self._validate("ASAR_AP_proc", ant_gain1.exists(), f"ant_gain1 path does not exist ({ant_gain1})")
        self._validate("ASAR_AP_proc", ant_gain2.exists(), f"ant_gain2 path does not exist ({ant_gain2})")

    def _mock_ASAR_AP_proc_outputs(
        self,
        L0: Path,
        INS: Path,
        SAR_par1: Path,
        SAR_par2: Path,
        PROC_par1: Path,
        PROC_par2: Path,
        raw1: Path,
        raw2: Path,
        ant_gain1: Path,
        ant_gain2: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
    ) -> None:
        if SAR_par1 is not None and str(SAR_par1) != "-":
            SAR_par1.touch()
        if SAR_par2 is not None and str(SAR_par2) != "-":
            SAR_par2.touch()
        if PROC_par1 is not None and str(PROC_par1) != "-":
            PROC_par1.touch()
        if PROC_par2 is not None and str(PROC_par2) != "-":
            PROC_par2.touch()
        if raw1 is not None and str(raw1) != "-":
            raw1.touch()
        if raw2 is not None and str(raw2) != "-":
            raw2.touch()

    def ASAR_AP_proc(
        self,
        L0: Path,
        INS: Path,
        SAR_par1: Path,
        SAR_par2: Path,
        PROC_par1: Path,
        PROC_par2: Path,
        raw1: Path,
        raw2: Path,
        ant_gain1: Path,
        ant_gain2: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        MSP preprocessing for ASAR L0 Alternating Polarization mode data


        input parameters:
          L0         (input) Level 0 Image Mode ASAR data file (ASA_IM_0P)
          INS        (input) ASAR instrument characterization file (ASA_INS_AX)
          SAR_par1   (output) MSP SAR sensor parameter file
          SAR_par2   (output) MSP SAR sensor parameter file
          PROC_par1  (output) MSP processing parameter file, (example p<orbit>.slc.par)
          PROC_par2  (output) MSP processing parameter file, (example p<orbit>.slc.par)
          raw1       (output) byte aligned 8-bit I/Q raw data
          raw2       (output) byte aligned 8-bit I/Q raw data
          ant_gain1  (input) antenna pattern file 1 (derived using program ASAR_XCA)
          ant_gain2  (input) antenna pattern file 2 (derived using program ASAR_XCA)
          loff       offset to first line to process (default = 0, enter - for default)
          nl         number of lines to process(default = to end of input, enter - for default)
          roff       offset to first range sample to process (default = 0, enter - for default)
          nr         number of range samples to process (default = to end of line, enter - for default)

         NOTE:  Possible AP modes are the following pairs  (HH/VV), (HH/HV), (VV/VH). Indices in the file names
         refer to the first and second polarization pairs (1/2). Filenames should be chosen chosen for consistency

        """
        if self.validate_inputs:
            self._validate_ASAR_AP_proc(
                L0, INS, SAR_par1, SAR_par2, PROC_par1, PROC_par2, raw1, raw2, ant_gain1, ant_gain2, loff, nl, roff, nr
            )
        if self.mock_outputs:
            self._mock_ASAR_AP_proc_outputs(
                L0, INS, SAR_par1, SAR_par2, PROC_par1, PROC_par2, raw1, raw2, ant_gain1, ant_gain2, loff, nl, roff, nr
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ASAR_AP_proc))
        return self._gamma_call("MSP", "ASAR_AP_proc", supplied_args)

    def _validate_JERS_proc_ASF(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "JERS_proc_ASF", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_JERS_proc_ASF_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def JERS_proc_ASF(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        JERS SAR processing parameters from ASF Level 0 (SKY) CEOS leader (2000)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR leader file (ASF Level 0 leader)
        PROC_par         (output) MSP processing parameter file, (example p<orbit>.slc.par)

        """
        if self.validate_inputs:
            self._validate_JERS_proc_ASF(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_JERS_proc_ASF_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.JERS_proc_ASF))
        return self._gamma_call("MSP", "JERS_proc_ASF", supplied_args)

    def _validate_rc_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[Any] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
        r_chirp: Optional[Path] = None,
        rfi_filt: Optional[Any] = None,
        rfi_thres: Optional[Any] = None,
    ) -> None:
        self._validate("rc_real", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("rc_real", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("rc_real", signal_data.exists(), f"signal_data path does not exist ({signal_data})")
        if r_chirp is not None:
            self._validate("rc_real", r_chirp.exists(), f"r_chirp path does not exist ({r_chirp})")

    def _mock_rc_real_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[Any] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
        r_chirp: Optional[Path] = None,
        rfi_filt: Optional[Any] = None,
        rfi_thres: Optional[Any] = None,
    ) -> None:
        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def rc_real(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        kaiser: Optional[Any] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
        r_chirp: Optional[Path] = None,
        rfi_filt: Optional[Any] = None,
        rfi_thres: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        SAR range compression for offset-video (SIR-C) raw data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          rc_data      (output) output range compressed data filename
          loff         number of lines offset (enter - for default)
          nl           number of lines to range compress (enter - for default)
          kaiser       range chirp Kaiser window parameter beta (enter - for default)
          nr_ext       near range swath extension in raw data samples (enter - for default)
          fr_ext       far range swath extension in raw data samples (enter - for default)
          r_chirp      (input) file containing user supplied range chirp samples (enter - for none)
          rfi_filt     RFI suppression filtering (0:OFF (default)  1:ON)
          rfi_thres    RFI detection threshold, nominal range 1.0 --> 1.5 (default= 1.100)

        """
        if self.validate_inputs:
            self._validate_rc_real(
                SAR_par, PROC_par, signal_data, rc_data, loff, nl, kaiser, nr_ext, fr_ext, r_chirp, rfi_filt, rfi_thres
            )
        if self.mock_outputs:
            self._mock_rc_real_outputs(
                SAR_par, PROC_par, signal_data, rc_data, loff, nl, kaiser, nr_ext, fr_ext, r_chirp, rfi_filt, rfi_thres
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rc_real))
        return self._gamma_call("MSP", "rc_real", supplied_args)

    def _validate_ERS_proc_CRISP(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_CRISP", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_CRISP_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_CRISP(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        ERS SAR processing  parameters, (CRISP, Singapore PAF)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par

        """
        if self.validate_inputs:
            self._validate_ERS_proc_CRISP(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_CRISP_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_CRISP))
        return self._gamma_call("MSP", "ERS_proc_CRISP", supplied_args)

    def _validate_prefilt(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        prefilt_out: Path,
        prefilt_dec: Any,
        filt_lm: Optional[Any] = None,
    ) -> None:
        self._validate("prefilt", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("prefilt", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("prefilt", rc_data.exists(), f"rc_data path does not exist ({rc_data})")

    def _mock_prefilt_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        prefilt_out: Path,
        prefilt_dec: Any,
        filt_lm: Optional[Any] = None,
    ) -> None:
        if prefilt_out is not None and str(prefilt_out) != "-":
            prefilt_out.touch()

    def prefilt(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        prefilt_out: Path,
        prefilt_dec: Any,
        filt_lm: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Prefilter for range-compressed SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          rc_data      (input) range compressed SAR data
          prefilt_out  (output) output prefiltered data filename
          prefilt_dec  prefilter decimation factor (enter - for default from PROC_par)
          filt_lm      filter length multiplier, FIR length = FIR_lm * prefilt_dec + 1 (enter - for default: 8)

        """
        if self.validate_inputs:
            self._validate_prefilt(SAR_par, PROC_par, rc_data, prefilt_out, prefilt_dec, filt_lm)
        if self.mock_outputs:
            self._mock_prefilt_outputs(SAR_par, PROC_par, rc_data, prefilt_out, prefilt_dec, filt_lm)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.prefilt))
        return self._gamma_call("MSP", "prefilt", supplied_args)

    def _validate_doppler(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
        order: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        self._validate("doppler", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("doppler", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("doppler", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_doppler_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
        order: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        if doppler is not None and str(doppler) != "-":
            doppler.touch()

    def doppler(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        doppler: Path,
        loff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flag: Optional[int] = None,
        namb: Optional[int] = None,
        order: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Doppler centroid estimation across track for IQ SAR data


        input parameters:
          SAR_par      (input) SAR sensor parameter file
          PROC_par     (input) processing parameter file
          signal_data  (input) input uncompressed IQ raw SAR data file
          doppler      (output) Doppler as a function of slant range
          loff         number of lines offset (enter - for default: PROC_par loff value)
          nsub         number of azimuth subapertures (enter - for default: 12)
          ambig_flag   Doppler ambiguity resolution flag
                         0: use unambiguous Doppler Ambiguity Resolver (DAR) estimate (default)
                         1: estimate Doppler ambiguity number from the Doppler slope
                         2: command line entry for the Doppler ambiguity number
          namb         user defined number of Doppler ambiguities to add to the Doppler function (enter - for default: 0)
          order        order of polynomial used to fit the range Doppler function 0-->3: (enter - for default: 1)
          pltflg       azimuth spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format

        """
        if self.validate_inputs:
            self._validate_doppler(SAR_par, PROC_par, signal_data, doppler, loff, nsub, ambig_flag, namb, order, pltflg)
        if self.mock_outputs:
            self._mock_doppler_outputs(
                SAR_par, PROC_par, signal_data, doppler, loff, nsub, ambig_flag, namb, order, pltflg
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.doppler))
        return self._gamma_call("MSP", "doppler", supplied_args)

    def _validate_DELFT_proc2(
        self,
        PROC_par: Path,
        DELFT_dir: Any,
        nstate: Optional[int] = None,
        interval: Optional[Any] = None,
        ODR: Optional[Any] = None,
    ) -> None:
        self._validate("DELFT_proc2", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")

    def _mock_DELFT_proc2_outputs(
        self,
        PROC_par: Path,
        DELFT_dir: Any,
        nstate: Optional[int] = None,
        interval: Optional[Any] = None,
        ODR: Optional[Any] = None,
    ) -> None:
        pass

    def DELFT_proc2(
        self,
        PROC_par: Path,
        DELFT_dir: Any,
        nstate: Optional[int] = None,
        interval: Optional[Any] = None,
        ODR: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Extract and interpolate Delft ERS-1, ERS-2, and ENVISAT state vectors for the MSP


        input parameters:
          PROC_par   (input) MSP processing parameter file
          DELFT_dir  directory containing Delft orbit arclist and ODR files for ERS-1, ERS-2 or ENVISAT
                       NOTE: enter . for current directory
          nstate     number of state vectors to generate (enter - for default (>= 11)
          interval   time interval between state vectors in the ISP image parameter file (s) (default: 10.0)
          ODR        ODR file to use (include path) rather than ODR file determined from the Delft orbit arclist

        """
        if self.validate_inputs:
            self._validate_DELFT_proc2(PROC_par, DELFT_dir, nstate, interval, ODR)
        if self.mock_outputs:
            self._mock_DELFT_proc2_outputs(PROC_par, DELFT_dir, nstate, interval, ODR)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.DELFT_proc2))
        return self._gamma_call("MSP", "DELFT_proc2", supplied_args)

    def _validate_ERS_proc_ESRIN_ACS(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_ESRIN_ACS", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_ESRIN_ACS_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ESRIN_ACS(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        SAR processing parameter input (ESRIN ACS processor)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par

        """
        if self.validate_inputs:
            self._validate_ERS_proc_ESRIN_ACS(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_ESRIN_ACS_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ESRIN_ACS))
        return self._gamma_call("MSP", "ERS_proc_ESRIN_ACS", supplied_args)

    def _validate_ERS_proc_ASF_91(self, CEOS_SAR_leader: Path, CEOS_trailer: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_ASF_91", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )
        self._validate("ERS_proc_ASF_91", CEOS_trailer.exists(), f"CEOS_trailer path does not exist ({CEOS_trailer})")

    def _mock_ERS_proc_ASF_91_outputs(self, CEOS_SAR_leader: Path, CEOS_trailer: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ASF_91(self, CEOS_SAR_leader: Path, CEOS_trailer: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        ERS SAR processing parameters from ASF CEOS format leader files (1991-1996)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR leader file (*.ldr)
        CEOS_trailer     (input) CEOS trailer file(*.tlr)
        PROC_par         (output) MSP processing parameter file, example pdate>.slc.par

        """
        if self.validate_inputs:
            self._validate_ERS_proc_ASF_91(CEOS_SAR_leader, CEOS_trailer, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_ASF_91_outputs(CEOS_SAR_leader, CEOS_trailer, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ASF_91))
        return self._gamma_call("MSP", "ERS_proc_ASF_91", supplied_args)

    def _validate_ORB_prop(
        self, PROC_par: Path, nstate: Optional[Any] = None, interval: Optional[Any] = None, extra: Optional[Any] = None
    ) -> None:
        self._validate("ORB_prop", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")

    def _mock_ORB_prop_outputs(
        self, PROC_par: Path, nstate: Optional[Any] = None, interval: Optional[Any] = None, extra: Optional[Any] = None
    ) -> None:
        pass

    def ORB_prop(
        self, PROC_par: Path, nstate: Optional[Any] = None, interval: Optional[Any] = None, extra: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        Calculate state vectors using orbit propagation and interpolation


        input parameters:
          PROC_par  (input) MSP processing parameter file
          nstate    number of state vectors to calculate for the MSP image parameter file,
                    (enter - for the default value determined from the duration of the state vectors)
          interval  time interval between state vectors (default: input state vector time interval)
          extra     extra time for state vector coverage at start and end of image (default= 30.0 s.)

        """
        if self.validate_inputs:
            self._validate_ORB_prop(PROC_par, nstate, interval, extra)
        if self.mock_outputs:
            self._mock_ORB_prop_outputs(PROC_par, nstate, interval, extra)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORB_prop))
        return self._gamma_call("MSP", "ORB_prop", supplied_args)

    def _validate_ERS_fix(self, ERS_PAF: Any, SAR_par: Path, PROC_par: Path, cc_flag: Any, output_file: Path) -> None:
        self._validate("ERS_fix", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("ERS_fix", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")

    def _mock_ERS_fix_outputs(
        self, ERS_PAF: Any, SAR_par: Path, PROC_par: Path, cc_flag: Any, output_file: Path
    ) -> None:
        if output_file is not None and str(output_file) != "-":
            output_file.touch()

    def ERS_fix(
        self, ERS_PAF: Any, SAR_par: Path, PROC_par: Path, cc_flag: Any, output_file: Path
    ) -> Tuple[int, str, str]:
        """

        ERS raw data missing line detection and range gate alignment


        input parameters:
          ERS_PAF        ERS Processing and Archive Facility (PAF), valid inputs:

             ENVISAT ACRES CCRS COLUMBIA DPAF ESA/ESRIN NASDA EIC CRISP UK/QinetiQ

          SAR_par        (input) MSP SAR sensor parameter file
          PROC_par       (input) MSP processing parameter file
          cc_flag        cross correlation detection of missing lines (default=0=OFF, 1=ON)
          raw data files (input) list of raw data file name(s) to check and concatenate
                         IMPORTANT: for ERS_PAF=ENVISAT use cat_raw to concatenate!
          output_file    (output) fixed raw data

        """
        if self.validate_inputs:
            self._validate_ERS_fix(ERS_PAF, SAR_par, PROC_par, cc_flag, output_file)
        if self.mock_outputs:
            self._mock_ERS_fix_outputs(ERS_PAF, SAR_par, PROC_par, cc_flag, output_file)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_fix))
        return self._gamma_call("MSP", "ERS_fix", supplied_args)

    def _validate_ERS_proc_CCRS(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_CCRS", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_CCRS_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_CCRS(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        ERS SAR processing processing parameters from CCRS PAF format CEOS leader


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file (contains no VMP header information)
        PROC_par         (output) MSP processing parameter file, (example p<date>.slc.par)

        """
        if self.validate_inputs:
            self._validate_ERS_proc_CCRS(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_CCRS_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_CCRS))
        return self._gamma_call("MSP", "ERS_proc_CCRS", supplied_args)

    def _validate_ptarg(
        self,
        SLC: Path,
        width: int,
        r_samp: Path,
        az_samp: Path,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        data_format: int,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        self._validate("ptarg", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("ptarg", r_samp.exists(), f"r_samp path does not exist ({r_samp})")
        self._validate("ptarg", az_samp.exists(), f"az_samp path does not exist ({az_samp})")

    def _mock_ptarg_outputs(
        self,
        SLC: Path,
        width: int,
        r_samp: Path,
        az_samp: Path,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        data_format: int,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        if ptr_image is not None and str(ptr_image) != "-":
            ptr_image.touch()
        if r_plot is not None and str(r_plot) != "-":
            r_plot.touch()
        if az_plot is not None and str(az_plot) != "-":
            az_plot.touch()

    def ptarg(
        self,
        SLC: Path,
        width: int,
        r_samp: Path,
        az_samp: Path,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        data_format: int,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Point target response analysis and interpolation


        input parameters:
          SLC          (input) SLC in fcomplex or scomplex format
          width        (input) SLC complex samples per line
          r_samp       (input) point target range sample number
          az_samp      (input) point target azimuth line number
          ptr_image    (output) oversampled point target image (fcomplex, 1024x1024 samples), with and without phase gradient
          r_plot       (output) range point target response plot data (text format)
          az_plot      (output) azimuth point target response plot data (text format)
          data_format  input data format flag (default:from MSP processing parameter file)
                         0: FCOMPLEX (pairs of 4-byte float)
                         1: SCOMPLEX (pairs of 2-byte short integer)
          win          maximum search window offset (samples) (integer, default: 1)
          pltflg       azimuth spectrum plotting flag:
                         0: none (default)
                         1: output plots in PNG format
                         2: screen output and PNG format plots

        """
        if self.validate_inputs:
            self._validate_ptarg(SLC, width, r_samp, az_samp, ptr_image, r_plot, az_plot, data_format, win, pltflg)
        if self.mock_outputs:
            self._mock_ptarg_outputs(SLC, width, r_samp, az_samp, ptr_image, r_plot, az_plot, data_format, win, pltflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ptarg))
        return self._gamma_call("MSP", "ptarg", supplied_args)

    def _validate_multi_GRD_SLC(
        self,
        SLC_PROC_par: Path,
        GRD_PROC_par: Path,
        SLC_image: Path,
        GRD_image: Path,
        rlks: int,
        azlks: int,
        interp_mode: Optional[int] = None,
        sample_spacing: Optional[Any] = None,
        gr_start: Optional[Any] = None,
        t_start: Optional[Any] = None,
        t_end: Optional[Any] = None,
    ) -> None:
        self._validate("multi_GRD_SLC", SLC_PROC_par.exists(), f"SLC_PROC_par path does not exist ({SLC_PROC_par})")
        self._validate("multi_GRD_SLC", SLC_image.exists(), f"SLC_image path does not exist ({SLC_image})")

    def _mock_multi_GRD_SLC_outputs(
        self,
        SLC_PROC_par: Path,
        GRD_PROC_par: Path,
        SLC_image: Path,
        GRD_image: Path,
        rlks: int,
        azlks: int,
        interp_mode: Optional[int] = None,
        sample_spacing: Optional[Any] = None,
        gr_start: Optional[Any] = None,
        t_start: Optional[Any] = None,
        t_end: Optional[Any] = None,
    ) -> None:
        if GRD_PROC_par is not None and str(GRD_PROC_par) != "-":
            GRD_PROC_par.touch()
        if GRD_image is not None and str(GRD_image) != "-":
            GRD_image.touch()

    def multi_GRD_SLC(
        self,
        SLC_PROC_par: Path,
        GRD_PROC_par: Path,
        SLC_image: Path,
        GRD_image: Path,
        rlks: int,
        azlks: int,
        interp_mode: Optional[int] = None,
        sample_spacing: Optional[Any] = None,
        gr_start: Optional[Any] = None,
        t_start: Optional[Any] = None,
        t_end: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Multi-look ground range (GRD) images from MSP SLC data


        input parameters:
          SLC_PROC_par    (input) MSP SLC processing parameter file
          GRD_PROC_par    (output) MSP ground range (GRD) multi-look image parameter file
          SLC_image       (input) SLC image file
          GRD_image       (output) ground-range projected image file (float)
          rlks            number of range looks (default: 1)
          azlks           number of azimuth looks (default: 1)
          interp_mode     interpolation mode:
                            0: nearest-neighbor
                            1: SINC interpolator (default)
          sample_spacing  multilook image sample spacing (m) (enter - for default: azimuth SLC spacing * azlks)
          gr_start        starting ground-range (meters), (enter - for default: start of data)
          t_start         starting time (s) for output, (enter - for default: start of data)
          t_end           ending time (s) for output, (enter -  for default: end of data)

        """
        if self.validate_inputs:
            self._validate_multi_GRD_SLC(
                SLC_PROC_par,
                GRD_PROC_par,
                SLC_image,
                GRD_image,
                rlks,
                azlks,
                interp_mode,
                sample_spacing,
                gr_start,
                t_start,
                t_end,
            )
        if self.mock_outputs:
            self._mock_multi_GRD_SLC_outputs(
                SLC_PROC_par,
                GRD_PROC_par,
                SLC_image,
                GRD_image,
                rlks,
                azlks,
                interp_mode,
                sample_spacing,
                gr_start,
                t_start,
                t_end,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_GRD_SLC))
        return self._gamma_call("MSP", "multi_GRD_SLC", supplied_args)

    def _validate_create_sar_par(self, SAR_par: Path) -> None:
        pass

    def _mock_create_sar_par_outputs(self, SAR_par: Path) -> None:
        if not SAR_par.exists():
            SAR_par.touch()

    def create_sar_par(self, SAR_par: Path) -> Tuple[int, str, str]:
        """

        Create SAR Sensor Parameter File


        input parameters:
          SAR_par  (input/output) MSP SAR sensor parameter file

        """
        if self.validate_inputs:
            self._validate_create_sar_par(SAR_par)
        if self.mock_outputs:
            self._mock_create_sar_par_outputs(SAR_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_sar_par))
        return self._gamma_call("MSP", "create_sar_par", supplied_args)

    def _validate_rspec_JERS(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        nr_samp: Optional[int] = None,
        nl_spec: Optional[int] = None,
        loff: Optional[Any] = None,
        nlines: Optional[int] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
    ) -> None:
        self._validate("rspec_JERS", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("rspec_JERS", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("rspec_JERS", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_rspec_JERS_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        nr_samp: Optional[int] = None,
        nl_spec: Optional[int] = None,
        loff: Optional[Any] = None,
        nlines: Optional[int] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
    ) -> None:
        if range_spec is not None and str(range_spec) != "-":
            range_spec.touch()

    def rspec_JERS(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        range_spec: Path,
        nr_samp: Optional[int] = None,
        nl_spec: Optional[int] = None,
        loff: Optional[Any] = None,
        nlines: Optional[int] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        JERS-1/PALSAR range spectrum estimation for RFI suppression


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          range_spec   (output) range spectra data file for RFI suppression
          nr_samp      number of range samples to process (enter - for default from PROC_par)
          nl_spec      number of lines to use to estimate spectrum (enter - for default=1024)
          loff         offset echoes for first line to process (enter - default from PROC_par)
          nlines       number of lines to process (enter - for default from PROC_par)
          nr_ext       near range swath extension in samples (default from PROC_par)
          fr_ext       far range swath extension in samples (default from PROC_par)

        """
        if self.validate_inputs:
            self._validate_rspec_JERS(
                SAR_par, PROC_par, signal_data, range_spec, nr_samp, nl_spec, loff, nlines, nr_ext, fr_ext
            )
        if self.mock_outputs:
            self._mock_rspec_JERS_outputs(
                SAR_par, PROC_par, signal_data, range_spec, nr_samp, nl_spec, loff, nlines, nr_ext, fr_ext
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rspec_JERS))
        return self._gamma_call("MSP", "rspec_JERS", supplied_args)

    def _validate_azsp_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        spectrum: Path,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flg: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        self._validate("azsp_IQ", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("azsp_IQ", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("azsp_IQ", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_azsp_IQ_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        spectrum: Path,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flg: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        if spectrum is not None and str(spectrum) != "-":
            spectrum.touch()

    def azsp_IQ(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        spectrum: Path,
        loff: Optional[int] = None,
        roff: Optional[int] = None,
        nsub: Optional[int] = None,
        ambig_flg: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Azimuth spectrum and Doppler centroid for IQ raw SAR data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) input raw I/Q format SAR data
          spectrum     (output) azimuth spectrum (text format)
          loff         number of lines offset to start of estimation window (default: 0)
          roff         range samples offset to center of estimation window (enter - for default: center_swath)
          nsub         number of azimuth subapertures for spectrum estimation (enter - for default: 24)
          ambig_flg    Doppler ambiguity resolution mode
                         0 = add multiples of PRF specified by the namb command line parameter
                         1 = use unambiguous Doppler centroid estimate from the PROC_par file (default)
          namb         number of multiples of the PRF to add to the ambiguous Doppler estimate (enter - for default: 0)
          pltflg       azimuth spectrum plotting flag:
                         0: none (default)
                         1: output plot in PNG format

        """
        if self.validate_inputs:
            self._validate_azsp_IQ(SAR_par, PROC_par, signal_data, spectrum, loff, roff, nsub, ambig_flg, namb, pltflg)
        if self.mock_outputs:
            self._mock_azsp_IQ_outputs(
                SAR_par, PROC_par, signal_data, spectrum, loff, roff, nsub, ambig_flg, namb, pltflg
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.azsp_IQ))
        return self._gamma_call("MSP", "azsp_IQ", supplied_args)

    def _validate_ERS_proc_ACRES(self, CEOS_SAR_leader: Path, PROC_par: Path, type: Optional[int] = None) -> None:
        self._validate(
            "ERS_proc_ACRES", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_ACRES_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path, type: Optional[int] = None) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ACRES(self, CEOS_SAR_leader: Path, PROC_par: Path, type: Optional[int] = None) -> Tuple[int, str, str]:
        """

        ERS SAR processing parameters (Australian ACRS PAF facility)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par
        type             raw data type:
                           0: CEOS leader format before 1998 (default)
                           1: CEOS leader format after 1998

        """
        if self.validate_inputs:
            self._validate_ERS_proc_ACRES(CEOS_SAR_leader, PROC_par, type)
        if self.mock_outputs:
            self._mock_ERS_proc_ACRES_outputs(CEOS_SAR_leader, PROC_par, type)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ACRES))
        return self._gamma_call("MSP", "ERS_proc_ACRES", supplied_args)

    def _validate_pre_rc_RSAT(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[Any] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[Any] = None,
        filt_lm: Optional[Any] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
    ) -> None:
        self._validate("pre_rc_RSAT", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("pre_rc_RSAT", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("pre_rc_RSAT", signal_data.exists(), f"signal_data path does not exist ({signal_data})")

    def _mock_pre_rc_RSAT_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[Any] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[Any] = None,
        filt_lm: Optional[Any] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
    ) -> None:
        if rc_data is not None and str(rc_data) != "-":
            rc_data.touch()

    def pre_rc_RSAT(
        self,
        SAR_par: Path,
        PROC_par: Path,
        signal_data: Path,
        rc_data: Path,
        prefilt_dec: Optional[Any] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        nr_samp: Optional[int] = None,
        kaiser: Optional[Any] = None,
        filt_lm: Optional[Any] = None,
        nr_ext: Optional[Any] = None,
        fr_ext: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Prefilter/SAR range compression for Radarsat-1 raw data


        input parameters:
          SAR_par      (input) MSP SAR sensor parameter file
          PROC_par     (input) MSP processing parameter file
          signal_data  (input) uncompressed raw SAR signal data filename
          rc_data      (output) range compressed data filename
          prefilt_dec  prefilter decimation factor (default from PROC_par)
          loff         number of lines offset (enter - for default=parameter file value)
          nl           number of lines filter/range compress (enter - for default=parameter file value)
          nr_samp      number of range samples (enter - for default from PROC_par)
          kaiser       range chirp Kaiser window parameter beta (default=2.120, -30 dB sidelobes)
          filt_lm      filter length multiplier, FIR length = FIR_lm * prefilt_dec + 1 (default=8)
          nr_ext       near range swath extension in samples (default from PROC_par)pixels
          fr_ext       far range swath extension in samples (default from PROC_par)

        """
        if self.validate_inputs:
            self._validate_pre_rc_RSAT(
                SAR_par, PROC_par, signal_data, rc_data, prefilt_dec, loff, nl, nr_samp, kaiser, filt_lm, nr_ext, fr_ext
            )
        if self.mock_outputs:
            self._mock_pre_rc_RSAT_outputs(
                SAR_par, PROC_par, signal_data, rc_data, prefilt_dec, loff, nl, nr_samp, kaiser, filt_lm, nr_ext, fr_ext
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pre_rc_RSAT))
        return self._gamma_call("MSP", "pre_rc_RSAT", supplied_args)

    def _validate_autof(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        autofocus: Path,
        SNR_min: Optional[Any] = None,
        prefilter: Optional[Any] = None,
        auto_az: Optional[Any] = None,
        az_offset: Optional[Any] = None,
        auto_bins: Optional[int] = None,
        dop_ambig: Optional[int] = None,
    ) -> None:
        self._validate("autof", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("autof", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("autof", rc_data.exists(), f"rc_data path does not exist ({rc_data})")

    def _mock_autof_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        autofocus: Path,
        SNR_min: Optional[Any] = None,
        prefilter: Optional[Any] = None,
        auto_az: Optional[Any] = None,
        az_offset: Optional[Any] = None,
        auto_bins: Optional[int] = None,
        dop_ambig: Optional[int] = None,
    ) -> None:
        if autofocus is not None and str(autofocus) != "-":
            autofocus.touch()

    def autof(
        self,
        SAR_par: Path,
        PROC_par: Path,
        rc_data: Path,
        autofocus: Path,
        SNR_min: Optional[Any] = None,
        prefilter: Optional[Any] = None,
        auto_az: Optional[Any] = None,
        az_offset: Optional[Any] = None,
        auto_bins: Optional[int] = None,
        dop_ambig: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Autofocus for range/Doppler processing


        input parameters:
          SAR_par    (input) MSP SAR sensor parameter file
          PROC_par   (input) MSP processing parameter file
          rc_data    (input) range compressed data file
          autofocus  (output) autofocus correlation function file (text format)
          SNR_min    minimum autofocus SNR to accept velocity estimate (default=5.0)
          prefilter  prefilter decimation factor (default from PROC_par)
          auto_az    autofocus azimuth correlation patch size (2**N, default = 2048)
          az_offset  offset in prefiltered lines from start of file (default=0)
          auto_bins  number of range bins to use for autofocus (2**N, default=1024)
          dop_ambig  Doppler ambiguity correction flag
                       0: Doppler centroid remains unchanged
                       1: Doppler centroid ambiguity corrected (default)

        """
        if self.validate_inputs:
            self._validate_autof(
                SAR_par, PROC_par, rc_data, autofocus, SNR_min, prefilter, auto_az, az_offset, auto_bins, dop_ambig
            )
        if self.mock_outputs:
            self._mock_autof_outputs(
                SAR_par, PROC_par, rc_data, autofocus, SNR_min, prefilter, auto_az, az_offset, auto_bins, dop_ambig
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.autof))
        return self._gamma_call("MSP", "autof", supplied_args)

    def _validate_cat_raw(
        self,
        RAW_list: Path,
        SAR_par: Path,
        PROC_par: Path,
        RAW_out: Path,
        fill: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        self._validate("cat_raw", RAW_list.exists(), f"RAW_list path does not exist ({RAW_list})")

    def _mock_cat_raw_outputs(
        self,
        RAW_list: Path,
        SAR_par: Path,
        PROC_par: Path,
        RAW_out: Path,
        fill: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()
        if RAW_out is not None and str(RAW_out) != "-":
            RAW_out.touch()

    def cat_raw(
        self,
        RAW_list: Path,
        SAR_par: Path,
        PROC_par: Path,
        RAW_out: Path,
        fill: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Concatenate a set of raw data files in MSP compatible format

        input parameters:
          RAW_list  (input) 3 column list of raw data and MSP sensor and processing parameter files:
                      1. SAR raw data file
                      2. MSP SAR sensor parameter file
                      3. MSP processing parameter file
          SAR_par   (output) MSP sensor parameter file for concatenated raw data set
          PROC_par  (output) MSP processing parameter file for concatenated raw data set
          RAW_out   (output) output concatenated raw data file
          fill      fill gaps between raw data files flag:
                      0: no
                      1: yes (default)
          loff      number of lines offset from start of file (enter - for default: 0)
          nl        number of lines to output (enter - for default: to end of data)

          NOTE: files must be in sequential order with the earliest file at the start of the RAW_list

        """
        if self.validate_inputs:
            self._validate_cat_raw(RAW_list, SAR_par, PROC_par, RAW_out, fill, loff, nl)
        if self.mock_outputs:
            self._mock_cat_raw_outputs(RAW_list, SAR_par, PROC_par, RAW_out, fill, loff, nl)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cat_raw))
        return self._gamma_call("MSP", "cat_raw", supplied_args)

    def _validate_ERS_proc_ASI(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        self._validate(
            "ERS_proc_ASI", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_ERS_proc_ASI_outputs(self, CEOS_SAR_leader: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def ERS_proc_ASI(self, CEOS_SAR_leader: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        ERS SAR processing parameters (ASI PAF)


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR raw data leader file
        PROC_par         (output) MSP processing parameter file, example p<date>.slc.par)

        """
        if self.validate_inputs:
            self._validate_ERS_proc_ASI(CEOS_SAR_leader, PROC_par)
        if self.mock_outputs:
            self._mock_ERS_proc_ASI_outputs(CEOS_SAR_leader, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ERS_proc_ASI))
        return self._gamma_call("MSP", "ERS_proc_ASI", supplied_args)

    def _validate_JERS_proc(self, CEOS_SAR_ldr: Path, PROC_par: Path) -> None:
        self._validate("JERS_proc", CEOS_SAR_ldr.exists(), f"CEOS_SAR_ldr path does not exist ({CEOS_SAR_ldr})")

    def _mock_JERS_proc_outputs(self, CEOS_SAR_ldr: Path, PROC_par: Path) -> None:
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def JERS_proc(self, CEOS_SAR_ldr: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        SAR processing  parameter input for JERS-1 data from NASDA


        input parameters:
          CEOS_SAR_ldr  (input) CEOS SAR leader file for JERS-1
          PROC_par      (output) MSP processing parameter file

        """
        if self.validate_inputs:
            self._validate_JERS_proc(CEOS_SAR_ldr, PROC_par)
        if self.mock_outputs:
            self._mock_JERS_proc_outputs(CEOS_SAR_ldr, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.JERS_proc))
        return self._gamma_call("MSP", "JERS_proc", supplied_args)

    def _validate_PALSAR_antpat(
        self,
        SAR_par: Path,
        PROC_par: Path,
        PAL_ANT: Path,
        ant_file: Path,
        Beam_ID: Optional[Path],
        TX_POL: Optional[int],
        RX_POL: Optional[int],
        Beam: Any,
    ) -> None:
        self._validate("PALSAR_antpat", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("PALSAR_antpat", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")
        self._validate("PALSAR_antpat", PAL_ANT.exists(), f"PAL_ANT path does not exist ({PAL_ANT})")
        if Beam_ID is not None:
            self._validate("PALSAR_antpat", Beam_ID.exists(), f"Beam_ID path does not exist ({Beam_ID})")

    def _mock_PALSAR_antpat_outputs(
        self,
        SAR_par: Path,
        PROC_par: Path,
        PAL_ANT: Path,
        ant_file: Path,
        Beam_ID: Optional[Path],
        TX_POL: Optional[int],
        RX_POL: Optional[int],
        Beam: Any,
    ) -> None:
        if ant_file is not None and str(ant_file) != "-":
            ant_file.touch()

    def PALSAR_antpat(
        self,
        SAR_par: Path,
        PROC_par: Path,
        PAL_ANT: Path,
        ant_file: Path,
        Beam_ID: Optional[Path],
        TX_POL: Optional[int],
        RX_POL: Optional[int],
        Beam: Any,
    ) -> Tuple[int, str, str]:
        """

        Extract specified antenna pattern from a PALSAR JAXA antenna pattern file


        input parameters:
          SAR_par     (input) MSP SAR sensor parameter file (enter - for none)
          PROC_par    (input) MSP processing parameter file (enter - for none)
          PALSAR_ANT  (input) PALSAR antenna pattern file provided by JAXA (e.g. palsar_ant_20061024.dat)
          ant_file    (output) MSP format antenna pattern file (text format)
          Beam_ID     (input) PALSAR mode beam ID, if not provided the program will determine the beam from the SAR_par look angle parameter
          TX_POL      transmit polarization: (required if PROC_par not specified)
                        0: H (default)
                        1: V
          RX_POL      receive polarization: (required if PROC_par not specified)
                        0: H (default)
                        1: V

        Beam IDs for different center-beam look angles and PALSAR modes:

        Beam ID    look angle (deg.)   Mode
        =======================================
           0              9.9          FBS
           1             14.1          FBS
           2             17.9          FBS
           3             21.2          FBS
           4             25.8          FBS
           5             28.7          FBS
           6             30.8          FBS
           7             34.0          FBS
           8             36.7          FBS
           9             38.5          FBS
           10            41.3          FBS
           11            43.4          FBS
           12            45.1          FBS
           13            46.6          FBS
           14            47.7          FBS
           15            49.0          FBS
           16            50.0          FBS
           17            50.6          FBS
           18            19.9          WB1, WB2 Beam 1
           19            25.8          WB1, WB2 Beam 2
           20            30.3          WB1, WB2 Beam 3
           21            33.6          WB1, WB2 Beam 4
           22            36.0          WB1, WB2 Beam 5
        """
        if self.validate_inputs:
            self._validate_PALSAR_antpat(SAR_par, PROC_par, PAL_ANT, ant_file, Beam_ID, TX_POL, RX_POL, Beam)
        if self.mock_outputs:
            self._mock_PALSAR_antpat_outputs(SAR_par, PROC_par, PAL_ANT, ant_file, Beam_ID, TX_POL, RX_POL, Beam)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PALSAR_antpat))
        return self._gamma_call("MSP", "PALSAR_antpat", supplied_args)

    def _validate_create_proc_par(self, SAR_par: Path, PROC_par: Path) -> None:
        self._validate("create_proc_par", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")

    def _mock_create_proc_par_outputs(self, SAR_par: Path, PROC_par: Path) -> None:
        if not PROC_par.exists():
            PROC_par.touch()

    def create_proc_par(self, SAR_par: Path, PROC_par: Path) -> Tuple[int, str, str]:
        """

        Create MSP processing parameter file


        input parameters:
          SAR_par   (input) MSP SAR sensor parameter file
          PROC_par  (input/output) MSP processing parameter file

        """
        if self.validate_inputs:
            self._validate_create_proc_par(SAR_par, PROC_par)
        if self.mock_outputs:
            self._mock_create_proc_par_outputs(SAR_par, PROC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_proc_par))
        return self._gamma_call("MSP", "create_proc_par", supplied_args)

    def _validate_SIRC_proc(
        self, CEOS_SAR_leader: Path, SAR_par: Path, PROC_par: Path, UTC_or_MET: Optional[Any] = None
    ) -> None:
        self._validate(
            "SIRC_proc", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_SIRC_proc_outputs(
        self, CEOS_SAR_leader: Path, SAR_par: Path, PROC_par: Path, UTC_or_MET: Optional[Any] = None
    ) -> None:
        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()

    def SIRC_proc(
        self, CEOS_SAR_leader: Path, SAR_par: Path, PROC_par: Path, UTC_or_MET: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        SIR-C MSP processing parameter extraction from CEOS leader


        input parameters:
          CEOS_SAR_leader  (input) CEOS SAR raw data leader file
          SAR_par          (output) MSP sensor parameter file, (example SIRC.par)
          PROC_par         (output) MSP processing parameter file, (example p<orbit>.slc.par)
          UTC/MET          raw data time reference: 0=UTC, 1=Mission Elapsed Time, default=UTC

        """
        if self.validate_inputs:
            self._validate_SIRC_proc(CEOS_SAR_leader, SAR_par, PROC_par, UTC_or_MET)
        if self.mock_outputs:
            self._mock_SIRC_proc_outputs(CEOS_SAR_leader, SAR_par, PROC_par, UTC_or_MET)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SIRC_proc))
        return self._gamma_call("MSP", "SIRC_proc", supplied_args)

    def _validate_ASAR_IM_proc(
        self,
        L0: Path,
        INS: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        ant_gain: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        self._validate("ASAR_IM_proc", L0.exists(), f"L0 path does not exist ({L0})")
        self._validate("ASAR_IM_proc", INS.exists(), f"INS path does not exist ({INS})")
        self._validate("ASAR_IM_proc", ant_gain.exists(), f"ant_gain path does not exist ({ant_gain})")

    def _mock_ASAR_IM_proc_outputs(
        self,
        L0: Path,
        INS: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        ant_gain: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        if SAR_par is not None and str(SAR_par) != "-":
            SAR_par.touch()
        if PROC_par is not None and str(PROC_par) != "-":
            PROC_par.touch()
        if raw is not None and str(raw) != "-":
            raw.touch()

    def ASAR_IM_proc(
        self,
        L0: Path,
        INS: Path,
        SAR_par: Path,
        PROC_par: Path,
        raw: Path,
        ant_gain: Path,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        MSP preprocessing for ASAR L0 Image mode data


        input parameters:
          L0       (input) Level 0 Image Mode ASAR data file (ASA_IM_0P)
          INS      (input) ASAR instrument characterization file (ASA_INS_AX)
          SAR_par  (output) MSP SAR sensor parameter file
          PROC_par (output) MSP processing parameter file, (example p<orbit>.slc.par)
          raw      (output) byte aligned 8-bit I/Q raw data
          ant_gain (input) antenna pattern file name (derived using program ASAR_XCA)
          loff     number of lines offset from start of raw data file (enter - for default: 0)
          nl       number of lines to extract (enter - for default: to end of input raw data

        """
        if self.validate_inputs:
            self._validate_ASAR_IM_proc(L0, INS, SAR_par, PROC_par, raw, ant_gain, loff, nl)
        if self.mock_outputs:
            self._mock_ASAR_IM_proc_outputs(L0, INS, SAR_par, PROC_par, raw, ant_gain, loff, nl)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ASAR_IM_proc))
        return self._gamma_call("MSP", "ASAR_IM_proc", supplied_args)

    def _validate_rasdt_pwr(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> None:
        self._validate("rasdt_pwr", data.exists(), f"data path does not exist ({data})")
        self._validate("rasdt_pwr", pwr.exists(), f"pwr path does not exist ({pwr})")

    def _mock_rasdt_pwr_outputs(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rasdt_pwr(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasdt_pwr
        Calculate a raster image of data (FLOAT) with linear scaling using a specified colormap combined with power-law scaled intensity (8 or 24-bits/pixel)


        input parameters:
          data    (input) data in FLOAT format (deformation, height, unwrapped phase, correlation...)
          pwr     (input) intensity image coregistered with data (enter - for none, FLOAT or raster image)
          width   number of samples/row of data and pwr
          start   starting line of data and pwr (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          min     minimum data value (enter - for default:  0.0000e+00)
          max     maximum data value (enter - for default:  1.0000e+00)
          cflg    cyclic data display flag:
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max - min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          scale   intensity display scale factor (enter - for default: 1.0)
          exp     intensity display exponent (enter - for default: 0.35)
          bits    bits/pixel:
                    8:  8-bit indexed color map (default)
                    24: RGB 8-bits/color
        """
        if self.validate_inputs:
            self._validate_rasdt_pwr(
                data, pwr, width, start, nlines, pixavx, pixavy, min, max, cflg, cmap, rasf, scale, exp, bits
            )
        if self.mock_outputs:
            self._mock_rasdt_pwr_outputs(
                data, pwr, width, start, nlines, pixavx, pixavy, min, max, cflg, cmap, rasf, scale, exp, bits
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasdt_pwr))
        return self._gamma_call("DISP", "rasdt_pwr", supplied_args)

    def _validate_rascpx(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        self._validate("rascpx", data.exists(), f"data path does not exist ({data})")

    def _mock_rascpx_outputs(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rascpx(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rascpx
        Calculate a raster image of data (FCOMPLEX, SCOMPLEX) using linear, logarithmic, or power-law scaling using a specified colormap


        input parameters:
          data   (input) input data (FCOMPLEX, SCOMPLEX)
          width  number of samples/row of data
          mode   display mode (enter - for default: power-law scaling)
                   0: intensity with power-law scaling (scale and exp), default colormap: gray.cm, (default)
                   1: intensity with logarithmic scaling min -> max (dB), default colormap: gray.cm
                   2: real component, scaling min -> max, default colormap: hls.cm
                   3: imaginary component, scaling min -> max, default colormap: hls.cm
                   4: phase, scaling min -> max, default colormap: default colormap rmg.cm
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          min     data display minimum (enter - for default mode 0: not used, mode 1: -10 dB, modes 2,3: -1.0, mode 4: -PI)
          max     data display maximum (enter - for default mode 0: not used, mode 1: +16 dB, modes 2,3: +1.0, mode 4: +PI)
          cmap    colormap file (enter - for default)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          scale   power-law scale factor, (enter - for default: 1.0) (mode 0 only)
          exp     power-law exponent (enter - for default: 0.35) (mode 0 only)
          dtype   input data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
          sc_ave  intensity to use to calculate image scaling (modes 0 and 1)
                  (enter- for default: determined from the input data file)

        """
        if self.validate_inputs:
            self._validate_rascpx(
                data, width, mode, start, nlines, pixavx, pixavy, min, max, cmap, rasf, scale, exp, dtype, sc_ave
            )
        if self.mock_outputs:
            self._mock_rascpx_outputs(
                data, width, mode, start, nlines, pixavx, pixavy, min, max, cmap, rasf, scale, exp, dtype, sc_ave
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rascpx))
        return self._gamma_call("DISP", "rascpx", supplied_args)

    def _validate_gcp_ras(self, ras: Path, GCP: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None) -> None:
        self._validate("gcp_ras", ras.exists(), f"ras path does not exist ({ras})")

    def _mock_gcp_ras_outputs(
        self, ras: Path, GCP: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> None:
        if GCP is not None and str(GCP) != "-":
            GCP.touch()

    def gcp_ras(
        self, ras: Path, GCP: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        DISP gcp_ras: select GCPs using a raster format reference image


        input parameters:
          ras     (input) image, SUN raster: *.ras, BMP: *.bmp, TIFF: *.tif
          GCP     (output) GCP data file (text format)
          mag     zoom magnification factor (enter - for default: 3)
          win_sz  zoom window size before magnification (enter - for default: 132)

        """
        if self.validate_inputs:
            self._validate_gcp_ras(ras, GCP, mag, win_sz)
        if self.mock_outputs:
            self._mock_gcp_ras_outputs(ras, GCP, mag, win_sz)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gcp_ras))
        return self._gamma_call("DISP", "gcp_ras", supplied_args)

    def _validate_cpx_math(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c_re: Optional[Any] = None,
        c_im: Optional[Any] = None,
        zflg: Optional[int] = None,
        rflg: Optional[Any] = None,
    ) -> None:
        self._validate("cpx_math", d1.exists(), f"d1 path does not exist ({d1})")
        self._validate("cpx_math", d2.exists(), f"d2 path does not exist ({d2})")

    def _mock_cpx_math_outputs(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c_re: Optional[Any] = None,
        c_im: Optional[Any] = None,
        zflg: Optional[int] = None,
        rflg: Optional[Any] = None,
    ) -> None:
        if d_out is not None and str(d_out) != "-":
            d_out.touch()

    def cpx_math(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c_re: Optional[Any] = None,
        c_im: Optional[Any] = None,
        zflg: Optional[int] = None,
        rflg: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/cpx_math
        Perform complex arithmetic operations on data files (FCOMPLEX format)


        input parameters:
          d1     (input) data file 1 (FCOMPLEX)
          d2     (input) data file 2 (FCOMPLEX) (enter - for none)
                 NOTE: if no input file is provided, d2 values are given by the c_re and c_im parameters
          d_out  (output) output of math operation on d1 and d2 (FCOMPLEX)
          width  number of samples/line
          mode   math operation to perform on data:
                   0:  addition, d1 + d2
                   1:  subtraction, d1 - d2
                   2:  multiplication, d1 * d2
                   3:  division, d1/d2
                   4:  conjugate, conj(d1)
                   5:  conjugate multiplication, d1*conj(d2)
          roff   range pixel offset to center of the reference region (enter - for default: no reference correction)
          loff   line offset to center of the reference region (enter - for default: no reference correction)
          nr     number of range pixels to average in the reference region (enter - for default: 13)
          nl     number of lines average in the reference region (enter - for default: 13)
          c_re   constant real value (enter - for default: 1.18e-38 for addition and subtraction, 1.0 for multiplication and division)
          c_im   constant imaginary value (enter - for default: 0.0)
          zflg   zero data flag (enter - for default: 0)
                   0: values of 0.0 in d1 or d2 are considered as no-data and the output is set to 0.0 (default)
                   1: values of 0.0 are considered as valid data
          rflg   reference region normalization flag (enter - for default: 0)
                   av1: average of d1 reference region
                   av2: average of d2 reference region

                   rflg = 0:
                      addition        (d1 - av1) + (d2 - av2)
                      subtraction     (d1 - av1) - (d2 - av2)
                      multiplication  (d1/av1) * (d2/av2)
                      conjugat mult.  (d1/av1) * conj(d2/av2)
                      division        (d1/av1) / (d2/av2)

                   rflg = 1:
                      addition        d1/exp(j*arg(av1)) + d2/exp(j*arg(av2))
                      subtraction     d1/exp(j*arg(av1)) - d2/exp(j*arg(av2))
                      multiplication  d1/exp(j*arg(av1)) * d2/exp(j*arg(av2))
                      conjugate mult. d1/exp(j*arg(av1)) * conj(d2/exp(j*arg(av2)))
                      division        d1/exp(j*arg(av1)) / d2/exp(j*arg(av2))

        """
        if self.validate_inputs:
            self._validate_cpx_math(d1, d2, d_out, width, mode, roff, loff, nr, nl, c_re, c_im, zflg, rflg)
        if self.mock_outputs:
            self._mock_cpx_math_outputs(d1, d2, d_out, width, mode, roff, loff, nr, nl, c_re, c_im, zflg, rflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cpx_math))
        return self._gamma_call("DISP", "cpx_math", supplied_args)

    def _validate_disflag(
        self, flag: Path, width: int, start: Optional[Any] = None, nlines: Optional[int] = None
    ) -> None:
        self._validate("disflag", flag.exists(), f"flag path does not exist ({flag})")

    def _mock_disflag_outputs(
        self, flag: Path, width: int, start: Optional[Any] = None, nlines: Optional[int] = None
    ) -> None:
        pass

    def disflag(
        self, flag: Path, width: int, start: Optional[Any] = None, nlines: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        DISP disflag: display phase unwrapping flag file


        input parameters:
          flag    (input) phase unwrapping flag file (unsigned char)
          width   samples per row of flag file
          start   starting line of flag file (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)

        """
        if self.validate_inputs:
            self._validate_disflag(flag, width, start, nlines)
        if self.mock_outputs:
            self._mock_disflag_outputs(flag, width, start, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disflag))
        return self._gamma_call("DISP", "disflag", supplied_args)

    def _validate_set_value(
        self, PAR_in: Path, PAR_out: Path, keyword: Any, value: Any, new_key: Optional[int] = None
    ) -> None:
        self._validate("set_value", PAR_in.exists(), f"PAR_in path does not exist ({PAR_in})")

    def _mock_set_value_outputs(
        self, PAR_in: Path, PAR_out: Path, keyword: Any, value: Any, new_key: Optional[int] = None
    ) -> None:
        if PAR_out is not None and str(PAR_out) != "-":
            PAR_out.touch()

    def set_value(
        self, PAR_in: Path, PAR_out: Path, keyword: Any, value: Any, new_key: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Update keyword:value in text parameter files


        input parameters:
          PAR_in   (input) keyword:value based parameter file
          PAR_out  (output) keyword:value based parameter file (can be the same file as PAR_in)
          keyword  search keyword of keyword:value pair
          value    new value (note: delimit value with double quotes if it contains spaces or punctuation)
          new_key  options for new keyword_value pair
                     0: update value of existing keyword:value pair (default)
                     1: append new keyword:value pair to PAR_out

        """
        if self.validate_inputs:
            self._validate_set_value(PAR_in, PAR_out, keyword, value, new_key)
        if self.mock_outputs:
            self._mock_set_value_outputs(PAR_in, PAR_out, keyword, value, new_key)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.set_value))
        return self._gamma_call("DISP", "set_value", supplied_args)

    def _validate_cpx_to_real(self, cpx: Path, real: Path, width: int, mode: int) -> None:
        self._validate("cpx_to_real", cpx.exists(), f"cpx path does not exist ({cpx})")

    def _mock_cpx_to_real_outputs(self, cpx: Path, real: Path, width: int, mode: int) -> None:
        if real is not None and str(real) != "-":
            real.touch()

    def cpx_to_real(self, cpx: Path, real: Path, width: int, mode: int) -> Tuple[int, str, str]:
        """

        Display Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/cpx_to_real.c
        Calculate real part, imaginary part, intensity, magnitude, or phase of FCOMPLEX data

        input parameters:
          cpx    (input) complex-valued data (FCOMPLEX)
          real   (output) real-valued data (FLOAT)
          width  samples per line of input data
          mode   math operation to perform on data:
                   0: real part
                   1: imaginary part
                   2: intensity (re*re + im*im)
                   3: magnitude (sqrt(re*re + im*im))
                   4: phase (atan2(im, re))

        """
        if self.validate_inputs:
            self._validate_cpx_to_real(cpx, real, width, mode)
        if self.mock_outputs:
            self._mock_cpx_to_real_outputs(cpx, real, width, mode)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cpx_to_real))
        return self._gamma_call("DISP", "cpx_to_real", supplied_args)

    def _validate_dis2_dB(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min_dB: Optional[Any] = None,
        max_dB: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        self._validate("dis2_dB", data1.exists(), f"data1 path does not exist ({data1})")
        self._validate("dis2_dB", data2.exists(), f"data2 path does not exist ({data2})")

    def _mock_dis2_dB_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min_dB: Optional[Any] = None,
        max_dB: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        pass

    def dis2_dB(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min_dB: Optional[Any] = None,
        max_dB: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2_dB
        Display of 2 intensity images (FLOAT or UNSIGNED SHORT) with logarithmic scaling using a specified colormap


        input parameters:
          data1    (input) data1 (FLOAT, UNSIGNED SHORT)
          data2    (input) data2 (FLOAT, UNSIGNED SHORT, same data type as data1
          width1   number of samples/row of data1
          width2   number of samples/row of data2
          start    starting line of data (enter - for default: 1)
          nlines   number of lines to display (enter - or 0 for default: to end of file)
          xoff     x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff     y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          min_dB   minimum data value (enter - for default: -1.0000e+01)
          max_dB   maximum data value (enter - for default:  1.0000e+01)
          cmap     colormap file (enter - for default: gray.cm)
                   NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                         colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype    data type (enter - for default)
                     0: FLOAT (default)
                     1: UNSIGNED SHORT
          sc_abs   absolute scaling flag (enter - for default)
                     0: scaling relative to average (min_dB + av_dB) -> (max_dB + av_dB) (default)
                        NOTE: av_dB is the average image intensity dB
                     1: absolute scaling range: min_dB -> max_dB

        """
        if self.validate_inputs:
            self._validate_dis2_dB(
                data1, data2, width1, width2, start, nlines, xoff, yoff, min_dB, max_dB, cmap, dtype, sc_abs
            )
        if self.mock_outputs:
            self._mock_dis2_dB_outputs(
                data1, data2, width1, width2, start, nlines, xoff, yoff, min_dB, max_dB, cmap, dtype, sc_abs
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2_dB))
        return self._gamma_call("DISP", "dis2_dB", supplied_args)

    def _validate_disgbyte(
        self,
        image: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        cmap: Optional[Path] = None,
    ) -> None:
        self._validate("disgbyte", image.exists(), f"image path does not exist ({image})")

    def _mock_disgbyte_outputs(
        self,
        image: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        cmap: Optional[Path] = None,
    ) -> None:
        pass

    def disgbyte(
        self,
        image: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        cmap: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP disgbyte: display data in GBYTE logarithmic scaled format


        input parameters:
          image   (input) GBYTE format data (1 byte/sample)
          width   samples per row of image
          start   starting line of image1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          scale   display scale factor (enter - for default: 1.0)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png

        """
        if self.validate_inputs:
            self._validate_disgbyte(image, width, start, nlines, scale, cmap)
        if self.mock_outputs:
            self._mock_disgbyte_outputs(image, width, start, nlines, scale, cmap)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disgbyte))
        return self._gamma_call("DISP", "disgbyte", supplied_args)

    def _validate_dis_dB(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min_dB: Optional[Any] = None,
        max_dB: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        self._validate("dis_dB", data.exists(), f"data path does not exist ({data})")

    def _mock_dis_dB_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min_dB: Optional[Any] = None,
        max_dB: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        pass

    def dis_dB(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min_dB: Optional[Any] = None,
        max_dB: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis_dB
        Display of intensity data (FLOAT or UNSIGNED SHORT) using logarithmic scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT or UNSIGNED SHORT)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          min_dB  data display minimum (enter - for default: -10.00 dB)
          max_dB  data display maximum (enter - for default: 10.00 dB)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT
          sc_abs  absolute scaling flag (enter - for default)
                    0: scaling relative to average (min_dB + av_dB) -> (max_dB + av_dB) (default)
                       NOTE: av_dB is the average image intensity dB
                    1: absolute scaling range: min_dB -> max_dB

        """
        if self.validate_inputs:
            self._validate_dis_dB(data, width, start, nlines, min_dB, max_dB, cmap, dtype, sc_abs)
        if self.mock_outputs:
            self._mock_dis_dB_outputs(data, width, start, nlines, min_dB, max_dB, cmap, dtype, sc_abs)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis_dB))
        return self._gamma_call("DISP", "dis_dB", supplied_args)

    def _validate_svg_map(
        self,
        image: Path,
        dem_par: Path,
        svg: Path,
        font: Optional[Any],
        fsize: Optional[Any],
        color: Optional[Any],
        gcolor: Optional[Any],
        majorx: Optional[Any],
        majory: Optional[Any],
        minorx: Optional[Any],
        minory: Optional[Any],
        thick: Optional[int],
        grid: Optional[Any],
        gopac: Any,
    ) -> None:
        self._validate("svg_map", image.exists(), f"image path does not exist ({image})")
        self._validate("svg_map", dem_par.exists(), f"dem_par path does not exist ({dem_par})")

    def _mock_svg_map_outputs(
        self,
        image: Path,
        dem_par: Path,
        svg: Path,
        font: Optional[Any],
        fsize: Optional[Any],
        color: Optional[Any],
        gcolor: Optional[Any],
        majorx: Optional[Any],
        majory: Optional[Any],
        minorx: Optional[Any],
        minory: Optional[Any],
        thick: Optional[int],
        grid: Optional[Any],
        gopac: Any,
    ) -> None:
        if svg is not None and str(svg) != "-":
            svg.touch()

    def svg_map(
        self,
        image: Path,
        dem_par: Path,
        svg: Path,
        font: Optional[Any],
        fsize: Optional[Any],
        color: Optional[Any],
        gcolor: Optional[Any],
        majorx: Optional[Any],
        majory: Optional[Any],
        minorx: Optional[Any],
        minory: Optional[Any],
        thick: Optional[int],
        grid: Optional[Any],
        gopac: Any,
    ) -> Tuple[int, str, str]:
        """

        DISP svg_map: SVG map generator


        input parameters:
          image   (input) URL of background image in png or jpg format (- for no background image)
          dem_par (input) corresponding dem_par file
          svg     (output) SVG output file
          font    name of labelling font (default = sans-serif)
          fsize   font size (default = 14)
          color   color of ticks and labels (default = black)
          gcolor  color of grid (default = black)
          majorx  major x-ticks in dem_par coordinates (default = 1)
          majory  major y-ticks in dem_par coordinates (default = 1)
          minorx  minor x-ticks in dem_par coordinates (default = 0.1)
          minory  minor y-ticks in dem_par coordinates (default = 0.1)
          thick   tick and gridline thickness in pixels (default = 1)
          grid    1 = draw grid, 0 = no grid (default = 0)
          gopac   grid opacity, 0.0 (fully transparent) to 1.0 (fully opaque), default=1.0
          gdash   grid dash size in px (default = 0 = no dashes)

        """
        if self.validate_inputs:
            self._validate_svg_map(
                image, dem_par, svg, font, fsize, color, gcolor, majorx, majory, minorx, minory, thick, grid, gopac
            )
        if self.mock_outputs:
            self._mock_svg_map_outputs(
                image, dem_par, svg, font, fsize, color, gcolor, majorx, majory, minorx, minory, thick, grid, gopac
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.svg_map))
        return self._gamma_call("DISP", "svg_map", supplied_args)

    def _validate_gbyte2float(self, infile: Path, outfile: Path) -> None:
        self._validate("gbyte2float", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_gbyte2float_outputs(self, infile: Path, outfile: Path) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def gbyte2float(self, infile: Path, outfile: Path) -> Tuple[int, str, str]:
        """

        Convert GBYTE logarithmic scaled format data (1 byte/value) to FLOAT format (4 bytes/value)***


        input parameters:
          infile   (input) GBYTE logarithmic scaled format data (1 byte/sample)
          outfile  (output) FLOAT format data (4 bytes/sample)
        """
        if self.validate_inputs:
            self._validate_gbyte2float(infile, outfile)
        if self.mock_outputs:
            self._mock_gbyte2float_outputs(infile, outfile)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gbyte2float))
        return self._gamma_call("DISP", "gbyte2float", supplied_args)

    def _validate_real_to_cpx(self, data1: Path, cpx: Path, width: int, type: int) -> None:
        self._validate("real_to_cpx", data1.exists(), f"data1 path does not exist ({data1})")
        self._validate("real_to_cpx", cpx.exists(), f"cpx path does not exist ({cpx})")

    def _mock_real_to_cpx_outputs(self, data1: Path, cpx: Path, width: int, type: int) -> None:
        pass

    def real_to_cpx(self, data1: Path, cpx: Path, width: int, type: int) -> Tuple[int, str, str]:
        """

        DISPLAY Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/real_to_cpx
        Generate FCOMPLEX data from real and imaginary or magnitude and phase components

        input parameters:
          data1  (input) input data file data1 (enter - for none, FLOAT)
          data2  (input) input data file data2 (enter - for none, FLOAT)
          cpx    (output) output data file (FCOMPLEX)
          width  samples per line of data files
          type   input data type:
                   0: data1: real, set to 0.0 if not specified
                      data2: imaginary, set to 0.0 if not specified
                   1: data1: magnitude, set to 1.0 if not specified
                      data2: phase (radians), set to 0.0 if not specified

        """
        if self.validate_inputs:
            self._validate_real_to_cpx(data1, cpx, width, type)
        if self.mock_outputs:
            self._mock_real_to_cpx_outputs(data1, cpx, width, type)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.real_to_cpx))
        return self._gamma_call("DISP", "real_to_cpx", supplied_args)

    def _validate_rasmph_pwr(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> None:
        self._validate("rasmph_pwr", data.exists(), f"data path does not exist ({data})")
        self._validate("rasmph_pwr", pwr.exists(), f"pwr path does not exist ({pwr})")

    def _mock_rasmph_pwr_outputs(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rasmph_pwr(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasmph_pwr
        Calculate a raster image of FCOMPLEX data phase using a specified colormap combined with power-law scaled intensity (8 or 24-bits/pixel)


        input parameters:
          data    (input) input data FCOMPLEX format
          pwr     (input) intensity image coregistered with data (enter - for none, FLOAT or raster image)
          width   number of samples/row of data and pwr
          start   starting line of data and pwr (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          scale   intensity display scale factor (enter - for default: 1.0)
          exp     intensity display exponent (enter - for default: 0.35)
          bits    bits/pixel:
                    8:  8-bit indexed color map (default)
                    24: RGB 8-bits/color

        """
        if self.validate_inputs:
            self._validate_rasmph_pwr(data, pwr, width, start, nlines, pixavx, pixavy, cmap, rasf, scale, exp, bits)
        if self.mock_outputs:
            self._mock_rasmph_pwr_outputs(data, pwr, width, start, nlines, pixavx, pixavy, cmap, rasf, scale, exp, bits)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasmph_pwr))
        return self._gamma_call("DISP", "rasmph_pwr", supplied_args)

    def _validate_data2geotiff(
        self,
        DEM_par: Path,
        data: Path,
        type: int,
        GeoTIFF: Path,
        no_data: Optional[Any] = None,
        COGflg: Optional[int] = None,
    ) -> None:
        self._validate("data2geotiff", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("data2geotiff", data.exists(), f"data path does not exist ({data})")

    def _mock_data2geotiff_outputs(
        self,
        DEM_par: Path,
        data: Path,
        type: int,
        GeoTIFF: Path,
        no_data: Optional[Any] = None,
        COGflg: Optional[int] = None,
    ) -> None:
        if GeoTIFF is not None and str(GeoTIFF) != "-":
            GeoTIFF.touch()

    def data2geotiff(
        self,
        DEM_par: Path,
        data: Path,
        type: int,
        GeoTIFF: Path,
        no_data: Optional[Any] = None,
        COGflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP data2geotiff: convert geocoded data with DEM parameter file to GeoTIFF format


        input parameters:
          DEM_par  (input) DIFF/GEO DEM parameter file
          data     (input) data file
          type     data type:
                     0: RASTER 8 or 24 bit uncompressed raster image, SUN (*.ras), BMP:(*.bmp), or TIFF: (*.tif)
                     1: SHORT integer (2 bytes/value)
                     2: FLOAT (4 bytes/value)
                     3: SCOMPLEX (short complex, 4 bytes/value)
                     4: FCOMPLEX (float complex, 8 bytes/value)
                     5: BYTE
                     6: UNSIGNED SHORT integer (2 bytes/value)
          GeoTIFF  (output) GeoTIFF file (.tif is the recommended extension)
          no_data  no_data value (enter -  for default: 0.0)
          COGflg   generate Cloud Optimized GeoTIFF (COG):
                      0: no COG tiling of output GeoTIFF (default)
                      1: generate tiled COG GeoTIFF

        """
        if self.validate_inputs:
            self._validate_data2geotiff(DEM_par, data, type, GeoTIFF, no_data, COGflg)
        if self.mock_outputs:
            self._mock_data2geotiff_outputs(DEM_par, data, type, GeoTIFF, no_data, COGflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.data2geotiff))
        return self._gamma_call("DISP", "data2geotiff", supplied_args)

    def _validate_disras(self, ras: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None) -> None:
        self._validate("disras", ras.exists(), f"ras path does not exist ({ras})")

    def _mock_disras_outputs(self, ras: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None) -> None:
        pass

    def disras(self, ras: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None) -> Tuple[int, str, str]:
        """

        DISP disras: Display raster format images, Sun Raster, BMP, or TIFF format


        input parameters:
          ras     (input) raster image
          mag     zoom magnification factor (enter - for default: 3)
          win_sz  zoom window size before magnification (enter - for default: 132)

          NOTE:   raster format file extensions: SUN: *.ras, BMP: *.bmp, TIFF: *.tif

        """
        if self.validate_inputs:
            self._validate_disras(ras, mag, win_sz)
        if self.mock_outputs:
            self._mock_disras_outputs(ras, mag, win_sz)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disras))
        return self._gamma_call("DISP", "disras", supplied_args)

    def _validate_dis2ras(
        self, ras1: Path, ras2: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> None:
        self._validate("dis2ras", ras1.exists(), f"ras1 path does not exist ({ras1})")
        self._validate("dis2ras", ras2.exists(), f"ras2 path does not exist ({ras2})")

    def _mock_dis2ras_outputs(
        self, ras1: Path, ras2: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> None:
        pass

    def dis2ras(
        self, ras1: Path, ras2: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        DISP dis2ras: alternating display of two raster (SUN/BMP/TIFF) format images


        input parameters:
          ras1    (input) SUN/BMP/TIFF image (8 or 24 bits/pixel) 1
          ras2    (input) SUN/BMP/TIFF image (8 or 24 bits/pixel) 2
          mag     zoom magnification factor (enter - for default: 3)
          win_sz  zoom window size before magnification (enter - for default: 132)

          NOTE:   raster format file extensions: SUN: *.ras, BMP: *.bmp, TIFF: *.tif

        """
        if self.validate_inputs:
            self._validate_dis2ras(ras1, ras2, mag, win_sz)
        if self.mock_outputs:
            self._mock_dis2ras_outputs(ras1, ras2, mag, win_sz)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2ras))
        return self._gamma_call("DISP", "dis2ras", supplied_args)

    def _validate_kml2poly(self, DEM_par: Path, kml: Path, poly: Path) -> None:
        self._validate("kml2poly", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("kml2poly", kml.exists(), f"kml path does not exist ({kml})")

    def _mock_kml2poly_outputs(self, DEM_par: Path, kml: Path, poly: Path) -> None:
        if poly is not None and str(poly) != "-":
            poly.touch()

    def kml2poly(self, DEM_par: Path, kml: Path, poly: Path) -> Tuple[int, str, str]:
        """

        Generate a polygon file from a KML file and a DEM/MAP parameter file


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          kml         (input) KML file containing georeferenced polygon corner coordinates
          poly        (output) file containing polygon corner coordinates

        """
        if self.validate_inputs:
            self._validate_kml2poly(DEM_par, kml, poly)
        if self.mock_outputs:
            self._mock_kml2poly_outputs(DEM_par, kml, poly)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.kml2poly))
        return self._gamma_call("DISP", "kml2poly", supplied_args)

    def _validate_dismph_pwr(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> None:
        self._validate("dismph_pwr", data.exists(), f"data path does not exist ({data})")
        self._validate("dismph_pwr", pwr.exists(), f"pwr path does not exist ({pwr})")

    def _mock_dismph_pwr_outputs(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> None:
        pass

    def dismph_pwr(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dismph_pwr
        Display FCOMPLEX data phase using a specified colormap combined with power-law scaled intensity (8 or 24-bits/pixel)


        input parameters:
          data    (input) data (FCOMPLEX)
          pwr     (input) intensity image coregistered with data (enter - for none, FLOAT or raster image)
          width   number of samples/row of data and pwr
          start   starting line of data and pwr (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   intensity display scale factor (enter - for default: 1.0)
          exp     intensity display exponent (enter - for default: 0.35)
          bits    bits/pixel (enter - for default)
                     8: 8-bit indexed color map (default)
                    24: RGB 8-bits/color

        """
        if self.validate_inputs:
            self._validate_dismph_pwr(data, pwr, width, start, nlines, cmap, scale, exp, bits)
        if self.mock_outputs:
            self._mock_dismph_pwr_outputs(data, pwr, width, start, nlines, cmap, scale, exp, bits)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dismph_pwr))
        return self._gamma_call("DISP", "dismph_pwr", supplied_args)

    def _validate_vec_math(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        c1: Optional[Any] = None,
        c2: Optional[Any] = None,
        c3: Optional[Any] = None,
        nflg: Optional[Any] = None,
        nl: Optional[int] = None,
    ) -> None:
        self._validate("vec_math", d1.exists(), f"d1 path does not exist ({d1})")
        self._validate("vec_math", d2.exists(), f"d2 path does not exist ({d2})")

    def _mock_vec_math_outputs(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        c1: Optional[Any] = None,
        c2: Optional[Any] = None,
        c3: Optional[Any] = None,
        nflg: Optional[Any] = None,
        nl: Optional[int] = None,
    ) -> None:
        if d_out is not None and str(d_out) != "-":
            d_out.touch()

    def vec_math(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        c1: Optional[Any] = None,
        c2: Optional[Any] = None,
        c3: Optional[Any] = None,
        nflg: Optional[Any] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/vec_math
        Perform vector and arithmetic operations on 3D float vector data


        input parameters:
          d1     (input) vector float data 1 (XYZ, ENU..., enter - for none)
                 NOTE: if no input file is provided, then d1 values are set to (0,0,0)
          d2     (input) vector float data 2 (XYZ, ENU..., enter - for none)
                 NOTE: if no input file is provided for modes 0->3, d2 values are set to (c1, c2, c3)
          d_out  (output) vector or scalar result (XYZ, ENU..., or scalar for modes 2,4: dot product and norm(d1))
          width  number of 3D vectors/line
          mode   math operations:
                   0: vector addition: d1 + d2
                   1: vector subtraction: d1 - d2
                   2: dot product: d1 . d2, scalar float output
                   3: cross product: d1 x d2
                   4: norm(d1), scalar float output
                   5: scalar multiply d1 * d2, where d2 is a scalar array
                   6: scalar divide d1/d2 where d2 is a scalar array
          c1     constant value for first vector component, when d2 set to - (float)
          c2     constant value for second vector component, when d2 set to - (float)
          c3     constant value for third vector component, when d2 set to - (float)
          nflg   normalize vector flag (enter - for default: 0):
                   0: do not normalize output vector data (default)
                   1: normalize output vector data, dividing by |d_out| for modes 0,1,3
                 NOTE: if the vector is (0,0,0) then the normalized output is set to (0,0,0)
          nl     number of lines, required only if d1 is set to -
          NOTE: The input data arrays d1 and d2 must all have the same number of samples/line
        """
        if self.validate_inputs:
            self._validate_vec_math(d1, d2, d_out, width, mode, c1, c2, c3, nflg, nl)
        if self.mock_outputs:
            self._mock_vec_math_outputs(d1, d2, d_out, width, mode, c1, c2, c3, nflg, nl)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.vec_math))
        return self._gamma_call("DISP", "vec_math", supplied_args)

    def _validate_dismph_fft(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        nfft: Optional[Any] = None,
        mag: Optional[Any] = None,
        data_type: Optional[int] = None,
    ) -> None:
        self._validate("dismph_fft", data.exists(), f"data path does not exist ({data})")

    def _mock_dismph_fft_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        nfft: Optional[Any] = None,
        mag: Optional[Any] = None,
        data_type: Optional[int] = None,
    ) -> None:
        pass

    def dismph_fft(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        nfft: Optional[Any] = None,
        mag: Optional[Any] = None,
        data_type: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP dismph_fft: Display of magnitude/phase and 2D FFT of complex data


        input parameters:
          data       (input) data (SCOMPLEX or FCOMPLEX)
          width      complex samples per row
          start      starting line to display (enter - for default: 1)
          nlines     number of lines to display (enter - or 0 for default: to end of file)
          scale      display scale factor (enter - for default: 1.0)
          exp        display exponent (enter - for default: 0.35)
          nfft       2D FFT size, nfft x nfft (enter - for default: 128)
          mag        zoom and FFT window magnification factor (enter - for default: 3)
          data_type  input data type (enter - for default)
                       0: FCOMPLEX (default)
                       1: SCOMPLEX

        """
        if self.validate_inputs:
            self._validate_dismph_fft(data, width, start, nlines, scale, exp, nfft, mag, data_type)
        if self.mock_outputs:
            self._mock_dismph_fft_outputs(data, width, start, nlines, scale, exp, nfft, mag, data_type)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dismph_fft))
        return self._gamma_call("DISP", "dismph_fft", supplied_args)

    def _validate_svg_arrow(
        self,
        dv_norm: Path,
        dv_phi: Path,
        width: int,
        svg: Path,
        image: Optional[Any] = None,
        norm: Optional[Any] = None,
        gridx: Optional[Any] = None,
        gridy: Optional[Any] = None,
        color: Optional[Any] = None,
        thick: Optional[int] = None,
        head: Optional[Any] = None,
    ) -> None:
        self._validate("svg_arrow", dv_norm.exists(), f"dv_norm path does not exist ({dv_norm})")
        self._validate("svg_arrow", dv_phi.exists(), f"dv_phi path does not exist ({dv_phi})")

    def _mock_svg_arrow_outputs(
        self,
        dv_norm: Path,
        dv_phi: Path,
        width: int,
        svg: Path,
        image: Optional[Any] = None,
        norm: Optional[Any] = None,
        gridx: Optional[Any] = None,
        gridy: Optional[Any] = None,
        color: Optional[Any] = None,
        thick: Optional[int] = None,
        head: Optional[Any] = None,
    ) -> None:
        if svg is not None and str(svg) != "-":
            svg.touch()

    def svg_arrow(
        self,
        dv_norm: Path,
        dv_phi: Path,
        width: int,
        svg: Path,
        image: Optional[Any] = None,
        norm: Optional[Any] = None,
        gridx: Optional[Any] = None,
        gridy: Optional[Any] = None,
        color: Optional[Any] = None,
        thick: Optional[int] = None,
        head: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP svg_arrow: Draw arrow files on an image and store as SVG


        input parameters:
          dv_norm (input) arrow length file (float)
          dv_phi  (input) arrow direction file (float)
          width   number of samples/row
          svg     (output) arrow file in SVG format
          image   URL of background image in png or jpg format (- for no background image)
          norm    arrow length normalisation factor (default = 1.0)
          gridx   step size for arrow grid in x direction (default = 10)
          gridy   step size for arrow grid in y direction (default = gridx)
          color   black, white, blue etc (default = black)
          thick   line thickness in pixels (default = 1)
          head    arrow head size (default = 3)

        """
        if self.validate_inputs:
            self._validate_svg_arrow(dv_norm, dv_phi, width, svg, image, norm, gridx, gridy, color, thick, head)
        if self.mock_outputs:
            self._mock_svg_arrow_outputs(dv_norm, dv_phi, width, svg, image, norm, gridx, gridy, color, thick, head)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.svg_arrow))
        return self._gamma_call("DISP", "svg_arrow", supplied_args)

    def _validate_ras3pwr(
        self,
        d1: Path,
        d2: Path,
        d3: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale1: Optional[Any] = None,
        scale2: Optional[Any] = None,
        scale3: Optional[Any] = None,
        exp: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        self._validate("ras3pwr", d1.exists(), f"d1 path does not exist ({d1})")
        self._validate("ras3pwr", d2.exists(), f"d2 path does not exist ({d2})")
        self._validate("ras3pwr", d3.exists(), f"d3 path does not exist ({d3})")

    def _mock_ras3pwr_outputs(
        self,
        d1: Path,
        d2: Path,
        d3: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale1: Optional[Any] = None,
        scale2: Optional[Any] = None,
        scale3: Optional[Any] = None,
        exp: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras3pwr(
        self,
        d1: Path,
        d2: Path,
        d3: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale1: Optional[Any] = None,
        scale2: Optional[Any] = None,
        scale3: Optional[Any] = None,
        exp: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras3pwr
        Generate 24-bit RGB raster graphics image of 3 intensity files


        input parameters:
          d1       (input) data channel 1 (used for image scaling) (float) (red)
          d2       (input) data channel 2 (float)(green)
          d3       (input) data channel 3 (float)(blue)
          width    number of samples/row in the input data files
          start    starting line (enter - for default: 1)
          nlines   number of lines (enter - or 0 for default: to end of file)
          pixavx   number of pixels to average across (enter - for default: 1)
          pixavy   number of pixels to average down (enter - for default: 1)
          scale1   relative display scale factor for channel 1 red   (enter - for default: 1.0)
          scale2   relative display scale factor for channel 2 green (enter - for default: 1.0)
          scale3   relative display scale factor for channel 3 blue  (enter - for default: 1.0)
          exp      display exponent (enter - for default: 0.35)
          rasf     (output) image filename, extension determines the format, enter - for default: *.bmp
                     *.bmp BMP format
                     *.ras Sun raster format
                     *.tif TIFF format

        """
        if self.validate_inputs:
            self._validate_ras3pwr(d1, d2, d3, width, start, nlines, pixavx, pixavy, scale1, scale2, scale3, exp, rasf)
        if self.mock_outputs:
            self._mock_ras3pwr_outputs(
                d1, d2, d3, width, start, nlines, pixavx, pixavy, scale1, scale2, scale3, exp, rasf
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras3pwr))
        return self._gamma_call("DISP", "ras3pwr", supplied_args)

    def _validate_disdt_pwr(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> None:
        self._validate("disdt_pwr", data.exists(), f"data path does not exist ({data})")
        self._validate("disdt_pwr", pwr.exists(), f"pwr path does not exist ({pwr})")

    def _mock_disdt_pwr_outputs(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> None:
        pass

    def disdt_pwr(
        self,
        data: Path,
        pwr: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        bits: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/disdt_pwr
        Display data (FLOAT) with linear scaling using a specified colormap combined with power-law scaled intensity (8 or 24-bits/pixel)


        input parameters:
          data    (input) data in FLOAT format (deformation, height, unwrapped phase, correlation...)
          pwr     (input) intensity image coregistered with data (enter - for none, FLOAT or raster image)
          width   number of samples/row of data and pwr
          start   starting line of data and pwr file (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          min     minimum data value (enter - for default:  0.0000e+00)
          max     maximum data value (enter - for default:  1.0000e+00)
          cflg    cyclic data display flag:
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max - min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   intensity display scale factor (enter - for default: 1.0)
          exp     intensity display exponent (enter - for default: 0.35)
          bits    bits/pixel (enter - for default)
                     8: 8-bit indexed color map (default)
                    24: RGB 8-bits/color
        """
        if self.validate_inputs:
            self._validate_disdt_pwr(data, pwr, width, start, nlines, min, max, cflg, cmap, scale, exp, bits)
        if self.mock_outputs:
            self._mock_disdt_pwr_outputs(data, pwr, width, start, nlines, min, max, cflg, cmap, scale, exp, bits)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disdt_pwr))
        return self._gamma_call("DISP", "disdt_pwr", supplied_args)

    def _validate_real_to_vec(self, cmp1: Path, cmp2: Path, cmp3: Path, width: int, vec: Path) -> None:
        self._validate("real_to_vec", cmp1.exists(), f"cmp1 path does not exist ({cmp1})")
        self._validate("real_to_vec", cmp2.exists(), f"cmp2 path does not exist ({cmp2})")
        self._validate("real_to_vec", cmp3.exists(), f"cmp3 path does not exist ({cmp3})")

    def _mock_real_to_vec_outputs(self, cmp1: Path, cmp2: Path, cmp3: Path, width: int, vec: Path) -> None:
        if vec is not None and str(vec) != "-":
            vec.touch()

    def real_to_vec(self, cmp1: Path, cmp2: Path, cmp3: Path, width: int, vec: Path) -> Tuple[int, str, str]:
        """

        Display Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/real_to_vec.c
        Combine 3 individual float vector components into a float vector format output file

        input parameters:
          cmp1   (input) vector component 1 (float, enter - for none)
                 NOTE: if the input is specified as -, then the component data value is set to 0.0
          cmp2   (input) vector component 2 (float, enter - for none)
          cmp3   (input) vector component 3 (float, enter - for none)
          width  number of vectors per line of the input data
          vec    (output) vector data (float)
                 NOTE: vector data are triplets of 4-byte single-precision floating point numbers (cmp1, cmp2, cmp3)

        """
        if self.validate_inputs:
            self._validate_real_to_vec(cmp1, cmp2, cmp3, width, vec)
        if self.mock_outputs:
            self._mock_real_to_vec_outputs(cmp1, cmp2, cmp3, width, vec)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.real_to_vec))
        return self._gamma_call("DISP", "real_to_vec", supplied_args)

    def _validate_float2short(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[Any],
        exp: Optional[Any],
        neg: Optional[int],
        dtype: Optional[int],
        output: Any,
    ) -> None:
        self._validate("float2short", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_float2short_outputs(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[Any],
        exp: Optional[Any],
        neg: Optional[int],
        dtype: Optional[int],
        output: Any,
    ) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def float2short(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[Any],
        exp: Optional[Any],
        neg: Optional[int],
        dtype: Optional[int],
        output: Any,
    ) -> Tuple[int, str, str]:
        """

        DISP float2short: Convert floating point data to short integer format


        input parameters:
          infile   (input) input data file (FLOAT, 4 bytes/sample)
          outfile  (output) output file (SHORT integers, 2 bytes/sample)
          scale    scale factor (enter - for default: 1.0)
          exp      exponent (enter - for default: 1.0)
          neg      behavior for negative output values (enter - for default)
                     0: replace by minimum positive value (default)
                     1: keep negative values
          dtype    output data type (enter - for default)
                     0: SHORT (int16, default)
                     1: UNSIGNED SHORT (uint16)

        output = scale*input^exp  (for SAR backscatter use scale=1000.0, exp=0.5)

        """
        if self.validate_inputs:
            self._validate_float2short(infile, outfile, scale, exp, neg, dtype, output)
        if self.mock_outputs:
            self._mock_float2short_outputs(infile, outfile, scale, exp, neg, dtype, output)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2short))
        return self._gamma_call("DISP", "float2short", supplied_args)

    def _validate_dis2mph_pwr(
        self,
        data1: Path,
        data2: Path,
        pwr: Path,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[Any] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        cmap: Optional[Any] = None,
        scale: Optional[Path] = None,
        exp: Optional[Any] = None,
    ) -> None:
        self._validate("dis2mph_pwr", data1.exists(), f"data1 path does not exist ({data1})")
        self._validate("dis2mph_pwr", data2.exists(), f"data2 path does not exist ({data2})")
        self._validate("dis2mph_pwr", pwr.exists(), f"pwr path does not exist ({pwr})")

    def _mock_dis2mph_pwr_outputs(
        self,
        data1: Path,
        data2: Path,
        pwr: Path,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[Any] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        cmap: Optional[Any] = None,
        scale: Optional[Path] = None,
        exp: Optional[Any] = None,
    ) -> None:
        pass

    def dis2mph_pwr(
        self,
        data1: Path,
        data2: Path,
        pwr: Path,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[Any] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        cmap: Optional[Any] = None,
        scale: Optional[Path] = None,
        exp: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2mph_pwr
        Display the phase of 2 complex images (FCOMPLEX type) combined with power-law scaled intensity


        input parameters:
          data1   (input) complex data1 (FCOMPLEX)
          data2   (input) complex data2 (FCOMPLEX)
          pwr     (input) intensity image coregistered with data1 (enter - for none, FLOAT or raster image)
          width1  data samples per row of data1
          width2  data samples per row of data2
          start   starting line of cpx1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   display scale factor (enter - for default: 1.0)
          exp     display exponent (enter - for default: 0.35)

        """
        if self.validate_inputs:
            self._validate_dis2mph_pwr(data1, data2, pwr, width2, start, nlines, xoff, yoff, cmap, scale, exp)
        if self.mock_outputs:
            self._mock_dis2mph_pwr_outputs(data1, data2, pwr, width2, start, nlines, xoff, yoff, cmap, scale, exp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2mph_pwr))
        return self._gamma_call("DISP", "dis2mph_pwr", supplied_args)

    def _validate_ras2ras(
        self, ras_in: Path, ras_out: Path, cmap: Optional[Path] = None, force24: Optional[int] = None
    ) -> None:
        self._validate("ras2ras", ras_in.exists(), f"ras_in path does not exist ({ras_in})")

    def _mock_ras2ras_outputs(
        self, ras_in: Path, ras_out: Path, cmap: Optional[Path] = None, force24: Optional[int] = None
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras2ras(
        self, ras_in: Path, ras_out: Path, cmap: Optional[Path] = None, force24: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Format and colormap conversion of raster images


        input parameters:
          ras_in   (input) SUN/BMP/TIFF format raster image (8 or 24 bits/sample)
          ras_out  (output) SUN/BMP/TIFF format raster image
          cmap     new colormap for 8-bit input image (enter - for default, retain original colormap)
                   NOTE: colormaps are located by default in $DISP_HOME/cmaps, examples: gray.cm, hls.cm, rmg.cm...
          force24  convert 8 to 24 bits: (enter - for default)
                     0: bits/sample remains unchanged (default)
                     1: output is 24 bits/sample

        """
        if self.validate_inputs:
            self._validate_ras2ras(ras_in, ras_out, cmap, force24)
        if self.mock_outputs:
            self._mock_ras2ras_outputs(ras_in, ras_out, cmap, force24)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras2ras))
        return self._gamma_call("DISP", "ras2ras", supplied_args)

    def _validate_ras24_float(
        self,
        f1: Path,
        f2: Path,
        f3: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int],
        h0: Optional[Any],
        hrange: Optional[Any],
        imin: Optional[Any],
        imax: Optional[Any],
        sat_min: Optional[Any],
        sat_max: Optional[Any],
        sc1: Optional[Any],
        A1: Optional[Any],
        B1: Optional[Any],
        cyclic1: Optional[Any],
        sc2: Optional[Any],
        A2: Optional[Any],
        B2: Optional[Any],
        start_f1: Optional[Any],
        start_f2: Optional[Any],
        nlines: Optional[Any],
        pixavr: Optional[Any],
        pixavaz: Optional[Any],
        B3: Any,
    ) -> None:
        self._validate("ras24_float", f1.exists(), f"f1 path does not exist ({f1})")
        self._validate("ras24_float", f2.exists(), f"f2 path does not exist ({f2})")
        self._validate("ras24_float", f3.exists(), f"f3 path does not exist ({f3})")

    def _mock_ras24_float_outputs(
        self,
        f1: Path,
        f2: Path,
        f3: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int],
        h0: Optional[Any],
        hrange: Optional[Any],
        imin: Optional[Any],
        imax: Optional[Any],
        sat_min: Optional[Any],
        sat_max: Optional[Any],
        sc1: Optional[Any],
        A1: Optional[Any],
        B1: Optional[Any],
        cyclic1: Optional[Any],
        sc2: Optional[Any],
        A2: Optional[Any],
        B2: Optional[Any],
        start_f1: Optional[Any],
        start_f2: Optional[Any],
        nlines: Optional[Any],
        pixavr: Optional[Any],
        pixavaz: Optional[Any],
        B3: Any,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras24_float(
        self,
        f1: Path,
        f2: Path,
        f3: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int],
        h0: Optional[Any],
        hrange: Optional[Any],
        imin: Optional[Any],
        imax: Optional[Any],
        sat_min: Optional[Any],
        sat_max: Optional[Any],
        sc1: Optional[Any],
        A1: Optional[Any],
        B1: Optional[Any],
        cyclic1: Optional[Any],
        sc2: Optional[Any],
        A2: Optional[Any],
        B2: Optional[Any],
        start_f1: Optional[Any],
        start_f2: Optional[Any],
        nlines: Optional[Any],
        pixavr: Optional[Any],
        pixavaz: Optional[Any],
        B3: Any,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras24_float
        Generate 24-bit raster graphics image of 1, 2, or 3 float data files


        input parameters:
          f1           (input) file 1 (float, red/hue           enter - if not available)
          f2           (input) file 2 (float, green/brightness, enter - if not available)
          f3           (input) file 3 (float, blue/saturation,  enter - if not available)
          width        samples per row of f1, f2, and f3
          rasf         (output) image filename, extension determines format:
                         *.bmp BMP format
                         *.ras Sun raster format
                         *.tif TIFF format
          color_model  color model selection flag: (enter - for default)
                         0: RGB color model (default)
                         1: HLS (double hexagon color model)
                         2: HSV (single hexagon color model)
          h0           starting hue (color for starting value, enter - for default: 0.0)
          hrange       range of hue values in degrees (-360. ... 360., enter - for default: 360.0)
          imin         minimum brightness value (0.0 ... 1.0, enter - for default: 0.15)
          imax         maximum brightness value (0.0 ... 1.0, enter - for default: 0.85)
          sat_min      minimum color saturation value (0.0 ... 1.0, enter - for default: 0.0)
          sat_max      maximum color saturation value (0.0 ... 1.0, enter - for default: 1.0)

        Input image f1 scaling parameters:
          sc1          Scaling model flag (enter - for default: 0; 0: lin, 1: log, 2: power-law)
          A1           Scaling parameter A (minimum or scale; enter - for default: 0.0)
          B1           Scaling parameter B (maximum or exponent; enter - for default: 6.2832)
          cyclic1      Cyclic scaling model (enter - for default: 1; 0: no 1: yes)

        Input image f2 scaling parameters:
          sc2          Scaling model flag (enter - for default: 2; 0: lin, 1: log, 2: power-law)
          A2           Scaling parameter A (minimum or scale; enter - for default: 1.0)
          B2           Scaling parameter B (maximum or exponent; enter - for default: 0.35)

        Input image f3 scaling parameters:
          sc3          Scaling model flag (enter - for default: 0; 0: lin, 1: log, 2: power-law)
          A3           Scaling parameter A (minimum or scale; enter - for default: 0.0)
          B3           Scaling parameter B (maximum or exponent; enter - for default: 1.0)

        General parameters:
          start_f1     starting line of f1 (enter - for default: 1)
          start_f2     starting line of f2 (enter - for default: 1)
          start_f3     starting line of f3 (enter - for default: 1)
          nlines       number of lines to process (enter - or 0 for default: to end of file)
          pixavr       number of pixels to average in range (enter - for default: 1)
          pixavaz      number of pixels to average in azimuth (enter - for default: 1)

        """
        if self.validate_inputs:
            self._validate_ras24_float(
                f1,
                f2,
                f3,
                width,
                rasf,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat_min,
                sat_max,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                nlines,
                pixavr,
                pixavaz,
                B3,
            )
        if self.mock_outputs:
            self._mock_ras24_float_outputs(
                f1,
                f2,
                f3,
                width,
                rasf,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat_min,
                sat_max,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                nlines,
                pixavr,
                pixavaz,
                B3,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras24_float))
        return self._gamma_call("DISP", "ras24_float", supplied_args)

    def _validate_double2float(
        self, infile: Path, outfile: Path, scale: Optional[Any] = None, exp: Optional[Any] = None
    ) -> None:
        self._validate("double2float", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_double2float_outputs(
        self, infile: Path, outfile: Path, scale: Optional[Any] = None, exp: Optional[Any] = None
    ) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def double2float(
        self, infile: Path, outfile: Path, scale: Optional[Any] = None, exp: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        DISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/double2float.c
        Convert double precision floating point data to single precision floating point data


        input parameters:
          infile   (input) input data file (double)
          outfile  (output) output data file (float)
          scale    scale factor (default: 1.0)
          exp      exponent (default: 1.0)

        NOTE: output = scale*input^exp

        """
        if self.validate_inputs:
            self._validate_double2float(infile, outfile, scale, exp)
        if self.mock_outputs:
            self._mock_double2float_outputs(infile, outfile, scale, exp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.double2float))
        return self._gamma_call("DISP", "double2float", supplied_args)

    def _validate_float2uchar(self, infile: Any, outfile: Any, scale: Any, exp: Any) -> None:
        pass

    def _mock_float2uchar_outputs(self, infile: Any, outfile: Any, scale: Any, exp: Any) -> None:
        pass

    def float2uchar(self, infile: Any, outfile: Any, scale: Any, exp: Any) -> Tuple[int, str, str]:
        """

        DISP float2uchar: Format transformation from float (4-byte) to unsigned char (1-byte)
        outfile = scale*infile^exp (for coherence use scale=255.0, exp=1.0)


        input parameters:
          infile   input file (float, 4 bytes/sample)
          outfile  output file (unsigned char, 1 byte/sample)
          scale    scale factor (default=1.0)
          exp      exponent (default=1.0)

        """
        if self.validate_inputs:
            self._validate_float2uchar(infile, outfile, scale, exp)
        if self.mock_outputs:
            self._mock_float2uchar_outputs(infile, outfile, scale, exp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2uchar))
        return self._gamma_call("DISP", "float2uchar", supplied_args)

    def _validate_float_math(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c0: Optional[Any] = None,
        zflg: Optional[int] = None,
    ) -> None:
        self._validate("float_math", d1.exists(), f"d1 path does not exist ({d1})")
        self._validate("float_math", d2.exists(), f"d2 path does not exist ({d2})")

    def _mock_float_math_outputs(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c0: Optional[Any] = None,
        zflg: Optional[int] = None,
    ) -> None:
        if d_out is not None and str(d_out) != "-":
            d_out.touch()

    def float_math(
        self,
        d1: Path,
        d2: Path,
        d_out: Path,
        width: int,
        mode: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        c0: Optional[Any] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/float_math
        Perform mathematical operations on data files (float)


        input parameters:
          d1     (input) data file 1 (float)
          d2     (input) data file 2 (float) (enter - for none)
                  NOTE: if no input file is provided, d2 values are set to value specified by c0 parameter
          d_out  (output) output of math operation on the input data, must differ from d1 and d2! (float)
          width  number of samples/line
          mode   math operation to perform on data:
                   0:  addition, d1 + d2
                   1:  subtraction, d1 - d2
                   2:  multiplication, d1 * d2
                   3:  division, d1/d2
                   4:  10 * log10(d1), evaluate dB value
                   5:  d1*d1
                   6:  sqrt(d1)
                   7:  sin(d1)
                   8:  cos(d1)
                   9:  tan(d1)
                   10: asin(d1)
                   11: acos(d1)
                   12: atan2(d2,d1)
                   13: d1**d2
                   14: abs(d1)
          roff   range pixel offset to center of the reference region (enter - for default: no reference correction)
          loff   line offset to center of the reference region (enter - for default: no reference correction)
          nr     number of range pixels to average in the reference region (enter - for default: 13)
          nl     number of lines average in the reference region (enter - for default: 13)
          c0     constant value (enter - for default: 1.18e-38 for addition and subtraction, 1.0 for multiplication and division)
          zflg   zero data flag (enter - for default:0):
                   0: values of 0.0 in d1 or d2 are considered as no-data and the output is set to 0.0 (default)
                   1: values of 0.0 are considered as valid data

          NOTE: when specifying a reference region with roff, loff, nr, nl parameters:
                modes 0, 1:  reference region average value is subtracted from d1 and d2 data respectively
                modes 2, 3:  d1 and d2 data are divided by the average in the reference region
                mode  4:     data values in d1 are divided by the average in the reference region
                modes 7->14: reference correction not applicable to these modes
        """
        if self.validate_inputs:
            self._validate_float_math(d1, d2, d_out, width, mode, roff, loff, nr, nl, c0, zflg)
        if self.mock_outputs:
            self._mock_float_math_outputs(d1, d2, d_out, width, mode, roff, loff, nr, nl, c0, zflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float_math))
        return self._gamma_call("DISP", "float_math", supplied_args)

    def _validate_cpd(
        self, din: Path, dout: Path, width: int, dtype: int, xoff: int, nx: int, yoff: int, ny: int
    ) -> None:
        self._validate("cpd", din.exists(), f"din path does not exist ({din})")

    def _mock_cpd_outputs(
        self, din: Path, dout: Path, width: int, dtype: int, xoff: int, nx: int, yoff: int, ny: int
    ) -> None:
        if dout is not None and str(dout) != "-":
            dout.touch()

    def cpd(
        self, din: Path, dout: Path, width: int, dtype: int, xoff: int, nx: int, yoff: int, ny: int
    ) -> Tuple[int, str, str]:
        """

        DISP cpd: Copy segments of FLOAT, FCOMPLEX and SCOMPLEX data files


        input parameters:
          din       (input) input data file
          dout      (output) output data file
          width     number of data values/line in the input data file
          dtype     input data type:
                      0: FLOAT (4 bytes/value)
                      1: FCOMPLEX (4 bytes real, 4 bytes imaginary)
                      2: SCOMPLEX (2 bytes real, 2 bytes imaginary)
          xoff      offset to starting sample (samples) (enter - for default: 0)
          nx        number of output samples/line (enter - for default: to end of line)
          yoff      offset to starting line (lines) (enter - for default: 0)
          ny        number of output lines (enter - for default: to end of file)
        """
        if self.validate_inputs:
            self._validate_cpd(din, dout, width, dtype, xoff, nx, yoff, ny)
        if self.mock_outputs:
            self._mock_cpd_outputs(din, dout, width, dtype, xoff, nx, yoff, ny)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cpd))
        return self._gamma_call("DISP", "cpd", supplied_args)

    def _validate_disras_dem_par(
        self, ras: Path, DEM_par: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> None:
        self._validate("disras_dem_par", ras.exists(), f"ras path does not exist ({ras})")
        self._validate("disras_dem_par", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_disras_dem_par_outputs(
        self, ras: Path, DEM_par: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> None:
        pass

    def disras_dem_par(
        self, ras: Path, DEM_par: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        DISP disras_dem_par: display raster image with DEM/MAP parameter file


        input parameters:
          ras      (input) raster image with same dimensions as in DEM_par (SUN *.ras, or BMP *.bmp format)
          DEM_par  (input) DIFF DEM/MAP parameter file
          mag      zoom magnification factor (enter - for default: 3)
          win_sz   zoom window size before magnification (enter - for default: 132)

        """
        if self.validate_inputs:
            self._validate_disras_dem_par(ras, DEM_par, mag, win_sz)
        if self.mock_outputs:
            self._mock_disras_dem_par_outputs(ras, DEM_par, mag, win_sz)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disras_dem_par))
        return self._gamma_call("DISP", "disras_dem_par", supplied_args)

    def _validate_ras2float(self, ras: Path, chan: int, mode: int, min: Any, max: Any, dout: Path) -> None:
        self._validate("ras2float", ras.exists(), f"ras path does not exist ({ras})")

    def _mock_ras2float_outputs(self, ras: Path, chan: int, mode: int, min: Any, max: Any, dout: Path) -> None:
        if dout is not None and str(dout) != "-":
            dout.touch()

    def ras2float(self, ras: Path, chan: int, mode: int, min: Any, max: Any, dout: Path) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras2float
        Convert selected color channel (RGB) of a raster image to 32-bit FLOAT


        input parameters:
          ras   (input) 8 or 24-bit raster image
                  *.bmp BMP format
                  *.ras Sun raster format
                  *.tif TIFF format
          chan  RGB channel to convert to FLOAT (enter - for default)
                  1: red (default)
                  2: green
                  3: blue
          mode  data scaling (enter - for default: linear scaling)
                  0: linear scaling: min -> max, (default)
                  1: logarithmic scaling: min_dB -> max_dB
          min   minimum value to rescale raster data (enter - for default)
                  linear:        0.0
                  logarithmic: -40.0 dB
          max   maximum value to rescale raster data (enter - for default)
                  linear:        2.0
                  logarithmic:  10.0 dB
          dout   (output) data file (FLOAT format)

        NOTES
          1. Data values are the selected R, G, or B channel of the colomap for 8-bit images
          2. min and max are interpreted as dB for mode 1: logarithmic scaling
          3. Data are converted to intensity from the rescaled dB values in mode 1: logarithmic scaling

        """
        if self.validate_inputs:
            self._validate_ras2float(ras, chan, mode, min, max, dout)
        if self.mock_outputs:
            self._mock_ras2float_outputs(ras, chan, mode, min, max, dout)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras2float))
        return self._gamma_call("DISP", "ras2float", supplied_args)

    def _validate_dismph(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        self._validate("dismph", data.exists(), f"data path does not exist ({data})")

    def _mock_dismph_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        pass

    def dismph(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dismph
        Display data (FCOMPLEX, SCOMPLEX, BCOMPLEX) using a specified colormap and power-law scaled intensity


        input parameters:
          data    (input) data (FCOMPLEX, SCOMPLEX, BCOMPLEX)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          scale   power-law scale factor, (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
                    2: BCOMPLEX
          bits    bits/pixel (enter - for default)
                     8: 8-bit indexed color map (default)
                    24: RGB 8-bits/color
          sc_ave  average intensity used to scale image (enter - for default: determined from data)

        """
        if self.validate_inputs:
            self._validate_dismph(data, width, start, nlines, scale, exp, cmap, dtype, bits, sc_ave)
        if self.mock_outputs:
            self._mock_dismph_outputs(data, width, start, nlines, scale, exp, cmap, dtype, bits, sc_ave)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dismph))
        return self._gamma_call("DISP", "dismph", supplied_args)

    def _validate_rasshd(
        self,
        DEM: Path,
        width: int,
        col_post: Any,
        row_post: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        theta0: Optional[Any] = None,
        phi0: Optional[Any] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
        shade: Optional[Path] = None,
    ) -> None:
        self._validate("rasshd", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_rasshd_outputs(
        self,
        DEM: Path,
        width: int,
        col_post: Any,
        row_post: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        theta0: Optional[Any] = None,
        phi0: Optional[Any] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
        shade: Optional[Path] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()
        if shade is not None and str(shade) != "-":
            shade.touch()

    def rasshd(
        self,
        DEM: Path,
        width: int,
        col_post: Any,
        row_post: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        theta0: Optional[Any] = None,
        phi0: Optional[Any] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
        shade: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasshd
        Generate 8-bit raster graphics image of DEM data as shaded relief


        input parameters:
          DEM         (input) digital elevation model (FLOAT or SHORT integer)
          width       samples per row of DEM
          col_post    posting between cols (in meters)
          row_post    posting between rows (in meters, enter - for default: col_post)
          start       starting line of DEM (enter - for default: 1)
          nlines      number of lines to display (enter - or 0 for default: to end of file)
          pixavx      number of pixels to average (and decimate) in horizontal direction (enter - for default: 1)
          pixavy      number of pixels to average (and decimate) in vertical direction (enter - for default: 1)
          theta0      illumination elevation angle in deg. (enter - for default: 45.0)
          phi0        illumination orientation angle in deg. (enter - default: 135.0)
                      (0.: right, 90: top, 180: left, 270: bottom)
          rasf        (output) image filename, extension determines the format, enter - for default: *.bmp
                        *.bmp BMP format
                        *.ras SUN raster format
                        *.tif TIFF format
          dtype       DEM data type (enter - for default):
                        0: FLOAT (default)
                        1: SHORT integer
          zflg        zero data handling (enter - for default):
                        0: 0.0 interpreted at missing value (default)
                        1: 0.0 interpreted as valid data
          scale       power-law display scale factor (enter - for default: 1.0)
          exp         power-law display exponent (enter - for default: 1.00)
          illum_mode  illumination mode (enter - for default)
                        0: single angle (default)
                        1: multiple angle
          sharpness   shaded relief sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes
          shade       (output) shaded relief intensity image (FLOAT) (enter - for none)

        """
        if self.validate_inputs:
            self._validate_rasshd(
                DEM,
                width,
                col_post,
                row_post,
                start,
                nlines,
                pixavx,
                pixavy,
                theta0,
                phi0,
                rasf,
                dtype,
                zflg,
                scale,
                exp,
                illum_mode,
                sharpness,
                edge,
                shade,
            )
        if self.mock_outputs:
            self._mock_rasshd_outputs(
                DEM,
                width,
                col_post,
                row_post,
                start,
                nlines,
                pixavx,
                pixavy,
                theta0,
                phi0,
                rasf,
                dtype,
                zflg,
                scale,
                exp,
                illum_mode,
                sharpness,
                edge,
                shade,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasshd))
        return self._gamma_call("DISP", "rasshd", supplied_args)

    def _validate_dis2mph(
        self,
        data1: Path,
        data2: Path,
        width1: Any,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        self._validate("dis2mph", data1.exists(), f"data1 path does not exist ({data1})")
        self._validate("dis2mph", data2.exists(), f"data2 path does not exist ({data2})")

    def _mock_dis2mph_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: Any,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        pass

    def dis2mph(
        self,
        data1: Path,
        data2: Path,
        width1: Any,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2mph
        Display the scaled intensity and phase of 2 complex images (FCOMPLEX, SCOMPLEX, BCOMPLEX)


        input parameters:
          data1   (input) complex data1 (FCOMPLEX, SCOMPLEX)
          data2   (input) complex data2 (same data type as data1)
          width1  data samples per row of data1
          width2  data samples per row of data2
          start   starting line of cpx1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          scale   display scale factor (enter - for default: 1.0)
          exp     display exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   input data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
                    2: BCOMPLEX
          sc_ave  average intensity used to scale images (enter - for default: determined from data)

        """
        if self.validate_inputs:
            self._validate_dis2mph(
                data1, data2, width1, width2, start, nlines, xoff, yoff, scale, exp, cmap, dtype, sc_ave
            )
        if self.mock_outputs:
            self._mock_dis2mph_outputs(
                data1, data2, width1, width2, start, nlines, xoff, yoff, scale, exp, cmap, dtype, sc_ave
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2mph))
        return self._gamma_call("DISP", "dis2mph", supplied_args)

    def _validate_poly2kml(
        self, DEM_par: Path, ras: Path, poly_in: Path, kml: Path, poly_out: Optional[Path] = None
    ) -> None:
        self._validate("poly2kml", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("poly2kml", ras.exists(), f"ras path does not exist ({ras})")
        self._validate("poly2kml", poly_in.exists(), f"poly_in path does not exist ({poly_in})")

    def _mock_poly2kml_outputs(
        self, DEM_par: Path, ras: Path, poly_in: Path, kml: Path, poly_out: Optional[Path] = None
    ) -> None:
        if kml is not None and str(kml) != "-":
            kml.touch()
        if poly_out is not None and str(poly_out) != "-":
            poly_out.touch()

    def poly2kml(
        self, DEM_par: Path, ras: Path, poly_in: Path, kml: Path, poly_out: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Generate a KML file from a polygon drawn on a georeferenced image


        input parameters:
          DEM_par     (input) DEM/MAP parameter file
          ras         (input) raster image (SUN/BMP/TIFF format, enter - for none)
          poly_in     (input) file containing polygon corner coordinates (enter - for none)
          kml         (output) KML file containing georeferenced polygon corner coordinates
          poly_out    (output) file containing polygon corner coordinates (enter - for none)

          NOTE: the KML file can be created in two ways:
          1. An existing polygon file <poly_in> is used as input to directly generate the KML file using the information
             in the <DEM_par> file. No raster image is used in that case (<ras> is ignored if specified in the command).
          2. A graphical interface permits drawing the polygon(s) over the background raster image using the mouse.
             A raster image <ras> corresponding to the <DEM_par> must be specified and - must be entered for <poly_in>.

        """
        if self.validate_inputs:
            self._validate_poly2kml(DEM_par, ras, poly_in, kml, poly_out)
        if self.mock_outputs:
            self._mock_poly2kml_outputs(DEM_par, ras, poly_in, kml, poly_out)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.poly2kml))
        return self._gamma_call("DISP", "poly2kml", supplied_args)

    def _validate_dis2SLC(
        self,
        data1: Path,
        data2: Path,
        width1: Any,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("dis2SLC", data1.exists(), f"data1 path does not exist ({data1})")
        self._validate("dis2SLC", data2.exists(), f"data2 path does not exist ({data2})")

    def _mock_dis2SLC_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: Any,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> None:
        pass

    def dis2SLC(
        self,
        data1: Path,
        data2: Path,
        width1: Any,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2SLC
        Display the intensity of 2 complex images (FCOMPLEX, SCOMPLEX) using power-law scaling


        input parameters:
          data1   (input) complex data1 (FCOMPLEX, SCOMPLEX)
          data2   (input) complex data2 (FCOMPLEX. SCOMPLEX, same type as data1)
          width1  data samples per row of data1
          width2  data samples per row of data2
          start   starting line of cpx1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          scale   display scale factor (enter - for default: 1.0)
          exp     display exponent (enter - for default: 0.35)
          dtype   input data type (enter - for default)
                    0: FCOMPLEX
                    1: SCOMPLEX (default)

        """
        if self.validate_inputs:
            self._validate_dis2SLC(data1, data2, width1, width2, start, nlines, xoff, yoff, scale, exp, dtype)
        if self.mock_outputs:
            self._mock_dis2SLC_outputs(data1, data2, width1, width2, start, nlines, xoff, yoff, scale, exp, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2SLC))
        return self._gamma_call("DISP", "dis2SLC", supplied_args)

    def _validate_raspwr(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        self._validate("raspwr", data.exists(), f"data path does not exist ({data})")

    def _mock_raspwr_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def raspwr(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/raspwr
        Calculate a raster image from data (FLOAT or UNSIGNED SHORT) with power-law scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT, UNSIGNED SHORT)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          scale   power-law display scale factor (enter - for default: 1.0)
          exp     power-law display exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   input data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT
          sc_ave  average intensity used to scale image
                  (enter - for default: determined from the data file)

        """
        if self.validate_inputs:
            self._validate_raspwr(data, width, start, nlines, pixavx, pixavy, scale, exp, cmap, rasf, dtype, sc_ave)
        if self.mock_outputs:
            self._mock_raspwr_outputs(data, width, start, nlines, pixavx, pixavy, scale, exp, cmap, rasf, dtype, sc_ave)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.raspwr))
        return self._gamma_call("DISP", "raspwr", supplied_args)

    def _validate_disSLC(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("disSLC", data.exists(), f"data path does not exist ({data})")

    def _mock_disSLC_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> None:
        pass

    def disSLC(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/disSLC
        Display complex data (FCOMPLEX, SCOMPLEX) intensity using power-law scaling


        input parameters:
          data    (input) input data (FCOMPLEX, SCOMPLEX SLC)
          width   number of samples/row of the data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          scale   power-law scale factor, (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          dtype   data type (enter - for default)
                    0: FCOMPLEX
                    1: SCOMPLEX (default)
        """
        if self.validate_inputs:
            self._validate_disSLC(data, width, start, nlines, scale, exp, dtype)
        if self.mock_outputs:
            self._mock_disSLC_outputs(data, width, start, nlines, scale, exp, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disSLC))
        return self._gamma_call("DISP", "disSLC", supplied_args)

    def _validate_ras8_colormap(
        self,
        model: int,
        h0: Any,
        hrange: Any,
        ival: Any,
        sat: Any,
        cm: Path,
        cm_ras: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[Path] = None,
    ) -> None:
        pass

    def _mock_ras8_colormap_outputs(
        self,
        model: int,
        h0: Any,
        hrange: Any,
        ival: Any,
        sat: Any,
        cm: Path,
        cm_ras: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[Path] = None,
    ) -> None:
        if cm is not None and str(cm) != "-":
            cm.touch()
        if cm_ras is not None and str(cm_ras) != "-":
            cm_ras.touch()

    def ras8_colormap(
        self,
        model: int,
        h0: Any,
        hrange: Any,
        ival: Any,
        sat: Any,
        cm: Path,
        cm_ras: Optional[Path] = None,
        width: Optional[int] = None,
        nlines: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras8_colormap
        Generate 8-bit raster color map with 256 levels


        input parameters:
          model   color model selection flag:
                    0: CMY color model used in Gamma Software (default)
                    1: HLS (double hexagon color model)
                    2: HSV (single hexagon color model)
                    3: SIN (sinusoidal color model)
          h0      starting hue (color for starting value)
          hrange  range of hue values in degrees (-360. ... 360)
          ival    relative brightness value (0.0 ... 1.0)
          sat     color saturation value (0.0 ... 1.0)
          cm      (output) text format colormap with 256 entries, triplets of R,G,B 0->255
          cm_ras  (output) raster image of the colormap, 512 samples wide x 32 lines (enter - for none, extension determines the format)
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          width   colorbar raster image width in pixels (enter - for default: 512)
          nlines  colorbar raster image height in lines (enter - for default: 32)

        """
        if self.validate_inputs:
            self._validate_ras8_colormap(model, h0, hrange, ival, sat, cm, cm_ras, width, nlines)
        if self.mock_outputs:
            self._mock_ras8_colormap_outputs(model, h0, hrange, ival, sat, cm, cm_ras, width, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras8_colormap))
        return self._gamma_call("DISP", "ras8_colormap", supplied_args)

    def _validate_cp_data(
        self,
        infile: Path,
        outfile: Path,
        lbytes: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        offset: Optional[Any] = None,
        file_ldr: Optional[Any] = None,
        offb: Optional[Any] = None,
        nbyte: Optional[int] = None,
    ) -> None:
        self._validate("cp_data", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_cp_data_outputs(
        self,
        infile: Path,
        outfile: Path,
        lbytes: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        offset: Optional[Any] = None,
        file_ldr: Optional[Any] = None,
        offb: Optional[Any] = None,
        nbyte: Optional[int] = None,
    ) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def cp_data(
        self,
        infile: Path,
        outfile: Path,
        lbytes: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        offset: Optional[Any] = None,
        file_ldr: Optional[Any] = None,
        offb: Optional[Any] = None,
        nbyte: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP cp_data: File copy utility


        input parameters:
          infile    (input) input data file
          outfile   (output) output data file
          lbytes    number of bytes per row of input file
          start     starting line (enter - for default: 1)
          nlines    number of lines to copy (enter - or 0 for default: to end of file)
          offset    offset in bytes from the start of the file to skip (enter - for default: 0)
          file_ldr  size of file leader (bytes) to copy after a skipping [offset] (enter - for default: 0)
          offb      offset in bytes for each line to start copy (enter - for default: 0)
          nbyte     number of bytes to copy from each line (enter - for default: (lbytes - offb))

        """
        if self.validate_inputs:
            self._validate_cp_data(infile, outfile, lbytes, start, nlines, offset, file_ldr, offb, nbyte)
        if self.mock_outputs:
            self._mock_cp_data_outputs(infile, outfile, lbytes, start, nlines, offset, file_ldr, offb, nbyte)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cp_data))
        return self._gamma_call("DISP", "cp_data", supplied_args)

    def _validate_uchar2float(self, infile: Path, outfile: Any, scale: Any, exp: Any, offset: Any) -> None:
        self._validate("uchar2float", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_uchar2float_outputs(self, infile: Path, outfile: Any, scale: Any, exp: Any, offset: Any) -> None:
        pass

    def uchar2float(self, infile: Path, outfile: Any, scale: Any, exp: Any, offset: Any) -> Tuple[int, str, str]:
        """

        DISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/uchar2float.c
        Format transformation from unsigned char (1-byte) to float (4-byte)
        output = scale * (data + offset)^exp (for coherence use scale=0.00392, exp=1.0)


        input parameters:
          data_in   (input) input data file (unsigned char, 1 byte/sample)
          data_out  (output output file (float)
          scale     scale factor (default: 1.0)
          exp       exponent (default: 1.0)
          offset    offset (default: 0.0)

        """
        if self.validate_inputs:
            self._validate_uchar2float(infile, outfile, scale, exp, offset)
        if self.mock_outputs:
            self._mock_uchar2float_outputs(infile, outfile, scale, exp, offset)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.uchar2float))
        return self._gamma_call("DISP", "uchar2float", supplied_args)

    def _validate_float2gbyte(self, infile: Path, outfile: Path) -> None:
        self._validate("float2gbyte", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_float2gbyte_outputs(self, infile: Path, outfile: Path) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def float2gbyte(self, infile: Path, outfile: Path) -> Tuple[int, str, str]:
        """

        Convert FLOAT format data to GBYTE logarithmic scaled format (1 byte/value)


        input parameters:
          infile   (input) FLOAT format data (4 bytes/sample)
          outfile  (output) GBYTE logarithmic scaled format data (1 byte/sample)
        """
        if self.validate_inputs:
            self._validate_float2gbyte(infile, outfile)
        if self.mock_outputs:
            self._mock_float2gbyte_outputs(infile, outfile)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2gbyte))
        return self._gamma_call("DISP", "float2gbyte", supplied_args)

    def _validate_kml_plan(
        self,
        MLI_par: Path,
        DEM_par: Path,
        lookup_table: Path,
        kml: Path,
        geoid: Optional[Path] = None,
        geoid_par: Optional[Path] = None,
        extension: Optional[Any] = None,
        flight_path: Optional[int] = None,
        t_event: Optional[Any] = None,
        pt_list: Optional[Path] = None,
    ) -> None:
        self._validate("kml_plan", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("kml_plan", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")
        self._validate("kml_plan", lookup_table.exists(), f"lookup_table path does not exist ({lookup_table})")
        if geoid is not None:
            self._validate("kml_plan", geoid.exists(), f"geoid path does not exist ({geoid})")
        if geoid_par is not None:
            self._validate("kml_plan", geoid_par.exists(), f"geoid_par path does not exist ({geoid_par})")
        if pt_list is not None:
            self._validate("kml_plan", pt_list.exists(), f"pt_list path does not exist ({pt_list})")

    def _mock_kml_plan_outputs(
        self,
        MLI_par: Path,
        DEM_par: Path,
        lookup_table: Path,
        kml: Path,
        geoid: Optional[Path] = None,
        geoid_par: Optional[Path] = None,
        extension: Optional[Any] = None,
        flight_path: Optional[int] = None,
        t_event: Optional[Any] = None,
        pt_list: Optional[Path] = None,
    ) -> None:
        if kml is not None and str(kml) != "-":
            kml.touch()

    def kml_plan(
        self,
        MLI_par: Path,
        DEM_par: Path,
        lookup_table: Path,
        kml: Path,
        geoid: Optional[Path] = None,
        geoid_par: Optional[Path] = None,
        extension: Optional[Any] = None,
        flight_path: Optional[int] = None,
        t_event: Optional[Any] = None,
        pt_list: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate a KML file containing a polygon corresponding to the scene area and a line corresponding to the platform path during the acquisition


        input parameters:
          MLI_par         (input) MLI or SLC image parameter file (slant range geometry)
          DEM_par         (input) DEM/MAP parameter file
          lookup_table    (input) geocoding lookup table (fcomplex, original DEM geometry)
          kml             (output) kml output file
          geoid           (input) global geoid (float, egm96 or egm2008) or constant geoid height value (enter - for none)
          geoid_par       (input) global geoid DEM_par file (enter - for none)
          extension       extension length before and after acquisition for waypoint calculation (enter - for default: 1852.0 m)
          flight_path     flight path visualization option: (enter - for default)
                            0: show flight path and flight path clamped to the ground (default)
                            1: do not show the flight path clamped to the ground
                            2: do not show the flight path
          t_event         additional event markers are added "t_event" seconds ahead of the actual event markers (enter - for default: 0.0 seconds)
          pt_list         (input) list of points triggering event markers (three columns, csv format: pt_name; east/lon/c; north/lat/s) (enter - for none)
        """
        if self.validate_inputs:
            self._validate_kml_plan(
                MLI_par, DEM_par, lookup_table, kml, geoid, geoid_par, extension, flight_path, t_event, pt_list
            )
        if self.mock_outputs:
            self._mock_kml_plan_outputs(
                MLI_par, DEM_par, lookup_table, kml, geoid, geoid_par, extension, flight_path, t_event, pt_list
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.kml_plan))
        return self._gamma_call("DISP", "kml_plan", supplied_args)

    def _validate_kml_map(self, image: Path, dem_par: Path, kml: Path) -> None:
        self._validate("kml_map", image.exists(), f"image path does not exist ({image})")
        self._validate("kml_map", dem_par.exists(), f"dem_par path does not exist ({dem_par})")

    def _mock_kml_map_outputs(self, image: Path, dem_par: Path, kml: Path) -> None:
        if kml is not None and str(kml) != "-":
            kml.touch()

    def kml_map(self, image: Path, dem_par: Path, kml: Path) -> Tuple[int, str, str]:
        """

        DISP kml_map: Create KML file with link to image


        input parameters:
          image   (input) URL of background image in bmp, png or jpg format,
                  needs to be in EQA projection with WGS84 for Google Earth
          dem_par (input) corresponding dem_par file
          kml     (output) kml output file (default = *.kml)

        """
        if self.validate_inputs:
            self._validate_kml_map(image, dem_par, kml)
        if self.mock_outputs:
            self._mock_kml_map_outputs(image, dem_par, kml)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.kml_map))
        return self._gamma_call("DISP", "kml_map", supplied_args)

    def _validate_ras_dB(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        self._validate("ras_dB", data.exists(), f"data path does not exist ({data})")

    def _mock_ras_dB_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras_dB(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_abs: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras_dB
        Calculate a raster image from data (FLOAT or UNSIGNED SHORT) using logarithmic scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT or UNSIGNED SHORT)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          min     minimum data value (enter - for default: -10.00 dB)
          max     maximum data value (enter - for default: 10.00 dB)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   input data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT
          sc_abs  absolute scaling flag:
                    0: scaling relative to average (min_dB + av_dB) -> (max_dB + av_dB) (default)
                       NOTE: av_dB is the average image intensity dB
                    1: absolute image scaling range: min_dB -> max_dB

        """
        if self.validate_inputs:
            self._validate_ras_dB(data, width, start, nlines, pixavx, pixavy, min, max, cmap, rasf, dtype, sc_abs)
        if self.mock_outputs:
            self._mock_ras_dB_outputs(data, width, start, nlines, pixavx, pixavy, min, max, cmap, rasf, dtype, sc_abs)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_dB))
        return self._gamma_call("DISP", "ras_dB", supplied_args)

    def _validate_thres_data(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        t_data: Path,
        t_min: Any,
        t_max: Any,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("thres_data", data_in.exists(), f"data_in path does not exist ({data_in})")
        self._validate("thres_data", t_data.exists(), f"t_data path does not exist ({t_data})")

    def _mock_thres_data_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        t_data: Path,
        t_min: Any,
        t_max: Any,
        dtype: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def thres_data(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        t_data: Path,
        t_min: Any,
        t_max: Any,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Data are set to 0 where t_data < t_min or t_data > t_max  (FLOAT, FCOMPLEX, or SUN/BMP/TIFF raster format)***


        input parameters:
          data_in     (input) data file (FLOAT, FCOMPLEX, or SUN/BMP/TIFF raster format)
          width       width of input data file and threshold data file
          data_out    (output) data file, same data format as input data
                      all points in data_in are set to 0.0 where thres_data < tmin or thres_data > t_max
          t_data      (input) data used for threshold test (FLOAT format)
          t_min       minimum threshold data value (FLOAT)
          t_max       maximum threshold data value (FLOAT)
          dtype       data type (enter - for default)
                        0: FLOAT (default)
                        1: FCOMPLEX
                        2: SUN/BMP/TIFF raster image

        """
        if self.validate_inputs:
            self._validate_thres_data(data_in, width, data_out, t_data, t_min, t_max, dtype)
        if self.mock_outputs:
            self._mock_thres_data_outputs(data_in, width, data_out, t_data, t_min, t_max, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.thres_data))
        return self._gamma_call("DISP", "thres_data", supplied_args)

    def _validate_distree(
        self,
        flag: Path,
        unw: Path,
        int: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[Any] = None,
    ) -> None:
        self._validate("distree", flag.exists(), f"flag path does not exist ({flag})")
        self._validate("distree", unw.exists(), f"unw path does not exist ({unw})")
        self._validate("distree", int.exists(), f"int path does not exist ({int})")

    def _mock_distree_outputs(
        self,
        flag: Path,
        unw: Path,
        int: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[Any] = None,
    ) -> None:
        pass

    def distree(
        self,
        flag: Path,
        unw: Path,
        int: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP distree: display of unwrapped phase + wrapped phase + flags


        input parameters:
          flag      (input) phase unwrapping flag file (unsigned char)
          unw       (input) unwrapped phase image (enter - for None) (FLOAT)
          int       (input) complex interferogram (wrapped) (enter - for None) (FCOMPLEX)
          width     samples per row of flag, unw, and int
          start     starting line of flag, unw, and int (enter - for default: 1)
          nlines    number of lines to display (enter - or 0 for default: to end of file)
          ph_scale  unwrapped phase display scale factor (enter - for default: 0.33333)

        """
        if self.validate_inputs:
            self._validate_distree(flag, unw, int, width, start, nlines, ph_scale)
        if self.mock_outputs:
            self._mock_distree_outputs(flag, unw, int, width, start, nlines, ph_scale)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.distree))
        return self._gamma_call("DISP", "distree", supplied_args)

    def _validate_dis_linear(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("dis_linear", data.exists(), f"data path does not exist ({data})")

    def _mock_dis_linear_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        pass

    def dis_linear(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis_linear
        Display of data (FLOAT, UNSIGNED SHORT, SIGNED SHORT, or UNSIGNED BYTE) with linear scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT, UNSIGNED SHORT, or UNSIGNED BYTE)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          min     data display minimum (enter - for default: 0.000)
          max     data display maximum (enter - for default: 1.000)
          cflg    cyclic data display flag (enter - for default)
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max-min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT (2-byte integer)
                    2: SIGNED SHORT (2-byte integer)
                    3: UNSIGNED BYTE

        """
        if self.validate_inputs:
            self._validate_dis_linear(data, width, start, nlines, min, max, cflg, cmap, dtype)
        if self.mock_outputs:
            self._mock_dis_linear_outputs(data, width, start, nlines, min, max, cflg, cmap, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis_linear))
        return self._gamma_call("DISP", "dis_linear", supplied_args)

    def _validate_disdem_par(
        self,
        DEM: Path,
        DEM_par: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        exaggerate: Optional[Any] = None,
        theta0: Optional[Any] = None,
        phi0: Optional[Any] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
    ) -> None:
        self._validate("disdem_par", DEM.exists(), f"DEM path does not exist ({DEM})")
        self._validate("disdem_par", DEM_par.exists(), f"DEM_par path does not exist ({DEM_par})")

    def _mock_disdem_par_outputs(
        self,
        DEM: Path,
        DEM_par: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        exaggerate: Optional[Any] = None,
        theta0: Optional[Any] = None,
        phi0: Optional[Any] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
    ) -> None:
        pass

    def disdem_par(
        self,
        DEM: Path,
        DEM_par: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        exaggerate: Optional[Any] = None,
        theta0: Optional[Any] = None,
        phi0: Optional[Any] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP disdem_par: Display DEM with DEM/MAP parameter file as shaded relief


        input parameters:
          DEM         (input) Digital elevation model (FLOAT or SHORT as specified in DEM_par)
          DEM_par     (input) DIFF/GEO DEM parameter file
          start       starting line of DEM (enter - for default: 1)
          nlines      number of lines to display (enter - or 0 for default: to end of file)
          exaggerate  relief exaggeration factor to increase contrast of display (enter - for default: 1.0)
          theta0      illumination elevation angle in deg. (enter - for default: 45.0)
          phi0        illumination orientation angle in deg. (enter - for default: 135.0)
                      (0.: right, 90: top, 180: left, 270: bottom)
          illum_mode  illumination mode (enter - for default)
                        0: single angle (default)
                        1: multiple angle
          sharpness   shaded relief sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes

        """
        if self.validate_inputs:
            self._validate_disdem_par(
                DEM, DEM_par, start, nlines, exaggerate, theta0, phi0, illum_mode, sharpness, edge
            )
        if self.mock_outputs:
            self._mock_disdem_par_outputs(
                DEM, DEM_par, start, nlines, exaggerate, theta0, phi0, illum_mode, sharpness, edge
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disdem_par))
        return self._gamma_call("DISP", "disdem_par", supplied_args)

    def _validate_gcp_2ras(
        self, ras1: Path, ras2: Path, gcp: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> None:
        self._validate("gcp_2ras", ras1.exists(), f"ras1 path does not exist ({ras1})")
        self._validate("gcp_2ras", ras2.exists(), f"ras2 path does not exist ({ras2})")

    def _mock_gcp_2ras_outputs(
        self, ras1: Path, ras2: Path, gcp: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> None:
        if gcp is not None and str(gcp) != "-":
            gcp.touch()

    def gcp_2ras(
        self, ras1: Path, ras2: Path, gcp: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        DISP gcp_2ras: Display 2 SUN raster, BMP, or TIFF format images and select corresponding pairs of points for ground control


        input parameters:
          ras1    (input) image 1, SUN raster: *.ras, BMP: *.bmp, TIFF: *.tif
          ras2    (input) image 2, SUN raster: *.ras, BMP: *.bmp, TIFF: *.tif
                  NOTE: the image depth (bits/pixel) of ras1 and ras2 must be the same
          gcp     (output) ground control point file (text format)
          mag     zoom magnification factor (enter - for default: 3)
          win_sz  zoom window size before magnification (enter - for default: 132)

        """
        if self.validate_inputs:
            self._validate_gcp_2ras(ras1, ras2, gcp, mag, win_sz)
        if self.mock_outputs:
            self._mock_gcp_2ras_outputs(ras1, ras2, gcp, mag, win_sz)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gcp_2ras))
        return self._gamma_call("DISP", "gcp_2ras", supplied_args)

    def _validate_ras_linear(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("ras_linear", data.exists(), f"data path does not exist ({data})")

    def _mock_ras_linear_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras_linear(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras_linear
        Calculate a raster image (FLOAT, UNSIGNED SHORT, SIGNED SHORT, or UNSIGNED BYTE) with linear scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT, UNSIGNED SHORT, or UNSIGNED BYTE)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          min     minimum data value (enter - for default: 0.000)
          max     maximum data value (enter - for default: 1.000)
          cflg    cyclic data display flag:
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max - min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   input data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT (2-byte integer)
                    2: SIGNED SHORT (2-byte integer)
                    3: UNSIGNED BYTE

        """
        if self.validate_inputs:
            self._validate_ras_linear(data, width, start, nlines, pixavx, pixavy, min, max, cflg, cmap, rasf, dtype)
        if self.mock_outputs:
            self._mock_ras_linear_outputs(data, width, start, nlines, pixavx, pixavy, min, max, cflg, cmap, rasf, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_linear))
        return self._gamma_call("DISP", "ras_linear", supplied_args)

    def _validate_tree_edit(
        self, flag: Path, ras: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> None:
        self._validate("tree_edit", flag.exists(), f"flag path does not exist ({flag})")
        self._validate("tree_edit", ras.exists(), f"ras path does not exist ({ras})")

    def _mock_tree_edit_outputs(
        self, flag: Path, ras: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> None:
        pass

    def tree_edit(
        self, flag: Path, ras: Path, mag: Optional[Any] = None, win_sz: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        DISP tree_edit: edit phase unwrapping flag file


        input parameters:
          flag    (input) phase unwrapping flag file with same dimensions as the raster overlay image
          ras     (input) 8-bit raster overlay image (Sun raster: *.ras, BMP: *.bmp, or TIFF: *.tif)
          mag     magnification factor (enter - for default: 5)
          win_sz  size of input data region to be magnified (enter - for default: 80)

        """
        if self.validate_inputs:
            self._validate_tree_edit(flag, ras, mag, win_sz)
        if self.mock_outputs:
            self._mock_tree_edit_outputs(flag, ras, mag, win_sz)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.tree_edit))
        return self._gamma_call("DISP", "tree_edit", supplied_args)

    def _validate_discpx(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        self._validate("discpx", data.exists(), f"data path does not exist ({data})")

    def _mock_discpx_outputs(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        pass

    def discpx(
        self,
        data: Path,
        width: int,
        mode: Optional[int] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/discpx
        Display of data (FCOMPLEX, SCOMPLEX) using linear, logarithmic, or power-law scaling using a specified colormap


        input parameters:
          data   (input) data (FCOMPLEX, SCOMPLEX)
          width  number of samples/row of data
          mode   display mode (enter - for default: power-law scaling)
                   0: intensity with power-law scaling (scale and exp), default colormap: gray.cm, (default)
                   1: intensity with logarithmic scaling min -> max (dB), default colormap: gray.cm
                   2: real component, scaling min -> max, default colormap: hls.cm
                   3: imaginary component, scaling min -> max, default colormap: hls.cm
                   4: phase, scaling min -> max, default colormap: default colormap rmg.cm
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          min     data display minimum (enter - for default mode 0: not used, mode 1: -10 dB, modes 2,3: -1.0, mode 4: -PI)
          max     data display maximum (enter - for default mode 0: not used, mode 1: +16 dB, modes 2,3: +1.0, mode 4: +PI)
          cmap    colormap file (enter - for default)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   power-law scale factor, (enter - for default: 1.0) (mode 0 only)
          exp     power-law exponent (enter - for default: 0.35) (mode 0 only)
          dtype   data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
          sc_ave  average intensity used to calculate image scaling (modes 0 and 1)
                  (enter - for default: determined from the input data file)

        """
        if self.validate_inputs:
            self._validate_discpx(data, width, mode, start, nlines, min, max, cmap, scale, exp, dtype, sc_ave)
        if self.mock_outputs:
            self._mock_discpx_outputs(data, width, mode, start, nlines, min, max, cmap, scale, exp, dtype, sc_ave)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.discpx))
        return self._gamma_call("DISP", "discpx", supplied_args)

    def _validate_fill(self, d1: Path, d2: Path, dout: Path, width: int) -> None:
        self._validate("fill", d1.exists(), f"d1 path does not exist ({d1})")
        self._validate("fill", d2.exists(), f"d2 path does not exist ({d2})")

    def _mock_fill_outputs(self, d1: Path, d2: Path, dout: Path, width: int) -> None:
        if dout is not None and str(dout) != "-":
            dout.touch()

    def fill(self, d1: Path, d2: Path, dout: Path, width: int) -> Tuple[int, str, str]:
        """

        DISP Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/fill
        Fill gaps in data file 1 with values from data file 2 or a constant value (float format)


        input parameters:
          d1     (input) data file 1 (float)
          d2     (input) data file 2 used to fill gaps in d1, or a constant value (float)
          dout   (output) d1 with gaps filled (float)
          width  number of samples/line

        """
        if self.validate_inputs:
            self._validate_fill(d1, d2, dout, width)
        if self.mock_outputs:
            self._mock_fill_outputs(d1, d2, dout, width)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.fill))
        return self._gamma_call("DISP", "fill", supplied_args)

    def _validate_dis2pwr(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        self._validate("dis2pwr", data1.exists(), f"data1 path does not exist ({data1})")
        self._validate("dis2pwr", data2.exists(), f"data2 path does not exist ({data2})")

    def _mock_dis2pwr_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        pass

    def dis2pwr(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2pwr
        Display 2 intensity images (FLOAT, UNSIGNED SHORT) with power-law scaling using a specified colormap


        input parameters:
          data1    (input) data1 (FLOAT, UNSIGNED SHORT)
          data2    (input) data2 (same data type as data1)
          width1   number of samples/row of data1
          width2   number of samples/row of data2
          start    starting line of data (enter - for default: 1)
          nlines   number of lines to display (enter - or 0 for default: to end of file)
          xoff     x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff     y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          scale    power-law scale factor (enter - for default: 1.0)
          exp      power-law exponent (enter - for default: 0.35)
          cmap     colormap file (enter - for default: gray.cm)
                   NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                         colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype    data type (enter - for default)
                     0: FLOAT (default)
                     1: UNSIGNED SHORT
          sc_ave   average intensity used to scale images (enter - for default: determined from data)

        """
        if self.validate_inputs:
            self._validate_dis2pwr(
                data1, data2, width1, width2, start, nlines, xoff, yoff, scale, exp, cmap, dtype, sc_ave
            )
        if self.mock_outputs:
            self._mock_dis2pwr_outputs(
                data1, data2, width1, width2, start, nlines, xoff, yoff, scale, exp, cmap, dtype, sc_ave
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2pwr))
        return self._gamma_call("DISP", "dis2pwr", supplied_args)

    def _validate_dispwr(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        self._validate("dispwr", data.exists(), f"data path does not exist ({data})")

    def _mock_dispwr_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        pass

    def dispwr(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dispwr
        Display intensity data (FLOAT or UNSIGNED SHORT) with power-law scaling using a specified colormap


        input parameters:
          data    (input) data (FLOAT, UNSIGNED SHORT)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          scale   power-law scale factor (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT
          sc_ave  average intensity used to scale image (enter - for default: determined from data)

        """
        if self.validate_inputs:
            self._validate_dispwr(data, width, start, nlines, scale, exp, cmap, dtype, sc_ave)
        if self.mock_outputs:
            self._mock_dispwr_outputs(data, width, start, nlines, scale, exp, cmap, dtype, sc_ave)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dispwr))
        return self._gamma_call("DISP", "dispwr", supplied_args)

    def _validate_rasSLC(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("rasSLC", data.exists(), f"data path does not exist ({data})")

    def _mock_rasSLC_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rasSLC(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasSLC
        Calculate a multilook intensity raster image from complex data (FCOMPLEX, SCOMPLEX) using power-law scaling


        input parameters:
          data    (input) input data (FCOMPLEX, SCOMPLEX SLC)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          scale   power-law scale factor, (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   data type (enter - for default)
                    0: FCOMPLEX
                    1: SCOMPLEX (default)
        """
        if self.validate_inputs:
            self._validate_rasSLC(data, width, start, nlines, pixavx, pixavy, scale, exp, rasf, dtype)
        if self.mock_outputs:
            self._mock_rasSLC_outputs(data, width, start, nlines, pixavx, pixavy, scale, exp, rasf, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasSLC))
        return self._gamma_call("DISP", "rasSLC", supplied_args)

    def _validate_short2float(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("short2float", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_short2float_outputs(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def short2float(
        self,
        infile: Path,
        outfile: Path,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP short2float: Convert short 2-byte integers to floating point format


        input parameters:
          infile   (input) input data file (SHORT integers, 2 bytes/sample)
          outfile  (output) output data file (FLOAT, 4 bytes/sample)
          scale    scale factor (enter - for default: 1.0)
          exp      exponent (enter - for default: 1.0)
          dtype    input data type (enter - for default)
                     0: SHORT (int16, default)
                     1: UNSIGNED SHORT (uint16)

        NOTE: output = scale*input^exp  (for SAR backscatter use scale=0.000001, exp=2.0)

        """
        if self.validate_inputs:
            self._validate_short2float(infile, outfile, scale, exp, dtype)
        if self.mock_outputs:
            self._mock_short2float_outputs(infile, outfile, scale, exp, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.short2float))
        return self._gamma_call("DISP", "short2float", supplied_args)

    def _validate_ras8_color_scale(
        self,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[Any] = None,
        hrange: Optional[Any] = None,
        ival: Optional[Any] = None,
        sat: Optional[Any] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        chip_height: Optional[int] = None,
        nval: Optional[int] = None,
    ) -> None:
        pass

    def _mock_ras8_color_scale_outputs(
        self,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[Any] = None,
        hrange: Optional[Any] = None,
        ival: Optional[Any] = None,
        sat: Optional[Any] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        chip_height: Optional[int] = None,
        nval: Optional[int] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras8_color_scale(
        self,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[Any] = None,
        hrange: Optional[Any] = None,
        ival: Optional[Any] = None,
        sat: Optional[Any] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        chip_height: Optional[int] = None,
        nval: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras8_color_scale
        Generate 8-bit raster graphics image of the selected color scale


        input parameters:
          rasf         (output) image filename, extension determines the format
                         *.bmp BMP format
                         *.ras Sun raster format
                         *.tif TIFF format
          color_model  color model selection flag: (enter - for default)
                         0: CMY color model used in Gamma Software (default)
                         1: HLS (double hexagon color model)
                         2: HSV (single hexagon color model)
                         3: SIN (sinusoidal color model)
          h0           starting hue (color for starting value, enter - for default: 0.0)
          hrange       range of hue values in degrees (-360. ... 360., enter - for default: 360.0)
          ival         relative brightness value (0.0 ... 1.0, enter - for default: 0.80)
          sat          color saturation value (0.0 ... 1.0, enter - for default: 0.75)
          chip_width   width of color chips (enter - for default: 8)
          gap          number of pixels between color chips (enter - for default: 1)
          chip_height  height of color chips (enter - for default: chip_width)
          nval         number of color chips (enter - for default: 16)

        """
        if self.validate_inputs:
            self._validate_ras8_color_scale(
                rasf, color_model, h0, hrange, ival, sat, chip_width, gap, chip_height, nval
            )
        if self.mock_outputs:
            self._mock_ras8_color_scale_outputs(
                rasf, color_model, h0, hrange, ival, sat, chip_width, gap, chip_height, nval
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras8_color_scale))
        return self._gamma_call("DISP", "ras8_color_scale", supplied_args)

    def _validate_rasmph(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        self._validate("rasmph", data.exists(), f"data path does not exist ({data})")

    def _mock_rasmph_outputs(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rasmph(
        self,
        data: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavx: Optional[int] = None,
        pixavy: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        cmap: Optional[Path] = None,
        rasf: Optional[Path] = None,
        dtype: Optional[int] = None,
        bits: Optional[int] = None,
        sc_ave: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rasmph
        Calculate a raster image of data (FCOMPLEX, SCOMPLEX, BCOMPLEX) using a specified colormap and power-law scaled intensity


        input parameters:
          data    (input) data (FCOMPLEX, SCOMPLEX, BCOMPLEX)
          width   number of samples/row of data
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          pixavx  number of pixels to average across (enter - for default: 1)
          pixavy  number of pixels to average down   (enter - for default: 1)
          scale   power-law scale factor, (enter - for default: 1.0)
          exp     power-law exponent (enter - for default: 0.35)
          cmap    colormap file (enter - for default: rmg.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          rasf    (output) image filename, extension determines the format, enter - for default: *.bmp
                    *.bmp BMP format
                    *.ras Sun raster format
                    *.tif TIFF format
          dtype   input data type (enter - for default)
                    0: FCOMPLEX (default)
                    1: SCOMPLEX
                    2: BCOMPLEX
          bits    bits/pixel:
                    8:  8-bit indexed color map (default)
                    24: RGB 8-bits/color
          sc_ave  average intensity used to scale image
                  (enter - for default: determined from data)

        """
        if self.validate_inputs:
            self._validate_rasmph(
                data, width, start, nlines, pixavx, pixavy, scale, exp, cmap, rasf, dtype, bits, sc_ave
            )
        if self.mock_outputs:
            self._mock_rasmph_outputs(
                data, width, start, nlines, pixavx, pixavy, scale, exp, cmap, rasf, dtype, bits, sc_ave
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rasmph))
        return self._gamma_call("DISP", "rasmph", supplied_args)

    def _validate_get_value(self, PAR_in: Any, keyword: Any) -> None:
        pass

    def _mock_get_value_outputs(self, PAR_in: Any, keyword: Any) -> None:
        pass

    def get_value(self, PAR_in: Any, keyword: Any) -> Tuple[int, str, str]:
        """

        Search a keyword based parameter using a key and copy the value to stdout


        input parameters:
          PAR_in       input  keyword:value based parameter file
          keyword      search keyword of keyword:value pair

        """
        if self.validate_inputs:
            self._validate_get_value(PAR_in, keyword)
        if self.mock_outputs:
            self._mock_get_value_outputs(PAR_in, keyword)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.get_value))
        return self._gamma_call("DISP", "get_value", supplied_args)

    def _validate_polyras(self, ras: Path, mag: Optional[Any], win_sz: Optional[Any], poly_file: Path) -> None:
        self._validate("polyras", ras.exists(), f"ras path does not exist ({ras})")

    def _mock_polyras_outputs(self, ras: Path, mag: Optional[Any], win_sz: Optional[Any], poly_file: Path) -> None:
        if poly_file is not None and str(poly_file) != "-":
            poly_file.touch()

    def polyras(self, ras: Path, mag: Optional[Any], win_sz: Optional[Any], poly_file: Path) -> Tuple[int, str, str]:
        """

        DISP polyras: polygon selection using a raster image as reference


        input parameters:
          ras        (input) raster image, SUN raster: *.ras, BMP: *.bmp, TIFF: *.tif
          mag        zoom magnification factor (enter - for default: 2)
          win_sz     zoom window size before magnification (enter - for default: 160)
          poly_file  (output) file containing polygon corner coordinates

          NOTE: 1. Use I/O redirection of STDOUT to write to the poly_file:
                        polyras my_image.bmp > poly_file
                2. Do not use raster images with left/right flipped geometry!

        """
        if self.validate_inputs:
            self._validate_polyras(ras, mag, win_sz, poly_file)
        if self.mock_outputs:
            self._mock_polyras_outputs(ras, mag, win_sz, poly_file)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polyras))
        return self._gamma_call("DISP", "polyras", supplied_args)

    def _validate_rastree(
        self,
        flag: Path,
        unw: Path,
        int: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        self._validate("rastree", flag.exists(), f"flag path does not exist ({flag})")
        self._validate("rastree", unw.exists(), f"unw path does not exist ({unw})")
        self._validate("rastree", int.exists(), f"int path does not exist ({int})")

    def _mock_rastree_outputs(
        self,
        flag: Path,
        unw: Path,
        int: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rastree(
        self,
        flag: Path,
        unw: Path,
        int: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        ph_scale: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/rastree
        Generate 8-bit raster graphics image of unwrapped phase, wrapped phase, and unwrapping flags


        input parameters:
          flag      (input) phase unwrapping flag file (unsigned char)
          unw       (input) unwrapped phase image (enter - for None) (FLOAT)
          int       (input) complex interferogram (wrapped) (enter - for None) (FCOMPLEX)
          width     samples per row of flag, unw, and int
          start     starting line of flag, unw, and int (enter - for default: 1)
          nlines    number of lines to display (enter - or 0 for default: to end of file)
          ph_scale  unwrapped phase display scale factor (enter - for default: 0.33333)
          rasf      (output) image filename, extension determines the format, enter - for default: *.bmp
                      *.bmp BMP format
                      *.ras Sun raster format
                      *.tif TIFF format
          NOTE: ph_scale < 1. permits detection of phase unwrapping errors

        """
        if self.validate_inputs:
            self._validate_rastree(flag, unw, int, width, start, nlines, ph_scale, rasf)
        if self.mock_outputs:
            self._mock_rastree_outputs(flag, unw, int, width, start, nlines, ph_scale, rasf)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rastree))
        return self._gamma_call("DISP", "rastree", supplied_args)

    def _validate_disshd(
        self,
        DEM: Path,
        width: int,
        col_post: Any,
        row_post: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        theta0: Optional[Any] = None,
        phi0: Optional[Any] = None,
        dtype: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
    ) -> None:
        self._validate("disshd", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_disshd_outputs(
        self,
        DEM: Path,
        width: int,
        col_post: Any,
        row_post: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        theta0: Optional[Any] = None,
        phi0: Optional[Any] = None,
        dtype: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
    ) -> None:
        pass

    def disshd(
        self,
        DEM: Path,
        width: int,
        col_post: Any,
        row_post: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        theta0: Optional[Any] = None,
        phi0: Optional[Any] = None,
        dtype: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP disshd: Display DEM as shaded relief


        input parameters:
          DEM         (input) digital elevation model (FLOAT or SHORT)
          width       samples per row of DEM
          col_post    posting between cols (same unit as DEM values)
          row_post    posting between rows (same unit as DEM, enter - for default: col_post)
          start       starting line of DEM (enter - for default: 1)
          nlines      number of lines to display (enter - or 0 for default: to end of file)
          theta0      illumination elevation angle in deg. (enter - for default: 45.0)
          phi0        illumination orientation angle in deg. (enter - for default: 135.0)
                      (0.: right, 90: top, 180: left, 270: bottom)
          dtype       data type (enter - for default)
                        0: FLOAT (default)
                        1: SHORT INTEGER
          illum_mode  illumination mode (enter - for default)
                        0: single angle (default)
                        1: multiple angle
          sharpness   shaded relief sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes

        """
        if self.validate_inputs:
            self._validate_disshd(
                DEM, width, col_post, row_post, start, nlines, theta0, phi0, dtype, illum_mode, sharpness, edge
            )
        if self.mock_outputs:
            self._mock_disshd_outputs(
                DEM, width, col_post, row_post, start, nlines, theta0, phi0, dtype, illum_mode, sharpness, edge
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.disshd))
        return self._gamma_call("DISP", "disshd", supplied_args)

    def _validate_dis2gbyte(
        self,
        image1: Path,
        image2: Path,
        width1: Any,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        cmap: Optional[Path] = None,
    ) -> None:
        self._validate("dis2gbyte", image1.exists(), f"image1 path does not exist ({image1})")
        self._validate("dis2gbyte", image2.exists(), f"image2 path does not exist ({image2})")

    def _mock_dis2gbyte_outputs(
        self,
        image1: Path,
        image2: Path,
        width1: Any,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        cmap: Optional[Path] = None,
    ) -> None:
        pass

    def dis2gbyte(
        self,
        image1: Path,
        image2: Path,
        width1: Any,
        width2: Any,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        scale: Optional[Any] = None,
        cmap: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP dis2gbyte: alternating display of two GBYTE format images


        input parameters:
          image1  (input) GBYTE format image 1
          image2  (input) GBYTE format image 2
          width1  samples per row of image1
          width2  samples per row of image2
          start   starting line of image1 (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          scale   display scale factor (enter - for default: 1.0)
          cmap    colormap file (enter - for default: gray.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png

        """
        if self.validate_inputs:
            self._validate_dis2gbyte(image1, image2, width1, width2, start, nlines, xoff, yoff, scale, cmap)
        if self.mock_outputs:
            self._mock_dis2gbyte_outputs(image1, image2, width1, width2, start, nlines, xoff, yoff, scale, cmap)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2gbyte))
        return self._gamma_call("DISP", "dis2gbyte", supplied_args)

    def _validate_ras8_float(
        self,
        f1: Path,
        f2: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[Any] = None,
        hrange: Optional[Any] = None,
        imin: Optional[Any] = None,
        imax: Optional[Any] = None,
        sat: Optional[Any] = None,
        sc1: Optional[Any] = None,
        A1: Optional[Any] = None,
        B1: Optional[Any] = None,
        cyclic1: Optional[Any] = None,
        sc2: Optional[Any] = None,
        A2: Optional[Any] = None,
        B2: Optional[Any] = None,
        start_f1: Optional[Any] = None,
        start_f2: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[Any] = None,
        pixavaz: Optional[Any] = None,
    ) -> None:
        self._validate("ras8_float", f1.exists(), f"f1 path does not exist ({f1})")
        self._validate("ras8_float", f2.exists(), f"f2 path does not exist ({f2})")

    def _mock_ras8_float_outputs(
        self,
        f1: Path,
        f2: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[Any] = None,
        hrange: Optional[Any] = None,
        imin: Optional[Any] = None,
        imax: Optional[Any] = None,
        sat: Optional[Any] = None,
        sc1: Optional[Any] = None,
        A1: Optional[Any] = None,
        B1: Optional[Any] = None,
        cyclic1: Optional[Any] = None,
        sc2: Optional[Any] = None,
        A2: Optional[Any] = None,
        B2: Optional[Any] = None,
        start_f1: Optional[Any] = None,
        start_f2: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[Any] = None,
        pixavaz: Optional[Any] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras8_float(
        self,
        f1: Path,
        f2: Path,
        width: int,
        rasf: Path,
        color_model: Optional[int] = None,
        h0: Optional[Any] = None,
        hrange: Optional[Any] = None,
        imin: Optional[Any] = None,
        imax: Optional[Any] = None,
        sat: Optional[Any] = None,
        sc1: Optional[Any] = None,
        A1: Optional[Any] = None,
        B1: Optional[Any] = None,
        cyclic1: Optional[Any] = None,
        sc2: Optional[Any] = None,
        A2: Optional[Any] = None,
        B2: Optional[Any] = None,
        start_f1: Optional[Any] = None,
        start_f2: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[Any] = None,
        pixavaz: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras8_float
        Generate 8-bit raster graphics image of 1 or 2 float data files


        input parameters:
          f1           (input) file 1 (float, enter - if not available --> greyscale image for f2)
          f2           (input) file 2 (float, enter - if not available --> 8-bit color image for f1)
          width        samples per row of f1 and f2
          rasf         (output) image filename, extension determines format:
                         *.bmp BMP format
                         *.ras Sun raster format
                         *.tif TIFF format
          color_model  color model selection flag: (enter - for default)
                         0: CMY color model used in Gamma Software (default)
                         1: HLS (double hexagon color model)
                         2: HSV (single hexagon color model)
                         3: SIN (sinus color model)
                         4: GREY (greyscale model for f1)
          h0           starting hue (color for starting value, enter - for default: 0.0)
          hrange       range of hue values in degrees (-360. ... 360., enter - for default: 360.0)
          imin         minimum brightness value (0.0 ... 1.0, enter - for default: 0.15)
          imax         maximum brightness value (0.0 ... 1.0, enter - for default: 0.85)
          sat          color saturation value (0.0 ... 1.0, enter - for default: 0.75)

        Image f1 scaling parameters:
          sc1          Scaling model flag (enter - for default: 0; 0: lin, 1: log, 2: power-law)
          A1           Scaling parameter A (minimum or scale; enter - for default: 0.0)
          B1           Scaling parameter B (maximum or exponent; enter - for default: 6.2832)
          cyclic1      Cyclic scaling model (enter - for default: 1; 0: no 1: yes)

        Image f2 scaling parameters:
          sc2          Scaling model flag (enter - for default: 2; 0: lin, 1: log, 2: power-law)
          A2           Scaling parameter A (minimum or scale; enter - for default: 1.0)
          B2           Scaling parameter B (maximum or exponent; enter - for default: 0.35)

        General parameters:
          start_f1     starting line of f1 (enter - for default: 1)
          start_f2     starting line of f2 (enter - for default: 1)
          nlines       number of lines to process (enter - or 0 for default: to end of file)
          pixavr       number of pixels to average in range (enter - for default: 1)
          pixavaz      number of pixels to average in azimuth (enter - for default: 1)

        """
        if self.validate_inputs:
            self._validate_ras8_float(
                f1,
                f2,
                width,
                rasf,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                nlines,
                pixavr,
                pixavaz,
            )
        if self.mock_outputs:
            self._mock_ras8_float_outputs(
                f1,
                f2,
                width,
                rasf,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                nlines,
                pixavr,
                pixavaz,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras8_float))
        return self._gamma_call("DISP", "ras8_float", supplied_args)

    def _validate_flip(
        self, infile: Path, outfile: Path, width: int, dtype: Optional[int] = None, direction: Optional[int] = None
    ) -> None:
        self._validate("flip", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_flip_outputs(
        self, infile: Path, outfile: Path, width: int, dtype: Optional[int] = None, direction: Optional[int] = None
    ) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def flip(
        self, infile: Path, outfile: Path, width: int, dtype: Optional[int] = None, direction: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        DISP Program: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/flip
        Flip data right/left, top/bottom or both (multiple formats)


        input parameters:
          infile      (input) input data file
          outfile     (output) output data file (flipped)
          width       number of data values/line
          dtype       data type (enter - for default)
                        0: FLOAT (default)
                        1: FCOMPLEX
                        2: SCOMPLEX
                        3: UNSIGNED CHAR
                        4: SHORT
                        5: INTEGER
                        6: DOUBLE
                        7: SUN/BMP/TIFF format raster image
          direction   flip direction (enter - for default)
                        1: right/left
                        2: top/bottom
                        3: right/left and top/bottom

        """
        if self.validate_inputs:
            self._validate_flip(infile, outfile, width, dtype, direction)
        if self.mock_outputs:
            self._mock_flip_outputs(infile, outfile, width, dtype, direction)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.flip))
        return self._gamma_call("DISP", "flip", supplied_args)

    def _validate_dis2dt_pwr(
        self,
        data1: Path,
        data2: Path,
        pwr: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        self._validate("dis2dt_pwr", data1.exists(), f"data1 path does not exist ({data1})")
        self._validate("dis2dt_pwr", data2.exists(), f"data2 path does not exist ({data2})")
        self._validate("dis2dt_pwr", pwr.exists(), f"pwr path does not exist ({pwr})")

    def _mock_dis2dt_pwr_outputs(
        self,
        data1: Path,
        data2: Path,
        pwr: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        pass

    def dis2dt_pwr(
        self,
        data1: Path,
        data2: Path,
        pwr: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2dt_pwr
        Display 2 data files (FLOAT, UNSIGNED SHORT, UNSIGNED BYTE) combined with power-law scaled intensity of a background image


        input parameters:
          data1   (input) data1 (FLOAT, UNSIGNED SHORT, or UNSIGNED BYTE)
          data2   (input) data2 (same data type as data1)
          pwr     (input) intensity image coregistered with data1 (enter - for none, FLOAT or raster image)
          width1  number of samples/row of data1
          width2  number of samples/row of data2
          start   starting line of data (enter - for default: 1)
          nlines  number of lines to display (enter - or 0 for default: to end of file)
          xoff    x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff    y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          min     minimum data value (enter - for default:  0.0000e+00)
          max     maximum data value (enter - for default:  1.0000e+00)
          cflg    cyclic data display flag (enter - for default)
                    0: display min <= data < max (default)
                    1: display (data - min) modulo (max - min)
                    2: autoscale between min and max value found in data
          cmap    colormap file (enter - for default: hls.cm)
                  NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                        colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          scale   display scale factor (enter - for default: 1.0)
          exp     display exponent (enter - for default: 0.35)

        """
        if self.validate_inputs:
            self._validate_dis2dt_pwr(
                data1, data2, pwr, width1, width2, start, nlines, xoff, yoff, min, max, cflg, cmap, scale, exp
            )
        if self.mock_outputs:
            self._mock_dis2dt_pwr_outputs(
                data1, data2, pwr, width1, width2, start, nlines, xoff, yoff, min, max, cflg, cmap, scale, exp
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2dt_pwr))
        return self._gamma_call("DISP", "dis2dt_pwr", supplied_args)

    def _validate_create_array(
        self,
        output: Path,
        width: int,
        nlines: int,
        dtype: Optional[int] = None,
        val: Optional[Any] = None,
        val_im: Optional[Any] = None,
    ) -> None:
        pass

    def _mock_create_array_outputs(
        self,
        output: Path,
        width: int,
        nlines: int,
        dtype: Optional[int] = None,
        val: Optional[Any] = None,
        val_im: Optional[Any] = None,
    ) -> None:
        if output is not None and str(output) != "-":
            output.touch()

    def create_array(
        self,
        output: Path,
        width: int,
        nlines: int,
        dtype: Optional[int] = None,
        val: Optional[Any] = None,
        val_im: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Create an array and store it as a binary file


        input parameters:
          output      (output) binary file
          width       width of output file
          nlines      number of lines of output file
          dtype       output data type (enter - for default)
                        0: FLOAT (default)
                        1: DOUBLE
                        2: INT
                        3: SHORT
                        4: SCOMPLEX
                        5: FCOMPLEX
                        6: UNSIGNED CHAR
                        7: SUN/BMP/TIFF 8-bit grayscale raster image
          val         constant value filling the array (real part for complex data) (enter - for default: 0)
          val_im      imaginary part of the constant value filling a complex array (enter - for default: 0)

        """
        if self.validate_inputs:
            self._validate_create_array(output, width, nlines, dtype, val, val_im)
        if self.mock_outputs:
            self._mock_create_array_outputs(output, width, nlines, dtype, val, val_im)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_array))
        return self._gamma_call("DISP", "create_array", supplied_args)

    def _validate_ascii2float(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        loff: Optional[Any] = None,
        nl: Optional[int] = None,
        coff: Optional[Any] = None,
        nv: Optional[int] = None,
    ) -> None:
        self._validate("ascii2float", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_ascii2float_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        loff: Optional[Any] = None,
        nl: Optional[int] = None,
        coff: Optional[Any] = None,
        nv: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def ascii2float(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        loff: Optional[Any] = None,
        nl: Optional[int] = None,
        coff: Optional[Any] = None,
        nv: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP program: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ascii2float.c
        Convert text format data to float format


        input parameters:
          data_in   (input) input text format data file with , or whitespace between columns
          width     number of data values (columns) in each line of text
          data_out  (output) output data file (float)
          loff      offset lines to start of data (enter - for default: 0)
          nl        number of lines (enter - for default: all)
          coff      offset columns to begin reading data values (enter - for default: 0)
          nv        number of values to read (enter - for default: to end of line)
        """
        if self.validate_inputs:
            self._validate_ascii2float(data_in, width, data_out, loff, nl, coff, nv)
        if self.mock_outputs:
            self._mock_ascii2float_outputs(data_in, width, data_out, loff, nl, coff, nv)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ascii2float))
        return self._gamma_call("DISP", "ascii2float", supplied_args)

    def _validate_data2tiff(
        self,
        data: Path,
        width: int,
        type: int,
        TIFF: Path,
        nodata: Optional[Any] = None,
        xspacing: Optional[Any] = None,
        yspacing: Optional[Any] = None,
    ) -> None:
        self._validate("data2tiff", data.exists(), f"data path does not exist ({data})")

    def _mock_data2tiff_outputs(
        self,
        data: Path,
        width: int,
        type: int,
        TIFF: Path,
        nodata: Optional[Any] = None,
        xspacing: Optional[Any] = None,
        yspacing: Optional[Any] = None,
    ) -> None:
        if TIFF is not None and str(TIFF) != "-":
            TIFF.touch()

    def data2tiff(
        self,
        data: Path,
        width: int,
        type: int,
        TIFF: Path,
        nodata: Optional[Any] = None,
        xspacing: Optional[Any] = None,
        yspacing: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP data2tiff: convert image data to TIFF format


        input parameters:
          data     (input) data file
          width    input data file width
          type     input data type:
                     0: RASTER, 8 or 24 bit uncompressed raster image, SUN (*.ras), BMP:(*.bmp), TIFF (*.tif)
                     1: SHORT integer
                     2: FLOAT (4 bytes/value)
                     3: SCOMPLEX (short complex)
                     4: FCOMPLEX (float complex)
                     5: BYTE
          TIFF     (output) TIFF file (.tif extension)
          nodata   nodata value (default=0.0)
          xspacing (ignored if omitted)
          yspacing (ignored if omitted, default=xspacing)

        """
        if self.validate_inputs:
            self._validate_data2tiff(data, width, type, TIFF, nodata, xspacing, yspacing)
        if self.mock_outputs:
            self._mock_data2tiff_outputs(data, width, type, TIFF, nodata, xspacing, yspacing)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.data2tiff))
        return self._gamma_call("DISP", "data2tiff", supplied_args)

    def _validate_dis2_linear(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("dis2_linear", data1.exists(), f"data1 path does not exist ({data1})")
        self._validate("dis2_linear", data2.exists(), f"data2 path does not exist ({data2})")

    def _mock_dis2_linear_outputs(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        pass

    def dis2_linear(
        self,
        data1: Path,
        data2: Path,
        width1: int,
        width2: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        xoff: Optional[int] = None,
        yoff: Optional[int] = None,
        min: Optional[Any] = None,
        max: Optional[Any] = None,
        cflg: Optional[int] = None,
        cmap: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/dis2_linear
        Display 2 data sets (FLOAT, UNSIGNED SHORT, SIGNED SHORT, or UNSIGNED BYTE) with linear scaling using a specified colormap


        input parameters:
          data1    (input) data1 (FLOAT, UNSIGNED SHORT, or UNSIGNED BYTE)
          data2    (input) data2 (same data type as data1)
          width1   number of samples/row of data1
          width2   number of samples/row of data2
          start    starting line of data (enter - for default: 1)
          nlines   number of lines to display (enter - or 0 for default: to end of file)
          xoff     x-offset (across) samples of data2 relative to data 1 (enter - for default: 0)
          yoff     y-offset (down) lines of data2 relative to data 1 (enter - for default: 0)
          min      minimum data value (enter - for default:  0.0000e+00)
          max      maximum data value (enter - for default:  1.0000e+00)
          cflg     cyclic data display flag (enter - for default: hls.cm)
                     0: display min <= data < max (default)
                     1: display (data - min) modulo (max - min)
                     2: autoscale between min and max value found in data
          cmap     colormap file (enter - for default: hls.cm)
                   NOTE: colormaps are text files in $DISP_HOME/cmaps, examples: cc.cm, rmg.cm, hls.cm, gray.cm, turbo.cm, BuYlRd.cm
                         colormap swatches: $DISP_HOME/cmaps/*.png, $DISP_HOME/cmaps/cmocean/*.png, $DISP_HOME/colorcet/*.png
          dtype   data type (enter - for default)
                    0: FLOAT (default)
                    1: UNSIGNED SHORT (2-byte integer)
                    2: SIGNED SHORT (2-byte integer)
                    3: UNSIGNED BYTE

        """
        if self.validate_inputs:
            self._validate_dis2_linear(
                data1, data2, width1, width2, start, nlines, xoff, yoff, min, max, cflg, cmap, dtype
            )
        if self.mock_outputs:
            self._mock_dis2_linear_outputs(
                data1, data2, width1, width2, start, nlines, xoff, yoff, min, max, cflg, cmap, dtype
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dis2_linear))
        return self._gamma_call("DISP", "dis2_linear", supplied_args)

    def _validate_mapshd(
        self,
        DEM: Path,
        width: int,
        col_post: Any,
        row_post: Any,
        theta0: Any,
        phi0: Any,
        shade: Path,
        dtype: Optional[int] = None,
        zero_flag: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
    ) -> None:
        self._validate("mapshd", DEM.exists(), f"DEM path does not exist ({DEM})")

    def _mock_mapshd_outputs(
        self,
        DEM: Path,
        width: int,
        col_post: Any,
        row_post: Any,
        theta0: Any,
        phi0: Any,
        shade: Path,
        dtype: Optional[int] = None,
        zero_flag: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
    ) -> None:
        if shade is not None and str(shade) != "-":
            shade.touch()

    def mapshd(
        self,
        DEM: Path,
        width: int,
        col_post: Any,
        row_post: Any,
        theta0: Any,
        phi0: Any,
        shade: Path,
        dtype: Optional[int] = None,
        zero_flag: Optional[int] = None,
        illum_mode: Optional[int] = None,
        sharpness: Optional[Any] = None,
        edge: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/mapshd
        Generate shaded relief intensity image from DEM


        input parameters:
          DEM         (input) digital elevation model (FLOAT)
          width       samples per row of DEM
          col_post    posting between cols (same unit as DEM values)
          row_post    posting between rows (enter - for default: col_post)
          theta0      illumination elevation angle in deg. (enter - for default: 45.)
          phi0        illumination orientation angle in deg. (enter - default: 135)
                      (0.: right, 90: top, 180: left, 270: bottom)
          shade       (output) shaded relief intensity image (FLOAT)
          dtype       DEM data type (enter - for default):
                        0: FLOAT (default)
                        1: SHORT integer
          zero_flag   zero data handling (enter - for default):
                        0: 0.0 interpreted at missing value (default)
                        1: 0.0 interpreted as valid data
          illum_mode  illumination mode (enter - for default)
                        0: single angle (default)
                        1: multiple angle
          sharpness   shaded relief sharpness (scale from 0 to 9, enter - for default: 1)
          edge        edge protection (reduce artifacts at the edges and near no-data values, enter - for default)
                        0: no (default)
                        1: yes

        """
        if self.validate_inputs:
            self._validate_mapshd(
                DEM, width, col_post, row_post, theta0, phi0, shade, dtype, zero_flag, illum_mode, sharpness, edge
            )
        if self.mock_outputs:
            self._mock_mapshd_outputs(
                DEM, width, col_post, row_post, theta0, phi0, shade, dtype, zero_flag, illum_mode, sharpness, edge
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mapshd))
        return self._gamma_call("DISP", "mapshd", supplied_args)

    def _validate_update_par(self, PAR_1: Path, PAR_2: Path) -> None:
        self._validate("update_par", PAR_1.exists(), f"PAR_1 path does not exist ({PAR_1})")

    def _mock_update_par_outputs(self, PAR_1: Path, PAR_2: Path) -> None:
        if PAR_2 is not None and str(PAR_2) != "-":
            PAR_2.touch()

    def update_par(self, PAR_1: Path, PAR_2: Path) -> Tuple[int, str, str]:
        """

        Update parameter file to the format of the latest version


        input parameters:
          PAR-1    (input) input SLC/MLI, TOPS, DEM, DIFF/GEO, ISP offset/interferogram or GPRI parameter file
          PAR-2    (output) updated SLC/MLI, TOPS, DEM, DIFF/GEO, ISP offset/interferogram or GPRI parameter file

          NOTE: The output parameter file can be the same as the input parameter file

        """
        if self.validate_inputs:
            self._validate_update_par(PAR_1, PAR_2)
        if self.mock_outputs:
            self._mock_update_par_outputs(PAR_1, PAR_2)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.update_par))
        return self._gamma_call("DISP", "update_par", supplied_args)

    def _validate_kml_pt(
        self,
        table: Path,
        lat_col: Any,
        lon_col: Any,
        val1_col: Any,
        val1_label: Any,
        val2_col: Any,
        val2_label: Any,
        val3_col: Any,
        val3_label: Any,
        id_col: Any,
        kml: Path,
        icon_URL: Optional[Any] = None,
        logo_URL: Optional[Any] = None,
        legend_URL: Optional[Any] = None,
        color_model: Optional[int] = None,
        h0: Optional[Any] = None,
        hrange: Optional[Any] = None,
        imin: Optional[Any] = None,
        imax: Optional[Any] = None,
        sat_min: Optional[Any] = None,
        sat_max: Optional[Any] = None,
        sc1: Optional[int] = None,
        A1: Optional[Any] = None,
        B1: Optional[Any] = None,
        cyclic1: Optional[Any] = None,
        sc2: Optional[int] = None,
        A2: Optional[Any] = None,
        B2: Optional[Any] = None,
        start_f1: Optional[int] = None,
        start_f2: Optional[Any] = None,
        icon_sz: Optional[Any] = None,
        dir_name: Optional[Any] = None,
    ) -> None:
        self._validate("kml_pt", table.exists(), f"table path does not exist ({table})")

    def _mock_kml_pt_outputs(
        self,
        table: Path,
        lat_col: Any,
        lon_col: Any,
        val1_col: Any,
        val1_label: Any,
        val2_col: Any,
        val2_label: Any,
        val3_col: Any,
        val3_label: Any,
        id_col: Any,
        kml: Path,
        icon_URL: Optional[Any] = None,
        logo_URL: Optional[Any] = None,
        legend_URL: Optional[Any] = None,
        color_model: Optional[int] = None,
        h0: Optional[Any] = None,
        hrange: Optional[Any] = None,
        imin: Optional[Any] = None,
        imax: Optional[Any] = None,
        sat_min: Optional[Any] = None,
        sat_max: Optional[Any] = None,
        sc1: Optional[int] = None,
        A1: Optional[Any] = None,
        B1: Optional[Any] = None,
        cyclic1: Optional[Any] = None,
        sc2: Optional[int] = None,
        A2: Optional[Any] = None,
        B2: Optional[Any] = None,
        start_f1: Optional[int] = None,
        start_f2: Optional[Any] = None,
        icon_sz: Optional[Any] = None,
        dir_name: Optional[Any] = None,
    ) -> None:
        if kml is not None and str(kml) != "-":
            kml.touch()

    def kml_pt(
        self,
        table: Path,
        lat_col: Any,
        lon_col: Any,
        val1_col: Any,
        val1_label: Any,
        val2_col: Any,
        val2_label: Any,
        val3_col: Any,
        val3_label: Any,
        id_col: Any,
        kml: Path,
        icon_URL: Optional[Any] = None,
        logo_URL: Optional[Any] = None,
        legend_URL: Optional[Any] = None,
        color_model: Optional[int] = None,
        h0: Optional[Any] = None,
        hrange: Optional[Any] = None,
        imin: Optional[Any] = None,
        imax: Optional[Any] = None,
        sat_min: Optional[Any] = None,
        sat_max: Optional[Any] = None,
        sc1: Optional[int] = None,
        A1: Optional[Any] = None,
        B1: Optional[Any] = None,
        cyclic1: Optional[Any] = None,
        sc2: Optional[int] = None,
        A2: Optional[Any] = None,
        B2: Optional[Any] = None,
        start_f1: Optional[int] = None,
        start_f2: Optional[Any] = None,
        icon_sz: Optional[Any] = None,
        dir_name: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP kml_pt: Create KML file with icons indicating values from ascii table


        input parameters:
          table       (input) ASCII file with columns of latitude, longitude and value
          lat_col     column number containing latitude information (WGS84, decimal)
          lon_col     column number containing longitude information (WGS84, decimal)
          val1_col    column number containing the value for red/hue (enter - if not available)
          val1_label  label of val1_col (enter - if values shall be omitted in the pop-up window)
          val2_col    column number containing the value for green/brightness (enter - if not available)
          val2_label  label of val2_col (enter - if values shall be omitted in the pop-up window)
          val3_col    column number containing the value for blue/saturation (enter - if not available)
          val3_label  label of val3_col (enter - if values shall be omitted in the pop-up window)
          id_col      column number containing the id values (enter - if no ID values shall be displayed)
          kml         (output) kml output file
          icon_URL    Uniform Resource Locator to the master icon (enter - for default: https://www.gamma-rs.ch/images/media/kml/images/button_master.png)
          logo_URL    Uniform Resource Locator to the logo image (enter - for none, enter "gamma" for gamma logo: https://www.gamma-rs.ch/images/media/kml/images/gamma_logo.png)
          legend_URL  Uniform Resource Locator to the legend image (use a vertical legend, enter - for none)
          color_model color model selection flag: (enter - for default)
                        0: RGB color model (default)
                        1: HLS (double hexagon color model)
                        2: HSV (single hexagon color model)
          h0          starting hue (color for starting value, enter - for default: 0.0)
          hrange      range of hue values in degrees (-360. ... 360., enter - for default: 360.)
          imin        minimum brightness value (0.0 ... 1.0, enter - for default: 0.15)
          imax        maximum brightness value (0.0 ... 1.0, enter - for default: 0.85)
          sat_min     minimum color saturation value (0.0 ... 1.0, enter - for default: 0.0)
          sat_max     maximum color saturation value (0.0 ... 1.0, enter - for default: 1.0)
                      Scaling parameters for val1:
          sc1         scaling model flag (enter - for default)
                        0: linear (default)
                        1: log
                        2: power-law
          A1          scaling parameter A (minimum or scale; enter - for default: 0.0)
          B1          scaling parameter B (maximum or exponent; enter - for default: 6.2832)
          cyclic1     cyclic scaling model (enter - for default)
                        0: no
                        1: yes (default)
                      Scaling parameters for val2:
          sc2         scaling model flag (enter - for default)
                        0: linear
                        1: log
                        2: power-law (default)
          A2          scaling parameter A (minimum or scale; enter - for default: 1.0)
          B2          scaling parameter B (maximum or exponent; enter - for default: 0.35)
                      Scaling parameters for val3:
          sc3         scaling model flag (enter - for default)
                        0: linear (default)
                        1: log
                        2: power-law
          A3          scaling parameter A (minimum or scale; enter - for default: 0.0)
          B3          scaling parameter B (maximum or exponent; enter - for default: 1.0)
          icon_sz     icon size (enter - for default: 0.3)
          dir_name    directory name for the KML tiles (enter - for default: kml)

        """
        if self.validate_inputs:
            self._validate_kml_pt(
                table,
                lat_col,
                lon_col,
                val1_col,
                val1_label,
                val2_col,
                val2_label,
                val3_col,
                val3_label,
                id_col,
                kml,
                icon_URL,
                logo_URL,
                legend_URL,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat_min,
                sat_max,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                icon_sz,
                dir_name,
            )
        if self.mock_outputs:
            self._mock_kml_pt_outputs(
                table,
                lat_col,
                lon_col,
                val1_col,
                val1_label,
                val2_col,
                val2_label,
                val3_col,
                val3_label,
                id_col,
                kml,
                icon_URL,
                logo_URL,
                legend_URL,
                color_model,
                h0,
                hrange,
                imin,
                imax,
                sat_min,
                sat_max,
                sc1,
                A1,
                B1,
                cyclic1,
                sc2,
                A2,
                B2,
                start_f1,
                start_f2,
                icon_sz,
                dir_name,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.kml_pt))
        return self._gamma_call("DISP", "kml_pt", supplied_args)

    def _validate_vec_to_real(self, vec: Path, width: int, index: int, cmp: Path) -> None:
        self._validate("vec_to_real", vec.exists(), f"vec path does not exist ({vec})")

    def _mock_vec_to_real_outputs(self, vec: Path, width: int, index: int, cmp: Path) -> None:
        if cmp is not None and str(cmp) != "-":
            cmp.touch()

    def vec_to_real(self, vec: Path, width: int, index: int, cmp: Path) -> Tuple[int, str, str]:
        """

        Display Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/vec_to_real.c
        Extract individual components from float vector data and store as float

        input parameters:
          vec    (input) vector input data (float)
                 NOTE: vector data are triplets of 4-byte single-precision floating point numbers
          width  number of vectors per line of the input data
          index  index of vector component to extract:
                   1: component 1
                   2: component 2
                   3: component 3
          cmp    (output) selected vector component (float)
        """
        if self.validate_inputs:
            self._validate_vec_to_real(vec, width, index, cmp)
        if self.mock_outputs:
            self._mock_vec_to_real_outputs(vec, width, index, cmp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.vec_to_real))
        return self._gamma_call("DISP", "vec_to_real", supplied_args)

    def _validate_ras_ras(
        self,
        ras_in: Path,
        ras_out: Path,
        col_looks: Optional[int] = None,
        row_looks: Optional[int] = None,
        LR: Optional[Any] = None,
        force24: Optional[int] = None,
    ) -> None:
        self._validate("ras_ras", ras_in.exists(), f"ras_in path does not exist ({ras_in})")

    def _mock_ras_ras_outputs(
        self,
        ras_in: Path,
        ras_out: Path,
        col_looks: Optional[int] = None,
        row_looks: Optional[int] = None,
        LR: Optional[Any] = None,
        force24: Optional[int] = None,
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_ras(
        self,
        ras_in: Path,
        ras_out: Path,
        col_looks: Optional[int] = None,
        row_looks: Optional[int] = None,
        LR: Optional[Any] = None,
        force24: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/ras_ras
        Multi-looking, left/right flip, and format conversion of SUN, BMP, or TIFF format raster images


        input parameters:
          ras_in     (input)  SUN/BMP/TIFF format raster image (8 or 24 bits/sample)
          ras_out    (output) SUN/BMP/TIFF format raster image
          col_looks  number of column looks (across) (enter - for default: 1)
          row_looks  number of row looks (down) (enter - for default: 1)
          LR         flip image left/right (1: normal (default), -1: mirror image) (enter - for default)
          force24    convert to 24 bits (enter - for default)
                       0: bits/sample remains unchanged (default)
                       1: output is 24 bits/sample
        """
        if self.validate_inputs:
            self._validate_ras_ras(ras_in, ras_out, col_looks, row_looks, LR, force24)
        if self.mock_outputs:
            self._mock_ras_ras_outputs(ras_in, ras_out, col_looks, row_looks, LR, force24)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_ras))
        return self._gamma_call("DISP", "ras_ras", supplied_args)

    def _validate_swap_bytes(self, infile: Path, outfile: Path, swap_type: int) -> None:
        self._validate("swap_bytes", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_swap_bytes_outputs(self, infile: Path, outfile: Path, swap_type: int) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def swap_bytes(self, infile: Path, outfile: Path, swap_type: int) -> Tuple[int, str, str]:
        """

        DISP swap_bytes: swap bytes for binary format data


        input parameters:
          infile     (input) input data file
          outfile    (output) output data file
          swap_type  data type (bytes/value)
                       2: (1,2,3,4,5,6,7,8...) --> (2,1,4,3,6,5,8,7...) (SHORT, SCOMPLEX)
                       4: (1,2,3,4,5,6,7,8...) --> (4,3,2,1,8,7,6,5...) (INT, FLOAT, FCOMPLEX)
                       8: (1,2,3,4,5,6,7,8...) --> (8,7,6,5,4,3,2,1...) (DOUBLE)

        """
        if self.validate_inputs:
            self._validate_swap_bytes(infile, outfile, swap_type)
        if self.mock_outputs:
            self._mock_swap_bytes_outputs(infile, outfile, swap_type)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.swap_bytes))
        return self._gamma_call("DISP", "swap_bytes", supplied_args)

    def _validate_float2double(self, infile: Path, outfile: Path, scale: Any, exp: Any) -> None:
        self._validate("float2double", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_float2double_outputs(self, infile: Path, outfile: Path, scale: Any, exp: Any) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def float2double(self, infile: Path, outfile: Path, scale: Any, exp: Any) -> Tuple[int, str, str]:
        """

        DISP float2double: Convert single precision floating point data to double precision floating point data


        input parameters:
          infile   (input) input data file (float, 4 bytes/sample)
          outfile  (output) output data file (double, 8 bytes/sample)
          scale    scale factor (default: 1.0)
          exp      exponent (default: 1.0)
        NOTE: output = scale*input^exp

        """
        if self.validate_inputs:
            self._validate_float2double(infile, outfile, scale, exp)
        if self.mock_outputs:
            self._mock_float2double_outputs(infile, outfile, scale, exp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2double))
        return self._gamma_call("DISP", "float2double", supplied_args)

    def _validate_svg_poly(
        self,
        image: Path,
        dem_par: Path,
        poly: Path,
        svg: Path,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
        thick: Optional[int] = None,
        lcolor: Optional[int] = None,
        lopac: Optional[Any] = None,
        pcolor: Optional[Any] = None,
        popac: Optional[Any] = None,
        tcolor: Optional[Any] = None,
        font: Optional[Any] = None,
        fsize: Optional[Any] = None,
    ) -> None:
        self._validate("svg_poly", image.exists(), f"image path does not exist ({image})")
        self._validate("svg_poly", dem_par.exists(), f"dem_par path does not exist ({dem_par})")
        self._validate("svg_poly", poly.exists(), f"poly path does not exist ({poly})")

    def _mock_svg_poly_outputs(
        self,
        image: Path,
        dem_par: Path,
        poly: Path,
        svg: Path,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
        thick: Optional[int] = None,
        lcolor: Optional[int] = None,
        lopac: Optional[Any] = None,
        pcolor: Optional[Any] = None,
        popac: Optional[Any] = None,
        tcolor: Optional[Any] = None,
        font: Optional[Any] = None,
        fsize: Optional[Any] = None,
    ) -> None:
        if svg is not None and str(svg) != "-":
            svg.touch()

    def svg_poly(
        self,
        image: Path,
        dem_par: Path,
        poly: Path,
        svg: Path,
        width: Optional[int] = None,
        nlines: Optional[int] = None,
        thick: Optional[int] = None,
        lcolor: Optional[int] = None,
        lopac: Optional[Any] = None,
        pcolor: Optional[Any] = None,
        popac: Optional[Any] = None,
        tcolor: Optional[Any] = None,
        font: Optional[Any] = None,
        fsize: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP svg_poly: Draw polygon on an image and store as SVG


        input parameters:
          image   (input) URL of background image in png or jpg format (- for no background image)
          dem_par (input) corresponding dem_par file (- for no dem_par file)
          poly    (input) polygon point file, format: x-coord y-coord index text
          svg     (output) SVG output file
          width   image width (overruled by dem_par width if applicable)
          nlines  number of image lines (overruled by dem_par nlines if applicable)
          mode    drawing mode (default = 0)
                   0: draw a solid polygon connecting points
                   1: draw a solid arc connecting points
                   2: draw a dashed polygon connecting points
                   3: draw a dashed arc connecting points
                   4: draw a solid polygon that respects insideness specified by the points
                   5: draw a dashed polygon that respects insideness specified by the points
                   6: draw crosses
                   7: draw triangles
                   8: draw circles
                   9: draw boxes
                  10: only text
          thick   line thickness in pixels (default = 1.0)
          lcolor  line/symbol color (default = black), use none for no stroke lines
          lopac   line/text opacity 0.0 (fully transparent) to 1.0 (fully opaque), default=1.0
          pcolor  polygon fill color (default = black), use none for no fill
          popac   polygon fill opacity 0.0 (fully transparent) to 1.0 (fully opaque), default=1.0
          tcolor  text color (default = black), use none for no text
          font    name of labelling font (default = sans-serif)
          fsize   font size (default = 14)

        """
        if self.validate_inputs:
            self._validate_svg_poly(
                image, dem_par, poly, svg, width, nlines, thick, lcolor, lopac, pcolor, popac, tcolor, font, fsize
            )
        if self.mock_outputs:
            self._mock_svg_poly_outputs(
                image, dem_par, poly, svg, width, nlines, thick, lcolor, lopac, pcolor, popac, tcolor, font, fsize
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.svg_poly))
        return self._gamma_call("DISP", "svg_poly", supplied_args)

    def _validate_get_data_values(
        self,
        data: Path,
        par_or_width: Path,
        positions: Path,
        report: Path,
        mode: Optional[Any] = None,
        dtype: Optional[int] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
        zero_flag: Optional[int] = None,
        print_flag: Optional[int] = None,
    ) -> None:
        self._validate("get_data_values", data.exists(), f"data path does not exist ({data})")
        self._validate("get_data_values", par_or_width.exists(), f"par_or_width path does not exist ({par_or_width})")
        self._validate("get_data_values", positions.exists(), f"positions path does not exist ({positions})")

    def _mock_get_data_values_outputs(
        self,
        data: Path,
        par_or_width: Path,
        positions: Path,
        report: Path,
        mode: Optional[Any] = None,
        dtype: Optional[int] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
        zero_flag: Optional[int] = None,
        print_flag: Optional[int] = None,
    ) -> None:
        if report is not None and str(report) != "-":
            report.touch()

    def get_data_values(
        self,
        data: Path,
        par_or_width: Path,
        positions: Path,
        report: Path,
        mode: Optional[Any] = None,
        dtype: Optional[int] = None,
        interp_mode: Optional[int] = None,
        order: Optional[int] = None,
        zero_flag: Optional[int] = None,
        print_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Extraction of data values along profiles, in polygon regions, or from indicated positions


        input parameters:
          data        (input) input data file
          par/width   (input) SLC/MLI, DEM, DIFF/GEO or ISP offset/interferogram parameter file for input data, or width of input data
          positions   (input) text file containing list of positions:
                        no DEM parameter file provided: column number, row number (can be integer or real values)
                        DEM parameter file provided: longitude, latitude (EQA) or easting, northing (map coordinates, e.g. UTM)
          report      (output) text file containing extracted values
          mode        data extraction mode (enter - for default)
                        0 : extract values along the profile connecting the indicated positions (default)
                        1 : extract values in the polygon region specified by the indicated positions
                        2 : extract values at the indicated positions
          dtype       data type (enter - for default)
                        0: FLOAT (default)
                        1: DOUBLE
                        2: INT
                        3: SHORT
                        4: SCOMPLEX
                        5: FCOMPLEX
                        6: UNSIGNED CHAR
                        7: SUN/BMP/TIFF raster image
          interp_mode interpolation mode (enter - for default)
                        0: nearest-neighbor
                        1: bicubic spline (default)
                        2: bicubic-log spline, interpolates log(data)
                        3: bicubic-sqrt spline, interpolates sqrt(data)
                        4: B-spline interpolation (default B-spline degree: 5)
                        5: B-spline interpolation sqrt(x) (default B-spline degree: 5)
                        6: Lanczos interpolation (default Lanczos function order: 5)
                        7: Lanczos interpolation sqrt(x) (default Lanczos function order: 5)
                      NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          order       Lanczos function order or B-spline degree (2->9) (enter - default: 5)
          zero_flag   interpretation of 0.0 values (enter - for default)
                        0: 0.0 indicates missing value (default)
                        1: 0.0 is a valid value
          print_flag  print flag (enter - for default)
                        0: print values at all positions (default)
                        1: print only positions with valid data

        """
        if self.validate_inputs:
            self._validate_get_data_values(
                data, par_or_width, positions, report, mode, dtype, interp_mode, order, zero_flag, print_flag
            )
        if self.mock_outputs:
            self._mock_get_data_values_outputs(
                data, par_or_width, positions, report, mode, dtype, interp_mode, order, zero_flag, print_flag
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.get_data_values))
        return self._gamma_call("DISP", "get_data_values", supplied_args)

    def _validate_float2ascii(
        self, din: Path, width: int, data_out: Path, loff: Optional[Any] = None, nl: Optional[int] = None
    ) -> None:
        self._validate("float2ascii", din.exists(), f"din path does not exist ({din})")

    def _mock_float2ascii_outputs(
        self, din: Path, width: int, data_out: Path, loff: Optional[Any] = None, nl: Optional[int] = None
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def float2ascii(
        self, din: Path, width: int, data_out: Path, loff: Optional[Any] = None, nl: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        DISP program: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/float2ascii.c
        Convert float format data to text format


        input parameters:
          din       (input) input data file (float)
          width     number of data values per line
          data_out  (output) input text format data file with whitespace between columns
          loff      offset lines to start of data (default: 0)
          nl        number of lines (enter - for default: to end of file)
        """
        if self.validate_inputs:
            self._validate_float2ascii(din, width, data_out, loff, nl)
        if self.mock_outputs:
            self._mock_float2ascii_outputs(din, width, data_out, loff, nl)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.float2ascii))
        return self._gamma_call("DISP", "float2ascii", supplied_args)

    def _validate_replace_values(
        self,
        data_in: Path,
        value: Any,
        new_value: Any,
        data_out: Path,
        width: int,
        rpl_flg: Optional[int] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        self._validate("replace_values", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_replace_values_outputs(
        self,
        data_in: Path,
        value: Any,
        new_value: Any,
        data_out: Path,
        width: int,
        rpl_flg: Optional[int] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def replace_values(
        self,
        data_in: Path,
        value: Any,
        new_value: Any,
        data_out: Path,
        width: int,
        rpl_flg: Optional[int] = None,
        dtype: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        DISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/DISP/bin/replace_values

        Replace value(s) of input data file with specified value or values extracted from a second input data file

        input parameters:
          data_in    (input) input data file
          value      threshold value or nan
          new_value  new value to use or a second input data file that is used to replace values in the output
                     NOTE: if this is a second input data file, it must be the same data type as data_in
          data_out   (output) output data file
                     NOTE: data_in and data_out can be the same file
          width      number of samples/row
          rpl_flg    replacement option flag (enter - for default)
                       0: replace all points == value with new_value (default)
                       1: replace all points >= value with new_value
                       2: replace all points <= value with new_value
          dtype      data type (enter - for default)
                       2: FLOAT (default)
                       4: SHORT integer
          zflg       interpretation of 0.0 values (enter - for default)
                       0: zero is interpreted as NO_DATA and is not changed (default)
                       1: zero is a valid data value

        """
        if self.validate_inputs:
            self._validate_replace_values(data_in, value, new_value, data_out, width, rpl_flg, dtype, zflg)
        if self.mock_outputs:
            self._mock_replace_values_outputs(data_in, value, new_value, data_out, width, rpl_flg, dtype, zflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.replace_values))
        return self._gamma_call("DISP", "replace_values", supplied_args)

    def _validate_SLC_deskew(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC_2: Path,
        SLC2_par: Path,
        mode: Optional[int] = None,
        interp: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
        ph_corr: Optional[int] = None,
    ) -> None:
        self._validate("SLC_deskew", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("SLC_deskew", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")

    def _mock_SLC_deskew_outputs(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC_2: Path,
        SLC2_par: Path,
        mode: Optional[int] = None,
        interp: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
        ph_corr: Optional[int] = None,
    ) -> None:
        if SLC_2 is not None and str(SLC_2) != "-":
            SLC_2.touch()
        if SLC2_par is not None and str(SLC2_par) != "-":
            SLC2_par.touch()

    def SLC_deskew(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC_2: Path,
        SLC2_par: Path,
        mode: Optional[int] = None,
        interp: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
        ph_corr: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Change geometry from Doppler centroid to zero-Doppler (deskew) or vice-versa


        input parameters:
          SLC-1     (input) SLC image file (FCOMPLEX or SCOMPLEX format)
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC-2     (output) SLC image file in new geometry
          SLC2_par  (output) SLC-2 ISP image parameter file
          mode      mode of operation (enter - for default)
                      0: change geometry from Doppler centroid to zero-Doppler (deskew, default)
                      1: change geometry from zero-Doppler to Doppler centroid (reskew)
          interp    interpolation method (enter - for default)
                      0: Lanczos interpolation (default)
                      1: B-spline interpolation
          order     Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)
          deramp    deramp flag (enter - for default)
                      0: do not deramp and reramp data
                      1: deramp data before interpolation and reramp afterwards (default)
          ph_corr   range shift phase correction flag (enter - for default)
                      0: do not correct phase related to range shift
                      1: correct phase related to range shift (default)

        """
        if self.validate_inputs:
            self._validate_SLC_deskew(SLC_1, SLC1_par, SLC_2, SLC2_par, mode, interp, order, deramp, ph_corr)
        if self.mock_outputs:
            self._mock_SLC_deskew_outputs(SLC_1, SLC1_par, SLC_2, SLC2_par, mode, interp, order, deramp, ph_corr)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_deskew))
        return self._gamma_call("ISP", "SLC_deskew", supplied_args)

    def _validate_sbi_offset(
        self, sbi_unw: Path, SLCf_par: Path, SLCb_par: Path, OFF_par: Path, az_offset: Path
    ) -> None:
        self._validate("sbi_offset", sbi_unw.exists(), f"sbi_unw path does not exist ({sbi_unw})")
        self._validate("sbi_offset", SLCf_par.exists(), f"SLCf_par path does not exist ({SLCf_par})")
        self._validate("sbi_offset", SLCb_par.exists(), f"SLCb_par path does not exist ({SLCb_par})")
        self._validate("sbi_offset", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_sbi_offset_outputs(
        self, sbi_unw: Path, SLCf_par: Path, SLCb_par: Path, OFF_par: Path, az_offset: Path
    ) -> None:
        if az_offset is not None and str(az_offset) != "-":
            az_offset.touch()

    def sbi_offset(
        self, sbi_unw: Path, SLCf_par: Path, SLCb_par: Path, OFF_par: Path, az_offset: Path
    ) -> Tuple[int, str, str]:
        """

        Calculate azimuth offsets from unwrapped split-beam interferogram


        input parameters:
          sbi_unw   (input) unwrapped phase of split-beam interferogram (float)
          SLCf_par  (input) reference SLC parameter file (forward-looking)
          SLCb_par  (input) reference SLC parameter file (backward-looking)
          OFF_par   (input) offset parameter file
          az_offset (output) azimuth offsets (m)
        """
        if self.validate_inputs:
            self._validate_sbi_offset(sbi_unw, SLCf_par, SLCb_par, OFF_par, az_offset)
        if self.mock_outputs:
            self._mock_sbi_offset_outputs(sbi_unw, SLCf_par, SLCb_par, OFF_par, az_offset)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sbi_offset))
        return self._gamma_call("ISP", "sbi_offset", supplied_args)

    def _validate_par_ASF_RSAT_SS(self, CEOS_leader: Path, CEOS_data: Path, GRD_par: Path, GRD: Path) -> None:
        self._validate("par_ASF_RSAT_SS", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_ASF_RSAT_SS", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_ASF_RSAT_SS_outputs(self, CEOS_leader: Path, CEOS_data: Path, GRD_par: Path, GRD: Path) -> None:
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_ASF_RSAT_SS(self, CEOS_leader: Path, CEOS_data: Path, GRD_par: Path, GRD: Path) -> Tuple[int, str, str]:
        """

        ISP parameter file for ASF Radarsat-1 SCANSAR images


        input parameters:
          CEOS_leader  (input) CEOS leader file (Radarsat-1 SCANSAR)
          CEOS_data    (input) CEOS data file (Radarsat-1 SCANSAR)
          GRD_par      (output) ISP image parameter file (example <orbit>.mli.par)
          GRD          (output) ISP image (example <orbit>.mli) (enter -  for none, short integer)
        """
        if self.validate_inputs:
            self._validate_par_ASF_RSAT_SS(CEOS_leader, CEOS_data, GRD_par, GRD)
        if self.mock_outputs:
            self._mock_par_ASF_RSAT_SS_outputs(CEOS_leader, CEOS_data, GRD_par, GRD)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_RSAT_SS))
        return self._gamma_call("ISP", "par_ASF_RSAT_SS", supplied_args)

    def _validate_par_ASF_SLC(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_data: Optional[Path] = None, SLC: Optional[Path] = None
    ) -> None:
        self._validate(
            "par_ASF_SLC", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )
        if CEOS_data is not None:
            self._validate("par_ASF_SLC", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_ASF_SLC_outputs(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_data: Optional[Path] = None, SLC: Optional[Path] = None
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_ASF_SLC(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_data: Optional[Path] = None, SLC: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Generate SLC image parameter file and reformat data


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file
          SLC_par      (output) ISP SLC parameter file (example <date>.slc.par)
          CEOS_data    (input) CEOS data file (example: dat_01.001)
          SLC          (output) SLC data with file and line headers removed (example: <date>.slc)
        """
        if self.validate_inputs:
            self._validate_par_ASF_SLC(CEOS_SAR_leader, SLC_par, CEOS_data, SLC)
        if self.mock_outputs:
            self._mock_par_ASF_SLC_outputs(CEOS_SAR_leader, SLC_par, CEOS_data, SLC)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_SLC))
        return self._gamma_call("ISP", "par_ASF_SLC", supplied_args)

    def _validate_par_KS_SLC(
        self,
    ) -> None:
        pass

    def _mock_par_KS_SLC_outputs(
        self,
    ) -> None:
        pass

    def par_KS_SLC(
        self,
    ) -> Tuple[int, str, str]:
        """

        dyld[47070]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_KS_SLC'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)
        """
        if self.validate_inputs:
            self._validate_par_KS_SLC()
        if self.mock_outputs:
            self._mock_par_KS_SLC_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_KS_SLC))
        return self._gamma_call("ISP", "par_KS_SLC", supplied_args)

    def _validate_ScanSAR_full_aperture_SLC(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        SLCR_tab: Optional[Path] = None,
        SLCR_dir: Optional[Any] = None,
        vmode: Optional[int] = None,
        wflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
        n_ovr: Optional[Any] = None,
    ) -> None:
        self._validate("ScanSAR_full_aperture_SLC", SLC1_tab.exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        if SLCR_tab is not None:
            self._validate("ScanSAR_full_aperture_SLC", SLCR_tab.exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_ScanSAR_full_aperture_SLC_outputs(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        SLCR_tab: Optional[Path] = None,
        SLCR_dir: Optional[Any] = None,
        vmode: Optional[int] = None,
        wflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
        n_ovr: Optional[Any] = None,
    ) -> None:
        if not SLC2_tab.exists():
            SLC2_tab.touch()

    def ScanSAR_full_aperture_SLC(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        SLCR_tab: Optional[Path] = None,
        SLCR_dir: Optional[Any] = None,
        vmode: Optional[int] = None,
        wflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
        n_ovr: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate continuous SLC data from ScanSAR burst data (Sentinel-1, RCM, and TSX)


        input parameters:
          SLC1_tab  (input) 3 column list of ScanSAR SLC swaths listed in order from near to far range
                      SLC1_tab line entries:   SLC   SLC_par  TOPS_par
          SLC2_tab  (input/output) 3 column list of oversampled continuous SLC swaths listed in order from near to far range
                      SLC2_tab line entries:   SLC   SLC_par
                    NOTE: if the SLC2_tab does not yet exist, the file entries will be created with names derived from the SLC1_tab entries
          SLCR_tab  (input) 3 column list of the reference scene with swaths, listed in order from near to far range (enter - for none)
                      SLCR_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_dir  directory for output oversampled continuous SLC, ignored if the SLC2_tab already exists (enter . for the current directory)
          vmode     sample validity mode (enter - for default):
                      0: all data in the burst are considered valid (default)
                      1: interpolate samples between the valid data bounds of the burst
          wflg      burst window calculation flag (enter - for default):
                      0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                      1: calculate burst window parameters from burst parameters and the number of range and azimuth looks
          imode     interpolation mode (enter - for default):
                      0: Lanczos (default)
                      1: B-spline
          order     Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 5)
          dtype     output data type, (enter - for default: same as input data):
                      0: FCOMPLEX
                      1: SCOMPLEX
          n_ovr     SLC oversampling factor, must be in the range 2 --> 32 (enter - for default: automatically calculated)

        """
        if self.validate_inputs:
            self._validate_ScanSAR_full_aperture_SLC(
                SLC1_tab, SLC2_tab, SLCR_tab, SLCR_dir, vmode, wflg, imode, order, n_ovr
            )
        if self.mock_outputs:
            self._mock_ScanSAR_full_aperture_SLC_outputs(
                SLC1_tab, SLC2_tab, SLCR_tab, SLCR_dir, vmode, wflg, imode, order, n_ovr
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_full_aperture_SLC))
        return self._gamma_call("ISP", "ScanSAR_full_aperture_SLC", supplied_args)

    def _validate_init_offset(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        offr: Optional[Any] = None,
        offaz: Optional[Any] = None,
        thres: Optional[Any] = None,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        cflag: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> None:
        self._validate("init_offset", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("init_offset", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("init_offset", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("init_offset", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("init_offset", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_init_offset_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        offr: Optional[Any] = None,
        offaz: Optional[Any] = None,
        thres: Optional[Any] = None,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        cflag: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> None:
        pass

    def init_offset(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        offr: Optional[Any] = None,
        offaz: Optional[Any] = None,
        thres: Optional[Any] = None,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        cflag: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Determine initial offset between SLC images using correlation of image intensity


        input parameters:
          SLC-1     (input) single-look complex image 1 (reference)
          SLC-2     (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          rlks      number of range looks (default: 1)
          azlks     number of azimuth looks (default: 1)
          rpos      center of patch in range (samples) (enter - for default: image center)
          azpos     center of patch in azimuth (lines) (enter - for default: image center)
          offr      initial range offset (samples) (enter - for default: 0)
          offaz     initial azimuth offset (lines) (enter - for default: 0)
          thres     cross-correlation threshold (enter - for default: 0.150)
          rwin      range window size (default: 512)
          azwin     azimuth window size (default: 512)
          cflag     copy offsets to the range and azimuth offset polynomials in the OFF_par (enter - for default)
                      0: do not copy
                      1: copy constant range and azimuth offset (default)
          deramp    deramp SLC phase flag (enter - for default)
                      0: no deramp (Doppler centroid close to 0) (default)
                      1: deramp SLC phase
        """
        if self.validate_inputs:
            self._validate_init_offset(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                rlks,
                azlks,
                rpos,
                azpos,
                offr,
                offaz,
                thres,
                rwin,
                azwin,
                cflag,
                deramp,
            )
        if self.mock_outputs:
            self._mock_init_offset_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                rlks,
                azlks,
                rpos,
                azpos,
                offr,
                offaz,
                thres,
                rwin,
                azwin,
                cflag,
                deramp,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.init_offset))
        return self._gamma_call("ISP", "init_offset", supplied_args)

    def _validate_bridge(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        bridge: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        self._validate("bridge", int.exists(), f"int path does not exist ({int})")
        self._validate("bridge", flag.exists(), f"flag path does not exist ({flag})")
        self._validate("bridge", bridge.exists(), f"bridge path does not exist ({bridge})")

    def _mock_bridge_outputs(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        bridge: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        if not unw.exists():
            unw.touch()

    def bridge(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        bridge: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Phase unwrap new regions with bridges to regions already unwrapped


        input parameters:
          int     (input) interferogram (fcomplex)
          flag    (input) unwrapping flag file
          unw     (input/output) unwrapped phase (float)
          bridge  (input) bridge data file (text format)
          width   number of samples/row
          xmin    starting range pixel offset to unwrap (default = 0)
          xmax    last range pixel offset to unwrap (default=width-1)
          ymin    starting azimuth row offset to unwrap, relative to start (default = 0)
          ymax    last azimuth row offset to unwrap, relative to start (default = nlines-1)

        """
        if self.validate_inputs:
            self._validate_bridge(int, flag, unw, bridge, width, xmin, xmax, ymin, ymax)
        if self.mock_outputs:
            self._mock_bridge_outputs(int, flag, unw, bridge, width, xmin, xmax, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.bridge))
        return self._gamma_call("ISP", "bridge", supplied_args)

    def _validate_par_ERSDAC_PALSAR(self, VEXCEL_SLC_par: Path, SLC_par: Path) -> None:
        pass

    def _mock_par_ERSDAC_PALSAR_outputs(self, VEXCEL_SLC_par: Path, SLC_par: Path) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ERSDAC_PALSAR(self, VEXCEL_SLC_par: Path, SLC_par: Path) -> Tuple[int, str, str]:
        """

        Generate the ISP image parameter file from ERSDAC PALSAR level 1.1 SLC data


        input parameters:
        ERSDAC_SLC_par (input) ERSDAC SLC parameter file Level 1.1 (PASL11*.SLC.par)
        SLC_par        (output) ISP image parameter file (example: yyyymmdd.slc.par)
        """
        if self.validate_inputs:
            self._validate_par_ERSDAC_PALSAR(VEXCEL_SLC_par, SLC_par)
        if self.mock_outputs:
            self._mock_par_ERSDAC_PALSAR_outputs(VEXCEL_SLC_par, SLC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ERSDAC_PALSAR))
        return self._gamma_call("ISP", "par_ERSDAC_PALSAR", supplied_args)

    def _validate_SR_to_GRD(
        self,
        MLI_par: Path,
        OFF_par: Path,
        GRD_par: Path,
        in_file: Path,
        out_file: Path,
        rlks: Optional[Any] = None,
        azlks: Optional[Any] = None,
        interp_mode: Optional[int] = None,
        grd_rsp: Optional[Any] = None,
        grd_azsp: Optional[Any] = None,
        degree: Optional[Any] = None,
    ) -> None:
        self._validate("SR_to_GRD", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("SR_to_GRD", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("SR_to_GRD", in_file.exists(), f"in_file path does not exist ({in_file})")

    def _mock_SR_to_GRD_outputs(
        self,
        MLI_par: Path,
        OFF_par: Path,
        GRD_par: Path,
        in_file: Path,
        out_file: Path,
        rlks: Optional[Any] = None,
        azlks: Optional[Any] = None,
        interp_mode: Optional[int] = None,
        grd_rsp: Optional[Any] = None,
        grd_azsp: Optional[Any] = None,
        degree: Optional[Any] = None,
    ) -> None:
        if not GRD_par.exists():
            GRD_par.touch()
        if out_file is not None and str(out_file) != "-":
            out_file.touch()

    def SR_to_GRD(
        self,
        MLI_par: Path,
        OFF_par: Path,
        GRD_par: Path,
        in_file: Path,
        out_file: Path,
        rlks: Optional[Any] = None,
        azlks: Optional[Any] = None,
        interp_mode: Optional[int] = None,
        grd_rsp: Optional[Any] = None,
        grd_azsp: Optional[Any] = None,
        degree: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Conversion to ground range for ISP MLI and INSAR data of type FLOAT


        input parameters:
          MLI_par      (input) MLI image parameter file of the slant-range image
          OFF_par      (input) ISP OFF_par of the input image (enter - when the image geometry specified by the MLI_par)
          GRD_par      (input/output) image parameter file of output ground range image
          in_file      (input) slant range image (FLOAT)
          out_file     (output) ground range image (FLOAT)
          rlks         multi-looking in range (prior to resampling, enter - for default: 1)
          azlks        multi-looking in azimuth (prior to resampling, enter - for default: 1)
          interp_mode  interpolation mode (enter - for default)
                         0: nearest-neighbor
                         1: bicubic spline
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 3)
                         5: B-spline interpolation sqrt(x) (default) (default B-spline degree: 3)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          grd_rsp      output image ground range sample spacing (m) (enter - for default: (input image azimuth spacing) * azlks)
          grd_azsp     output image azimuth sample spacing (m) (default = (input image azimuth spacing) * azlks)
          degree       B-spline degree (2->9) (enter - for default: 3)

        """
        if self.validate_inputs:
            self._validate_SR_to_GRD(
                MLI_par, OFF_par, GRD_par, in_file, out_file, rlks, azlks, interp_mode, grd_rsp, grd_azsp, degree
            )
        if self.mock_outputs:
            self._mock_SR_to_GRD_outputs(
                MLI_par, OFF_par, GRD_par, in_file, out_file, rlks, azlks, interp_mode, grd_rsp, grd_azsp, degree
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SR_to_GRD))
        return self._gamma_call("ISP", "SR_to_GRD", supplied_args)

    def _validate_par_ACS_ERS(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        self._validate(
            "par_ACS_ERS", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_par_ACS_ERS_outputs(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ACS_ERS(self, CEOS_SAR_leader: Path, SLC_par: Path) -> Tuple[int, str, str]:
        """

        ISP parameter file generation for ERS SLC data from the ACS processor


        input parameters:
        CEOS_SAR_leader  (input) ERS CEOS SAR leader file
        SLC_par          (output) ISP SLC parameter file (example <orbit>.slc.par)

        """
        if self.validate_inputs:
            self._validate_par_ACS_ERS(CEOS_SAR_leader, SLC_par)
        if self.mock_outputs:
            self._mock_par_ACS_ERS_outputs(CEOS_SAR_leader, SLC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ACS_ERS))
        return self._gamma_call("ISP", "par_ACS_ERS", supplied_args)

    def _validate_offset_fit(
        self,
        offs: Path,
        ccp: Path,
        OFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[Any] = None,
        npoly: Optional[int] = None,
        interact_flag: Optional[int] = None,
    ) -> None:
        self._validate("offset_fit", offs.exists(), f"offs path does not exist ({offs})")
        self._validate("offset_fit", ccp.exists(), f"ccp path does not exist ({ccp})")
        self._validate("offset_fit", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_offset_fit_outputs(
        self,
        offs: Path,
        ccp: Path,
        OFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[Any] = None,
        npoly: Optional[int] = None,
        interact_flag: Optional[int] = None,
    ) -> None:
        if coffs is not None and str(coffs) != "-":
            coffs.touch()
        if coffsets is not None and str(coffsets) != "-":
            coffsets.touch()

    def offset_fit(
        self,
        offs: Path,
        ccp: Path,
        OFF_par: Path,
        coffs: Optional[Path] = None,
        coffsets: Optional[Path] = None,
        thres: Optional[Any] = None,
        npoly: Optional[int] = None,
        interact_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Range and azimuth offset polynomial estimation


        input parameters:
          offs          (input) range and azimuth offset estimates for each patch (fcomplex)
          ccp           (input) cross-correlation or SNR of each patch (float)
          OFF_par       (input) ISP offset/interferogram parameter file
          coffs         (output) culled range and azimuth offset estimates (fcomplex, enter - for none)
          coffsets      (output) culled offset estimates and cross-correlation values (text format, enter - for none)
          thres         cross-correlation threshold (enter - for default from OFF_par)
          npoly         number of model polynomial parameters (enter - for default, 1, 3, 4, 6, default: 4)
          interact_mode interactive culling of input data:
                          0: off (default)
                          1: on
        """
        if self.validate_inputs:
            self._validate_offset_fit(offs, ccp, OFF_par, coffs, coffsets, thres, npoly, interact_flag)
        if self.mock_outputs:
            self._mock_offset_fit_outputs(offs, ccp, OFF_par, coffs, coffsets, thres, npoly, interact_flag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_fit))
        return self._gamma_call("ISP", "offset_fit", supplied_args)

    def _validate_radcal_PRI(
        self,
        PRI: Path,
        PRI_PAR: Path,
        GRD: Path,
        GRD_PAR: Path,
        K_dB: Optional[Any] = None,
        inc_ref: Optional[Any] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        self._validate("radcal_PRI", PRI.exists(), f"PRI path does not exist ({PRI})")
        self._validate("radcal_PRI", PRI_PAR.exists(), f"PRI_PAR path does not exist ({PRI_PAR})")

    def _mock_radcal_PRI_outputs(
        self,
        PRI: Path,
        PRI_PAR: Path,
        GRD: Path,
        GRD_PAR: Path,
        K_dB: Optional[Any] = None,
        inc_ref: Optional[Any] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        if GRD is not None and str(GRD) != "-":
            GRD.touch()
        if GRD_PAR is not None and str(GRD_PAR) != "-":
            GRD_PAR.touch()

    def radcal_PRI(
        self,
        PRI: Path,
        PRI_PAR: Path,
        GRD: Path,
        GRD_PAR: Path,
        K_dB: Optional[Any] = None,
        inc_ref: Optional[Any] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Convert ESA processed short integer format PRI to radiometrically calibrated GRD image (float)


        input parameters:
          PRI       (input) PRI ground-range image (short integer, sqrt(backscat. intensity)
          PRI_PAR   (input) SLC parameter file of input PRI ground-range image (yyyymmdd.pri.par)
          GRD       (output) calibrated ground-range image (float, backscat. intensity)
          GRD_PAR   (output) ISP image parameter file of output calibrated ground-range image (yyyymmdd.grd.par)
          K_dB      calibration factor in decibels (default: 59.75 dB)
                    ERS1 (D-Paf,ESRIN): 58.24 dB, ERS2 (D-Paf,ESRIN,I-Paf,UK-Paf after 1997): 59.75 dB
                    ENVISAT ASAR: 55.0 dB (all modes)
                    for details see product specifications and ESA publications.
          inc_ref   reference incidence angle in deg. (default: 23.0 deg.)
                    ENVISAT ASAR: 90.0 deg. (all modes)
          roff      offset to starting range sample (default: 0)
          nr        number of range samples (default: 0, to end of line)
          loff      offset to starting line (default: 0, 1 header line in the input file is assumed for ERS)
          nl        number of lines to copy (default: 0, to end of file)

        """
        if self.validate_inputs:
            self._validate_radcal_PRI(PRI, PRI_PAR, GRD, GRD_PAR, K_dB, inc_ref, roff, nr, loff, nl)
        if self.mock_outputs:
            self._mock_radcal_PRI_outputs(PRI, PRI_PAR, GRD, GRD_PAR, K_dB, inc_ref, roff, nr, loff, nl)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.radcal_PRI))
        return self._gamma_call("ISP", "radcal_PRI", supplied_args)

    def _validate_gcp_phase(
        self, unw: Path, OFF_par: Path, gcp: Path, gcp_ph: Path, win_sz: Optional[Any] = None
    ) -> None:
        self._validate("gcp_phase", unw.exists(), f"unw path does not exist ({unw})")
        self._validate("gcp_phase", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("gcp_phase", gcp.exists(), f"gcp path does not exist ({gcp})")

    def _mock_gcp_phase_outputs(
        self, unw: Path, OFF_par: Path, gcp: Path, gcp_ph: Path, win_sz: Optional[Any] = None
    ) -> None:
        if gcp_ph is not None and str(gcp_ph) != "-":
            gcp_ph.touch()

    def gcp_phase(
        self, unw: Path, OFF_par: Path, gcp: Path, gcp_ph: Path, win_sz: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        Extract unwrapped phase at GCP locations


        input parameters:
          unw      (input) unwrapped interferometric phase
          OFF_par  (input) ISP interferogram/offset parameter file
          gcp      (input) ground control point data (text format)
          gcp_ph   (output) ground control point data + extracted unwrapped phase (text)
          win_sz   window size for averaging phase for each GCP, must be odd (default: 1)

        """
        if self.validate_inputs:
            self._validate_gcp_phase(unw, OFF_par, gcp, gcp_ph, win_sz)
        if self.mock_outputs:
            self._mock_gcp_phase_outputs(unw, OFF_par, gcp, gcp_ph, win_sz)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gcp_phase))
        return self._gamma_call("ISP", "gcp_phase", supplied_args)

    def _validate_par_MSP(
        self, SAR_par: Path, PROC_par: Path, SLC_or_MLI_par: Path, image_format: Optional[int] = None
    ) -> None:
        self._validate("par_MSP", SAR_par.exists(), f"SAR_par path does not exist ({SAR_par})")
        self._validate("par_MSP", PROC_par.exists(), f"PROC_par path does not exist ({PROC_par})")

    def _mock_par_MSP_outputs(
        self, SAR_par: Path, PROC_par: Path, SLC_or_MLI_par: Path, image_format: Optional[int] = None
    ) -> None:
        if SLC_or_MLI_par is not None and str(SLC_or_MLI_par) != "-":
            SLC_or_MLI_par.touch()

    def par_MSP(
        self, SAR_par: Path, PROC_par: Path, SLC_or_MLI_par: Path, image_format: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        ISP image parameter file from MSP processing parameter and sensor files


        input parameters:
          SAR_par       (input) MSP SAR sensor parameter file
          PROC_par      (input) MSP processing parameter file
          SLC/MLI_par   (output) ISP SLC/MLI image parameter file
          image_format  image format flag (default: from MSP processing parameter file)
                          0: FCOMPLEX (pairs of 4-byte float)
                          1: SCOMPLEX (pairs of 2-byte short integer)
                          2: FLOAT (4-bytes/value)
        """
        if self.validate_inputs:
            self._validate_par_MSP(SAR_par, PROC_par, SLC_or_MLI_par, image_format)
        if self.mock_outputs:
            self._mock_par_MSP_outputs(SAR_par, PROC_par, SLC_or_MLI_par, image_format)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_MSP))
        return self._gamma_call("ISP", "par_MSP", supplied_args)

    def _validate_SLC_deramp_ScanSAR(
        self, SLC1_tab: Path, SLC2_tab: Path, mode: int, phflg: Optional[int] = None
    ) -> None:
        self._validate("SLC_deramp_ScanSAR", SLC1_tab.exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        self._validate("SLC_deramp_ScanSAR", SLC2_tab.exists(), f"SLC2_tab path does not exist ({SLC2_tab})")

    def _mock_SLC_deramp_ScanSAR_outputs(
        self, SLC1_tab: Path, SLC2_tab: Path, mode: int, phflg: Optional[int] = None
    ) -> None:
        pass

    def SLC_deramp_ScanSAR(
        self, SLC1_tab: Path, SLC2_tab: Path, mode: int, phflg: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Calculate and subtract ScanSAR or TOPS Doppler phase from burst SLC data


        input parameters:
          SLC1_tab   (input) 3 column list of input ScanSAR SLC, swaths are listed in order from near to far range:
                     SLC_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_tab   (input) 3 column list of output ScanSAR SLC, swaths are listed in order from near to far range
          mode       mode of operation:
                       0: subtract ScanSAR Doppler phase (deramp)
                       1: add Doppler phase ramp (reramp)
          phflg      deramp phase flag (enter - for default)
                       0: do not save ScanSAR Doppler phase (default)
                       1: save ScanSAR Doppler phase, output filename is the same as the deramped SLC with extension .dph

        """
        if self.validate_inputs:
            self._validate_SLC_deramp_ScanSAR(SLC1_tab, SLC2_tab, mode, phflg)
        if self.mock_outputs:
            self._mock_SLC_deramp_ScanSAR_outputs(SLC1_tab, SLC2_tab, mode, phflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_deramp_ScanSAR))
        return self._gamma_call("ISP", "SLC_deramp_ScanSAR", supplied_args)

    def _validate_offset_pwr_tracking2(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        OFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        self._validate("offset_pwr_tracking2", SLC1.exists(), f"SLC1 path does not exist ({SLC1})")
        self._validate("offset_pwr_tracking2", SLC2.exists(), f"SLC2 path does not exist ({SLC2})")
        self._validate("offset_pwr_tracking2", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("offset_pwr_tracking2", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("offset_pwr_tracking2", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        if OFF_par2 is not None:
            self._validate("offset_pwr_tracking2", OFF_par2.exists(), f"OFF_par2 path does not exist ({OFF_par2})")
        if offs2 is not None:
            self._validate("offset_pwr_tracking2", offs2.exists(), f"offs2 path does not exist ({offs2})")

    def _mock_offset_pwr_tracking2_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        OFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if ccp is not None and str(ccp) != "-":
            ccp.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()
        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_tracking2(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        OFF_par2: Optional[Path] = None,
        offs2: Optional[Path] = None,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Intensity cross-correlation offset tracking with the initial offset for each patch determined from input offset map


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          OFF_par2  (input) ISP offset/interferogram parameter file of the offset map to determine initial offsets (enter - for none)
          offs2     (input) input range and azimuth offset map to determine initial offsets (enter - for none)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          deramp    deramp SLC phase flag (enter - for default)
                      0: no deramp (Doppler centroid close to 0) (default)
                      1: deramp SLC phase
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)

        NOTE: ScanSAR and TOPS data need to be previously deramped

        """
        if self.validate_inputs:
            self._validate_offset_pwr_tracking2(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                OFF_par2,
                offs2,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        if self.mock_outputs:
            self._mock_offset_pwr_tracking2_outputs(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                OFF_par2,
                offs2,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_tracking2))
        return self._gamma_call("ISP", "offset_pwr_tracking2", supplied_args)

    def _validate_offset_tracking(
        self,
        offs: Path,
        ccp: Path,
        SLC_par: Path,
        OFF_par: Path,
        disp_map: Path,
        disp_val: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[Any] = None,
        poly_flag: Optional[int] = None,
    ) -> None:
        self._validate("offset_tracking", offs.exists(), f"offs path does not exist ({offs})")
        self._validate("offset_tracking", ccp.exists(), f"ccp path does not exist ({ccp})")
        self._validate("offset_tracking", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("offset_tracking", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_offset_tracking_outputs(
        self,
        offs: Path,
        ccp: Path,
        SLC_par: Path,
        OFF_par: Path,
        disp_map: Path,
        disp_val: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[Any] = None,
        poly_flag: Optional[int] = None,
    ) -> None:
        if disp_map is not None and str(disp_map) != "-":
            disp_map.touch()
        if disp_val is not None and str(disp_val) != "-":
            disp_val.touch()

    def offset_tracking(
        self,
        offs: Path,
        ccp: Path,
        SLC_par: Path,
        OFF_par: Path,
        disp_map: Path,
        disp_val: Optional[Path] = None,
        mode: Optional[int] = None,
        thres: Optional[Any] = None,
        poly_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Conversion of range and azimuth offsets files to displacement map


        input parameters:
          offs       (input) range and azimuth offset estimates (fcomplex)
          ccp        (input) cross-correlation of the offset estimates (float)
          SLC_par    (input) SLC parameter file of reference SLC
          OFF_par    (input) offset parameter file used in the offset tracking
          disp_map   (output) range and azimuth displacement estimates (fcomplex)
          disp_val   (output) range and azimuth displacement estimates and cross-correlation values (enter - for none) (text)
          mode       flag indicating displacement mode:
                       0: displacement in range and azimuth pixels
                       1: displacement in meters in slant range and azimuth directions
                       2: displacement in meters in ground range and azimuth directions (default)
          thres      cross-correlation threshold to accept offset value (default from OFF_par)
          poly_flag  flag indicating if trend calculated using offset polynomials from OFF_par is subtracted:
                       0: do not subtract polynomial trend from offset data
                       1: subtract polynomial trend from offset data (default)

        """
        if self.validate_inputs:
            self._validate_offset_tracking(offs, ccp, SLC_par, OFF_par, disp_map, disp_val, mode, thres, poly_flag)
        if self.mock_outputs:
            self._mock_offset_tracking_outputs(offs, ccp, SLC_par, OFF_par, disp_map, disp_val, mode, thres, poly_flag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_tracking))
        return self._gamma_call("ISP", "offset_tracking", supplied_args)

    def _validate_SLC_interp_ScanSAR(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        OFF_par: Path,
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[Any] = None,
    ) -> None:
        self._validate("SLC_interp_ScanSAR", SLC2_tab.exists(), f"SLC2_tab path does not exist ({SLC2_tab})")
        self._validate("SLC_interp_ScanSAR", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("SLC_interp_ScanSAR", SLC1_tab.exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        self._validate("SLC_interp_ScanSAR", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("SLC_interp_ScanSAR", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_SLC_interp_ScanSAR_outputs(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        OFF_par: Path,
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[Any] = None,
    ) -> None:
        if not SLC2R_tab.exists():
            SLC2R_tab.touch()
        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()
        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp_ScanSAR(
        self,
        SLC2_tab: Path,
        SLC2_par: Path,
        SLC1_tab: Path,
        SLC1_par: Path,
        OFF_par: Path,
        SLC2R_tab: Path,
        SLC_2R: Optional[Path] = None,
        SLC2R_par: Optional[Path] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        SLC2R_dir: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Resample ScanSAR burst mode SLC using global offset polynomial


        input parameters:
          SLC2_tab    (input) 3 column list of ScanSAR SLC-2 swaths to be resampled into the geometry of SLC-1 listed in order from near to far range
                        SLC2_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_par    (input) SLC parameter file of ScanSAR SLC-2 mosaic, SLC-2 is generated from the ScanSAR swaths listed in SLC2_tab
          SLC1_tab    (input) 3 column list of the reference ScanSAR SLC swaths listed in order from near to far range
          SLC1_par    (input) SLC parameter file of the reference ScanSAR SLC-1 mosaic, SLC-1 is generated from the ScanSAR swaths listed in SLC1_tab
          OFF_par     (input) global ISP offset and interferogram parameter file, the offset model is determined from the ScanSAR SLC mosaics
                      NOTE: The OFF_par specifies the number of range and azimuth looks required to determine valid data bounds (burst windows)
          SLC2R_tab   (input/output) 3 column list of the resampled ScanSAR SLC2 swaths listed in order from near to far range
                      NOTE: If the SLC2R_tab does not yet exist, the entires will be created with file names derived from the filenames in SLC2_tab and the SLC2R_dir
                            The file extensions of the new entries are changed from slc to rslc
          SLC-2R      (output) mosaic generated from the resampled swaths listed in SLC2R_tab, coregistered to the reference mosaic of SLC-1 (enter - for none)
          SLC2R_par   (output) SLC parameter file associated with the mosaic created from the resampled swaths SLC-2R (enter - for none)
          mode        complex data interpolation mode (enter - for default)
                        0: Lanczos (default)
                        1: B-spline
          order       Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)
          SLC2R_dir   directory for resampled burst SLC2R data, ignored if the DIFF_tab already exists (enter - for default: current directory)

        """
        if self.validate_inputs:
            self._validate_SLC_interp_ScanSAR(
                SLC2_tab, SLC2_par, SLC1_tab, SLC1_par, OFF_par, SLC2R_tab, SLC_2R, SLC2R_par, mode, order, SLC2R_dir
            )
        if self.mock_outputs:
            self._mock_SLC_interp_ScanSAR_outputs(
                SLC2_tab, SLC2_par, SLC1_tab, SLC1_par, OFF_par, SLC2R_tab, SLC_2R, SLC2R_par, mode, order, SLC2R_dir
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp_ScanSAR))
        return self._gamma_call("ISP", "SLC_interp_ScanSAR", supplied_args)

    def _validate_error_stat(
        self, d1: Path, d2: Path, width: int, dtype: int, roff: int, loff: int, nr: int, nl: int, report: Any
    ) -> None:
        self._validate("error_stat", d1.exists(), f"d1 path does not exist ({d1})")
        self._validate("error_stat", d2.exists(), f"d2 path does not exist ({d2})")

    def _mock_error_stat_outputs(
        self, d1: Path, d2: Path, width: int, dtype: int, roff: int, loff: int, nr: int, nl: int, report: Any
    ) -> None:
        pass

    def error_stat(
        self, d1: Path, d2: Path, width: int, dtype: int, roff: int, loff: int, nr: int, nl: int, report: Any
    ) -> Tuple[int, str, str]:
        """

        Calculate statistics for two data files and their difference (FLOAT or FCOMPLEX)


        input parameters:
          d1      (input) data file 1
          d2      (input) data file 2
          width   image line width (samples/line)
          dtype   data type for d1 and d2:
                    0: FLOAT
                    1: FCOMPLEX
          roff    sample offset to region start (enter - for default: 0)
          loff    line offset to region start (enter - for default: 0)
          nr      region width (samples, enter - for default: width - roff)
          nl      number of lines in the region (enter - for default: data_lines - loff)
          report  output text file (keyword:value format)
                  keywords: data_1, data_2, d1_mean, d2_mean, d1_stddev, d2_stddev, root_mean_square_error, normalized_mean_square_error,
                   cross_correlation_coefficient, cross_correlation_angle, total_samples, non_zero_samples, valid_fraction

        """
        if self.validate_inputs:
            self._validate_error_stat(d1, d2, width, dtype, roff, loff, nr, nl, report)
        if self.mock_outputs:
            self._mock_error_stat_outputs(d1, d2, width, dtype, roff, loff, nr, nl, report)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.error_stat))
        return self._gamma_call("ISP", "error_stat", supplied_args)

    def _validate_par_SICD_SLC(
        self, NITF: Path, radcal: int, noise: int, SLC_par: Path, SLC: Optional[Path] = None
    ) -> None:
        self._validate("par_SICD_SLC", NITF.exists(), f"NITF path does not exist ({NITF})")

    def _mock_par_SICD_SLC_outputs(
        self, NITF: Path, radcal: int, noise: int, SLC_par: Path, SLC: Optional[Path] = None
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_SICD_SLC(
        self, NITF: Path, radcal: int, noise: int, SLC_par: Path, SLC: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for SICD SLC data


        input parameters:
          NITF      (input) Sensor Independent Complex Data (SICD) file in NITF 2.1 container file (e.g.: CAPELLA_C03_SM_SICD_HH_20210512034455_20210512034459.ntf)
          radcal    radiometric calibration flag (enter - for default)
                      0: none
                      1: beta0 (default)
                      2: sigma0
                      3: gamma0
          noise     noise levels flag (enter - for default)
                      0: do not use noise levels (default)
                      1: use noise levels
          SLC_par   (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC       (output) SLC data file (enter - for none, example: yyyymmdd.slc)

        """
        if self.validate_inputs:
            self._validate_par_SICD_SLC(NITF, radcal, noise, SLC_par, SLC)
        if self.mock_outputs:
            self._mock_par_SICD_SLC_outputs(NITF, radcal, noise, SLC_par, SLC)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_SICD_SLC))
        return self._gamma_call("ISP", "par_SICD_SLC", supplied_args)

    def _validate_res_map(
        self,
        hgt: Path,
        gr: Path,
        data: Path,
        SLC_par: Path,
        OFF_par: Path,
        res_hgt: Path,
        res_data: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        azps_res: Optional[Path] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("res_map", hgt.exists(), f"hgt path does not exist ({hgt})")
        self._validate("res_map", gr.exists(), f"gr path does not exist ({gr})")
        self._validate("res_map", data.exists(), f"data path does not exist ({data})")
        self._validate("res_map", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("res_map", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_res_map_outputs(
        self,
        hgt: Path,
        gr: Path,
        data: Path,
        SLC_par: Path,
        OFF_par: Path,
        res_hgt: Path,
        res_data: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        azps_res: Optional[Path] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        if res_hgt is not None and str(res_hgt) != "-":
            res_hgt.touch()
        if res_data is not None and str(res_data) != "-":
            res_data.touch()

    def res_map(
        self,
        hgt: Path,
        gr: Path,
        data: Path,
        SLC_par: Path,
        OFF_par: Path,
        res_hgt: Path,
        res_data: Path,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        azps_res: Optional[Path] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Slant range to ground range transformation based on interferometric ground-range


        input parameters:
          hgt        (input) height file in slant range geometry
          gr         (input) ground range file in slant range geometry
          data       (input) data file in slant range geometry (float) (intensity *.pwr or correlation *.cc)
          SLC_par    (input) ISP parameter file of reference SLC
          OFF_par    (input) offset/interferogram processing parameters
          res_hgt    (output) resampled height file in ground range geometry
          res_data   (output) resampled data file in ground range geometry
          nr         number of range samples for L.S. estimate (default=7, must be odd)
          naz        number of azimuth samples for L.S. extimate (default=7, must be odd)
          azps_res   azimuth output map sample spacing in meters (default=azimuth spacing)
          loff       offset to starting line for height calculations (default=0)
          nlines     number of lines to calculate (default=to end of file)

        """
        if self.validate_inputs:
            self._validate_res_map(hgt, gr, data, SLC_par, OFF_par, res_hgt, res_data, nr, naz, azps_res, loff, nlines)
        if self.mock_outputs:
            self._mock_res_map_outputs(
                hgt, gr, data, SLC_par, OFF_par, res_hgt, res_data, nr, naz, azps_res, loff, nlines
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.res_map))
        return self._gamma_call("ISP", "res_map", supplied_args)

    def _validate_RSAT2_vec(self, SLC_par: Path, RSAT2_orb: Any, nstate: Optional[int] = None) -> None:
        self._validate("RSAT2_vec", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_RSAT2_vec_outputs(self, SLC_par: Path, RSAT2_orb: Any, nstate: Optional[int] = None) -> None:
        pass

    def RSAT2_vec(self, SLC_par: Path, RSAT2_orb: Any, nstate: Optional[int] = None) -> Tuple[int, str, str]:
        """

        Extract Radarsat-2 state vectors from a definitive orbit file


        input parameters:
          SLC_par    (input) ISP image parameter file
          RSAT2_orb  Radarsat-2 definitive orbit data file available from MDA (orbit_number_def.orb)
          nstate     number of state vectors to extract (enter - for default: 9)

        """
        if self.validate_inputs:
            self._validate_RSAT2_vec(SLC_par, RSAT2_orb, nstate)
        if self.mock_outputs:
            self._mock_RSAT2_vec_outputs(SLC_par, RSAT2_orb, nstate)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.RSAT2_vec))
        return self._gamma_call("ISP", "RSAT2_vec", supplied_args)

    def _validate_par_S1_GRD(
        self,
        GeoTIFF: Path,
        annotation_XML: Path,
        calibration_XML: Path,
        noise_XML: Path,
        MLI_par: Path,
        MLI: Path,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        eflg: Optional[Any] = None,
        rps: Optional[Any] = None,
        noise_pwr: Optional[Any] = None,
        edge_flag: Optional[Any] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        self._validate("par_S1_GRD", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_S1_GRD", annotation_XML.exists(), f"annotation_XML path does not exist ({annotation_XML})")
        self._validate(
            "par_S1_GRD", calibration_XML.exists(), f"calibration_XML path does not exist ({calibration_XML})"
        )
        self._validate("par_S1_GRD", noise_XML.exists(), f"noise_XML path does not exist ({noise_XML})")

    def _mock_par_S1_GRD_outputs(
        self,
        GeoTIFF: Path,
        annotation_XML: Path,
        calibration_XML: Path,
        noise_XML: Path,
        MLI_par: Path,
        MLI: Path,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        eflg: Optional[Any] = None,
        rps: Optional[Any] = None,
        noise_pwr: Optional[Any] = None,
        edge_flag: Optional[Any] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_S1_GRD(
        self,
        GeoTIFF: Path,
        annotation_XML: Path,
        calibration_XML: Path,
        noise_XML: Path,
        MLI_par: Path,
        MLI: Path,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        eflg: Optional[Any] = None,
        rps: Optional[Any] = None,
        noise_pwr: Optional[Any] = None,
        edge_flag: Optional[Any] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate MLI and GRD images and parameter files from a Sentinel-1 GRD product


        input parameters:
          GeoTIFF         (input) image data file in GeoTIFF format (enter - for none, *.tiff)
          annotation_XML  (input) Sentinel-1 L1 XML annotation file
          calibration_XML (input) Sentinel-1 L1 radiometric calibration XML file (enter - for no radiometric calibration)
          noise_XML       (input) Sentinel-1 L1 noise XML file (enter - to not subtract thermal noise power level)
          MLI_par         (output) MLI parameter file (example: yyyymmdd_pp.mli.par)
          MLI             (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par         (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD             (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          eflg            GR-SR grid extrapolation flag (enter - for default)
                            0: no extrapolation of the GR-SR grid beyond the grid boundaries
                            1: permit extrapolation of the GR-SR grid to cover the entire image (default)
                          NOTE: extrapolation of the GR-SR grid may introduce geocoding errors
          rps             slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)
          noise_pwr       noise intensity for each MLI sample in slant range using data from noise_XML
                          NOTE: when the noise_pwr file is specified, noise power correction will NOT be applied to the MLI data values
          edge_flag       edge cleaning flag (enter - for default)
                            0: do not clean edges (default for Sentinel-1 IPF version >= 2.90)
                            1: basic method
                            2: elaborate method based on Canny edge detection (default for Sentinel-1 IPF version < 2.90)
                            3: force basic method when Sentinel-1 IPF version >= 2.90
                            4: force elaborate method based on Canny edge detection when Sentinel-1 IPF version >= 2.90
                          NOTE: options 1 and 2 are changed to 0 when Sentinel-1 IPF version >= 2.90
          loff            offset to starting line of the input segment (default: 0)
          nl              number of lines to read from the file beginning at loff (default: to end of file)

        """
        if self.validate_inputs:
            self._validate_par_S1_GRD(
                GeoTIFF,
                annotation_XML,
                calibration_XML,
                noise_XML,
                MLI_par,
                MLI,
                GRD_par,
                GRD,
                eflg,
                rps,
                noise_pwr,
                edge_flag,
                loff,
                nl,
            )
        if self.mock_outputs:
            self._mock_par_S1_GRD_outputs(
                GeoTIFF,
                annotation_XML,
                calibration_XML,
                noise_XML,
                MLI_par,
                MLI,
                GRD_par,
                GRD,
                eflg,
                rps,
                noise_pwr,
                edge_flag,
                loff,
                nl,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_S1_GRD))
        return self._gamma_call("ISP", "par_S1_GRD", supplied_args)

    def _validate_adf2(
        self,
        interf: Path,
        cc_interf: Path,
        sm: float,
        cc_filt: Path,
        width: int,
        alpha_max: Optional[Any] = None,
        nfft: Optional[Any] = None,
        cc_win: Optional[Any] = None,
        step: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[Any] = None,
    ) -> None:
        self._validate("adf2", interf.exists(), f"interf path does not exist ({interf})")
        self._validate("adf2", cc_interf.exists(), f"cc_interf path does not exist ({cc_interf})")

    def _mock_adf2_outputs(
        self,
        interf: Path,
        cc_interf: Path,
        sm: float,
        cc_filt: Path,
        width: int,
        alpha_max: Optional[Any] = None,
        nfft: Optional[Any] = None,
        cc_win: Optional[Any] = None,
        step: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[Any] = None,
    ) -> None:
        if cc_filt is not None and str(cc_filt) != "-":
            cc_filt.touch()

    def adf2(
        self,
        interf: Path,
        cc_interf: Path,
        sm: float,
        cc_filt: Path,
        width: int,
        alpha_max: Optional[Any] = None,
        nfft: Optional[Any] = None,
        cc_win: Optional[Any] = None,
        step: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Adaptive interferogram filter based on the power spectral density and correlation coefficient


        input parameters:
          interf      (input) complex interferogram (fcomplex)
          cc_interf   (input) correlation coefficient of the input interferogram (float)
          sm          (output) filtered interferogram (fcomplex)
          cc_filt     (output) filtered interferogram correlation coefficient (float)
          width       number of samples/line
          alpha_max   maximum value for the adaptive filter exponent (enter - for default: 0.50)
          nfft        filter window FFT size, 2**N, 8->512, (enter - for default: 32)
          cc_win      filtered interferogram correlation estimation window size odd, max: 21 (enter - for default: 9)
          step        processing step in range and azimuth (enter - for default: nfft/8)
          loff        offset to starting line to process (enter - for default: 0)
          nlines      number of lines to process (enter - for default: to end of file)
          wfrac       minimum fraction of points required to be non-zero in the filter window (enter - for default: 0.200)

        """
        if self.validate_inputs:
            self._validate_adf2(
                interf, cc_interf, sm, cc_filt, width, alpha_max, nfft, cc_win, step, loff, nlines, wfrac
            )
        if self.mock_outputs:
            self._mock_adf2_outputs(
                interf, cc_interf, sm, cc_filt, width, alpha_max, nfft, cc_win, step, loff, nlines, wfrac
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.adf2))
        return self._gamma_call("ISP", "adf2", supplied_args)

    def _validate_par_RSAT_SGF(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Path,
        sc_dB: Optional[Any] = None,
        dt: Optional[Any] = None,
    ) -> None:
        self._validate("par_RSAT_SGF", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_RSAT_SGF", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_RSAT_SGF_outputs(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Path,
        sc_dB: Optional[Any] = None,
        dt: Optional[Any] = None,
    ) -> None:
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_RSAT_SGF(
        self,
        CEOS_leader: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Path,
        sc_dB: Optional[Any] = None,
        dt: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        ISP parameter file for RSI/Atlantis Radarsat SGF (ground range) and SCANSAR SCW16 data


        input parameters:
          CEOS_leader (input) CEOS leader file (RSI SGF or SCW16 products, LEA_01.001)
          CEOS_data   (input) CEOS data file (RSI SGF or SCW16 products, DAT_01.001)
          GRD_par     (output) ISP ground range image parameter file (example <orbit>.mli.par)
          GRD         (output) ISP ground range image (example <orbit>.grd.par) (enter -  for none, float)
          sc_dB       intensity scale factor in dB (enter - for default:   0.00)
          dt          azimuth image time offset (s) (enter - for default = 0.0)

        """
        if self.validate_inputs:
            self._validate_par_RSAT_SGF(CEOS_leader, CEOS_data, GRD_par, GRD, sc_dB, dt)
        if self.mock_outputs:
            self._mock_par_RSAT_SGF_outputs(CEOS_leader, CEOS_data, GRD_par, GRD, sc_dB, dt)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT_SGF))
        return self._gamma_call("ISP", "par_RSAT_SGF", supplied_args)

    def _validate_par_ICEYE_GRD(
        self,
        GeoTIFF: Path,
        MLI_par: Path,
        mli: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
    ) -> None:
        self._validate("par_ICEYE_GRD", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_ICEYE_GRD", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")

    def _mock_par_ICEYE_GRD_outputs(
        self,
        GeoTIFF: Path,
        MLI_par: Path,
        mli: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
    ) -> None:
        if mli is not None and str(mli) != "-":
            mli.touch()
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_ICEYE_GRD(
        self,
        GeoTIFF: Path,
        MLI_par: Path,
        mli: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate MLI and GRD image and parameter files for ICEYE GRD data


        input parameters:
          GeoTIFF   (input) ICEYE GRD data file in GeoTIFF format (enter - for none, *.tif)
          XML       (input) ICEYE XML annotation file
          MLI_par   (output) MLI parameter file (example: yyyymmdd.mli.par)
          MLI       (output) MLI data file in slant range geometry (example: yyyymmdd.mli, enter - for none)
          GRD_par   (output) GRD parameter file (example: yyyymmdd.grd.par, enter - for none)
          GRD       (output) GRD data file (example: yyyymmdd.grd, enter - for none)
          rps       slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)

        """
        if self.validate_inputs:
            self._validate_par_ICEYE_GRD(GeoTIFF, MLI_par, mli, GRD_par, GRD, rps)
        if self.mock_outputs:
            self._mock_par_ICEYE_GRD_outputs(GeoTIFF, MLI_par, mli, GRD_par, GRD, rps)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ICEYE_GRD))
        return self._gamma_call("ISP", "par_ICEYE_GRD", supplied_args)

    def _validate_par_CS_SLC_TIF(self, GeoTIFF: Path, XML: Path, trunk: Path) -> None:
        self._validate("par_CS_SLC_TIF", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_CS_SLC_TIF", XML.exists(), f"XML path does not exist ({XML})")

    def _mock_par_CS_SLC_TIF_outputs(self, GeoTIFF: Path, XML: Path, trunk: Path) -> None:
        if trunk is not None and str(trunk) != "-":
            trunk.touch()

    def par_CS_SLC_TIF(self, GeoTIFF: Path, XML: Path, trunk: Path) -> Tuple[int, str, str]:
        """

        Generate ISP SLC parameter and image files for Cosmo Skymed SCS data in GeoTIFF format


        input parameters:
          GeoTIFF  (input) SCS data file in GeoTIFF format
          XML      (input) SCS meta data file in XML format
          trunk    (output) output file name trunk used for output filenames
                   (example: yyyymmdd -> yyyymmdd_pol_beamid.slc yyyymmdd_pol_beamid.slc.par)

        """
        if self.validate_inputs:
            self._validate_par_CS_SLC_TIF(GeoTIFF, XML, trunk)
        if self.mock_outputs:
            self._mock_par_CS_SLC_TIF_outputs(GeoTIFF, XML, trunk)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_CS_SLC_TIF))
        return self._gamma_call("ISP", "par_CS_SLC_TIF", supplied_args)

    def _validate_DORIS_vec(self, SLC_PAR: Path, DOR: Path, nstate: Optional[int] = None) -> None:
        self._validate("DORIS_vec", DOR.exists(), f"DOR path does not exist ({DOR})")

    def _mock_DORIS_vec_outputs(self, SLC_PAR: Path, DOR: Path, nstate: Optional[int] = None) -> None:
        if not SLC_PAR.exists():
            SLC_PAR.touch()

    def DORIS_vec(self, SLC_PAR: Path, DOR: Path, nstate: Optional[int] = None) -> Tuple[int, str, str]:
        """

        Extract ENVISAT DORIS state vectors and write to an ISP image parameter file


        input parameters:
          SLC_par  (input/output)ISP SLC/MLI image parameter file
          DOR      (input) ASAR DORIS data file (DOR_VOR_AXVF)
          nstate   number of state vectors to extract (enter - for default: 11)
        """
        if self.validate_inputs:
            self._validate_DORIS_vec(SLC_PAR, DOR, nstate)
        if self.mock_outputs:
            self._mock_DORIS_vec_outputs(SLC_PAR, DOR, nstate)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.DORIS_vec))
        return self._gamma_call("ISP", "DORIS_vec", supplied_args)

    def _validate_bpf(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        fc_x: Any,
        bw_x: int,
        fc_y: Any,
        bw_y: int,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        dtype: Optional[int] = None,
        zflag: Optional[int] = None,
        beta: Optional[Any] = None,
        fir_len: Optional[Any] = None,
    ) -> None:
        self._validate("bpf", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_bpf_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        fc_x: Any,
        bw_x: int,
        fc_y: Any,
        bw_y: int,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        dtype: Optional[int] = None,
        zflag: Optional[int] = None,
        beta: Optional[Any] = None,
        fir_len: Optional[Any] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def bpf(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        fc_x: Any,
        bw_x: int,
        fc_y: Any,
        bw_y: int,
        roff: Optional[int] = None,
        azoff: Optional[int] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        dtype: Optional[int] = None,
        zflag: Optional[int] = None,
        beta: Optional[Any] = None,
        fir_len: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Interferometric SAR Processor (ISP): Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/bpf.c
        Bandpass filter for 2-dimensional image data (FCOMPLEX, SCOMPLEX, and FLOAT)


        input parameters:
          data_in   (input) input image data  file
          data_out  (output) bandpass filtered image data
          width     number of samples/line
          fc_x      normalized x-coord. (across) filter center frequency (range: -0.5 --> 0.5)
          bw_x      normalized x-coord. bandwidth (range: 0 --> 1.0)
          fc_y      normalized y-coord. (down) filter center frequency (range: -0.5 --> 0.5)
          bw_y      normalized y-coord. bandwidth (range: 0 --> 1.0)
          roff      offset to starting range to filter (enter - for default: 0)
          azoff     offset to starting azimuth to filter (enter - for default: 0)
          nr        number of range pixels to filter  (enter - for default: width - roff)
          naz       number of azimuth lines to filter (enter - for default: nlines - azoff)
          dtype     data type (enter - for default):
                      0: FCOMPLEX (default)
                      1: SCOMPLEX
                      2: FLOAT
          zflag     zero data flag (enter - for default):
                      0: set output to 0.0 when the input data are 0.0 (no_data)(default)
                      1: 0.0 values are considered as valid data
          beta      Kaiser window beta parameter (enter - for default:    4.538)
          fir_len   finite impulse response filter length (default - : 64)

        """
        if self.validate_inputs:
            self._validate_bpf(
                data_in, data_out, width, fc_x, bw_x, fc_y, bw_y, roff, azoff, nr, naz, dtype, zflag, beta, fir_len
            )
        if self.mock_outputs:
            self._mock_bpf_outputs(
                data_in, data_out, width, fc_x, bw_x, fc_y, bw_y, roff, azoff, nr, naz, dtype, zflag, beta, fir_len
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.bpf))
        return self._gamma_call("ISP", "bpf", supplied_args)

    def _validate_image_stat(
        self,
        image: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        report: Optional[Any] = None,
        median_flg: Optional[int] = None,
    ) -> None:
        self._validate("image_stat", image.exists(), f"image path does not exist ({image})")

    def _mock_image_stat_outputs(
        self,
        image: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        report: Optional[Any] = None,
        median_flg: Optional[int] = None,
    ) -> None:
        pass

    def image_stat(
        self,
        image: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        report: Optional[Any] = None,
        median_flg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate mean, standard deviation, number of non-zero values, min, max and median for a rectangular image region (FLOAT format)


        input parameters:
          image         (input) image data file (FLOAT)
          width         image line width (samples/line)
          roff          sample offset to region start (enter - for default: 0)
          loff          line offset to region start (enter - for default: 0)
          nr            region width (samples, enter - for default: width - roff)
          nl            number of lines in the region (enter - for default: image_lines - loff)
          report        output text file (keyword:value format, enter - for none)
                        keywords: file, mean, stdev, total_samples, non_zero_samples, fraction_valid, min, max, median
          median_flg    median calculation flag (enter - for default)
                          0: do not calculate median
                          1: calculate median (default, memory use may be large)

          NOTE: only the non-zero samples are considered in the statistical values

        """
        if self.validate_inputs:
            self._validate_image_stat(image, width, roff, loff, nr, nl, report, median_flg)
        if self.mock_outputs:
            self._mock_image_stat_outputs(image, width, roff, loff, nr, nl, report, median_flg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.image_stat))
        return self._gamma_call("ISP", "image_stat", supplied_args)

    def _validate_clear_flag(
        self, flag: Path, width: int, flag_bits: Any, xmin: int, xmax: int, ymin: int, ymax: int
    ) -> None:
        self._validate("clear_flag", flag.exists(), f"flag path does not exist ({flag})")

    def _mock_clear_flag_outputs(
        self, flag: Path, width: int, flag_bits: Any, xmin: int, xmax: int, ymin: int, ymax: int
    ) -> None:
        pass

    def clear_flag(
        self, flag: Path, width: int, flag_bits: Any, xmin: int, xmax: int, ymin: int, ymax: int
    ) -> Tuple[int, str, str]:
        """

        Clear phase unwrapping flag bits


        input parameters:
          flag       (input)phase unwrapping flag filename
          width      number of samples/row
          flag_bits  byte with value of flag(s) to be cleared:

                Charges = 3	Guides = 4	Low SNR = 8	Visited = 16
                BRANCH PT. = 32	Cuts   = 64	Lawn    = 128

          xmin       starting range pixel offset (default = 0)
          xmax       last range pixel offset (default = width-1)
          ymin       starting azimuth row offset, relative to start (default = 0)
          ymax       last azimuth row offset, relative to start (default = nlines-1)

        """
        if self.validate_inputs:
            self._validate_clear_flag(flag, width, flag_bits, xmin, xmax, ymin, ymax)
        if self.mock_outputs:
            self._mock_clear_flag_outputs(flag, width, flag_bits, xmin, xmax, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.clear_flag))
        return self._gamma_call("ISP", "clear_flag", supplied_args)

    def _validate_par_NovaSAR_GRD(
        self,
        GeoTIFF: Path,
        XML: Path,
        polarization: Any,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        self._validate("par_NovaSAR_GRD", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_NovaSAR_GRD", XML.exists(), f"XML path does not exist ({XML})")

    def _mock_par_NovaSAR_GRD_outputs(
        self,
        GeoTIFF: Path,
        XML: Path,
        polarization: Any,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_NovaSAR_GRD(
        self,
        GeoTIFF: Path,
        XML: Path,
        polarization: Any,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate MLI and GRD image and parameter files for NovaSAR GRD and SCD data


        input parameters:
          GeoTIFF       (input) NovaSAR image data file in GeoTIFF format (enter - for none, *.tif)
          XML           (input) NovaSAR XML annotation file
          polarization  image polarization: HH, VV, HV, VH, CH, CV
          MLI_par       (output) MLI parameter file (example: yyyymmdd_pp.mli.par)
          MLI           (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par       (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD           (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          rps           slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)
          radcal        radiometric calibration flag (enter - for default)
                          0: beta0 (default)
                          1: sigma0
          noise         noise levels flag (enter - for default)
                          0: do not use noise levels (default)
                          1: use noise levels

        """
        if self.validate_inputs:
            self._validate_par_NovaSAR_GRD(GeoTIFF, XML, polarization, MLI_par, MLI, GRD_par, GRD, rps, radcal, noise)
        if self.mock_outputs:
            self._mock_par_NovaSAR_GRD_outputs(
                GeoTIFF, XML, polarization, MLI_par, MLI, GRD_par, GRD, rps, radcal, noise
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_NovaSAR_GRD))
        return self._gamma_call("ISP", "par_NovaSAR_GRD", supplied_args)

    def _validate_slant_range(self, SLC_par: Path, slr: Path) -> None:
        self._validate("slant_range", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_slant_range_outputs(self, SLC_par: Path, slr: Path) -> None:
        if slr is not None and str(slr) != "-":
            slr.touch()

    def slant_range(self, SLC_par: Path, slr: Path) -> Tuple[int, str, str]:
        """

        Calculate slant range for every range sample


        input parameters:
          SLC_par  (input) SLC or MLI image parameter file
          slr      (output) slant range for every sample in the image (float)

        """
        if self.validate_inputs:
            self._validate_slant_range(SLC_par, slr)
        if self.mock_outputs:
            self._mock_slant_range_outputs(SLC_par, slr)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.slant_range))
        return self._gamma_call("ISP", "slant_range", supplied_args)

    def _validate_par_IECAS_SLC(
        self, aux_data: Path, slc_Re: Path, slc_Im: Path, date: Path, SLC_par: Path, SLC: Path
    ) -> None:
        self._validate("par_IECAS_SLC", aux_data.exists(), f"aux_data path does not exist ({aux_data})")
        self._validate("par_IECAS_SLC", slc_Re.exists(), f"slc_Re path does not exist ({slc_Re})")
        self._validate("par_IECAS_SLC", slc_Im.exists(), f"slc_Im path does not exist ({slc_Im})")
        self._validate("par_IECAS_SLC", date.exists(), f"date path does not exist ({date})")

    def _mock_par_IECAS_SLC_outputs(
        self, aux_data: Path, slc_Re: Path, slc_Im: Path, date: Path, SLC_par: Path, SLC: Path
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_IECAS_SLC(
        self, aux_data: Path, slc_Re: Path, slc_Im: Path, date: Path, SLC_par: Path, SLC: Path
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for IECAS SLC data


        input parameters:
          aux_data   (input) IECAS SAR auxillary data (POS*.dat)
          slc_Re     (input) real part of complex SLC data
          slc_Im     (input) imaginary part of complex SLC data
          date       (input) acquistion date format: YYYYMMDD (example 20110121) from aux_data filename
          SLC_par    (output) ISP SLC parameter file
          SLC        (output) SLC image
        """
        if self.validate_inputs:
            self._validate_par_IECAS_SLC(aux_data, slc_Re, slc_Im, date, SLC_par, SLC)
        if self.mock_outputs:
            self._mock_par_IECAS_SLC_outputs(aux_data, slc_Re, slc_Im, date, SLC_par, SLC)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_IECAS_SLC))
        return self._gamma_call("ISP", "par_IECAS_SLC", supplied_args)

    def _validate_corr_flag(
        self,
        corr: Path,
        flag: Path,
        width: int,
        corr_thr: Any,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        border: Optional[Any] = None,
    ) -> None:
        self._validate("corr_flag", corr.exists(), f"corr path does not exist ({corr})")

    def _mock_corr_flag_outputs(
        self,
        corr: Path,
        flag: Path,
        width: int,
        corr_thr: Any,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        border: Optional[Any] = None,
    ) -> None:
        if not flag.exists():
            flag.touch()

    def corr_flag(
        self,
        corr: Path,
        flag: Path,
        width: int,
        corr_thr: Any,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        border: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Low correlation region detection for phase unwrapping


        input parameters:
          corr      (input)interferometric correlation file
          flag      (input/output) phase unwrapping flag filename
          width     number of samples/row
          corr_thr  correlation threshold (0 --> 1.0)
          xmin      starting range pixel offset (default = 0)
          xmax      last range pixel offset (default = width-1)
          ymin      starting azimuth row offset, relative to start (default = 0)
          ymax      last azimuth row offset, relative to start (default = nlines-1)
          border    effective range of low coherence pixels to set low coherence flag (default=2)

        """
        if self.validate_inputs:
            self._validate_corr_flag(corr, flag, width, corr_thr, xmin, xmax, ymin, ymax, border)
        if self.mock_outputs:
            self._mock_corr_flag_outputs(corr, flag, width, corr_thr, xmin, xmax, ymin, ymax, border)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.corr_flag))
        return self._gamma_call("ISP", "corr_flag", supplied_args)

    def _validate_ptarg_cal_MLI(
        self,
        MLI_par: Path,
        MLI: Path,
        r_samp: Any,
        az_samp: Any,
        psigma: Any,
        c_r_samp: Any,
        c_az_samp: Any,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[Any] = None,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
        psz: Optional[Any] = None,
        csz: Optional[Any] = None,
        theta_inc: Optional[Any] = None,
    ) -> None:
        self._validate("ptarg_cal_MLI", MLI_par.exists(), f"MLI_par path does not exist ({MLI_par})")
        self._validate("ptarg_cal_MLI", MLI.exists(), f"MLI path does not exist ({MLI})")

    def _mock_ptarg_cal_MLI_outputs(
        self,
        MLI_par: Path,
        MLI: Path,
        r_samp: Any,
        az_samp: Any,
        psigma: Any,
        c_r_samp: Any,
        c_az_samp: Any,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[Any] = None,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
        psz: Optional[Any] = None,
        csz: Optional[Any] = None,
        theta_inc: Optional[Any] = None,
    ) -> None:
        if ptr_image is not None and str(ptr_image) != "-":
            ptr_image.touch()
        if r_plot is not None and str(r_plot) != "-":
            r_plot.touch()
        if az_plot is not None and str(az_plot) != "-":
            az_plot.touch()
        if pcal is not None and str(pcal) != "-":
            pcal.touch()

    def ptarg_cal_MLI(
        self,
        MLI_par: Path,
        MLI: Path,
        r_samp: Any,
        az_samp: Any,
        psigma: Any,
        c_r_samp: Any,
        c_az_samp: Any,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[Any] = None,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
        psz: Optional[Any] = None,
        csz: Optional[Any] = None,
        theta_inc: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Point target analysis and radiometric calibration of slant-range and ground-range (GRD) images


        input parameters:
          MLI_par    (input) slant-range or ground-range image parameter file for detected intensity data
          MLI        (input) ground-range or slant range detected image in FLOAT format
          r_samp     point target range sample number, target region size is 16x16
          az_samp    point target azimuth line number, target region size is 16x16
          psigma     radar cross-section of the calibration target in m**2
          c_r_samp   clutter region center range sample number, clutter region size is 16x16
          c_az_samp  clutter region center azimuth line number, clutter region size is 16x16
          ptr_image  (output) oversampled point target image, with and without phase gradient, nominal width: 256
          r_plot     (output) range point target response plot data (text format)
          az_plot    (output) azimuth point target response plot data (text format)
          pcal       (output) measured point target parameters and radiometric calibration factor (text format)
          osf        image over-sampling factor, 2, 4, 8, 16, 32, 64 (enter - for default: 16)
          win        maximum search window offset (samples) (enter - for default: 1)
          pltflg     plotting mode flag:
                       0: none
                       1: output plots in PNG format (default)
                       2: screen output
                       3: output plots in PDF format
          psz        point target region size (samples) (enter - for default: 16)
          csz        clutter region size (samples) (enter - for default: 16)
          theta_inc  incidence angle required for calibration of terrain corrrected RISAT-1 images
        """
        if self.validate_inputs:
            self._validate_ptarg_cal_MLI(
                MLI_par,
                MLI,
                r_samp,
                az_samp,
                psigma,
                c_r_samp,
                c_az_samp,
                ptr_image,
                r_plot,
                az_plot,
                pcal,
                osf,
                win,
                pltflg,
                psz,
                csz,
                theta_inc,
            )
        if self.mock_outputs:
            self._mock_ptarg_cal_MLI_outputs(
                MLI_par,
                MLI,
                r_samp,
                az_samp,
                psigma,
                c_r_samp,
                c_az_samp,
                ptr_image,
                r_plot,
                az_plot,
                pcal,
                osf,
                win,
                pltflg,
                psz,
                csz,
                theta_inc,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ptarg_cal_MLI))
        return self._gamma_call("ISP", "ptarg_cal_MLI", supplied_args)

    def _validate_ORB_filt(
        self, SLC_par_in: Path, SLC_par_out: Path, interval: Optional[Any] = None, extra: Optional[Any] = None
    ) -> None:
        self._validate("ORB_filt", SLC_par_in.exists(), f"SLC_par_in path does not exist ({SLC_par_in})")

    def _mock_ORB_filt_outputs(
        self, SLC_par_in: Path, SLC_par_out: Path, interval: Optional[Any] = None, extra: Optional[Any] = None
    ) -> None:
        if SLC_par_out is not None and str(SLC_par_out) != "-":
            SLC_par_out.touch()

    def ORB_filt(
        self, SLC_par_in: Path, SLC_par_out: Path, interval: Optional[Any] = None, extra: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        Filter state vectors using a least-squares polynomial model


        input parameters:
          SLC_par_in   (input) ISP image parameter file at least 5 state vectors
          SLC_par_out  (output) ISP image parameter file with state vectors filtered using least-squares
          interval     time interval between state vectors (enter - for default: state vector time interval in SLC_par)
          extra        extra time for state vectors at start and end of image (sec.) (enter - for default: 5.0)
        """
        if self.validate_inputs:
            self._validate_ORB_filt(SLC_par_in, SLC_par_out, interval, extra)
        if self.mock_outputs:
            self._mock_ORB_filt_outputs(SLC_par_in, SLC_par_out, interval, extra)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORB_filt))
        return self._gamma_call("ISP", "ORB_filt", supplied_args)

    def _validate_offset_sub(self, offs: Path, OFF_par: Path, offs_sub: Path) -> None:
        self._validate("offset_sub", offs.exists(), f"offs path does not exist ({offs})")
        self._validate("offset_sub", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_offset_sub_outputs(self, offs: Path, OFF_par: Path, offs_sub: Path) -> None:
        if offs_sub is not None and str(offs_sub) != "-":
            offs_sub.touch()

    def offset_sub(self, offs: Path, OFF_par: Path, offs_sub: Path) -> Tuple[int, str, str]:
        """

        Subtraction of polynomial from range and azimuth offset estimates


        input parameters:
          offs      (input) range and azimuth offset estimates (fcomplex)
          OFF_par   (input) ISP offset/interferogram parameter file
          offs_sub  (output) range and azimuth offset estimates after polynomial subtraction (fcomplex)
        """
        if self.validate_inputs:
            self._validate_offset_sub(offs, OFF_par, offs_sub)
        if self.mock_outputs:
            self._mock_offset_sub_outputs(offs, OFF_par, offs_sub)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_sub))
        return self._gamma_call("ISP", "offset_sub", supplied_args)

    def _validate_radcal_MLI(
        self,
        MLI: Path,
        MLI_PAR: Path,
        OFF_par: Path,
        CMLI: Path,
        antenna: Optional[Path] = None,
        rloss_flag: Optional[Any] = None,
        ant_flag: Optional[Any] = None,
        refarea_flag: Optional[Any] = None,
        sc_dB: Optional[Any] = None,
        K_dB: Optional[Any] = None,
        pix_area: Optional[Path] = None,
    ) -> None:
        self._validate("radcal_MLI", MLI.exists(), f"MLI path does not exist ({MLI})")
        self._validate("radcal_MLI", MLI_PAR.exists(), f"MLI_PAR path does not exist ({MLI_PAR})")
        self._validate("radcal_MLI", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        if antenna is not None:
            self._validate("radcal_MLI", antenna.exists(), f"antenna path does not exist ({antenna})")

    def _mock_radcal_MLI_outputs(
        self,
        MLI: Path,
        MLI_PAR: Path,
        OFF_par: Path,
        CMLI: Path,
        antenna: Optional[Path] = None,
        rloss_flag: Optional[Any] = None,
        ant_flag: Optional[Any] = None,
        refarea_flag: Optional[Any] = None,
        sc_dB: Optional[Any] = None,
        K_dB: Optional[Any] = None,
        pix_area: Optional[Path] = None,
    ) -> None:
        if CMLI is not None and str(CMLI) != "-":
            CMLI.touch()
        if pix_area is not None and str(pix_area) != "-":
            pix_area.touch()

    def radcal_MLI(
        self,
        MLI: Path,
        MLI_PAR: Path,
        OFF_par: Path,
        CMLI: Path,
        antenna: Optional[Path] = None,
        rloss_flag: Optional[Any] = None,
        ant_flag: Optional[Any] = None,
        refarea_flag: Optional[Any] = None,
        sc_dB: Optional[Any] = None,
        K_dB: Optional[Any] = None,
        pix_area: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Radiometric calibration for multi-look intensity (MLI) data


        input parameters:
          MLI           (input) MLI image (float)
          MLI_PAR       (input) SLC parameter file of input MLI image
          OFF_par       (input) ISP offset/interferogram parameter file (enter - for images in MLI geometry)
          CMLI          (output) radiometrically calibrated output MLI (float)
          antenna       (input) 1-way antenna gain pattern file or - if not provided
          rloss_flag    range spreading loss correction:
                           0: no correction (default)
                           1: apply r^3 correction  (all modes except ASAR APS)
                           2: apply r^4 correction (used only for ASAR APS mode)
                          -1: undo r^3 correction
                          -2: undo r^4 correction)
          ant_flag      antenna pattern correction:
                           0: no correction (default)
                           1: apply antenna pattern correction
                          -1: undo antenna pattern correction)
          refarea_flag  reference pixel area correction:
                           0: no pixel area correction (default)
                           1: calculate sigma0, scale area by sin(inc_ang)/sin(ref_inc_ang)
                           2: calculate gamma0, scale area by sin(inc_ang)/(cos(inc_ang)*sin(ref_inc_ang)
                          -1: undo sigma0 area scaling factor
                          -2: undo gamma0 area scaling factor
          sc_dB         scale factor in dB (default: 0.0)
          K_dB          calibration factor in dB (default: -(value from MLI_PAR))
          pix_area      (output) ellipsoid-based ground range sigma0 or gamma0 pixel reference area (float)
                           refarea_flag 1 or -1: sigma0 ref. area
                           refarea_flag 2 or -2: gamma0 ref. area

        """
        if self.validate_inputs:
            self._validate_radcal_MLI(
                MLI, MLI_PAR, OFF_par, CMLI, antenna, rloss_flag, ant_flag, refarea_flag, sc_dB, K_dB, pix_area
            )
        if self.mock_outputs:
            self._mock_radcal_MLI_outputs(
                MLI, MLI_PAR, OFF_par, CMLI, antenna, rloss_flag, ant_flag, refarea_flag, sc_dB, K_dB, pix_area
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.radcal_MLI))
        return self._gamma_call("ISP", "radcal_MLI", supplied_args)

    def _validate_S1_OPOD_vec(self, SLC_PAR: Path, OPOD: Path, nstate: Optional[int] = None) -> None:
        self._validate("S1_OPOD_vec", OPOD.exists(), f"OPOD path does not exist ({OPOD})")

    def _mock_S1_OPOD_vec_outputs(self, SLC_PAR: Path, OPOD: Path, nstate: Optional[int] = None) -> None:
        if not SLC_PAR.exists():
            SLC_PAR.touch()

    def S1_OPOD_vec(self, SLC_PAR: Path, OPOD: Path, nstate: Optional[int] = None) -> Tuple[int, str, str]:
        """

        Extract Sentinel-1 OPOD state vectors and copy into the ISP image parameter file


        input parameters:
          SLC_par  (input/output)ISP SLC/MLI image parameter file
          OPOD     (input) Sentinel-1 OPOD orbit data file (AUX_POEORB or AUX_RESORB)
                   https://qc.sentinel1.eo.esa.int/aux_resorb/
          nstate   number of state vectors to extract (default: include 60 sec extention at the start and end of the SLC data)
        """
        if self.validate_inputs:
            self._validate_S1_OPOD_vec(SLC_PAR, OPOD, nstate)
        if self.mock_outputs:
            self._mock_S1_OPOD_vec_outputs(SLC_PAR, OPOD, nstate)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.S1_OPOD_vec))
        return self._gamma_call("ISP", "S1_OPOD_vec", supplied_args)

    def _validate_par_RCM_GRD(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise: Any,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        self._validate("par_RCM_GRD", RCM_dir.exists(), f"RCM_dir path does not exist ({RCM_dir})")

    def _mock_par_RCM_GRD_outputs(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise: Any,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()
        if noise_pwr is not None and str(noise_pwr) != "-":
            noise_pwr.touch()

    def par_RCM_GRD(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise: Any,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
        noise_pwr: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate MLI and GRD images and parameter files from a Radarsat Constellation GRD (Ground Range georeferenced Detected) product


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM1_OK1001327_PK1001418_1_3M28_20160417_013625_HH_GRD)
          polarization   image polarization: HH, VV, HV, VH, CH, CV
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise          noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          MLI_par        (output) MLI parameter file (example: yyyymmdd_pp.mli.par, enter - for none)
          MLI            (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par        (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD            (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          rps            slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)
          noise_pwr      (output) noise intensity for each MLI sample in slant range using data from noise levels file (enter - for none)
                         NOTE: when the noise_pwr file is specified, noise power correction will NOT be applied to the GRD / MLI data values

        """
        if self.validate_inputs:
            self._validate_par_RCM_GRD(RCM_dir, polarization, radcal, noise, MLI_par, MLI, GRD_par, GRD, rps, noise_pwr)
        if self.mock_outputs:
            self._mock_par_RCM_GRD_outputs(
                RCM_dir, polarization, radcal, noise, MLI_par, MLI, GRD_par, GRD, rps, noise_pwr
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_GRD))
        return self._gamma_call("ISP", "par_RCM_GRD", supplied_args)

    def _validate_offset_pwr_tracking(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        self._validate("offset_pwr_tracking", SLC1.exists(), f"SLC1 path does not exist ({SLC1})")
        self._validate("offset_pwr_tracking", SLC2.exists(), f"SLC2 path does not exist ({SLC2})")
        self._validate("offset_pwr_tracking", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("offset_pwr_tracking", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("offset_pwr_tracking", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_offset_pwr_tracking_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if ccp is not None and str(ccp) != "-":
            ccp.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()
        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr_tracking(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Offset tracking between SLC images using intensity cross-correlation


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          deramp    deramp SLC phase flag (enter - for default)
                      0: no deramp (Doppler centroid close to 0) (default)
                      1: deramp SLC phase
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)

        NOTE: ScanSAR and TOPS data need to be previously deramped

        """
        if self.validate_inputs:
            self._validate_offset_pwr_tracking(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        if self.mock_outputs:
            self._mock_offset_pwr_tracking_outputs(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                lanczos,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_tracking))
        return self._gamma_call("ISP", "offset_pwr_tracking", supplied_args)

    def _validate_SLC_phase_shift(
        self, SLC_1: Path, SLC_par1: Path, SLC_2: Path, SLC_par2: Path, ph_shift: Any
    ) -> None:
        self._validate("SLC_phase_shift", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("SLC_phase_shift", SLC_par1.exists(), f"SLC_par1 path does not exist ({SLC_par1})")

    def _mock_SLC_phase_shift_outputs(
        self, SLC_1: Path, SLC_par1: Path, SLC_2: Path, SLC_par2: Path, ph_shift: Any
    ) -> None:
        if SLC_2 is not None and str(SLC_2) != "-":
            SLC_2.touch()
        if SLC_par2 is not None and str(SLC_par2) != "-":
            SLC_par2.touch()

    def SLC_phase_shift(
        self, SLC_1: Path, SLC_par1: Path, SLC_2: Path, SLC_par2: Path, ph_shift: Any
    ) -> Tuple[int, str, str]:
        """

        Add a constant phase from an SLC image


        input parameters:
          SLC-1     (input) SLC data file (fcomplex or scomplex format)
          SLC_par1  (input) SLC parameter file
          SLC-2     (output) SLC with phase shift
          SLC_par2  (output) SLC parameter file for the output SLC
          ph_shift  phase shift to add to SLC phase (radians)

          NOTE: Used to apply a constant phase shift of -1.25 radians to Sentinel-1 TOPS SLC data
                from swath IW1 acquired up to 10-Mar-2015.

                Used to apply a constant phase shift of -3.83 radians to Sentinel-1 TOPS SLC data with
                H-POL on receive (e.g. VH) acquired up to 10-Mar-2015.

        """
        if self.validate_inputs:
            self._validate_SLC_phase_shift(SLC_1, SLC_par1, SLC_2, SLC_par2, ph_shift)
        if self.mock_outputs:
            self._mock_SLC_phase_shift_outputs(SLC_1, SLC_par1, SLC_2, SLC_par2, ph_shift)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_phase_shift))
        return self._gamma_call("ISP", "SLC_phase_shift", supplied_args)

    def _validate_unw_model(
        self,
        interf: Path,
        unw_model: Path,
        unw: Path,
        width: int,
        xinit: Optional[int] = None,
        yinit: Optional[int] = None,
        ref_ph: Optional[Any] = None,
        width_model: Optional[int] = None,
    ) -> None:
        self._validate("unw_model", interf.exists(), f"interf path does not exist ({interf})")
        self._validate("unw_model", unw_model.exists(), f"unw_model path does not exist ({unw_model})")

    def _mock_unw_model_outputs(
        self,
        interf: Path,
        unw_model: Path,
        unw: Path,
        width: int,
        xinit: Optional[int] = None,
        yinit: Optional[int] = None,
        ref_ph: Optional[Any] = None,
        width_model: Optional[int] = None,
    ) -> None:
        if unw is not None and str(unw) != "-":
            unw.touch()

    def unw_model(
        self,
        interf: Path,
        unw_model: Path,
        unw: Path,
        width: int,
        xinit: Optional[int] = None,
        yinit: Optional[int] = None,
        ref_ph: Optional[Any] = None,
        width_model: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Phase unwrapping using a model of the unwrapped phase


        input parameters:
          interf       (input) complex interferogram
          unw_model    (input) approximate unwrapped phase model (float)
          unw          (output) unwrapped phase (float)
          width        number of samples/row of the interferogram
          xinit        offset to phase reference location in range (col)
          yinit        offset to phase reference location in azimuth (row)
          ref_ph       reference point phase (radians) (enter - for phase at the reference point )
          width_model  number of samples/row of the unwrapped phase model (default: interferogram width)

        """
        if self.validate_inputs:
            self._validate_unw_model(interf, unw_model, unw, width, xinit, yinit, ref_ph, width_model)
        if self.mock_outputs:
            self._mock_unw_model_outputs(interf, unw_model, unw, width, xinit, yinit, ref_ph, width_model)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.unw_model))
        return self._gamma_call("ISP", "unw_model", supplied_args)

    def _validate_par_TX_SLC(
        self,
        annotation_XML: Path,
        COSAR: Path,
        SLC_par: Path,
        SLC: Path,
        pol: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("par_TX_SLC", annotation_XML.exists(), f"annotation_XML path does not exist ({annotation_XML})")
        self._validate("par_TX_SLC", COSAR.exists(), f"COSAR path does not exist ({COSAR})")

    def _mock_par_TX_SLC_outputs(
        self,
        annotation_XML: Path,
        COSAR: Path,
        SLC_par: Path,
        SLC: Path,
        pol: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_TX_SLC(
        self,
        annotation_XML: Path,
        COSAR: Path,
        SLC_par: Path,
        SLC: Path,
        pol: Optional[Any] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter file and SLC image from a Terrasar-X SSC data set


        input parameters:
          annotation_XML (input) TerraSAR-X product annotation XML file
          COSAR          (input) COSAR SSC stripmap or spotlight mode SLC data file
          SLC_par        (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC            (output) SLC data file, example: yyyymmdd.slc (enter - for none, SLC output will not be produced)
          pol            polarisation HH, HV, VH, VV (enter - for default: first polarisation found in the annotation_XML)
          dtype          output data type (enter - for default)
                           0: same as input (default)
                           1: FCOMPLEX

        """
        if self.validate_inputs:
            self._validate_par_TX_SLC(annotation_XML, COSAR, SLC_par, SLC, pol, dtype)
        if self.mock_outputs:
            self._mock_par_TX_SLC_outputs(annotation_XML, COSAR, SLC_par, SLC, pol, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_TX_SLC))
        return self._gamma_call("ISP", "par_TX_SLC", supplied_args)

    def _validate_ScanSAR_burst_MLI(
        self,
        SLC_tab: Path,
        MLI_tab: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        MLI_dir: Optional[Any] = None,
        scale: Optional[Any] = None,
    ) -> None:
        self._validate("ScanSAR_burst_MLI", SLC_tab.exists(), f"SLC_tab path does not exist ({SLC_tab})")
        if SLCR_tab is not None:
            self._validate("ScanSAR_burst_MLI", SLCR_tab.exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_ScanSAR_burst_MLI_outputs(
        self,
        SLC_tab: Path,
        MLI_tab: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        MLI_dir: Optional[Any] = None,
        scale: Optional[Any] = None,
    ) -> None:
        if MLI_tab is not None and str(MLI_tab) != "-":
            MLI_tab.touch()

    def ScanSAR_burst_MLI(
        self,
        SLC_tab: Path,
        MLI_tab: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        MLI_dir: Optional[Any] = None,
        scale: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate MLI burst data from ScanSAR burst SLC data (Sentinel-1, RCM, and TSX)


        input parameters:
          SLC_tab   (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par
          MLI_tab   (output) 3 column list of MLI swaths listed in order from near to far range
                      MLI_tab line entries:   MLI   MLI_par  TOPS_par
                    NOTE: if the MLI_tab does not yet exist, the file entries will be created with names derived from the SLC_tab entries
          rlks      number of range looks  (1...80)
          azlks     number of azimuth look (1...20)
          bflg      burst window calculation flag (enter - for default):
                      0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                      1: calculate burst window parameters from burst parameters and the number of range and azimuth looks
          SLCR_tab  (input) 3 column list of the reference scene with swaths, listed in order from near to far range, enter - for none
                      SLCR_tab line entries:   SLC    SLC_par   TOPS_par
          MLI_dir   directory for output burst MLI data, ignored if the MLI_tab already exists (default: current directory)
          scale     scale factor for output MLI (enter - for default: calculate from calibration gain in SLC parameter file)

        """
        if self.validate_inputs:
            self._validate_ScanSAR_burst_MLI(SLC_tab, MLI_tab, rlks, azlks, bflg, SLCR_tab, MLI_dir, scale)
        if self.mock_outputs:
            self._mock_ScanSAR_burst_MLI_outputs(SLC_tab, MLI_tab, rlks, azlks, bflg, SLCR_tab, MLI_dir, scale)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_MLI))
        return self._gamma_call("ISP", "ScanSAR_burst_MLI", supplied_args)

    def _validate_base_copy(
        self, SLC1_par: Path, baseline_1: Path, SLC2_par: Path, baseline_2: Path, time_rev: Optional[Any] = None
    ) -> None:
        self._validate("base_copy", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("base_copy", baseline_1.exists(), f"baseline_1 path does not exist ({baseline_1})")
        self._validate("base_copy", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_base_copy_outputs(
        self, SLC1_par: Path, baseline_1: Path, SLC2_par: Path, baseline_2: Path, time_rev: Optional[Any] = None
    ) -> None:
        if baseline_2 is not None and str(baseline_2) != "-":
            baseline_2.touch()

    def base_copy(
        self, SLC1_par: Path, baseline_1: Path, SLC2_par: Path, baseline_2: Path, time_rev: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        Calculate baseline file for a subsection of a reference SLC


        input parameters:
          SLC1_par    (input) ISP image parameter file of the reference SLC
          baseline-1  (input) baseline file derived using the reference SLC geometry
          SLC2_par    (input) ISP image parameter file corresponding to the subsecton of the reference SLC
          baseline-2  (output) baseline file derived using the geometry and timing of the SLC subsection
          time_rev    SLC image normal=1,  time-reversed = -1 (default=1)

        """
        if self.validate_inputs:
            self._validate_base_copy(SLC1_par, baseline_1, SLC2_par, baseline_2, time_rev)
        if self.mock_outputs:
            self._mock_base_copy_outputs(SLC1_par, baseline_1, SLC2_par, baseline_2, time_rev)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_copy))
        return self._gamma_call("ISP", "base_copy", supplied_args)

    def _validate_SLC_interp_map(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        OFF_par2: Path,
        coffs_sm: Path,
        loff: Optional[int],
        nlines: Optional[int],
        mode: int,
    ) -> None:
        self._validate("SLC_interp_map", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("SLC_interp_map", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("SLC_interp_map", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("SLC_interp_map", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("SLC_interp_map", OFF_par2.exists(), f"OFF_par2 path does not exist ({OFF_par2})")
        self._validate("SLC_interp_map", coffs_sm.exists(), f"coffs_sm path does not exist ({coffs_sm})")

    def _mock_SLC_interp_map_outputs(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        OFF_par2: Path,
        coffs_sm: Path,
        loff: Optional[int],
        nlines: Optional[int],
        mode: int,
    ) -> None:
        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()
        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp_map(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        OFF_par2: Path,
        coffs_sm: Path,
        loff: Optional[int],
        nlines: Optional[int],
        mode: int,
    ) -> Tuple[int, str, str]:
        """

        SLC image resampling using a 2-D offset map


        input parameters:
          SLC-2      (input) SLC-2 image to be resampled to the reference SLC-1 reference image
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2_par   (input) SLC-2 ISP image parameter file
          OFF_par    (input) ISP offset/interferogram parameter file
          SLC-2R     (output) single-look complex image 2 coregistered to SLC-1
          SLC2R_par  (output) SLC-2R ISP image parameter file for co-registered image
          OFF_par2   (input) ISP offset/interferogram parameter file used for residual offsets map (coffs2_sm)
          coffs2_sm  (input) smoothed residual range and azimuth offsets (fcomplex)
          loff       offset to first valid output line (in SLC-1 lines) (enter - for default: 0)
          nlines     number of valid output lines (enter - or 0 for default: to end of file)
          mode       interpolation mode (enter - for default)
                       0: Lanczos (default)
                       1: B-spline
          order      Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)

        """
        if self.validate_inputs:
            self._validate_SLC_interp_map(
                SLC_2, SLC1_par, SLC2_par, OFF_par, SLC_2R, SLC2R_par, OFF_par2, coffs_sm, loff, nlines, mode
            )
        if self.mock_outputs:
            self._mock_SLC_interp_map_outputs(
                SLC_2, SLC1_par, SLC2_par, OFF_par, SLC_2R, SLC2R_par, OFF_par2, coffs_sm, loff, nlines, mode
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp_map))
        return self._gamma_call("ISP", "SLC_interp_map", supplied_args)

    def _validate_base_perp(
        self, baseline: Path, SLC1_par: Path, OFF_par: Path, time_rev: Optional[Any] = None
    ) -> None:
        self._validate("base_perp", baseline.exists(), f"baseline path does not exist ({baseline})")
        self._validate("base_perp", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("base_perp", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_base_perp_outputs(
        self, baseline: Path, SLC1_par: Path, OFF_par: Path, time_rev: Optional[Any] = None
    ) -> None:
        pass

    def base_perp(
        self, baseline: Path, SLC1_par: Path, OFF_par: Path, time_rev: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        Calculate baseline components perpendicular and parallel to look vector


        input parameters:
          baseline  (input) baseline file (text)
          SLC1_par  (input) ISP parameter file of SLC-1 (reference SLC)
          OFF_par   (input) ISP interferogram/offset parameter file
          time_rev  SLC image normal=1 (default), image time-reversed = -1

        """
        if self.validate_inputs:
            self._validate_base_perp(baseline, SLC1_par, OFF_par, time_rev)
        if self.mock_outputs:
            self._mock_base_perp_outputs(baseline, SLC1_par, OFF_par, time_rev)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_perp))
        return self._gamma_call("ISP", "base_perp", supplied_args)

    def _validate_SLC_RFI_filt(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[Any] = None,
        nfft_r: Optional[Any] = None,
        nfft_az: Optional[Any] = None,
        r_step: Optional[Any] = None,
        az_step: Optional[Any] = None,
        mwin_r: Optional[Any] = None,
        mwin_az: Optional[Any] = None,
    ) -> None:
        self._validate("SLC_RFI_filt", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("SLC_RFI_filt", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_SLC_RFI_filt_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[Any] = None,
        nfft_r: Optional[Any] = None,
        nfft_az: Optional[Any] = None,
        r_step: Optional[Any] = None,
        az_step: Optional[Any] = None,
        mwin_r: Optional[Any] = None,
        mwin_az: Optional[Any] = None,
    ) -> None:
        if SLC_filt is not None and str(SLC_filt) != "-":
            SLC_filt.touch()

    def SLC_RFI_filt(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[Any] = None,
        nfft_r: Optional[Any] = None,
        nfft_az: Optional[Any] = None,
        r_step: Optional[Any] = None,
        az_step: Optional[Any] = None,
        mwin_r: Optional[Any] = None,
        mwin_az: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Adaptive RFI filtering for SLC image using median spectral filtering


        input parameters:
          SLC          (input) SLC to be filtered (FCOMPLEX or SCOMPLEX)
          SLC_par      (input) reference SLC parameter file
          SLC_filt     (output) output filtered SLC using the power spectrum of the reference SLC
          rfi_thres    RFI threshold (default: 10.00)
          nfft_r       range filter FFT window size, 2**N, 16->1024, (enter - for default: 128)
          nfft_az      azimuth filter FFT window size, 2**N, 16->1024, (enter - for default: 128)
          r_step       range processing step (enter - for default: nfft_r/4)
          az_step      azimuth processing step (enter - for default: nfft_az/4)
          mwin_r       range median window size for median PSD filtering (enter - for default: 5)
          mwin_az      azimuth median window size for median PSD filtering (enter - for default: 5)

        """
        if self.validate_inputs:
            self._validate_SLC_RFI_filt(
                SLC, SLC_par, SLC_filt, rfi_thres, nfft_r, nfft_az, r_step, az_step, mwin_r, mwin_az
            )
        if self.mock_outputs:
            self._mock_SLC_RFI_filt_outputs(
                SLC, SLC_par, SLC_filt, rfi_thres, nfft_r, nfft_az, r_step, az_step, mwin_r, mwin_az
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_RFI_filt))
        return self._gamma_call("ISP", "SLC_RFI_filt", supplied_args)

    def _validate_SLC_adf(
        self,
        SLC: Path,
        ref_SLC: Path,
        ref_SLC_par: Path,
        SLC_filt: Path,
        mode: Optional[int] = None,
        alpha: Optional[Any] = None,
        nfft_r: Optional[Any] = None,
        nfft_az: Optional[Any] = None,
        r_step: Optional[Any] = None,
        az_step: Optional[Any] = None,
        mwin_r: Optional[Any] = None,
        mwin_az: Optional[Any] = None,
    ) -> None:
        self._validate("SLC_adf", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("SLC_adf", ref_SLC.exists(), f"ref_SLC path does not exist ({ref_SLC})")
        self._validate("SLC_adf", ref_SLC_par.exists(), f"ref_SLC_par path does not exist ({ref_SLC_par})")

    def _mock_SLC_adf_outputs(
        self,
        SLC: Path,
        ref_SLC: Path,
        ref_SLC_par: Path,
        SLC_filt: Path,
        mode: Optional[int] = None,
        alpha: Optional[Any] = None,
        nfft_r: Optional[Any] = None,
        nfft_az: Optional[Any] = None,
        r_step: Optional[Any] = None,
        az_step: Optional[Any] = None,
        mwin_r: Optional[Any] = None,
        mwin_az: Optional[Any] = None,
    ) -> None:
        if SLC_filt is not None and str(SLC_filt) != "-":
            SLC_filt.touch()

    def SLC_adf(
        self,
        SLC: Path,
        ref_SLC: Path,
        ref_SLC_par: Path,
        SLC_filt: Path,
        mode: Optional[int] = None,
        alpha: Optional[Any] = None,
        nfft_r: Optional[Any] = None,
        nfft_az: Optional[Any] = None,
        r_step: Optional[Any] = None,
        az_step: Optional[Any] = None,
        mwin_r: Optional[Any] = None,
        mwin_az: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Adaptive filtering of SLC data based on the local PSD of a reference SLC image


        input parameters:
          SLC           (input) SLC to be filtered (FCOMPLEX or SCOMPLEX)
          ref_SLC       (input) reference SLC
          ref_SLC_par   (input) reference SLC parameter file
          SLC_filt      (output) output filtered SLC using the power spectrum of the reference SLC
          mode          SLC filtering mode (enter - for default):
                          0: 1D range PSD filter
                          1: 1D azimuth PSD filter
                          2: 2D range PSD * azimuth PSD filter
                          3: 2D median-filtered PSD filtering (default)
          alpha         exponent to apply to PSD value (enter - for default: 0.30)
          nfft_r        range filter FFT window size, 2**N, 16->1024, (enter - for default: 128)
          nfft_az       azimuth filter FFT window size, 2**N, 16->1024, (enter - for default: 128)
          r_step        range processing step (enter - for default: nfft_r/4)
          az_step       azimuth processing step (enter - for default: nfft_az/4)
          mwin_r        range median window size for median PSD filtering (enter - for default: 5)
          mwin_az       azimuth median window size for median PSD filtering (enter - for default: 5)

        """
        if self.validate_inputs:
            self._validate_SLC_adf(
                SLC, ref_SLC, ref_SLC_par, SLC_filt, mode, alpha, nfft_r, nfft_az, r_step, az_step, mwin_r, mwin_az
            )
        if self.mock_outputs:
            self._mock_SLC_adf_outputs(
                SLC, ref_SLC, ref_SLC_par, SLC_filt, mode, alpha, nfft_r, nfft_az, r_step, az_step, mwin_r, mwin_az
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_adf))
        return self._gamma_call("ISP", "SLC_adf", supplied_args)

    def _validate_offset_SLC(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        ISZ: Optional[Any] = None,
        pflag: Optional[Any] = None,
    ) -> None:
        self._validate("offset_SLC", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("offset_SLC", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("offset_SLC", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("offset_SLC", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("offset_SLC", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_offset_SLC_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        ISZ: Optional[Any] = None,
        pflag: Optional[Any] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if snr is not None and str(snr) != "-":
            snr.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()

    def offset_SLC(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        ISZ: Optional[Any] = None,
        pflag: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Offsets between SLC images using fringe visibility


        input parameters:
          SLC-1     (input) single-look complex image 1 (reference)
          SLC-2     (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates (fcomplex)
          snr       (output) offset estimation SNR (float)
          rwin      search window size (range pixels, (enter - for default from offset parameter file))
          azwin     search window size (azimuth lines, (enter - for default from offset parameter file))
          offsets   (output) range and azimuth offsets and SNR data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4) default = 2)
          nr        number of offset estimates in range direction (enter - for default from offset parameter file)
          naz       number of offset estimates in azimuth direction (enter - for default from offset parameter file)
          thres     offset estimation quality threshold (enter - for default from offset parameter file)
          ISZ       search chip interferogram size (in non-oversampled pixels, default=16)
          pflag     print flag (0:print offset summary  default=1:print all offset data)

        """
        if self.validate_inputs:
            self._validate_offset_SLC(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                snr,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                ISZ,
                pflag,
            )
        if self.mock_outputs:
            self._mock_offset_SLC_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                snr,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                ISZ,
                pflag,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_SLC))
        return self._gamma_call("ISP", "offset_SLC", supplied_args)

    def _validate_adf(
        self,
        interf: Path,
        sm: float,
        cc: Path,
        width: int,
        alpha: Optional[Any] = None,
        nfft: Optional[Any] = None,
        cc_win: Optional[Any] = None,
        step: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[Any] = None,
    ) -> None:
        self._validate("adf", interf.exists(), f"interf path does not exist ({interf})")

    def _mock_adf_outputs(
        self,
        interf: Path,
        sm: float,
        cc: Path,
        width: int,
        alpha: Optional[Any] = None,
        nfft: Optional[Any] = None,
        cc_win: Optional[Any] = None,
        step: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[Any] = None,
    ) -> None:
        if cc is not None and str(cc) != "-":
            cc.touch()

    def adf(
        self,
        interf: Path,
        sm: float,
        cc: Path,
        width: int,
        alpha: Optional[Any] = None,
        nfft: Optional[Any] = None,
        cc_win: Optional[Any] = None,
        step: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        wfrac: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Adaptive interferogram bandpass filter based on the power spectral density


        input parameters:
          interf  (input) interferogram (fcomplex)
          sm      (output) filtered interferogram (fcomplex)
          cc      (output) filtered interferogram correlation coefficient (float)
          width   number of samples/line
          alpha   exponent for non-linear filtering (enter - for default: 0.40)
          nfft    filtering FFT window size, 2**N, 8 --> 512, (enter - for default: 32)
          cc_win  correlation parameter estimation window size odd, max: 15 (enter - for default: 5)
          step    processing step (enter - for default: nfft/8)
          loff    offset to starting line to process (enter - for default: 0)
          nlines  number of lines to process (enter - for default: to end of file)
          wfrac   minimum fraction of points required to be non-zero in the filter window (enter - for default: 0.200)

        """
        if self.validate_inputs:
            self._validate_adf(interf, sm, cc, width, alpha, nfft, cc_win, step, loff, nlines, wfrac)
        if self.mock_outputs:
            self._mock_adf_outputs(interf, sm, cc, width, alpha, nfft, cc_win, step, loff, nlines, wfrac)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.adf))
        return self._gamma_call("ISP", "adf", supplied_args)

    def _validate_PRC_vec(self, SLC_par: Path, PRC: Path, nstate: Optional[int] = None) -> None:
        self._validate("PRC_vec", PRC.exists(), f"PRC path does not exist ({PRC})")

    def _mock_PRC_vec_outputs(self, SLC_par: Path, PRC: Path, nstate: Optional[int] = None) -> None:
        if not SLC_par.exists():
            SLC_par.touch()

    def PRC_vec(self, SLC_par: Path, PRC: Path, nstate: Optional[int] = None) -> Tuple[int, str, str]:
        """

        State vectors from ERS PRC orbit data for ISP processing clw/uw


        input parameters:
          SLC_par  (input/output) ISP SLC/MLI image parameter file
          PRC      (input) PRC state vector file
          nstate   number of state vectors (default=5, maximum=1024)

        """
        if self.validate_inputs:
            self._validate_PRC_vec(SLC_par, PRC, nstate)
        if self.mock_outputs:
            self._mock_PRC_vec_outputs(SLC_par, PRC, nstate)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.PRC_vec))
        return self._gamma_call("ISP", "PRC_vec", supplied_args)

    def _validate_par_Capella_SLC(
        self,
        GeoTIFF: Path,
        ext_JSON: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        self._validate("par_Capella_SLC", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_Capella_SLC", ext_JSON.exists(), f"ext_JSON path does not exist ({ext_JSON})")

    def _mock_par_Capella_SLC_outputs(
        self,
        GeoTIFF: Path,
        ext_JSON: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_Capella_SLC(
        self,
        GeoTIFF: Path,
        ext_JSON: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for Capella SLC data


        input parameters:
          GeoTIFF       (input) Capella image data file in GeoTIFF format (*.tif)
          ext_JSON      (input) Capella extended metadata file in JSON format (*_extended.json)
          SLC_par       (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC           (output) SLC data file (enter - for none, example: yyyymmdd.slc)
          radcal        radiometric calibration flag (enter - for default)
                          0: beta0 (default)
                          1: sigma0
          noise         noise levels flag (enter - for default)
                          0: do not use noise levels (default)
                          1: use noise levels

        NOTE: Capella terrain geocoded data in GeoTIFF format can be read using par_Capella_geo program

        """
        if self.validate_inputs:
            self._validate_par_Capella_SLC(GeoTIFF, ext_JSON, SLC_par, SLC, radcal, noise)
        if self.mock_outputs:
            self._mock_par_Capella_SLC_outputs(GeoTIFF, ext_JSON, SLC_par, SLC, radcal, noise)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_Capella_SLC))
        return self._gamma_call("ISP", "par_Capella_SLC", supplied_args)

    def _validate_adapt_filt(
        self,
        int: Path,
        sm: float,
        width: int,
        low_SNR_thr: Optional[Any] = None,
        filt_width: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        self._validate("adapt_filt", int.exists(), f"int path does not exist ({int})")

    def _mock_adapt_filt_outputs(
        self,
        int: Path,
        sm: float,
        width: int,
        low_SNR_thr: Optional[Any] = None,
        filt_width: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        pass

    def adapt_filt(
        self,
        int: Path,
        sm: float,
        width: int,
        low_SNR_thr: Optional[Any] = None,
        filt_width: Optional[int] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Adaptive bandpass filtering of interferograms


        input parameters:
          int          (input) complex interferogram image filename
          sm           (output) smoothed interferogram filename
          width        number of samples/row
          low_snr_thr  low SNR threshold (default = .25);
          filt_width   filter width in pixels (default = 1.0)
          xmin         offset to starting range pixel(default = 0)
          xmax         offset last range pixel (default = width-1)
          ymin         offset to starting azimuth row (default = 0)
          ymax         offset to last azimuth row (default = nlines-1)

        """
        if self.validate_inputs:
            self._validate_adapt_filt(int, sm, width, low_SNR_thr, filt_width, xmin, xmax, ymin, ymax)
        if self.mock_outputs:
            self._mock_adapt_filt_outputs(int, sm, width, low_SNR_thr, filt_width, xmin, xmax, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.adapt_filt))
        return self._gamma_call("ISP", "adapt_filt", supplied_args)

    def _validate_par_RSAT2_SG(
        self,
        product_XML: Path,
        lut_XML: Path,
        GeoTIFF: Path,
        polarization: Path,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
    ) -> None:
        self._validate("par_RSAT2_SG", product_XML.exists(), f"product_XML path does not exist ({product_XML})")
        self._validate("par_RSAT2_SG", lut_XML.exists(), f"lut_XML path does not exist ({lut_XML})")
        self._validate("par_RSAT2_SG", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_RSAT2_SG", polarization.exists(), f"polarization path does not exist ({polarization})")

    def _mock_par_RSAT2_SG_outputs(
        self,
        product_XML: Path,
        lut_XML: Path,
        GeoTIFF: Path,
        polarization: Path,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
    ) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_RSAT2_SG(
        self,
        product_XML: Path,
        lut_XML: Path,
        GeoTIFF: Path,
        polarization: Path,
        MLI_par: Optional[Path] = None,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate MLI and GRD images and parameter files from Radarsat 2 SGF/SGX/SCF data


        input parameters:
          product_XML    (input) Radarsat-2 product annotation XML file (product.xml)
          lut_XML        (input) Radarsat-2 calibration XML file (lutSigma.xml), use - for no calibration
          GeoTIFF        (input) image data file in GeoTIFF format (imagery_PP.tif)
          polarization   (input) image polarization: HH, VV, HV, VH
          MLI_par        (output) MLI parameter file (example: yyyymmdd_pp.mli.par, enter - for none)
          MLI            (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par        (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD            (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          rps            slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)

        NOTE: Ground range geometry is less accurate than slant range geometry and should be avoided

        """
        if self.validate_inputs:
            self._validate_par_RSAT2_SG(product_XML, lut_XML, GeoTIFF, polarization, MLI_par, MLI, GRD_par, GRD, rps)
        if self.mock_outputs:
            self._mock_par_RSAT2_SG_outputs(
                product_XML, lut_XML, GeoTIFF, polarization, MLI_par, MLI, GRD_par, GRD, rps
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT2_SG))
        return self._gamma_call("ISP", "par_RSAT2_SG", supplied_args)

    def _validate_ScanSAR_burst_corners(self, SLC_par: Path, TOPS_par: Path, KML: Optional[Path] = None) -> None:
        self._validate("ScanSAR_burst_corners", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("ScanSAR_burst_corners", TOPS_par.exists(), f"TOPS_par path does not exist ({TOPS_par})")

    def _mock_ScanSAR_burst_corners_outputs(self, SLC_par: Path, TOPS_par: Path, KML: Optional[Path] = None) -> None:
        if KML is not None and str(KML) != "-":
            KML.touch()

    def ScanSAR_burst_corners(self, SLC_par: Path, TOPS_par: Path, KML: Optional[Path] = None) -> Tuple[int, str, str]:
        """

        Calculate corner geographic coordinates of ScanSAR burst data and generate a KML with burst rectangles


        input parameters:
          SLC_par   (input) SLC parameter file for the ScanSAR burst data
          TOPS_par  (input) ScanSAR burst parameter file
          KML       (output) KML output file

        """
        if self.validate_inputs:
            self._validate_ScanSAR_burst_corners(SLC_par, TOPS_par, KML)
        if self.mock_outputs:
            self._mock_ScanSAR_burst_corners_outputs(SLC_par, TOPS_par, KML)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_corners))
        return self._gamma_call("ISP", "ScanSAR_burst_corners", supplied_args)

    def _validate_par_RCM_SLC_ScanSAR(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise_in: Any,
        root_name: Path,
        SLC_tab: Optional[Path] = None,
        beam: Optional[Any] = None,
        noise_out: Optional[Any] = None,
    ) -> None:
        self._validate("par_RCM_SLC_ScanSAR", RCM_dir.exists(), f"RCM_dir path does not exist ({RCM_dir})")

    def _mock_par_RCM_SLC_ScanSAR_outputs(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise_in: Any,
        root_name: Path,
        SLC_tab: Optional[Path] = None,
        beam: Optional[Any] = None,
        noise_out: Optional[Any] = None,
    ) -> None:
        if root_name is not None and str(root_name) != "-":
            root_name.touch()
        if SLC_tab is not None and str(SLC_tab) != "-":
            SLC_tab.touch()

    def par_RCM_SLC_ScanSAR(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise_in: Any,
        root_name: Path,
        SLC_tab: Optional[Path] = None,
        beam: Optional[Any] = None,
        noise_out: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files from Radarsat Constellation ScanSAR SLC data in GeoTIFF or NITF format


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM2_OK1002260_PK1002436_3_SC50MB_20160417_002427_VH_VV_SLC)
          polarization   image polarization: HH, VV, HV, VH, CH, CV
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise_in       noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          root_name      (output) root name of the generated output files (example: yyyymmdd_pp)
                         NOTE: the program will automatically complete the root_name with beam numbers and extensions for the SLC, SLC_par, and TOPS_par files
          SLC_tab        (output) 3 column list of SLC, SLC_par, and TOPS_par files, with the beams sorted from near to far range (example: yyyymmdd_pp.SLC_tab)
          beam           number specifying the desired ScanSAR beam number (enter - for default: extract all beams)
                         NOTE: enter 0 to get the list of the available beams
          noise_out      output noise intensity for each SLC sample in slant range flag (enter - for default)
                           0: do not write noise intensity files (default)
                           1: write noise intensity files (file name(s) automatically defined)
                         NOTE: when noise intensity files are written, noise power correction will NOT be applied to the SLC data values

        """
        if self.validate_inputs:
            self._validate_par_RCM_SLC_ScanSAR(
                RCM_dir, polarization, radcal, noise_in, root_name, SLC_tab, beam, noise_out
            )
        if self.mock_outputs:
            self._mock_par_RCM_SLC_ScanSAR_outputs(
                RCM_dir, polarization, radcal, noise_in, root_name, SLC_tab, beam, noise_out
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_SLC_ScanSAR))
        return self._gamma_call("ISP", "par_RCM_SLC_ScanSAR", supplied_args)

    def _validate_offset_add(self, OFF_par1: Path, OFF_par2: Path, OFF_par3: Path) -> None:
        self._validate("offset_add", OFF_par1.exists(), f"OFF_par1 path does not exist ({OFF_par1})")
        self._validate("offset_add", OFF_par2.exists(), f"OFF_par2 path does not exist ({OFF_par2})")

    def _mock_offset_add_outputs(self, OFF_par1: Path, OFF_par2: Path, OFF_par3: Path) -> None:
        if OFF_par3 is not None and str(OFF_par3) != "-":
            OFF_par3.touch()

    def offset_add(self, OFF_par1: Path, OFF_par2: Path, OFF_par3: Path) -> Tuple[int, str, str]:
        """

        Add range and azimuth offset polynomial coefficients


        input parameters:
          OFF_par1  (input) ISP offset/interferogram parameter file
          OFF_par2  (input) ISP offset/interferogram parameter file
          OFF_par3  (output) ISP offset/interferogram parameter file with sums of the
                    range and azimuth offset polynomials in OFF_par1 and OFF_par2

        """
        if self.validate_inputs:
            self._validate_offset_add(OFF_par1, OFF_par2, OFF_par3)
        if self.mock_outputs:
            self._mock_offset_add_outputs(OFF_par1, OFF_par2, OFF_par3)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_add))
        return self._gamma_call("ISP", "offset_add", supplied_args)

    def _validate_multi_SLC_WSS(self, SLC: Path, SLC_par: Path, MLI: Path, MLI_par: Path) -> None:
        self._validate("multi_SLC_WSS", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("multi_SLC_WSS", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_multi_SLC_WSS_outputs(self, SLC: Path, SLC_par: Path, MLI: Path, MLI_par: Path) -> None:
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def multi_SLC_WSS(self, SLC: Path, SLC_par: Path, MLI: Path, MLI_par: Path) -> Tuple[int, str, str]:
        """

        Calculate multi-look intensity image (MLI) from a ASAR Wide-Swath SLC


        input parameters:
          SLC      (input) ASAR Wide-Swath SLC image
          SLC_par  (input) ASAR Wide-Swath SLC image parameter file
          MLI      (output) multi-look intensity image
          MLI_par  (output) MLI image parameter file
        """
        if self.validate_inputs:
            self._validate_multi_SLC_WSS(SLC, SLC_par, MLI, MLI_par)
        if self.mock_outputs:
            self._mock_multi_SLC_WSS_outputs(SLC, SLC_par, MLI, MLI_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_SLC_WSS))
        return self._gamma_call("ISP", "multi_SLC_WSS", supplied_args)

    def _validate_doppler_2d_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        dop2d: Path,
        loff: Optional[int] = None,
        blsz: Optional[Any] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> None:
        self._validate("doppler_2d_SLC", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("doppler_2d_SLC", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_doppler_2d_SLC_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        dop2d: Path,
        loff: Optional[int] = None,
        blsz: Optional[Any] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> None:
        if dop2d is not None and str(dop2d) != "-":
            dop2d.touch()

    def doppler_2d_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        dop2d: Path,
        loff: Optional[int] = None,
        blsz: Optional[Any] = None,
        nbl: Optional[int] = None,
        a2_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        b1_flg: Optional[int] = None,
        c0_flg: Optional[int] = None,
        namb: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        2-D Doppler centroid trend estimation from SLC data


        input parameters:
          SLC      (input) SLC image (SCOMPLEX or FCOMPLEX format)
          SLC_par  (input) SLC parameter file
          dop2d    (output) estimated doppler centroid as a function of range for each block (text format) (enter - for none)
          loff     number of lines offset (enter - for default: 0)
          blsz     block size lines, minimum: 256 (enter - for default: 2048)
          nbl      number of blocks (enter - for default: calculated automatically)
          a2_flg   fit a2 for second derivative of the Doppler centroid w.r.t.range (Hz/m/m) (enter - for default)
                     0: no (default)
                     1: yes
          b0_flg   fit b0 for first derivative of the Doppler centroid w.r.t. along-track time (Hz/sec) (enter - for default)
                     0: no
                     1: yes (default)
          b1_flg   fit b1 for along-track rate of the change in slope of Doppler w.r.t. range (Hz/sec/m)(enter - for default)
                     0: no
                     1: yes (default)
          c0_flg   fit c0 for second derivative of the Doppler centroid w.r.t. along-track time (Hz/sec/sec) (enter - for default)
                     0: no (default)
                     1: yes
          namb     user defined number of Doppler ambiguities to add to the Doppler function (enter - for default: 0)

        """
        if self.validate_inputs:
            self._validate_doppler_2d_SLC(SLC, SLC_par, dop2d, loff, blsz, nbl, a2_flg, b0_flg, b1_flg, c0_flg, namb)
        if self.mock_outputs:
            self._mock_doppler_2d_SLC_outputs(
                SLC, SLC_par, dop2d, loff, blsz, nbl, a2_flg, b0_flg, b1_flg, c0_flg, namb
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.doppler_2d_SLC))
        return self._gamma_call("ISP", "doppler_2d_SLC", supplied_args)

    def _validate_SLC_cat_ScanSAR(self, SLC_tab1: Path, SLC_tab2: Path, SLC_tab3: Path) -> None:
        self._validate("SLC_cat_ScanSAR", SLC_tab1.exists(), f"SLC_tab1 path does not exist ({SLC_tab1})")
        self._validate("SLC_cat_ScanSAR", SLC_tab2.exists(), f"SLC_tab2 path does not exist ({SLC_tab2})")
        self._validate("SLC_cat_ScanSAR", SLC_tab3.exists(), f"SLC_tab3 path does not exist ({SLC_tab3})")

    def _mock_SLC_cat_ScanSAR_outputs(self, SLC_tab1: Path, SLC_tab2: Path, SLC_tab3: Path) -> None:
        pass

    def SLC_cat_ScanSAR(self, SLC_tab1: Path, SLC_tab2: Path, SLC_tab3: Path) -> Tuple[int, str, str]:
        """

        Concatenate sequential ScanSAR burst SLC images


        input parameters:
          SLC_tab1  (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range (earlier time)
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par
          SLC_tab2  (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range (later time)
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par
          SLC_tab3  (input) 3 column list of concatenated ScanSAR SLC, swaths are listed in order from near to far range
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par

        """
        if self.validate_inputs:
            self._validate_SLC_cat_ScanSAR(SLC_tab1, SLC_tab2, SLC_tab3)
        if self.mock_outputs:
            self._mock_SLC_cat_ScanSAR_outputs(SLC_tab1, SLC_tab2, SLC_tab3)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_cat_ScanSAR))
        return self._gamma_call("ISP", "SLC_cat_ScanSAR", supplied_args)

    def _validate_par_RSAT_SLC(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        sc_dB: Optional[Any] = None,
        dt: Optional[Any] = None,
    ) -> None:
        self._validate("par_RSAT_SLC", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_RSAT_SLC", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_RSAT_SLC_outputs(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        sc_dB: Optional[Any] = None,
        dt: Optional[Any] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_RSAT_SLC(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        sc_dB: Optional[Any] = None,
        dt: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        ISP parameter file for RSI/Atlantis/ASF processed Radarsat SLC data


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file (example: lea_01.001)
          SLC_par      (output) ISP SLC parameter file (example: <date>.slc.par)
          CEOS_data    (input) CEOS data file (example: dat_01.001)
          SLC          (output) SLC data with file and line headers removed (example: <date>.slc)
          sc_dB        intensity scale factor in dB (enter - for default:  60.00)
          dt           azimuth image time offset (s) (enter - for default = 0.0)

        """
        if self.validate_inputs:
            self._validate_par_RSAT_SLC(CEOS_leader, SLC_par, CEOS_data, SLC, sc_dB, dt)
        if self.mock_outputs:
            self._mock_par_RSAT_SLC_outputs(CEOS_leader, SLC_par, CEOS_data, SLC, sc_dB, dt)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT_SLC))
        return self._gamma_call("ISP", "par_RSAT_SLC", supplied_args)

    def _validate_base_est_fft(
        self,
        interf: Path,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        nazfft: Optional[Any] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[Any] = None,
        nrfft: Optional[Any] = None,
    ) -> None:
        self._validate("base_est_fft", interf.exists(), f"interf path does not exist ({interf})")
        self._validate("base_est_fft", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("base_est_fft", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_base_est_fft_outputs(
        self,
        interf: Path,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        nazfft: Optional[Any] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[Any] = None,
        nrfft: Optional[Any] = None,
    ) -> None:
        if baseline is not None and str(baseline) != "-":
            baseline.touch()

    def base_est_fft(
        self,
        interf: Path,
        SLC1_par: Path,
        OFF_par: Path,
        baseline: Path,
        nazfft: Optional[Any] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[Any] = None,
        nrfft: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Estimate baseline from interferogram phase spectrum

        input parameters:
          interf    (input) multilook interferogram with residual range and azimuth fringes
          SLC1_par  (input) SLC-1 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          baseline  (output) baseline file
          nazfft    size of azimuth FFT (2**N) (default: 512)
          r_samp    range pixel offset to center of the FFT window (enter - for default: center)
          az_line   line offset from start of the interf. for the  FFT window (enter - for default: center)
          nrfft     size of the range FFT (2**N), minimum: 32 (enter - for default: 512)

        """
        if self.validate_inputs:
            self._validate_base_est_fft(interf, SLC1_par, OFF_par, baseline, nazfft, r_samp, az_line, nrfft)
        if self.mock_outputs:
            self._mock_base_est_fft_outputs(interf, SLC1_par, OFF_par, baseline, nazfft, r_samp, az_line, nrfft)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_est_fft))
        return self._gamma_call("ISP", "base_est_fft", supplied_args)

    def _validate_par_RCM_GRC(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise: Any,
        SLC_par: Optional[Path] = None,
        SLC: Optional[Path] = None,
        GRC_par: Optional[Path] = None,
        GRC: Optional[Path] = None,
        rps: Optional[Any] = None,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        self._validate("par_RCM_GRC", RCM_dir.exists(), f"RCM_dir path does not exist ({RCM_dir})")

    def _mock_par_RCM_GRC_outputs(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise: Any,
        SLC_par: Optional[Path] = None,
        SLC: Optional[Path] = None,
        GRC_par: Optional[Path] = None,
        GRC: Optional[Path] = None,
        rps: Optional[Any] = None,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()
        if GRC_par is not None and str(GRC_par) != "-":
            GRC_par.touch()
        if GRC is not None and str(GRC) != "-":
            GRC.touch()
        if noise_pwr is not None and str(noise_pwr) != "-":
            noise_pwr.touch()

    def par_RCM_GRC(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise: Any,
        SLC_par: Optional[Path] = None,
        SLC: Optional[Path] = None,
        GRC_par: Optional[Path] = None,
        GRC: Optional[Path] = None,
        rps: Optional[Any] = None,
        noise_pwr: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate slant and ground range complex images and parameter files from a Radarsat Constellation GRC (Ground Range georeferenced Complex) product


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM3_OK1001322_PK1001415_1_5M4_20160417_004803_VV_GRC)
          polarization   image polarization: HH, VV, HV, VH, CH, CV
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise          noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          SLC_par        (output) SLC parameter file (example: yyyymmdd_pp.slc.par, enter - for none)
          SLC            (output) SLC data file in slant range geometry (example: yyyymmdd_pp.slc, enter - for none)
          GRC_par        (output) GRC parameter file (example: yyyymmdd_pp.grc.par, enter - for none)
          GRC            (output) GRC data file (example: yyyymmdd_pp.grc, enter - for none)
          rps            slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)
          noise_pwr      (output) noise intensity for each SLC sample in slant range using data from noise levels file (enter - for none)
                         NOTE: when the noise_pwr file is specified, noise power correction will NOT be applied to the GRC / SLC data values

        """
        if self.validate_inputs:
            self._validate_par_RCM_GRC(RCM_dir, polarization, radcal, noise, SLC_par, SLC, GRC_par, GRC, rps, noise_pwr)
        if self.mock_outputs:
            self._mock_par_RCM_GRC_outputs(
                RCM_dir, polarization, radcal, noise, SLC_par, SLC, GRC_par, GRC, rps, noise_pwr
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_GRC))
        return self._gamma_call("ISP", "par_RCM_GRC", supplied_args)

    def _validate_base_orbit(self, SLC1_par: Path, SLC2_par: Path, baseline: Path) -> None:
        self._validate("base_orbit", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("base_orbit", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_base_orbit_outputs(self, SLC1_par: Path, SLC2_par: Path, baseline: Path) -> None:
        if baseline is not None and str(baseline) != "-":
            baseline.touch()

    def base_orbit(self, SLC1_par: Path, SLC2_par: Path, baseline: Path) -> Tuple[int, str, str]:
        """

        Estimate baseline from orbit state vectors


        input parameters:
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          baseline  (output) baseline file (text format, enter - for none)

        """
        if self.validate_inputs:
            self._validate_base_orbit(SLC1_par, SLC2_par, baseline)
        if self.mock_outputs:
            self._mock_base_orbit_outputs(SLC1_par, SLC2_par, baseline)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_orbit))
        return self._gamma_call("ISP", "base_orbit", supplied_args)

    def _validate_par_KS_DGM(
        self,
    ) -> None:
        pass

    def _mock_par_KS_DGM_outputs(
        self,
    ) -> None:
        pass

    def par_KS_DGM(
        self,
    ) -> Tuple[int, str, str]:
        """

        dyld[47068]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_KS_DGM'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)
        """
        if self.validate_inputs:
            self._validate_par_KS_DGM()
        if self.mock_outputs:
            self._mock_par_KS_DGM_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_KS_DGM))
        return self._gamma_call("ISP", "par_KS_DGM", supplied_args)

    def _validate_par_RSI_ERS(self, CEOS_SAR_leader: Any, SLC_par: Path) -> None:
        pass

    def _mock_par_RSI_ERS_outputs(self, CEOS_SAR_leader: Any, SLC_par: Path) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_RSI_ERS(self, CEOS_SAR_leader: Any, SLC_par: Path) -> Tuple[int, str, str]:
        """

        ISP parameter file for RSI processed ERS SLC data


        input parameters:
        CEOS_SAR_leader (input) ERS CEOS SAR leader file
        SLC_par         (output) ISP SLC parameter file (example <orbit>.slc.par)

        """
        if self.validate_inputs:
            self._validate_par_RSI_ERS(CEOS_SAR_leader, SLC_par)
        if self.mock_outputs:
            self._mock_par_RSI_ERS_outputs(CEOS_SAR_leader, SLC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSI_ERS))
        return self._gamma_call("ISP", "par_RSI_ERS", supplied_args)

    def _validate_af_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        thres: Optional[Any] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        roff: Optional[Any] = None,
        azoff: Optional[Any] = None,
    ) -> None:
        self._validate("af_SLC", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("af_SLC", SLC.exists(), f"SLC path does not exist ({SLC})")

    def _mock_af_SLC_outputs(
        self,
        SLC_par: Path,
        SLC: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        thres: Optional[Any] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        roff: Optional[Any] = None,
        azoff: Optional[Any] = None,
    ) -> None:
        if offsets is not None and str(offsets) != "-":
            offsets.touch()

    def af_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        dr: Optional[Any] = None,
        daz: Optional[Any] = None,
        thres: Optional[Any] = None,
        a1_flg: Optional[int] = None,
        b0_flg: Optional[int] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        roff: Optional[Any] = None,
        azoff: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Focus testing for SLC data using autofocus estimation of effective velocity


        input parameters:
          SLC_par    (input) ISP SLC image parameter file
          SLC        (input) single-look complex image
          rwin       range window size (enter - for default: 1024)
          azwin      azimuth window size (enter - for default: 4096)
          dr         range sample increment (enter - for default: 1024,  enter 0 for single patch)
          daz        azimuth line increment (enter - for default: 8192,  enter 0 for single patch)
          thres      offset estimation SNR threshold (enter - for default: 10.000)
          a1_flg     fit a1 for first derivative of the effective velocity w.r.t.range
                       0: no (default)
                       1: yes
          b0_flg     fit b0 for first derivative of the effective velocity w.r.t. along-track time
                       0: no (default)
                       1: yes
          offsets    (output) range and azimuth offsets and SNR data in text format, enter - for no output
          n_ovr      SLC oversampling factor (1,2,4: enter - for default: 1)
          roff       range offset for single patch center
          azoff      azimuth offset for single patch center
        """
        if self.validate_inputs:
            self._validate_af_SLC(
                SLC_par, SLC, rwin, azwin, dr, daz, thres, a1_flg, b0_flg, offsets, n_ovr, roff, azoff
            )
        if self.mock_outputs:
            self._mock_af_SLC_outputs(
                SLC_par, SLC, rwin, azwin, dr, daz, thres, a1_flg, b0_flg, offsets, n_ovr, roff, azoff
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.af_SLC))
        return self._gamma_call("ISP", "af_SLC", supplied_args)

    def _validate_par_EORC_JERS_SLC(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_data: Optional[Path] = None, slc: Optional[Path] = None
    ) -> None:
        self._validate(
            "par_EORC_JERS_SLC", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )
        if CEOS_data is not None:
            self._validate("par_EORC_JERS_SLC", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_EORC_JERS_SLC_outputs(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_data: Optional[Path] = None, slc: Optional[Path] = None
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if slc is not None and str(slc) != "-":
            slc.touch()

    def par_EORC_JERS_SLC(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_data: Optional[Path] = None, slc: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Reformat EORC processed JERS-1 SLC and generate the ISP parameter file


        input parameters:
          CEOS_SAR_leader  (input) CEOS SAR leader file for JERS SLC processed by EORC
          SLC_par          (output) ISP image parameter file
          CEOS_data        (input) CEOS format SLC data (IMOP_01.DAT, enter - for none)
          SLC              (output) reformated JERS SLC (example: yyyymmdd.slc, enter - for none)
        """
        if self.validate_inputs:
            self._validate_par_EORC_JERS_SLC(CEOS_SAR_leader, SLC_par, CEOS_data, slc)
        if self.mock_outputs:
            self._mock_par_EORC_JERS_SLC_outputs(CEOS_SAR_leader, SLC_par, CEOS_data, slc)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_EORC_JERS_SLC))
        return self._gamma_call("ISP", "par_EORC_JERS_SLC", supplied_args)

    def _validate_fill_gaps(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        method: Optional[Any] = None,
        max_dist: Optional[int] = None,
        bp_flag: Optional[Any] = None,
        win: Optional[Any] = None,
        ds_method: Optional[Any] = None,
        ds_size: Optional[int] = None,
        ds_data: Optional[Path] = None,
    ) -> None:
        self._validate("fill_gaps", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_fill_gaps_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        method: Optional[Any] = None,
        max_dist: Optional[int] = None,
        bp_flag: Optional[Any] = None,
        win: Optional[Any] = None,
        ds_method: Optional[Any] = None,
        ds_size: Optional[int] = None,
        ds_data: Optional[Path] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()
        if ds_data is not None and str(ds_data) != "-":
            ds_data.touch()

    def fill_gaps(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        method: Optional[Any] = None,
        max_dist: Optional[int] = None,
        bp_flag: Optional[Any] = None,
        win: Optional[Any] = None,
        ds_method: Optional[Any] = None,
        ds_size: Optional[int] = None,
        ds_data: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Fill gaps in 2D raster file


        input parameters:
          data_in     (input) input data file (FLOAT / FCOMPLEX)
          width       width of input data
          data_out    (output) output data file (FLOAT / FCOMPLEX)
          dtype       input and output data type (enter - for default)
                        0: FLOAT (default)
                        1: FCOMPLEX
          method      method flag (enter - for default: 4)
                        0: Laplace interpolation and linear extrapolation - least squares solution
                        1: Laplace interpolation and linear extrapolation - smaller system of linear equations than in method #0 in case of few missing values - least squares solution
                        2: Laplace interpolation and linear extrapolation - solves a direct linear system of equations for the missing values (not a least squares solution)
                        3: biharmonic interpolation - implementation similar to method #1 - least squares solution
                        4: spring analogy: assumes springs (with a nominal length of zero) connect each node with every neighbor - least squares solution (default)
                        5: average of the 8 nearest neighbors - this method solves a direct linear system for the missing values (not a least squares solution)
                      NOTE: small gaps: use method #0, #1 or #3 - large gaps: use method #2, #4 or #5 - most demanding: method #3
          max_dist    maximum interpolation / extrapolation distance in pixels (enter - or 0 for default: unlimited)
          bp_flag     perform block processing (enter - for default: 0)
                        0: no block processing (default)
                        1: block processing (faster, avoid overflow, however might be slightly less accurate)
                      NOTE: when block processing is selected, a two-step process is carried out: 1: solving the downsampled array (coarse processing), 2: block processing
          win         block size (pixels, 10 < win < 1000, enter - for default: 100)
          ds_method   method flag (0 - 5, same choices as for [method] option) (enter - for default: same as [method])
                      NOTE: for an input containing large gaps, method #2, #4 or #5 may yield more appropriate results.
          ds_size     maximum size of downsampled data (for both width and height) (pixels, ds_size > 10, enter - for default: 400)
          ds_data     (output) write intermediate data after solving the downsampled array (FLOAT / FCOMPLEX)

        """
        if self.validate_inputs:
            self._validate_fill_gaps(
                data_in, width, data_out, dtype, method, max_dist, bp_flag, win, ds_method, ds_size, ds_data
            )
        if self.mock_outputs:
            self._mock_fill_gaps_outputs(
                data_in, width, data_out, dtype, method, max_dist, bp_flag, win, ds_method, ds_size, ds_data
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.fill_gaps))
        return self._gamma_call("ISP", "fill_gaps", supplied_args)

    def _validate_rascc_mask_thinning(
        self,
        ras_in: Path,
        in_file: Path,
        width: int,
        ras_out: Path,
        nmax: Optional[int] = None,
        thresh_1: Optional[Any] = None,
        thresh_nmax: Optional[Any] = None,
        *args,
    ) -> None:
        self._validate("rascc_mask_thinning", ras_in.exists(), f"ras_in path does not exist ({ras_in})")
        self._validate("rascc_mask_thinning", in_file.exists(), f"in_file path does not exist ({in_file})")

    def _mock_rascc_mask_thinning_outputs(
        self,
        ras_in: Path,
        in_file: Path,
        width: int,
        ras_out: Path,
        nmax: Optional[int] = None,
        thresh_1: Optional[Any] = None,
        thresh_nmax: Optional[Any] = None,
        *args,
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def rascc_mask_thinning(
        self,
        ras_in: Path,
        in_file: Path,
        width: int,
        ras_out: Path,
        nmax: Optional[int] = None,
        thresh_1: Optional[Any] = None,
        thresh_nmax: Optional[Any] = None,
        *args,
    ) -> Tuple[int, str, str]:
        """

        Adaptive sampling reduction for phase unwrapping validity mask


        input parameters:
          ras_in       (input) validity mask (SUN/BMP/TIFF raster format 8-bit image)
          in_file      (input) file used for adaptive sampling reduction, e.g. correlation coefficient (float)
          width        number of samples/row of in_file
          ras_out      (output) validity mask with reduced sampling (8-bit SUN rasterfile or BMP format image)
          nmax         number of sampling reduction runs (default: 3)
          thresh_1     first threshold (used for smallest scale sampling reduction)
          ...          further thresholds
          thresh_nmax  threshold nmax (used for largest scale sampling reduction)

        """
        if self.validate_inputs:
            self._validate_rascc_mask_thinning(ras_in, in_file, width, ras_out, nmax, thresh_1, thresh_nmax, *args)
        if self.mock_outputs:
            self._mock_rascc_mask_thinning_outputs(ras_in, in_file, width, ras_out, nmax, thresh_1, thresh_nmax, *args)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rascc_mask_thinning))
        return self._gamma_call("ISP", "rascc_mask_thinning", supplied_args)

    def _validate_GRD_to_SR(
        self,
        GRD_par: Path,
        SLC_par: Path,
        OFF_par: Path,
        in_file: Path,
        out_file: Path,
        rlks: Optional[Any] = None,
        azlks: Optional[Any] = None,
        interp_mode: Optional[int] = None,
        sr_rsp: Optional[Any] = None,
        sr_azsp: Optional[Any] = None,
        degree: Optional[Any] = None,
    ) -> None:
        self._validate("GRD_to_SR", GRD_par.exists(), f"GRD_par path does not exist ({GRD_par})")
        self._validate("GRD_to_SR", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("GRD_to_SR", in_file.exists(), f"in_file path does not exist ({in_file})")

    def _mock_GRD_to_SR_outputs(
        self,
        GRD_par: Path,
        SLC_par: Path,
        OFF_par: Path,
        in_file: Path,
        out_file: Path,
        rlks: Optional[Any] = None,
        azlks: Optional[Any] = None,
        interp_mode: Optional[int] = None,
        sr_rsp: Optional[Any] = None,
        sr_azsp: Optional[Any] = None,
        degree: Optional[Any] = None,
    ) -> None:
        if not SLC_par.exists():
            SLC_par.touch()
        if out_file is not None and str(out_file) != "-":
            out_file.touch()

    def GRD_to_SR(
        self,
        GRD_par: Path,
        SLC_par: Path,
        OFF_par: Path,
        in_file: Path,
        out_file: Path,
        rlks: Optional[Any] = None,
        azlks: Optional[Any] = None,
        interp_mode: Optional[int] = None,
        sr_rsp: Optional[Any] = None,
        sr_azsp: Optional[Any] = None,
        degree: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Conversion to slant range for ISP MLI and INSAR ground range data of type FLOAT


        input parameters:
          GRD_par      (input) SLC parameter file of output ground range image
          MLI_par      (input/output) MLI ISP image parameter file for slant range image
                       NOTE: delete an existing MLI parameter file to recalculate the output MLI parameters
          OFF_par      (input) ISP offset/interferogram parameter file of input image (enter - image in MLI geometry)
          in_file      (input) ground range image (FLOAT)
          out_file     (output) slant range image (FLOAT)
          rlks         multi-looking in range (prior to resampling, enter - for default: 1)
          azlks        multi-looking in azimuth (prior to resampling, enter - for default: 1)
          interp_mode  interpolation mode (enter - for default)
                         0: nearest-neighbor
                         1: bicubic spline
                         2: bicubic spline log(x)
                         3: bicubic spline sqrt(x)
                         4: B-spline interpolation (default B-spline degree: 3)
                         5: B-spline interpolation sqrt(x) (default) (default B-spline degree: 3)
                       NOTE: log and sqrt interpolation modes should only be used with non-negative data!
          sr_rsp       output image slant range sample spacing (m) (enter - for default: c/(2*adc_sampling_rate)
          sr_azsp      output image azimuth sample spacing (m) (enter - for default: (input image azimuth spacing) * azlks)
          degree       B-spline degree (2->9) (enter - for default: 3)

        """
        if self.validate_inputs:
            self._validate_GRD_to_SR(
                GRD_par, SLC_par, OFF_par, in_file, out_file, rlks, azlks, interp_mode, sr_rsp, sr_azsp, degree
            )
        if self.mock_outputs:
            self._mock_GRD_to_SR_outputs(
                GRD_par, SLC_par, OFF_par, in_file, out_file, rlks, azlks, interp_mode, sr_rsp, sr_azsp, degree
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.GRD_to_SR))
        return self._gamma_call("ISP", "GRD_to_SR", supplied_args)

    def _validate_multi_look2(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        r_dec: Any,
        az_dec: Any,
        rwin: Optional[int] = None,
        azwin: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        self._validate("multi_look2", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("multi_look2", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_multi_look2_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        r_dec: Any,
        az_dec: Any,
        rwin: Optional[int] = None,
        azwin: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def multi_look2(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        r_dec: Any,
        az_dec: Any,
        rwin: Optional[int] = None,
        azwin: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate an MLI image from an SLC with separate averaging window dimensions and decimation factors


        input parameters:
          SLC      (input) single-look complex image (SCOMPLEX or FCOMPLEX)
          SLC_par  (input) SLC image parameter file
          MLI      (output) multi-look intensity image (FLOAT)
          MLI_par  (output) MLI image parameter file
          r_dec    range decimation factor (int)
          az_dec   azimuth decimation factor (int)
          rwin     averaging window width (int)  (enter - for default: r_dec)
          azwin    averaging window height (int) (enter - for default: az_dec)
          wflg     window weighting function (enter - for default):
                     0: rectangular (default)
                     1: Kaiser
                     2: circular Gaussian
          n_ovr    oversampling factor 1 -> 2 (enter - for default: 1)
          lanczos  Lanczos interpolator order 5 -> 9 (enter - for default: 7)
          beta     Gaussian or Kaiser window parameter (enter - for default: 2.0)
          scale    scale factor for output MLI (enter - for default: 1.0)
          exp      exponent for the output MLI (enter - for default: 1.0)

        """
        if self.validate_inputs:
            self._validate_multi_look2(
                SLC, SLC_par, MLI, MLI_par, r_dec, az_dec, rwin, azwin, wflg, n_ovr, lanczos, beta, scale, exp
            )
        if self.mock_outputs:
            self._mock_multi_look2_outputs(
                SLC, SLC_par, MLI, MLI_par, r_dec, az_dec, rwin, azwin, wflg, n_ovr, lanczos, beta, scale, exp
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look2))
        return self._gamma_call("ISP", "multi_look2", supplied_args)

    def _validate_dcomp_sirc(
        self, infile: Path, outfile: Path, samples: int, loff: Optional[int] = None, nlines: Optional[int] = None
    ) -> None:
        self._validate("dcomp_sirc", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_dcomp_sirc_outputs(
        self, infile: Path, outfile: Path, samples: int, loff: Optional[int] = None, nlines: Optional[int] = None
    ) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def dcomp_sirc(
        self, infile: Path, outfile: Path, samples: int, loff: Optional[int] = None, nlines: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Extract SIR-C SLC compressed single-pol data


        input parameters:
          infile     (input) SIR-C single-pol SLC compressed data
          outfile    (output) complex floating point data
          samples    number of polarimetric samples per input line (4 bytes/sample)
          loff       offset to starting line (default: 0)
          nlines     number of lines to copy(default: entire file, 0 = entire file)
        """
        if self.validate_inputs:
            self._validate_dcomp_sirc(infile, outfile, samples, loff, nlines)
        if self.mock_outputs:
            self._mock_dcomp_sirc_outputs(infile, outfile, samples, loff, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dcomp_sirc))
        return self._gamma_call("ISP", "dcomp_sirc", supplied_args)

    def _validate_subtract_phase(
        self, interf_in: Path, phase_file: Path, interf_out: Path, width: int, factor: Optional[Any] = None
    ) -> None:
        self._validate("subtract_phase", interf_in.exists(), f"interf_in path does not exist ({interf_in})")
        self._validate("subtract_phase", phase_file.exists(), f"phase_file path does not exist ({phase_file})")

    def _mock_subtract_phase_outputs(
        self, interf_in: Path, phase_file: Path, interf_out: Path, width: int, factor: Optional[Any] = None
    ) -> None:
        if interf_out is not None and str(interf_out) != "-":
            interf_out.touch()

    def subtract_phase(
        self, interf_in: Path, phase_file: Path, interf_out: Path, width: int, factor: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        ISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/subtract_phase
        Subtract scaled phase image from a complex interferogram


        input parameters:
          interf_in   (input) input interferogram (fcomplex format)
          phase_file  (input) unwrapped interferometric phase (float)
          interf_out  (output) output interferogram (input interferogram - scaled phase) (fcomplex)
          width       number of samples/line
          factor      constant scale factor for input phase data [default=1.0]

        """
        if self.validate_inputs:
            self._validate_subtract_phase(interf_in, phase_file, interf_out, width, factor)
        if self.mock_outputs:
            self._mock_subtract_phase_outputs(interf_in, phase_file, interf_out, width, factor)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.subtract_phase))
        return self._gamma_call("ISP", "subtract_phase", supplied_args)

    def _validate_dcomp_sirc_quad(
        self,
        infile: Path,
        outfile: Path,
        samples: int,
        parameter: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("dcomp_sirc_quad", infile.exists(), f"infile path does not exist ({infile})")

    def _mock_dcomp_sirc_quad_outputs(
        self,
        infile: Path,
        outfile: Path,
        samples: int,
        parameter: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        if outfile is not None and str(outfile) != "-":
            outfile.touch()

    def dcomp_sirc_quad(
        self,
        infile: Path,
        outfile: Path,
        samples: int,
        parameter: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Extract SIR-C MLC or SLC compressed quad-pol data


        input parameters:
          infile     (input) SIR-C SLC or MLC quad-pol compressed data
          outfile    (output) complex floating point data
          samples    number of polarimetric samples per input line (10 bytes/sample)
          parameter  polarimetric parameter to extract from SLC or MLC product:
                       0:  SLC total power
                       1:  SLC-HH
                       2:  SLC-HV
                       3:  SLC-VH
                       4:  SLC-VV
                       5:  MLC total power
                       6:  MLC-HVHV*
                       7:  MLC-VVVV*
                       8:  MLC-HHHH*
                       9:  MLC-HHHV*
                       10: MLC-HHVV*
                       11: MLC-HVVV*
          loff       offset to starting line (default: 0)
          nlines     number of lines to copy(default: entire file, 0 = entire file)
        """
        if self.validate_inputs:
            self._validate_dcomp_sirc_quad(infile, outfile, samples, parameter, loff, nlines)
        if self.mock_outputs:
            self._mock_dcomp_sirc_quad_outputs(infile, outfile, samples, parameter, loff, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.dcomp_sirc_quad))
        return self._gamma_call("ISP", "dcomp_sirc_quad", supplied_args)

    def _validate_SLC_copy_ScanSAR(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        BURST_tab: Path,
        dtype: Optional[int] = None,
        SLC2_dir: Optional[Any] = None,
    ) -> None:
        self._validate("SLC_copy_ScanSAR", SLC1_tab.exists(), f"SLC1_tab path does not exist ({SLC1_tab})")
        self._validate("SLC_copy_ScanSAR", BURST_tab.exists(), f"BURST_tab path does not exist ({BURST_tab})")

    def _mock_SLC_copy_ScanSAR_outputs(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        BURST_tab: Path,
        dtype: Optional[int] = None,
        SLC2_dir: Optional[Any] = None,
    ) -> None:
        if not SLC2_tab.exists():
            SLC2_tab.touch()

    def SLC_copy_ScanSAR(
        self,
        SLC1_tab: Path,
        SLC2_tab: Path,
        BURST_tab: Path,
        dtype: Optional[int] = None,
        SLC2_dir: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Burst selection and copy from ScanSAR burst data (FCOMPLEX, SCOMPLEX)


        input parameters:
          SLC1_tab   (input) 3 column list of ScanSAR SLC-1 swaths in order from near to far range
                       SLC1_tab line entries:   SLC    SLC_par   TOPS_par
          SLC2_tab   (input/output) 3 column list of the burst data copied from the ScanSAR swaths listed in SLC1_tab, in order from near to far range
                       SLC2_tab line entries:   SLC    SLC_par   TOPS_par
                     NOTE: If the SLC2_tab does not yet exist, the SLC2_tab will be created with file names derived from the SLC1_tab entries and the SLC2_dir
                           The new file names will have _2 appended to the root file names of the entries in SLC1_tab
          BURST_tab  (input) 2 column list of the first and last burst to copy from each swath, one line for each swath
                     BURST_tab line entries: first_burst  last_burst
                     NOTES: 1. The first burst is 1, enter - to select last physical burst
                            2. If first_burst <= 0, then blank bursts are generated at the start of the output swath
                            3. If last_burst exceeds the number of bursts, then blank bursts are appended to the end of the output swath
          dtype      output data format for complex data (enter - for default: output data has the same format as input data):
                       0: FCOMPLEX
                       1: SCOMPLEX
          SLC2_dir   directory for ScanSAR burst data copied from SLC-1 data, ignored if the SLC2_tab already exists (default: current directory)

        """
        if self.validate_inputs:
            self._validate_SLC_copy_ScanSAR(SLC1_tab, SLC2_tab, BURST_tab, dtype, SLC2_dir)
        if self.mock_outputs:
            self._mock_SLC_copy_ScanSAR_outputs(SLC1_tab, SLC2_tab, BURST_tab, dtype, SLC2_dir)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_copy_ScanSAR))
        return self._gamma_call("ISP", "SLC_copy_ScanSAR", supplied_args)

    def _validate_par_RISAT_SLC(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        SLC_par: Path,
        CEOS_image: Path,
        SLC: Optional[Path] = None,
        line_dir: Optional[Any] = None,
        pix_dir: Optional[Any] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[Any] = None,
    ) -> None:
        self._validate("par_RISAT_SLC", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_RISAT_SLC", BAND_META.exists(), f"BAND_META path does not exist ({BAND_META})")
        self._validate("par_RISAT_SLC", CEOS_image.exists(), f"CEOS_image path does not exist ({CEOS_image})")

    def _mock_par_RISAT_SLC_outputs(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        SLC_par: Path,
        CEOS_image: Path,
        SLC: Optional[Path] = None,
        line_dir: Optional[Any] = None,
        pix_dir: Optional[Any] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[Any] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_RISAT_SLC(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        SLC_par: Path,
        CEOS_image: Path,
        SLC: Optional[Path] = None,
        line_dir: Optional[Any] = None,
        pix_dir: Optional[Any] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Read RISAT-1 CEOS format SLC data and perform radiometric calibration


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file (example: lea_01.001)
          BAND_META    (input) BAND_META.txt, additional RISAT system parameters for the scene (format keywork=value)
          SLC_par      (output) ISP SLC image parameter file (example: YYYYMMDD.grd.par)
          CEOS_image   (input) CEOS SLC image file (example: dat_01.001)
          SLC          (output) SLC data with file and line headers removed (enter - for none: example: YYYYMMDD.grd)
          line_dir     set output image line direction (enter - for default):
                         0: used value derived from CEOS leader file
                         1: retain input data line direction  (default)
                        -1: reverse input data line direction
          pix_dir      set output pixel direction (enter - for default):
                         0: used value derived from CEOS leader file
                         1: retain input data pixel direction (default)
                        -1: reverse input data pixel direction
          cal_flg      calibration flag (enter - for default):
                         0: do not apply radiometric calibration
                         1: apply radiometric calibration including KdB and incidence angle correction (default)
          KdB          calibration constant (dB) (enter - to use value in the CEOS leader)

        """
        if self.validate_inputs:
            self._validate_par_RISAT_SLC(
                CEOS_leader, BAND_META, SLC_par, CEOS_image, SLC, line_dir, pix_dir, cal_flg, KdB
            )
        if self.mock_outputs:
            self._mock_par_RISAT_SLC_outputs(
                CEOS_leader, BAND_META, SLC_par, CEOS_image, SLC, line_dir, pix_dir, cal_flg, KdB
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RISAT_SLC))
        return self._gamma_call("ISP", "par_RISAT_SLC", supplied_args)

    def _validate_SLC_freq_shift(
        self, SLC: Path, SLC_par: Path, SLC_shift: Path, SLC_shift_par: Path, freq_shift: Any
    ) -> None:
        self._validate("SLC_freq_shift", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("SLC_freq_shift", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_SLC_freq_shift_outputs(
        self, SLC: Path, SLC_par: Path, SLC_shift: Path, SLC_shift_par: Path, freq_shift: Any
    ) -> None:
        if SLC_shift is not None and str(SLC_shift) != "-":
            SLC_shift.touch()
        if SLC_shift_par is not None and str(SLC_shift_par) != "-":
            SLC_shift_par.touch()

    def SLC_freq_shift(
        self, SLC: Path, SLC_par: Path, SLC_shift: Path, SLC_shift_par: Path, freq_shift: Any
    ) -> Tuple[int, str, str]:
        """

        ISP Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/SLC_freq_shift
        Shift the effective radar carrier frequency of an SLC image by a specified amount


        input parameters:
          SLC            (input) SLC file (FCOMPLEX or SCOMPLEX)
          SLC_par        (input) SLC parameter file
          SLC_shift      (output) SLC data with shifted radar carrier frequency
          SLC_shift_par  (output) SLC parameter file with shifted radar carrier frequency
          freq_shift     radar carrier frequency shift (Hz)

        """
        if self.validate_inputs:
            self._validate_SLC_freq_shift(SLC, SLC_par, SLC_shift, SLC_shift_par, freq_shift)
        if self.mock_outputs:
            self._mock_SLC_freq_shift_outputs(SLC, SLC_par, SLC_shift, SLC_shift_par, freq_shift)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_freq_shift))
        return self._gamma_call("ISP", "SLC_freq_shift", supplied_args)

    def _validate_DELFT_vec2(
        self,
        SLC_par: Path,
        DELFT_dir: Any,
        nstate: Optional[int] = None,
        interval: Optional[Any] = None,
        ODR: Optional[Any] = None,
    ) -> None:
        self._validate("DELFT_vec2", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_DELFT_vec2_outputs(
        self,
        SLC_par: Path,
        DELFT_dir: Any,
        nstate: Optional[int] = None,
        interval: Optional[Any] = None,
        ODR: Optional[Any] = None,
    ) -> None:
        pass

    def DELFT_vec2(
        self,
        SLC_par: Path,
        DELFT_dir: Any,
        nstate: Optional[int] = None,
        interval: Optional[Any] = None,
        ODR: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Extract and interpolate DELFT ERS-1, ERS-2, and ENVISAT state vectors


        input parameters:
          SLC_par    (input) ISP image parameter file
          DELFT_dir  directory containing Delft orbit arclist and ODR files for ERS-1, ERS-2 or ENVISAT
                       NOTE: enter . for current directory
          nstate     number of state vectors to generate (enter - for default (>= 15)
          interval   time interval between state vectors in the ISP image parameter file (s) (default: 10.0)
          ODR        ODR file to use (include path) rather than ODR file determined from the Delft orbit arclist

        """
        if self.validate_inputs:
            self._validate_DELFT_vec2(SLC_par, DELFT_dir, nstate, interval, ODR)
        if self.mock_outputs:
            self._mock_DELFT_vec2_outputs(SLC_par, DELFT_dir, nstate, interval, ODR)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.DELFT_vec2))
        return self._gamma_call("ISP", "DELFT_vec2", supplied_args)

    def _validate_SLC_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
        SLC_1s: Optional[Any] = None,
        SLC_2Rs: Optional[Any] = None,
        SLC_1s_par: Optional[Path] = None,
        SLC_2Rs_par: Optional[Path] = None,
        az_beta: Optional[Any] = None,
    ) -> None:
        self._validate("SLC_intf", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("SLC_intf", SLC_2R.exists(), f"SLC_2R path does not exist ({SLC_2R})")
        self._validate("SLC_intf", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("SLC_intf", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        self._validate("SLC_intf", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_SLC_intf_outputs(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
        SLC_1s: Optional[Any] = None,
        SLC_2Rs: Optional[Any] = None,
        SLC_1s_par: Optional[Path] = None,
        SLC_2Rs_par: Optional[Path] = None,
        az_beta: Optional[Any] = None,
    ) -> None:
        if interf is not None and str(interf) != "-":
            interf.touch()

    def SLC_intf(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        OFF_par: Path,
        interf: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        sps_flg: Optional[int] = None,
        azf_flg: Optional[int] = None,
        rp1_flg: Optional[int] = None,
        rp2_flg: Optional[int] = None,
        SLC_1s: Optional[Any] = None,
        SLC_2Rs: Optional[Any] = None,
        SLC_1s_par: Optional[Path] = None,
        SLC_2Rs_par: Optional[Path] = None,
        az_beta: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate interferogram from co-registered SLC image data


        input parameters:
          SLC-1      (input) single-look complex image 1 (reference)
          SLC-2R     (input) single-look complex image 2 coregistered to SLC-1
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2R_par  (input) SLC-2R ISP image parameter file for the co-registered image
          OFF_par    (input) ISP offset/interferogram parameter file
          interf     (output) interferogram from SLC-1 and SLC-2R
          rlks       number of range looks
          azlks      number of azimuth looks
          loff       offset to starting line relative to SLC-1 for interferogram (enter - for default: 0)
          nlines     number of SLC lines to process (enter - for default: to end of file)
          sps_flg    range spectral shift flag:
                       1: apply range spectral shift filter (default)
                       0: do not apply range spectral shift filter
          azf_flg    azimuth common band filter flag:
                       1: apply azimuth common-band filter (default)
                       0: do not apply azimuth common band filter
          rp1_flg    SLC-1 range phase mode
                       0: nearest approach (zero-Doppler) phase
                       1: ref. function center (Doppler centroid) (default)
          rp2_flg    SLC-2 range phase mode
                       0: nearest approach (zero-Doppler) phase
                       1: ref. function center (Doppler centroid) (default)
          SLC-1s     SLC-1 after range spectral shift and azimuth common-band filtering (FCOMPLEX format)  (enter - for none)
          SLC-2Rs    SLC-2R after range spectral shift and azimuth common-band filtering (FCOMPLEX format) (enter - for none)
          SLC1s_par  SLC-1s ISP image parameter file (enter - for none)
          SLC2Rs_par SLC-2Rs ISP image parameter file (enter - for none)
          az_beta    azimuth common-band filter Kaiser window parameter (default: 2.120)

        """
        if self.validate_inputs:
            self._validate_SLC_intf(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                interf,
                rlks,
                azlks,
                loff,
                nlines,
                sps_flg,
                azf_flg,
                rp1_flg,
                rp2_flg,
                SLC_1s,
                SLC_2Rs,
                SLC_1s_par,
                SLC_2Rs_par,
                az_beta,
            )
        if self.mock_outputs:
            self._mock_SLC_intf_outputs(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                OFF_par,
                interf,
                rlks,
                azlks,
                loff,
                nlines,
                sps_flg,
                azf_flg,
                rp1_flg,
                rp2_flg,
                SLC_1s,
                SLC_2Rs,
                SLC_1s_par,
                SLC_2Rs_par,
                az_beta,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_intf))
        return self._gamma_call("ISP", "SLC_intf", supplied_args)

    def _validate_ptarg_cal_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: Any,
        az_samp: Any,
        psigma: Any,
        c_r_samp: Any,
        c_az_samp: Any,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[Any] = None,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
        psz: Optional[Any] = None,
        csz: Optional[Any] = None,
        c_image: Optional[Path] = None,
    ) -> None:
        self._validate("ptarg_cal_SLC", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("ptarg_cal_SLC", SLC.exists(), f"SLC path does not exist ({SLC})")

    def _mock_ptarg_cal_SLC_outputs(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: Any,
        az_samp: Any,
        psigma: Any,
        c_r_samp: Any,
        c_az_samp: Any,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[Any] = None,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
        psz: Optional[Any] = None,
        csz: Optional[Any] = None,
        c_image: Optional[Path] = None,
    ) -> None:
        if ptr_image is not None and str(ptr_image) != "-":
            ptr_image.touch()
        if r_plot is not None and str(r_plot) != "-":
            r_plot.touch()
        if az_plot is not None and str(az_plot) != "-":
            az_plot.touch()
        if pcal is not None and str(pcal) != "-":
            pcal.touch()
        if c_image is not None and str(c_image) != "-":
            c_image.touch()

    def ptarg_cal_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: Any,
        az_samp: Any,
        psigma: Any,
        c_r_samp: Any,
        c_az_samp: Any,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        pcal: Path,
        osf: Optional[Any] = None,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
        psz: Optional[Any] = None,
        csz: Optional[Any] = None,
        c_image: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Point target analysis and radiometric calibration of SLC images


        input parameters:
          SLC_par    (input) SLC image parameter file
          SLC        (input) SLC image in FCOMPLEX or SCOMPLEX format
          r_samp     point target range sample number, target region size is 16x16
          az_samp    point target azimuth line number, target region size is 16x16
          psigma     radar cross-section of the calibration target in m**2
          c_r_samp   clutter region center range sample number, clutter region size is 16x16
          c_az_samp  clutter region center azimuth line number, clutter region size is 16x16
          ptr_image  (output) oversampled point target image, with and without phase gradient, nominal width: 256
          r_plot     (output) range point target response plot data (text format)
          az_plot    (output) azimuth point target response plot data (text format)
          pcal       (output) measured point target parameters and radiometric calibration factor (text format)
          osf        image over-sampling factor, 2, 4, 8, 16, 32, 64 (enter - for default: 16)
          win        maximum search window offset (samples) (enter - for default: 1)
          pltflg     plotting mode flag:
                       0: none
                       1: output plots in PNG format (default)
                       2: screen output
                       3: output plots in PDF format
          psz        point target region size (samples) (enter - for default: 16)
          csz        clutter region size (samples) (enter - for default: 16)
          c_image    (output) clutter region image (FCOMPLEX format)

        """
        if self.validate_inputs:
            self._validate_ptarg_cal_SLC(
                SLC_par,
                SLC,
                r_samp,
                az_samp,
                psigma,
                c_r_samp,
                c_az_samp,
                ptr_image,
                r_plot,
                az_plot,
                pcal,
                osf,
                win,
                pltflg,
                psz,
                csz,
                c_image,
            )
        if self.mock_outputs:
            self._mock_ptarg_cal_SLC_outputs(
                SLC_par,
                SLC,
                r_samp,
                az_samp,
                psigma,
                c_r_samp,
                c_az_samp,
                ptr_image,
                r_plot,
                az_plot,
                pcal,
                osf,
                win,
                pltflg,
                psz,
                csz,
                c_image,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ptarg_cal_SLC))
        return self._gamma_call("ISP", "ptarg_cal_SLC", supplied_args)

    def _validate_sbi_filt(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        SLCf: Path,
        SLCf_par: Path,
        SLCb: Path,
        SLCb_par: Path,
        norm_sq: int,
        iwflg: Optional[int] = None,
    ) -> None:
        self._validate("sbi_filt", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("sbi_filt", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("sbi_filt", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")

    def _mock_sbi_filt_outputs(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        SLCf: Path,
        SLCf_par: Path,
        SLCb: Path,
        SLCb_par: Path,
        norm_sq: int,
        iwflg: Optional[int] = None,
    ) -> None:
        if SLCf is not None and str(SLCf) != "-":
            SLCf.touch()
        if SLCf_par is not None and str(SLCf_par) != "-":
            SLCf_par.touch()
        if SLCb is not None and str(SLCb) != "-":
            SLCb.touch()
        if SLCb_par is not None and str(SLCb_par) != "-":
            SLCb_par.touch()

    def sbi_filt(
        self,
        SLC_1: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        SLCf: Path,
        SLCf_par: Path,
        SLCb: Path,
        SLCb_par: Path,
        norm_sq: int,
        iwflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Azimuth filtering of SLC data to support split-beam interferometry to measure azimuth offsets

        input parameters:
          SLC-1     (input) SLC image (SCOMPLEX or FCOMPLEX format)
          SLC1_par  (input) SLC image parameter file
          SLC2R_par (input) SLC2 ISP image parameter file for the co-registered image of the interferometric pair,
                    used to determine azimuth common-band for each output SLC (enter - for none)
          SLCf      (output) SLC image (forward-looking, FCOMPLEX format)
          SLCf_par  (output) SLC parameter file (forward-looking)
          SLCb      (output) SLC image (backward-looking, FCOMPLEX format)
          SLCb_par  (output) SLC parameter file (backward-looking)
          norm_sq   squint between beams as a fraction of the azimuth spectrum width (default: 0.5)
          iwflg     inverse weighting flag:
                      0: no compensation for azimuth spectrum weighting
                      1: compensate for the azimuth spectrum weighting (default)
        """
        if self.validate_inputs:
            self._validate_sbi_filt(SLC_1, SLC1_par, SLC2R_par, SLCf, SLCf_par, SLCb, SLCb_par, norm_sq, iwflg)
        if self.mock_outputs:
            self._mock_sbi_filt_outputs(SLC_1, SLC1_par, SLC2R_par, SLCf, SLCf_par, SLCb, SLCb_par, norm_sq, iwflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sbi_filt))
        return self._gamma_call("ISP", "sbi_filt", supplied_args)

    def _validate_par_NovaSAR_SRD(
        self,
        GeoTIFF: Path,
        XML: Path,
        polarization: Any,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        self._validate("par_NovaSAR_SRD", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_NovaSAR_SRD", XML.exists(), f"XML path does not exist ({XML})")

    def _mock_par_NovaSAR_SRD_outputs(
        self,
        GeoTIFF: Path,
        XML: Path,
        polarization: Any,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if MLI is not None and str(MLI) != "-":
            MLI.touch()

    def par_NovaSAR_SRD(
        self,
        GeoTIFF: Path,
        XML: Path,
        polarization: Any,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate MLI image and parameter files for NovaSAR SRD data


        input parameters:
          GeoTIFF       (input) NovaSAR image data file in GeoTIFF format (enter - for none, *.tif)
          XML           (input) NovaSAR XML annotation file
          polarization  image polarization: HH, VV, HV, VH, CH, CV
          MLI_par       (output) MLI parameter file (example: yyyymmdd_pp.mli.par)
          MLI           (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          radcal        radiometric calibration flag (enter - for default)
                          0: beta0 (default)
                          1: sigma0
          noise         noise levels flag (enter - for default)
                          0: do not use noise levels (default)
                          1: use noise levels

        """
        if self.validate_inputs:
            self._validate_par_NovaSAR_SRD(GeoTIFF, XML, polarization, MLI_par, MLI, radcal, noise)
        if self.mock_outputs:
            self._mock_par_NovaSAR_SRD_outputs(GeoTIFF, XML, polarization, MLI_par, MLI, radcal, noise)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_NovaSAR_SRD))
        return self._gamma_call("ISP", "par_NovaSAR_SRD", supplied_args)

    def _validate_ph_slope_base(
        self,
        int_in: Path,
        SLC_par: Path,
        OFF_par: Path,
        base: Path,
        int_out: Path,
        int_type: Optional[int] = None,
        inverse: Optional[Any] = None,
    ) -> None:
        self._validate("ph_slope_base", int_in.exists(), f"int_in path does not exist ({int_in})")
        self._validate("ph_slope_base", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("ph_slope_base", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("ph_slope_base", base.exists(), f"base path does not exist ({base})")

    def _mock_ph_slope_base_outputs(
        self,
        int_in: Path,
        SLC_par: Path,
        OFF_par: Path,
        base: Path,
        int_out: Path,
        int_type: Optional[int] = None,
        inverse: Optional[Any] = None,
    ) -> None:
        if int_out is not None and str(int_out) != "-":
            int_out.touch()

    def ph_slope_base(
        self,
        int_in: Path,
        SLC_par: Path,
        OFF_par: Path,
        base: Path,
        int_out: Path,
        int_type: Optional[int] = None,
        inverse: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Subtract/add interferogram flat-Earth phase trend as estimated from initial baseline


        input parameters:
          int_in    (input) interferogram (FCOMPLEX) or unwrapped phase (FLOAT) (unflattened)
          SLC_par   (input) ISP parameter file for the reference SLC
          OFF_par   (input) ISP offset/interferogram parameter file
          base      (input) baseline file
          int_out   (output) interferogram (FCOMPLEX) or unwrapped phase (FLOAT) with phase trend subtracted/added
          int_type  interferogram type: 0=unwrapped phase, 1=complex interf. (default=1)
          inverse   subtract/add inversion flag (0=subtract phase ramp, 1=add phase ramp (default=0)
        """
        if self.validate_inputs:
            self._validate_ph_slope_base(int_in, SLC_par, OFF_par, base, int_out, int_type, inverse)
        if self.mock_outputs:
            self._mock_ph_slope_base_outputs(int_in, SLC_par, OFF_par, base, int_out, int_type, inverse)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ph_slope_base))
        return self._gamma_call("ISP", "ph_slope_base", supplied_args)

    def _validate_multi_look_ScanSAR(
        self,
        SLC_tab: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        scale: Optional[Any] = None,
    ) -> None:
        self._validate("multi_look_ScanSAR", SLC_tab.exists(), f"SLC_tab path does not exist ({SLC_tab})")
        if SLCR_tab is not None:
            self._validate("multi_look_ScanSAR", SLCR_tab.exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_multi_look_ScanSAR_outputs(
        self,
        SLC_tab: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        scale: Optional[Any] = None,
    ) -> None:
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def multi_look_ScanSAR(
        self,
        SLC_tab: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        scale: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate MLI mosaic from ScanSAR SLC burst data (Sentinel-1, TerraSAR-X, RCM...)


        input parameters:
          SLC_tab   (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range
                      SLC_tab line entries:   SLC   SLC_par  TOPS_par
          MLI       (output) mosaicked MLI image (non-overlapping burst windows)
          MLI_par   (output) MLI image parameter file
          rlks      number of range looks
          azlks     number of azimuth looks
          bflg      burst window calculation flag (enter - for default):
                      0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                      1: calculate burst window parameters from burst parameters and the number of range and azimuth looks
          SLCR_tab  (input) 3 column list of the reference scene, swaths are listed in order from near to far range, enter - for none
                      SLCR_tab line entries:   SLC    SLC_par   TOPS_par
          scale     scale factor for output MLI (enter - for default: calculate from calibration gain in SLC parameter file)

                    NOTE: When generating an MLI mosaic from resampled SLC data, the SLC_tab of the reference scene is required

        """
        if self.validate_inputs:
            self._validate_multi_look_ScanSAR(SLC_tab, MLI, MLI_par, rlks, azlks, bflg, SLCR_tab, scale)
        if self.mock_outputs:
            self._mock_multi_look_ScanSAR_outputs(SLC_tab, MLI, MLI_par, rlks, azlks, bflg, SLCR_tab, scale)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look_ScanSAR))
        return self._gamma_call("ISP", "multi_look_ScanSAR", supplied_args)

    def _validate_par_ASNARO2(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        reramp: Optional[int] = None,
    ) -> None:
        self._validate("par_ASNARO2", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")
        self._validate("par_ASNARO2", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")

    def _mock_par_ASNARO2_outputs(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        reramp: Optional[int] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_ASNARO2(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        reramp: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for ASNARO-2 Spotlight, Stripmap and ScanSAR level 1.1 data


        input parameters:
          CEOS_data     (input) CEOS format SLC data (IMG-PP-AS2*)
          CEOS_leader   (input) CEOS SAR leader file for ASNARO-2 data (LED-AS2*)
          SLC_par       (output) ISP SLC parameter file (example: yyyymmdd_pp.slc.par)
          SLC           (output) SLC (Spotlight and Stripmap) or SLI (ScanSAR) data file (enter - for none, example: yyyymmdd_pp.slc)
          reramp        reramp SLC phase flag (enter - for default)
                          0: no reramp
                          1: reramp SLC phase (default)

        NOTE: ASNARO2 geocoded and georeferenced data in GeoTIFF format (level 1.5) can be read using par_ASNARO2_geo program.

        """
        if self.validate_inputs:
            self._validate_par_ASNARO2(CEOS_data, CEOS_leader, SLC_par, SLC, reramp)
        if self.mock_outputs:
            self._mock_par_ASNARO2_outputs(CEOS_data, CEOS_leader, SLC_par, SLC, reramp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASNARO2))
        return self._gamma_call("ISP", "par_ASNARO2", supplied_args)

    def _validate_grasses(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        xinit: Optional[int] = None,
        yinit: Optional[Any] = None,
        init_ph: Optional[Any] = None,
    ) -> None:
        self._validate("grasses", int.exists(), f"int path does not exist ({int})")
        self._validate("grasses", flag.exists(), f"flag path does not exist ({flag})")

    def _mock_grasses_outputs(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        xinit: Optional[int] = None,
        yinit: Optional[Any] = None,
        init_ph: Optional[Any] = None,
    ) -> None:
        if unw is not None and str(unw) != "-":
            unw.touch()

    def grasses(
        self,
        int: Path,
        flag: Path,
        unw: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
        xinit: Optional[int] = None,
        yinit: Optional[Any] = None,
        init_ph: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Phase unwrapping by region growing


        input parameters:
          int      (input) interferogram filename
          flag     (input) unwrapping flag filename
          unw      (output) unwrapped phase filename
          width    number of samples/row
          xmin     starting range pixel offset (default = 0)
          xmax     last range pixel offset (default=width-1)
          ymin     starting azimuth row offset, relative to start (default = 0)
          ymax     last azimuth row offset, relative to start (default = nlines-1)
          xinit    starting range pixel for unwrapping (default = width/2)
          yinit    starting row to unwrap (default = height/2)
          init_ph  flag to set phase at starting point to 0.0 (default 0: not set to 0.0, 1: set to 0.0)

        """
        if self.validate_inputs:
            self._validate_grasses(int, flag, unw, width, xmin, xmax, ymin, ymax, xinit, yinit, init_ph)
        if self.mock_outputs:
            self._mock_grasses_outputs(int, flag, unw, width, xmin, xmax, ymin, ymax, xinit, yinit, init_ph)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.grasses))
        return self._gamma_call("ISP", "grasses", supplied_args)

    def _validate_mask_data(
        self, data_in: Path, width: int, data_out: Path, mask: Path, dtype: Optional[int] = None
    ) -> None:
        self._validate("mask_data", data_in.exists(), f"data_in path does not exist ({data_in})")
        self._validate("mask_data", mask.exists(), f"mask path does not exist ({mask})")

    def _mock_mask_data_outputs(
        self, data_in: Path, width: int, data_out: Path, mask: Path, dtype: Optional[int] = None
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def mask_data(
        self, data_in: Path, width: int, data_out: Path, mask: Path, dtype: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Mask float or fcomplex data using an 8-bit SUN/BMP/TIFF format raster image


        input parameters:
          data_in  (input) data file (FLOAT or FCOMPLEX format)
          width    width of input data file
          data_out (output) data file, same data format as input
          mask     (input) mask file, SUN/BMP/TIFF raster format, 8-bits/pixel
                   output data values are set to 0.0 at all locations where the mask is black (0,0,0) or dn = 0
                   NOTE: mask file must have the same width as the input data file
          dtype    data format:
                      0: FLOAT (default)
                      1: FCOMPLEX

        """
        if self.validate_inputs:
            self._validate_mask_data(data_in, width, data_out, mask, dtype)
        if self.mock_outputs:
            self._mock_mask_data_outputs(data_in, width, data_out, mask, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mask_data))
        return self._gamma_call("ISP", "mask_data", supplied_args)

    def _validate_par_ESA_JERS_SEASAT_SLC(
        self, CEOS_data: Path, CEOS_leader: Path, SLC_par: Path, SLC: Optional[Path] = None
    ) -> None:
        self._validate("par_ESA_JERS_SEASAT_SLC", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")
        self._validate(
            "par_ESA_JERS_SEASAT_SLC", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})"
        )

    def _mock_par_ESA_JERS_SEASAT_SLC_outputs(
        self, CEOS_data: Path, CEOS_leader: Path, SLC_par: Path, SLC: Optional[Path] = None
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_ESA_JERS_SEASAT_SLC(
        self, CEOS_data: Path, CEOS_leader: Path, SLC_par: Path, SLC: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for ESA-provided JERS and SEASAT SLC data


        input parameters:
          CEOS_data     (input) CEOS format SLC data (DAT_01.001)
          CEOS_leader   (input) CEOS SAR leader file for JERS SLC processed by ESA (LEA_01.001)
          SLC_par       (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC           (output) SLC data file (enter - for none, example: yyyymmdd.slc)

        """
        if self.validate_inputs:
            self._validate_par_ESA_JERS_SEASAT_SLC(CEOS_data, CEOS_leader, SLC_par, SLC)
        if self.mock_outputs:
            self._mock_par_ESA_JERS_SEASAT_SLC_outputs(CEOS_data, CEOS_leader, SLC_par, SLC)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ESA_JERS_SEASAT_SLC))
        return self._gamma_call("ISP", "par_ESA_JERS_SEASAT_SLC", supplied_args)

    def _validate_ScanSAR_burst_overlap(
        self,
        SLC_tab: Path,
        root_name: Path,
        rlks: int,
        azlks: int,
        mode: Optional[int] = None,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        dburst: Optional[Any] = None,
        bound: Optional[Any] = None,
    ) -> None:
        self._validate("ScanSAR_burst_overlap", SLC_tab.exists(), f"SLC_tab path does not exist ({SLC_tab})")
        if SLCR_tab is not None:
            self._validate("ScanSAR_burst_overlap", SLCR_tab.exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_ScanSAR_burst_overlap_outputs(
        self,
        SLC_tab: Path,
        root_name: Path,
        rlks: int,
        azlks: int,
        mode: Optional[int] = None,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        dburst: Optional[Any] = None,
        bound: Optional[Any] = None,
    ) -> None:
        if root_name is not None and str(root_name) != "-":
            root_name.touch()

    def ScanSAR_burst_overlap(
        self,
        SLC_tab: Path,
        root_name: Path,
        rlks: int,
        azlks: int,
        mode: Optional[int] = None,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
        dburst: Optional[Any] = None,
        bound: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Extract and mosaic overlapping parts of ScanSAR / TOPS burst data


        input parameters:
          SLC_tab     (input) 3 column list of SLC, SLC_par, Sentinel-1 TOPS_par sorted in the order IW1, IW2, IW3...
          root_name   (output) output data root name (example: yyyymmdd_pp_overlap)
          rlks        number of range looks used to determine burst window boundaries
          azlks       number of azimuth looks used to determine burst window boundaries
          mode        output mode (enter - for default)
                        0: output data are mosaics, non-overlapping parts are set to 0 (default)
                        1: output data are mosaics, non-overlapping parts are written
                        2: output data are burst data containing only overlapping parts
                        3: output data is a polygon file with polygons encompassing overlapping areas in the SLC mosaic
                        4: output data is a polygon file with polygons encompassing overlapping areas in the MLI mosaic
          bflg        burst window calculation flag (enter - for default)
                        0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                        1: recalculate burst window parameters from burst parameters and the number of range and azimuth looks
          SLCR_tab    (input) SLC_tab of the reference scene, 3 column list of SLC, SLC_par, TOPS_par sorted sorted in the order IW1, IW2, IW3
                      NOTE: When generating a mosaic of a resampled SLC, the SLC_tab of the reference scene is required
          dburst      delta burst number (1=overlap of subsequent bursts, enter - for default: 1)
          bound       boundary pixels in polygon (enter - for default: 0)

        """
        if self.validate_inputs:
            self._validate_ScanSAR_burst_overlap(SLC_tab, root_name, rlks, azlks, mode, bflg, SLCR_tab, dburst, bound)
        if self.mock_outputs:
            self._mock_ScanSAR_burst_overlap_outputs(
                SLC_tab, root_name, rlks, azlks, mode, bflg, SLCR_tab, dburst, bound
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_overlap))
        return self._gamma_call("ISP", "ScanSAR_burst_overlap", supplied_args)

    def _validate_par_HISEA1_SLC(
        self,
        GeoTIFF: Path,
        annotation_XML: Path,
        calibration_XML: Path,
        SLC_par: Path,
        SLC: Path,
        dtype: Optional[int] = None,
        sc_dB: Optional[Any] = None,
        shift: Optional[int] = None,
    ) -> None:
        self._validate("par_HISEA1_SLC", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate(
            "par_HISEA1_SLC", annotation_XML.exists(), f"annotation_XML path does not exist ({annotation_XML})"
        )
        self._validate(
            "par_HISEA1_SLC", calibration_XML.exists(), f"calibration_XML path does not exist ({calibration_XML})"
        )

    def _mock_par_HISEA1_SLC_outputs(
        self,
        GeoTIFF: Path,
        annotation_XML: Path,
        calibration_XML: Path,
        SLC_par: Path,
        SLC: Path,
        dtype: Optional[int] = None,
        sc_dB: Optional[Any] = None,
        shift: Optional[int] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_HISEA1_SLC(
        self,
        GeoTIFF: Path,
        annotation_XML: Path,
        calibration_XML: Path,
        SLC_par: Path,
        SLC: Path,
        dtype: Optional[int] = None,
        sc_dB: Optional[Any] = None,
        shift: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for Hisea-1 SLC data


        input parameters:
          GeoTIFF         (input) image data file in GeoTIFF format (enter - for none, *.tiff)
          annotation_XML  (input) Hisea-1 L1 XML annotation file
          calibration_XML (input) Hisea-1 L1 radiometric calibration XML file (enter - for no radiometric calibration)
          SLC_par         (output) ISP SLC parameter file (example: yyyymmdd_vv.slc.par)
          SLC             (output) SLC data file (enter - for none, example: yyyymmdd_vv.slc)
          dtype           output data type (enter - for default)
                            0: FCOMPLEX (default)
                            1: SCOMPLEX
          sc_dB           scale factor for FCOMPLEX -> SCOMPLEX, (enter - for default: HH,VV (dB): 60.0000,  VH,HV: 70.0000)
          shift           shift azimuth spectrum by fs/2 (enter - for default)
                            0: no
                            1: yes (default)

        """
        if self.validate_inputs:
            self._validate_par_HISEA1_SLC(GeoTIFF, annotation_XML, calibration_XML, SLC_par, SLC, dtype, sc_dB, shift)
        if self.mock_outputs:
            self._mock_par_HISEA1_SLC_outputs(
                GeoTIFF, annotation_XML, calibration_XML, SLC_par, SLC, dtype, sc_dB, shift
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_HISEA1_SLC))
        return self._gamma_call("ISP", "par_HISEA1_SLC", supplied_args)

    def _validate_ORB_prop_SLC(
        self,
        SLC_par: Path,
        nstate: Optional[int] = None,
        interval: Optional[Any] = None,
        extra: Optional[Any] = None,
        mode: Optional[Any] = None,
    ) -> None:
        self._validate("ORB_prop_SLC", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_ORB_prop_SLC_outputs(
        self,
        SLC_par: Path,
        nstate: Optional[int] = None,
        interval: Optional[Any] = None,
        extra: Optional[Any] = None,
        mode: Optional[Any] = None,
    ) -> None:
        pass

    def ORB_prop_SLC(
        self,
        SLC_par: Path,
        nstate: Optional[int] = None,
        interval: Optional[Any] = None,
        extra: Optional[Any] = None,
        mode: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate state vectors using orbit propagation and interpolation


        input parameters:
          SLC_par   (input) ISP image parameter file with at least 1 state vector
          nstate    number of state vectors to calculate (enter - for default: nstate from image duration + extra)
          interval  time interval between state vectors (enter - for default: state vector time interval in SLC_par)
          extra     extra time for state vectors at start and end of image (sec.) (enter - for default: 30.0)
          mode      orbit propagation mode:
                      0: polynomial interpolation (default, if 3 or more state vectors available)
                      1: integration of the equations of motion (default, if less than 3 state vectors available)
                      2: interpolate between state vectors, minimum of 3 state vectors;
                         interpolation of the equations of motion outside of the time span of the existing state vectors

        """
        if self.validate_inputs:
            self._validate_ORB_prop_SLC(SLC_par, nstate, interval, extra, mode)
        if self.mock_outputs:
            self._mock_ORB_prop_SLC_outputs(SLC_par, nstate, interval, extra, mode)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORB_prop_SLC))
        return self._gamma_call("ISP", "ORB_prop_SLC", supplied_args)

    def _validate_interp_ad(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        r_max: Optional[Any] = None,
        np_min: Optional[int] = None,
        np_max: Optional[int] = None,
        w_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        cp_data: Optional[int] = None,
    ) -> None:
        self._validate("interp_ad", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_interp_ad_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        r_max: Optional[Any] = None,
        np_min: Optional[int] = None,
        np_max: Optional[int] = None,
        w_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        cp_data: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def interp_ad(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        r_max: Optional[Any] = None,
        np_min: Optional[int] = None,
        np_max: Optional[int] = None,
        w_mode: Optional[int] = None,
        dtype: Optional[int] = None,
        cp_data: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Weighted interpolation of gaps in 2D data using an adaptive smoothing window


        input parameters:
          data_in   (input) data with gaps
          data_out  (output) data with gaps filled by interpolation
          width     number of samples/row
          r_max     maximum interpolation window radius (default(-): 16)
          np_min    minimum number of points used for the interpolation (default(-): 16)
          np_max    maximum number of points used for the interpolation (default(-): 16)
          w_mode    data weighting mode (enter - for default):
                      0: constant
                      1: 1 - (r/r_max)
                      2: 1 - (r/r_max)**2  (default)
                      3: exp(-2.*(r**2/r_max**2))
          dtype     input and output data type:
                      0: FCOMPLEX
                      1: SCOMPLEX
                      2: FLOAT (default)
                      3: INT
                      4: SHORT
          cp_data   copy data flag:
                      0: do not copy input data values to output
                      1: copy input data values to output (default)

        """
        if self.validate_inputs:
            self._validate_interp_ad(data_in, data_out, width, r_max, np_min, np_max, w_mode, dtype, cp_data)
        if self.mock_outputs:
            self._mock_interp_ad_outputs(data_in, data_out, width, r_max, np_min, np_max, w_mode, dtype, cp_data)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.interp_ad))
        return self._gamma_call("ISP", "interp_ad", supplied_args)

    def _validate_par_RISAT_GRD(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        GRD_par: Path,
        CEOS_image: Path,
        GRD: Optional[Path] = None,
        line_dir: Optional[Any] = None,
        pix_dir: Optional[Any] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[Any] = None,
    ) -> None:
        self._validate("par_RISAT_GRD", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_RISAT_GRD", BAND_META.exists(), f"BAND_META path does not exist ({BAND_META})")
        self._validate("par_RISAT_GRD", CEOS_image.exists(), f"CEOS_image path does not exist ({CEOS_image})")

    def _mock_par_RISAT_GRD_outputs(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        GRD_par: Path,
        CEOS_image: Path,
        GRD: Optional[Path] = None,
        line_dir: Optional[Any] = None,
        pix_dir: Optional[Any] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[Any] = None,
    ) -> None:
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_RISAT_GRD(
        self,
        CEOS_leader: Path,
        BAND_META: Path,
        GRD_par: Path,
        CEOS_image: Path,
        GRD: Optional[Path] = None,
        line_dir: Optional[Any] = None,
        pix_dir: Optional[Any] = None,
        cal_flg: Optional[int] = None,
        KdB: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Read RISAT-1 Ground-Range data from a CEOS data set and perform radiometric calibration


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file (example: lea_01.001)
          BAND_META    (input) BAND_META.txt, additional RISAT system parameters for the scene (format keywork=value)
          GRD_par      (output) ISP GRD parameter file (example: YYYYMMDD.grd.par)
          CEOS_image   (input) CEOS Ground-Range image file (example: dat_01.001)
          GRD          (output) Ground-Range data with file and line headers removed (enter - for none: example: YYYYMMDD.grd)
          line_dir     set output image line direction (enter - for default):
                         0: used value derived from CEOS leader file
                         1: retain input data line direction  (default)
                        -1: reverse input data line direction
          pix_dir      set output pixel direction (enter - for default):
                         0: used value derived from CEOS leader file
                         1: retain input data pixel direction (default)
                        -1: reverse input data pixel direction
          cal_flg      calibration flag (enter - for default):
                         0: do not apply radiometric calibration
                         1: apply radiometric calibration including KdB and incidence angle correction (default)
          KdB          calibration constant (dB) (enter - to use value in the CEOS leader)

        """
        if self.validate_inputs:
            self._validate_par_RISAT_GRD(
                CEOS_leader, BAND_META, GRD_par, CEOS_image, GRD, line_dir, pix_dir, cal_flg, KdB
            )
        if self.mock_outputs:
            self._mock_par_RISAT_GRD_outputs(
                CEOS_leader, BAND_META, GRD_par, CEOS_image, GRD, line_dir, pix_dir, cal_flg, KdB
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RISAT_GRD))
        return self._gamma_call("ISP", "par_RISAT_GRD", supplied_args)

    def _validate_par_RSAT_SCW(
        self,
        CEOS_leader: Path,
        CEOS_trailer: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Path,
        sc_dB: Optional[Any] = None,
        dt: Optional[Any] = None,
    ) -> None:
        self._validate("par_RSAT_SCW", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_RSAT_SCW", CEOS_trailer.exists(), f"CEOS_trailer path does not exist ({CEOS_trailer})")
        self._validate("par_RSAT_SCW", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_RSAT_SCW_outputs(
        self,
        CEOS_leader: Path,
        CEOS_trailer: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Path,
        sc_dB: Optional[Any] = None,
        dt: Optional[Any] = None,
    ) -> None:
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_RSAT_SCW(
        self,
        CEOS_leader: Path,
        CEOS_trailer: Path,
        CEOS_data: Path,
        GRD_par: Path,
        GRD: Path,
        sc_dB: Optional[Any] = None,
        dt: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        ISP parameter file for SCANSAR Wide Swath Data


        input parameters:
          CEOS_leader  (input) CEOS SAR leader file
          CEOS_trailer (input) CEOS SAR trailer file
          CEOS_data    (input) CEOS data file binary)
          GRD_par      (output) ISP ground range image parameter file (example <orbit>.mli.par)
          GRD          (output) ISP ground range image (example <orbit>.mli) (enter -  for none, float)
          sc_dB        intensity scale factor in dB (enter - for default:   0.00)
          dt           azimuth image time offset (s) (enter - for default = 0.0)

        """
        if self.validate_inputs:
            self._validate_par_RSAT_SCW(CEOS_leader, CEOS_trailer, CEOS_data, GRD_par, GRD, sc_dB, dt)
        if self.mock_outputs:
            self._mock_par_RSAT_SCW_outputs(CEOS_leader, CEOS_trailer, CEOS_data, GRD_par, GRD, sc_dB, dt)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT_SCW))
        return self._gamma_call("ISP", "par_RSAT_SCW", supplied_args)

    def _validate_neutron(
        self,
        intensity: Path,
        flag: Path,
        width: int,
        n_thres: Any,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        self._validate("neutron", intensity.exists(), f"intensity path does not exist ({intensity})")
        self._validate("neutron", flag.exists(), f"flag path does not exist ({flag})")

    def _mock_neutron_outputs(
        self,
        intensity: Path,
        flag: Path,
        width: int,
        n_thres: Any,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        pass

    def neutron(
        self,
        intensity: Path,
        flag: Path,
        width: int,
        n_thres: Any,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate phase unwrapping neutrons using image intensity


        input parameters:
          intensity  (input) image intensity
          flag       (input) phase unwrapping flag file
          width      number of samples/row
          n_thres    neutron threshold, multiples of the average intensity (default=6.0)
          ymin       offset to starting azimuth row (default = 0)
          ymax       offset to last azimuth row (default = nlines-1)

        """
        if self.validate_inputs:
            self._validate_neutron(intensity, flag, width, n_thres, ymin, ymax)
        if self.mock_outputs:
            self._mock_neutron_outputs(intensity, flag, width, n_thres, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.neutron))
        return self._gamma_call("ISP", "neutron", supplied_args)

    def _validate_multi_look(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        self._validate("multi_look", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("multi_look", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_multi_look_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> None:
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def multi_look(
        self,
        SLC: Path,
        SLC_par: Path,
        MLI: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate a multi-look intensity (MLI) image from an SLC image


        input parameters:
          SLC      (input) single-look complex image (SCOMPLEX or FCOMPLEX)
          SLC_par  (input) SLC ISP image parameter file
          MLI      (output) multi-look intensity image (FLOAT)
          MLI_par  (output) MLI ISP image parameter file
          rlks     number of range looks (INT)
          azlks    number of azimuth looks (INT)
          loff     offset to starting line (enter - for default: 0)
          nlines   number of SLC lines to process (enter - for default: entire file)
          scale    scale factor for output MLI (enter - for default: 1.0)
          exp      exponent for the output MLI (enter - for default: 1.0)

        """
        if self.validate_inputs:
            self._validate_multi_look(SLC, SLC_par, MLI, MLI_par, rlks, azlks, loff, nlines, scale, exp)
        if self.mock_outputs:
            self._mock_multi_look_outputs(SLC, SLC_par, MLI, MLI_par, rlks, azlks, loff, nlines, scale, exp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look))
        return self._gamma_call("ISP", "multi_look", supplied_args)

    def _validate_mosaic_WB(self, data_tab: Path, dtype: int, data_out: Path, data_par_out: Path, sc_flg: int) -> None:
        self._validate("mosaic_WB", data_tab.exists(), f"data_tab path does not exist ({data_tab})")

    def _mock_mosaic_WB_outputs(
        self, data_tab: Path, dtype: int, data_out: Path, data_par_out: Path, sc_flg: int
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()
        if data_par_out is not None and str(data_par_out) != "-":
            data_par_out.touch()

    def mosaic_WB(
        self, data_tab: Path, dtype: int, data_out: Path, data_par_out: Path, sc_flg: int
    ) -> Tuple[int, str, str]:
        """

        ISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/mosaic_WB.c
        Mosaic Wide-Beam ScanSAR data processed by the MSP


        input parameters:
          data_tab      (input) 2 column list of data  and ISP image parameter files for the beams in the mosaic (text)
          dtype         (input) input data type:
                           0: FLOAT
                           1: FCOMPLEX
          data_out      (output) output image mosaic
          data_par_out  (output) ISP image parameter file for output image mosaic
          sc_flg        intensity scaling flag:
                          0: do not scale different beam data values
                          1: use overlap regions to scale beam intensities (default)

        """
        if self.validate_inputs:
            self._validate_mosaic_WB(data_tab, dtype, data_out, data_par_out, sc_flg)
        if self.mock_outputs:
            self._mock_mosaic_WB_outputs(data_tab, dtype, data_out, data_par_out, sc_flg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mosaic_WB))
        return self._gamma_call("ISP", "mosaic_WB", supplied_args)

    def _validate_ScanSAR_burst_to_mosaic(
        self,
        DATA_tab: Path,
        mosaic: Path,
        MLI_par: Path,
        mflg: Optional[int] = None,
        dtype: Optional[int] = None,
        data_tab_ref: Optional[int] = None,
        min_ovr: Optional[int] = None,
    ) -> None:
        self._validate("ScanSAR_burst_to_mosaic", DATA_tab.exists(), f"DATA_tab path does not exist ({DATA_tab})")

    def _mock_ScanSAR_burst_to_mosaic_outputs(
        self,
        DATA_tab: Path,
        mosaic: Path,
        MLI_par: Path,
        mflg: Optional[int] = None,
        dtype: Optional[int] = None,
        data_tab_ref: Optional[int] = None,
        min_ovr: Optional[int] = None,
    ) -> None:
        if mosaic is not None and str(mosaic) != "-":
            mosaic.touch()
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def ScanSAR_burst_to_mosaic(
        self,
        DATA_tab: Path,
        mosaic: Path,
        MLI_par: Path,
        mflg: Optional[int] = None,
        dtype: Optional[int] = None,
        data_tab_ref: Optional[int] = None,
        min_ovr: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate mosaic of multilook ScanSAR burst data (FLOAT or FCOMPLEX)


        input parameters:
          DATA_tab      (input) 3 column list of swaths in ML_DATA burst geometry listed in the order from near to far range
                          DATA_tab line entries:   DATA   MLI_par  TOPS_par
                        NOTE: The data type (FLOAT or FCOMPLEX) is specified in the MLI_par and the burst parameters (TOPS_par) must agree
          mosaic        (output) mosaic image from bursts in multi-look geometry
          MLI_par       (output) mosaic image parameter file
          mflg          mosaicking option flag (enter - for default)
                          0: no overlap between bursts or image swaths (default)
                          1: average data in the overlap between bursts and in the overlap between image swaths
                          2: average data in the overlap between bursts but not in the overlap between image swaths
          DATA_tab_ref  (input) reference scene DATA_tab, 3 column list of DATA, MLI_par, TOPS_par listed in order from near to far range (enter - for none)
                        NOTE: When generating a mosaic produced using data from a resampled scene, the MLI_tab of the reference scene is required
          min_ovr       minimum number of overlapping bursts (using mflg = 1 or 2, enter - for default: 1)
          max_ovr       maximum number of overlapping bursts (using mflg = 1 or 2, enter - for default: unlimited)

        """
        if self.validate_inputs:
            self._validate_ScanSAR_burst_to_mosaic(DATA_tab, mosaic, MLI_par, mflg, dtype, data_tab_ref, min_ovr)
        if self.mock_outputs:
            self._mock_ScanSAR_burst_to_mosaic_outputs(DATA_tab, mosaic, MLI_par, mflg, dtype, data_tab_ref, min_ovr)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_to_mosaic))
        return self._gamma_call("ISP", "ScanSAR_burst_to_mosaic", supplied_args)

    def _validate_par_UAVSAR_SLC(
        self,
        ann: Path,
        SLC_or_MLC_in: Path,
        SLC_or_MLI_par: Path,
        SLC_or_MLI_out: Optional[Path] = None,
        image_type: Optional[int] = None,
        image_format: Optional[int] = None,
        DOP: Optional[Path] = None,
    ) -> None:
        self._validate("par_UAVSAR_SLC", ann.exists(), f"ann path does not exist ({ann})")
        self._validate("par_UAVSAR_SLC", SLC_or_MLC_in.exists(), f"SLC_or_MLC_in path does not exist ({SLC_or_MLC_in})")
        if DOP is not None:
            self._validate("par_UAVSAR_SLC", DOP.exists(), f"DOP path does not exist ({DOP})")

    def _mock_par_UAVSAR_SLC_outputs(
        self,
        ann: Path,
        SLC_or_MLC_in: Path,
        SLC_or_MLI_par: Path,
        SLC_or_MLI_out: Optional[Path] = None,
        image_type: Optional[int] = None,
        image_format: Optional[int] = None,
        DOP: Optional[Path] = None,
    ) -> None:
        if SLC_or_MLI_par is not None and str(SLC_or_MLI_par) != "-":
            SLC_or_MLI_par.touch()
        if SLC_or_MLI_out is not None and str(SLC_or_MLI_out) != "-":
            SLC_or_MLI_out.touch()

    def par_UAVSAR_SLC(
        self,
        ann: Path,
        SLC_or_MLC_in: Path,
        SLC_or_MLI_par: Path,
        SLC_or_MLI_out: Optional[Path] = None,
        image_type: Optional[int] = None,
        image_format: Optional[int] = None,
        DOP: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        ISP image parameter file from UAVSAR annotation file (ann) for SLC and MLC products


        input parameters:
          ann           (input) UAVSAR annotation file (*ann.txt or *.ann)
          SLC/MLC_in    (input) UAVSAR binary data file (required for annotation file version 1.2) (enter - for none)
          SLC/MLI_par   (output) ISP image parameter file
          SLC/MLI_out   (output) SLC data file (enter - for none)
          image_type    image type flag (enter - for default)
                          0: SLC (slc) in slant range coordinates (default)
                          1: MLC (mlc) in slant range coordinates
                             HHHH*, VVVV*, HVHV* are FLOAT format
                             HHHV*, HHVV*, HVVV* are FCOMPLEX format
          image_format  image data format flag (enter - for default)
                          0: FCOMPLEX (pairs of 4-byte float (re,im)) (default)
                          2: FLOAT  (4-bytes/value)
          DOP           (input) UAVSAR Doppler look-up table (if not zero-Doppler) (enter - for none)
        """
        if self.validate_inputs:
            self._validate_par_UAVSAR_SLC(
                ann, SLC_or_MLC_in, SLC_or_MLI_par, SLC_or_MLI_out, image_type, image_format, DOP
            )
        if self.mock_outputs:
            self._mock_par_UAVSAR_SLC_outputs(
                ann, SLC_or_MLC_in, SLC_or_MLI_par, SLC_or_MLI_out, image_type, image_format, DOP
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_UAVSAR_SLC))
        return self._gamma_call("ISP", "par_UAVSAR_SLC", supplied_args)

    def _validate_ave_cpx(
        self,
        cpx_list: Path,
        width: int,
        cpx_ave: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        self._validate("ave_cpx", cpx_list.exists(), f"cpx_list path does not exist ({cpx_list})")

    def _mock_ave_cpx_outputs(
        self,
        cpx_list: Path,
        width: int,
        cpx_ave: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        if cpx_ave is not None and str(cpx_ave) != "-":
            cpx_ave.touch()

    def ave_cpx(
        self,
        cpx_list: Path,
        width: int,
        cpx_ave: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate average of a set of FCOMPLEX images


        input parameters:
          cpx_list  (input) list of coregistered images (FCOMPLEX)
          width     number of samples/line
          cpx_ave   (output) average of images listed in cpx_list (FCOMPLEX)
          start     starting line (enter - for default: 1)
          nlines    number of lines to process (enter - for default: entire file)
          zflag     zero flag (enter - for default)
                      0: interpret 0.0 as missing data value (default)
                      1: interpret 0.0 as valid data

        """
        if self.validate_inputs:
            self._validate_ave_cpx(cpx_list, width, cpx_ave, start, nlines, zflag)
        if self.mock_outputs:
            self._mock_ave_cpx_outputs(cpx_list, width, cpx_ave, start, nlines, zflag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ave_cpx))
        return self._gamma_call("ISP", "ave_cpx", supplied_args)

    def _validate_ScanSAR_burst_copy(
        self,
        SLC: Path,
        SLC_par: Path,
        TOPS_par: Path,
        SLC_out: Path,
        SLC_out_par: Path,
        burst_num: int,
        drflg: Optional[int] = None,
        SLC_par2: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("ScanSAR_burst_copy", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("ScanSAR_burst_copy", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("ScanSAR_burst_copy", TOPS_par.exists(), f"TOPS_par path does not exist ({TOPS_par})")

    def _mock_ScanSAR_burst_copy_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        TOPS_par: Path,
        SLC_out: Path,
        SLC_out_par: Path,
        burst_num: int,
        drflg: Optional[int] = None,
        SLC_par2: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> None:
        if SLC_out is not None and str(SLC_out) != "-":
            SLC_out.touch()
        if SLC_out_par is not None and str(SLC_out_par) != "-":
            SLC_out_par.touch()
        if SLC_par2 is not None and str(SLC_par2) != "-":
            SLC_par2.touch()

    def ScanSAR_burst_copy(
        self,
        SLC: Path,
        SLC_par: Path,
        TOPS_par: Path,
        SLC_out: Path,
        SLC_out_par: Path,
        burst_num: int,
        drflg: Optional[int] = None,
        SLC_par2: Optional[Path] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Copy selected burst from Sentinel-1 TOPS SLC to a file


        input parameters:
          SLC          (input) ScanSAR mode burst SLC
          SLC_par      (input) SLC parameter file for the ScanSAR burst scene
          TOPS_par     (input) burst parameter file for the ScanSAR burst SLC
          SLC_out      (output) SLC file containing a single burst
          SLC_out_par  (output) SLC parameter file for the single burst
          burst_num    burst number of selected burst (1 -> number of bursts in the SLC)
          drflg        deramp phase flag (enter - for default)
                         0: no modification of the burst SLC phase (default)
                         1: subtract TOPS mode Doppler phase ramp for Sentinel-1 (deramp)
          SLC_par2     (output) SLC parameter file for the single burst SLC with deramped phase (drflg: 1, enter - for none)
          dtype        output data type (enter - for default: same as input data):
                         0: FCOMPLEX
                         1: SCOMPLEX

        """
        if self.validate_inputs:
            self._validate_ScanSAR_burst_copy(
                SLC, SLC_par, TOPS_par, SLC_out, SLC_out_par, burst_num, drflg, SLC_par2, dtype
            )
        if self.mock_outputs:
            self._mock_ScanSAR_burst_copy_outputs(
                SLC, SLC_par, TOPS_par, SLC_out, SLC_out_par, burst_num, drflg, SLC_par2, dtype
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_burst_copy))
        return self._gamma_call("ISP", "ScanSAR_burst_copy", supplied_args)

    def _validate_hgt_map(
        self,
        unw: Path,
        SLC_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        gr: Path,
        ph_flag: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> None:
        self._validate("hgt_map", unw.exists(), f"unw path does not exist ({unw})")
        self._validate("hgt_map", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("hgt_map", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("hgt_map", baseline.exists(), f"baseline path does not exist ({baseline})")
        if SLC2R_par is not None:
            self._validate("hgt_map", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")

    def _mock_hgt_map_outputs(
        self,
        unw: Path,
        SLC_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        gr: Path,
        ph_flag: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> None:
        if hgt is not None and str(hgt) != "-":
            hgt.touch()
        if gr is not None and str(gr) != "-":
            gr.touch()

    def hgt_map(
        self,
        unw: Path,
        SLC_par: Path,
        OFF_par: Path,
        baseline: Path,
        hgt: Path,
        gr: Path,
        ph_flag: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Interferometric height/ground range estimation vs. slant range


        input parameters:
          unw        (input) unwrapped interferometric phase
          SLC_par    (input) ISP parameter file for the reference SLC
          OFF_par    (input) ISP offset/interferogram processing parameters
          baseline   (input) baseline parameter file
          hgt        (output) height file (in slant range geometry) relative to the WGS-84 ellipsoid
          gr         (output) cross-track ground ranges on the WGS-84 ellipsoid (in slant range geometry)
          ph_flag    restore phase slope flag (0:no phase change  default=1:add back phase ramp)
          loff       offset to starting line (default = 0)
          nlines     number of lines to calculate (enter - for default: to end of file)
          SLC2R_par  (input) parameter file of resampled SLC, required if SLC-2 frequency differs from SLC-1

        """
        if self.validate_inputs:
            self._validate_hgt_map(unw, SLC_par, OFF_par, baseline, hgt, gr, ph_flag, loff, nlines, SLC2R_par)
        if self.mock_outputs:
            self._mock_hgt_map_outputs(unw, SLC_par, OFF_par, baseline, hgt, gr, ph_flag, loff, nlines, SLC2R_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.hgt_map))
        return self._gamma_call("ISP", "hgt_map", supplied_args)

    def _validate_par_CS_SLC(
        self,
    ) -> None:
        pass

    def _mock_par_CS_SLC_outputs(
        self,
    ) -> None:
        pass

    def par_CS_SLC(
        self,
    ) -> Tuple[int, str, str]:
        """

        dyld[47036]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_CS_SLC'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)
        """
        if self.validate_inputs:
            self._validate_par_CS_SLC()
        if self.mock_outputs:
            self._mock_par_CS_SLC_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_CS_SLC))
        return self._gamma_call("ISP", "par_CS_SLC", supplied_args)

    def _validate_par_TX_GRD(
        self, annotation_XML: Path, COSAR: Path, GRD_par: Path, GRD: Path, pol: Optional[Any] = None
    ) -> None:
        self._validate("par_TX_GRD", annotation_XML.exists(), f"annotation_XML path does not exist ({annotation_XML})")
        self._validate("par_TX_GRD", COSAR.exists(), f"COSAR path does not exist ({COSAR})")

    def _mock_par_TX_GRD_outputs(
        self, annotation_XML: Path, COSAR: Path, GRD_par: Path, GRD: Path, pol: Optional[Any] = None
    ) -> None:
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_TX_GRD(
        self, annotation_XML: Path, COSAR: Path, GRD_par: Path, GRD: Path, pol: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        Generate ground range image and image parameter file for Terrasar-X MGD data in GeoTIFF format


        input parameters:
          annotation_XML (input) Terrasar-X product annotation XML file
          GeoTIFF  (input) image data file in geotiff format
                    NOTE: make sure the data set contains the selected polarisation)
          GRD_par   ISP ground range image parameter file (example: yyyymmdd.grd.par
          GRD       (output) calibrated ground range data file (example: yyyymmdd.grd)
          pol       polarisation: HH, HV, VH, VV (default: first polarisation found in the annotation_XML)

        """
        if self.validate_inputs:
            self._validate_par_TX_GRD(annotation_XML, COSAR, GRD_par, GRD, pol)
        if self.mock_outputs:
            self._mock_par_TX_GRD_outputs(annotation_XML, COSAR, GRD_par, GRD, pol)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_TX_GRD))
        return self._gamma_call("ISP", "par_TX_GRD", supplied_args)

    def _validate_split_WB(self, data_in: Path, data_par_in: Path, data_tab: Path, dtype: int) -> None:
        self._validate("split_WB", data_in.exists(), f"data_in path does not exist ({data_in})")
        self._validate("split_WB", data_par_in.exists(), f"data_par_in path does not exist ({data_par_in})")
        self._validate("split_WB", data_tab.exists(), f"data_tab path does not exist ({data_tab})")

    def _mock_split_WB_outputs(self, data_in: Path, data_par_in: Path, data_tab: Path, dtype: int) -> None:
        pass

    def split_WB(self, data_in: Path, data_par_in: Path, data_tab: Path, dtype: int) -> Tuple[int, str, str]:
        """

        ISP: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/split_WB
        Split WB mosaic image into individual beams using ISP parameter files


        input parameters:
          data_in      (input) input mosaicked data in slant-range geometry (e.g. DEM data)
          data_par_in  (input) ISP image parameter file for data in the input mosaic
          data_tab     (input) 2 column list of output data filenames and ISP image parameter files for each beam in the mosaic (text)
          dtype        (input) input data type:
                          0: FLOAT
                          1: FCOMPLEX
        """
        if self.validate_inputs:
            self._validate_split_WB(data_in, data_par_in, data_tab, dtype)
        if self.mock_outputs:
            self._mock_split_WB_outputs(data_in, data_par_in, data_tab, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.split_WB))
        return self._gamma_call("ISP", "split_WB", supplied_args)

    def _validate_base_init(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        interf: Path,
        base: Path,
        mflag: Optional[int] = None,
        nrfft: Optional[int] = None,
        nazfft: Optional[Any] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[Any] = None,
    ) -> None:
        self._validate("base_init", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("base_init", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("base_init", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("base_init", interf.exists(), f"interf path does not exist ({interf})")

    def _mock_base_init_outputs(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        interf: Path,
        base: Path,
        mflag: Optional[int] = None,
        nrfft: Optional[int] = None,
        nazfft: Optional[Any] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[Any] = None,
    ) -> None:
        if base is not None and str(base) != "-":
            base.touch()

    def base_init(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        interf: Path,
        base: Path,
        mflag: Optional[int] = None,
        nrfft: Optional[int] = None,
        nazfft: Optional[Any] = None,
        r_samp: Optional[int] = None,
        az_line: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Estimate initial baseline using orbit state vectors, offsets, and interferogram phase


        input parameters:
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file (enter - for none)
          interf    (input) unflattened interferogram (enter - for none)
          baseline  (output) baseline parameter file
          mflag     baseline estimation method flag (enter - for default)
                    mflag    b_para    b_perp    input
                      0:     orbits    orbits    p1,p2  (default)
                      1:     offsets   offsets   p1,p2,off
                      2:     orbits    fft       p1,p2,off,int
                      3:     offsets   fft       p1,p2,off,int
                      4:     fft       fft       p1,off,int
          nrfft     size of range FFT   (512, 1024,...) (enter - for default determined from image width)
          nazfft    size of azimuth FFT (512, 1024,...) (enter - for default determined from image azimuth lines)
          r_samp    range pixel offset to center of the FFT window (enter - for default, default: range center)
          az_line   line offset from start of the interf. for the  FFT window (enter - for default, default: azimuth center)

          NOTE: Not all  input data files are required for the different methods

                enter - for files that are not provided

        """
        if self.validate_inputs:
            self._validate_base_init(SLC1_par, SLC2_par, OFF_par, interf, base, mflag, nrfft, nazfft, r_samp, az_line)
        if self.mock_outputs:
            self._mock_base_init_outputs(
                SLC1_par, SLC2_par, OFF_par, interf, base, mflag, nrfft, nazfft, r_samp, az_line
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_init))
        return self._gamma_call("ISP", "base_init", supplied_args)

    def _validate_par_SAOCOM_SLC(
        self,
        data: Path,
        XML: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        RSLC_par: Optional[Path] = None,
    ) -> None:
        self._validate("par_SAOCOM_SLC", data.exists(), f"data path does not exist ({data})")
        self._validate("par_SAOCOM_SLC", XML.exists(), f"XML path does not exist ({XML})")
        if RSLC_par is not None:
            self._validate("par_SAOCOM_SLC", RSLC_par.exists(), f"RSLC_par path does not exist ({RSLC_par})")

    def _mock_par_SAOCOM_SLC_outputs(
        self,
        data: Path,
        XML: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        RSLC_par: Optional[Path] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()
        if TOPS_par is not None and str(TOPS_par) != "-":
            TOPS_par.touch()

    def par_SAOCOM_SLC(
        self,
        data: Path,
        XML: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        RSLC_par: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for SAOCOM stripmap and TOPS SLC data


        input parameters:
          data          (input) SAOCOM image data file in binary format (enter - for none, e.g. slc-acqId0000089010-a-tna-0000000000-s3qp-hh)
          XML           (input) SAOCOM XML annotation file (e.g. slc-acqId0000089010-a-tna-0000000000-s3qp-hh.xml)
          SLC_par       (output) SLC parameter file (example: yyyymmdd_s3_pp.slc.par)
          SLC           (output) SLC data file (FCOMPLEX, enter - for none, example: yyyymmdd_s3_pp.slc)
          TOPS_par      (output) SLC burst annotation file, TOPS data only (enter - for none, example: yyyymmdd_s3_vv.slc.tops_par)
          RSLC_par      (input) reference SLC parameter file to keep consistent range pixel spacing (example: yyyymmdd_s1_pp.slc.par)

        NOTE: SAOCOM geocoded data in GeoTIFF format (GEC and GTC / level 1C and 1D data) can be read using par_SAOCOM_geo program

        """
        if self.validate_inputs:
            self._validate_par_SAOCOM_SLC(data, XML, SLC_par, SLC, TOPS_par, RSLC_par)
        if self.mock_outputs:
            self._mock_par_SAOCOM_SLC_outputs(data, XML, SLC_par, SLC, TOPS_par, RSLC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_SAOCOM_SLC))
        return self._gamma_call("ISP", "par_SAOCOM_SLC", supplied_args)

    def _validate_par_SIRC(self, CEOS_leader: Path, SLC_par: Path, UTC_or_MET: Optional[Any] = None) -> None:
        self._validate("par_SIRC", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")

    def _mock_par_SIRC_outputs(self, CEOS_leader: Path, SLC_par: Path, UTC_or_MET: Optional[Any] = None) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_SIRC(self, CEOS_leader: Path, SLC_par: Path, UTC_or_MET: Optional[Any] = None) -> Tuple[int, str, str]:
        """

        ISP SLC parameter file from SIR-C CEOS leader file


        input parameters:
          CEOS_leader   (input) JPL SIR-C CEOS leader file
          SLC_par       (output) ISP SLC parameter file
          UTC/MET       time reference for state vectors:
                        MET (Mission Elapsed Time) or UTC (default=UTC)
        """
        if self.validate_inputs:
            self._validate_par_SIRC(CEOS_leader, SLC_par, UTC_or_MET)
        if self.mock_outputs:
            self._mock_par_SIRC_outputs(CEOS_leader, SLC_par, UTC_or_MET)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_SIRC))
        return self._gamma_call("ISP", "par_SIRC", supplied_args)

    def _validate_rascc_mask(
        self,
        cc: Path,
        pwr: Optional[Path],
        width: int,
        start_cc: Optional[Any] = None,
        start_pwr: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        cc_thres: Optional[Any] = None,
        pwr_thres: Optional[Any] = None,
        cc_min: Optional[Any] = None,
        cc_max: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        LR: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        self._validate("rascc_mask", cc.exists(), f"cc path does not exist ({cc})")
        if pwr is not None:
            self._validate("rascc_mask", pwr.exists(), f"pwr path does not exist ({pwr})")

    def _mock_rascc_mask_outputs(
        self,
        cc: Path,
        pwr: Optional[Path],
        width: int,
        start_cc: Optional[Any] = None,
        start_pwr: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        cc_thres: Optional[Any] = None,
        pwr_thres: Optional[Any] = None,
        cc_min: Optional[Any] = None,
        cc_max: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        LR: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def rascc_mask(
        self,
        cc: Path,
        pwr: Optional[Path],
        width: int,
        start_cc: Optional[Any] = None,
        start_pwr: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        cc_thres: Optional[Any] = None,
        pwr_thres: Optional[Any] = None,
        cc_min: Optional[Any] = None,
        cc_max: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        LR: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate phase unwrapping validity mask using correlation and intensity


        input parameters:
          cc         (input)interferometric correlation image (float)
          pwr        (input)intensity image (float, enter - if not available)
          width      number of samples/row
          start_cc   starting line of coherence image (default: 1)
          start_pwr  starting line of intensity image (default: 1)
          nlines     number of lines to display (default=0: to end of file)
          pixavr     number of pixels to average in range (default: 1)
          pixavaz    number of pixels to average in azimuth (default: 1)
          cc_thres   coherence threshold for masking, pixels with cc < cc_thres are set to 0 (default: 0.0)
          pwr_thres  relative intensity threshold for masking, pixels with intensity < pwr_thres * average intensity are set to 0 (default: 0)
          cc_min     minimum coherence value used for color display (default: 0.1)
          cc_max     maximum coherence value used for color display (default: 0.9)
          scale      intensity display scale factor (default: 1.)
          exp        intensity display exponent (default: .35)
          LR         left/right mirror image flag, (1: normal (default), -1: mirror image)
          rasf       (output) image filename, extension determines the format, enter - for default: *.bmp
                       *.bmp BMP format
                       *.ras Sun raster format
                       *.tif TIFF format
        """
        if self.validate_inputs:
            self._validate_rascc_mask(
                cc,
                pwr,
                width,
                start_cc,
                start_pwr,
                nlines,
                pixavr,
                pixavaz,
                cc_thres,
                pwr_thres,
                cc_min,
                cc_max,
                scale,
                exp,
                LR,
                rasf,
            )
        if self.mock_outputs:
            self._mock_rascc_mask_outputs(
                cc,
                pwr,
                width,
                start_cc,
                start_pwr,
                nlines,
                pixavr,
                pixavaz,
                cc_thres,
                pwr_thres,
                cc_min,
                cc_max,
                scale,
                exp,
                LR,
                rasf,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.rascc_mask))
        return self._gamma_call("ISP", "rascc_mask", supplied_args)

    def _validate_SLC_mosaic_ScanSAR(
        self,
        SLC_tab: Path,
        SLC: Path,
        SLC_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
    ) -> None:
        self._validate("SLC_mosaic_ScanSAR", SLC_tab.exists(), f"SLC_tab path does not exist ({SLC_tab})")
        if SLCR_tab is not None:
            self._validate("SLC_mosaic_ScanSAR", SLCR_tab.exists(), f"SLCR_tab path does not exist ({SLCR_tab})")

    def _mock_SLC_mosaic_ScanSAR_outputs(
        self,
        SLC_tab: Path,
        SLC: Path,
        SLC_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
    ) -> None:
        if SLC is not None and str(SLC) != "-":
            SLC.touch()
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def SLC_mosaic_ScanSAR(
        self,
        SLC_tab: Path,
        SLC: Path,
        SLC_par: Path,
        rlks: int,
        azlks: int,
        bflg: Optional[int] = None,
        SLCR_tab: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate SLC mosaic of ScanSAR SLC burst data (Sentinel-1, TerraSAR-X, RCM...)


        input parameters:
          SLC_tab    (input) 3 column list of ScanSAR SLC, swaths are listed in order from near to far range
                       SLC_tab line entries:   SLC   SLC_par   TOPS_par
          SLC        (output) SLC mosaic image
          SLC_par    (output) SLC mosaic image parameter file
          rlks       number of range looks used to determine burst window boundaries for the mosaic
          azlks      number of azimuth looks used to determine burst window boundaries for the mosaic
          bflg       burst window calculation flag:
                       0: use existing burst window parameters if they exist, otherwise calculate burst window parameters (default)
                       1: calculate burst window parameters from burst parameters and the number of range and azimuth looks
          SLCR_tab   (input) 3 column list of the reference scene, swaths are listed in order from near to far range, enter - for none
                       SLCR_tab line entries:   SLC   SLC_par   TOPS_par
                     NOTE: When generating a mosaic of a resampled SLC, the SLC_tab of the reference scene is required

        """
        if self.validate_inputs:
            self._validate_SLC_mosaic_ScanSAR(SLC_tab, SLC, SLC_par, rlks, azlks, bflg, SLCR_tab)
        if self.mock_outputs:
            self._mock_SLC_mosaic_ScanSAR_outputs(SLC_tab, SLC, SLC_par, rlks, azlks, bflg, SLCR_tab)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_mosaic_ScanSAR))
        return self._gamma_call("ISP", "SLC_mosaic_ScanSAR", supplied_args)

    def _validate_init_offset_orbit(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        cflag: Optional[int] = None,
    ) -> None:
        self._validate("init_offset_orbit", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("init_offset_orbit", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_init_offset_orbit_outputs(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        cflag: Optional[int] = None,
    ) -> None:
        if not OFF_par.exists():
            OFF_par.touch()

    def init_offset_orbit(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        rpos: Optional[Any] = None,
        azpos: Optional[Any] = None,
        cflag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Initial SLC image offset estimation from orbit state-vectors and image parameters


        input parameters:
          SLC1_par  (input) SLC-1 parameter file
          SLC2_par  (input) SLC-2 parameter file
          OFF_par   (input/output) ISP/offset parameter file
          rpos      range position for offset estimation (enter - for default: center of SLC-1)
          azpos     azimuth position for offset estimation (enter - for default: center of SLC-1)
          cflag     copy offsets to the range and azimuth offset polynomials in the OFF_par
                      0: do not copy
                      1: copy constant range and azimuth offset (default)

        """
        if self.validate_inputs:
            self._validate_init_offset_orbit(SLC1_par, SLC2_par, OFF_par, rpos, azpos, cflag)
        if self.mock_outputs:
            self._mock_init_offset_orbit_outputs(SLC1_par, SLC2_par, OFF_par, rpos, azpos, cflag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.init_offset_orbit))
        return self._gamma_call("ISP", "init_offset_orbit", supplied_args)

    def _validate_interf_SLC(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        MLI_1: Path,
        MLI_2: Path,
        interf: Any,
        nrlk: Optional[int] = None,
        nazlk: Optional[int] = None,
        loff: Optional[int] = None,
        nltot: Optional[int] = None,
        rfilt: Optional[int] = None,
        azfilt: Optional[int] = None,
        s_off: Optional[int] = None,
    ) -> None:
        self._validate("interf_SLC", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("interf_SLC", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("interf_SLC", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("interf_SLC", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("interf_SLC", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_interf_SLC_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        MLI_1: Path,
        MLI_2: Path,
        interf: Any,
        nrlk: Optional[int] = None,
        nazlk: Optional[int] = None,
        loff: Optional[int] = None,
        nltot: Optional[int] = None,
        rfilt: Optional[int] = None,
        azfilt: Optional[int] = None,
        s_off: Optional[int] = None,
    ) -> None:
        if MLI_1 is not None and str(MLI_1) != "-":
            MLI_1.touch()
        if MLI_2 is not None and str(MLI_2) != "-":
            MLI_2.touch()

    def interf_SLC(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        MLI_1: Path,
        MLI_2: Path,
        interf: Any,
        nrlk: Optional[int] = None,
        nazlk: Optional[int] = None,
        loff: Optional[int] = None,
        nltot: Optional[int] = None,
        rfilt: Optional[int] = None,
        azfilt: Optional[int] = None,
        s_off: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Interferogram generation using a pair of SLC images


        input parameters:
          SLC-1     (input) single-look complex image 1 (reference)
          SLC-2     (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          MLI-1     (output) multi-look intensity image 1
          MLI-2     (output) multi-look intensity image 2
          interf    interferogram from SLC-1 and SLC-2
          nrlk      number of interferogram range looks (default: 2)
          nazlk     number of interferogram azimuth looks (default: 10)
          loff      offset to starting line of interferogram (relative to start of SLC-1) (default: 0)
          nltot     number of SLC lines to process (default: 0, to end of file)
          rfilt     range common band filtering flag
                      0: OFF
                      1: ON (default)
          azfilt    azimuth common band filtering flag
                      0: OFF
                      1: ON (default)
          s_off     offset to the nominal range spectral shift (frac. of range sampling freq.) (default: 0.0)

        NOTE: enter - as filename to avoid creation of corresponding output file

        """
        if self.validate_inputs:
            self._validate_interf_SLC(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                MLI_1,
                MLI_2,
                interf,
                nrlk,
                nazlk,
                loff,
                nltot,
                rfilt,
                azfilt,
                s_off,
            )
        if self.mock_outputs:
            self._mock_interf_SLC_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                MLI_1,
                MLI_2,
                interf,
                nrlk,
                nazlk,
                loff,
                nltot,
                rfilt,
                azfilt,
                s_off,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.interf_SLC))
        return self._gamma_call("ISP", "interf_SLC", supplied_args)

    def _validate_MLI_cat(
        self,
        MLI_1: Path,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        MLI_3: Path,
        MLI3_par: Path,
        dtype: Optional[int] = None,
        mflg: Optional[int] = None,
        overlap: Optional[int] = None,
        interp_mode: Optional[int] = None,
        degree: Optional[Any] = None,
        extrapol: Optional[int] = None,
    ) -> None:
        self._validate("MLI_cat", MLI_1.exists(), f"MLI_1 path does not exist ({MLI_1})")
        self._validate("MLI_cat", MLI_2.exists(), f"MLI_2 path does not exist ({MLI_2})")
        self._validate("MLI_cat", MLI1_par.exists(), f"MLI1_par path does not exist ({MLI1_par})")
        self._validate("MLI_cat", MLI2_par.exists(), f"MLI2_par path does not exist ({MLI2_par})")

    def _mock_MLI_cat_outputs(
        self,
        MLI_1: Path,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        MLI_3: Path,
        MLI3_par: Path,
        dtype: Optional[int] = None,
        mflg: Optional[int] = None,
        overlap: Optional[int] = None,
        interp_mode: Optional[int] = None,
        degree: Optional[Any] = None,
        extrapol: Optional[int] = None,
    ) -> None:
        if MLI_3 is not None and str(MLI_3) != "-":
            MLI_3.touch()
        if MLI3_par is not None and str(MLI3_par) != "-":
            MLI3_par.touch()

    def MLI_cat(
        self,
        MLI_1: Path,
        MLI_2: Path,
        MLI1_par: Path,
        MLI2_par: Path,
        MLI_3: Path,
        MLI3_par: Path,
        dtype: Optional[int] = None,
        mflg: Optional[int] = None,
        overlap: Optional[int] = None,
        interp_mode: Optional[int] = None,
        degree: Optional[Any] = None,
        extrapol: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Concatenate two MLI images using B-spline interpolation


        input parameters:
          MLI-1         (input) MLI-1 image (single-look)
          MLI-2         (input) MLI-2 image to be appended to MLI-1
          MLI1_par      (input) MLI-1 ISP image parameter file
          MLI2_par      (input) MLI-2 ISP image parameter file
          MLI-3         (output) concatenated MLI image
          MLI3_par      (output) ISP image parameter file for concatenated image
          dtype         input/output data type (enter - for default)
                          0: FLOAT (default)
                          1: FCOMPLEX
                        NOTE: FCOMPLEX is for differential interferograms
          mflg          mosaicking option flag (enter - for default)
                          0: in overlapping areas, use MLI-2 data to fill MLI-1 empty areas (default)
                          1: in overlapping areas, do not use MLI-2 data to fill MLI-1 empty areas
          overlap       number of pixels at the edge of MLI-1 valid areas to replace by MLI-2 data (only if mflg=0, enter - for default: 0)
          interp_mode   interpolation mode in case of different geometries (enter - for default)
                          0: B-spline interpolation (default for FCOMPLEX)
                          1: B-spline interpolation sqrt(x) (default for FLOAT)
                        NOTE: sqrt interpolation mode should only be used with non-negative data!
          degree        B-spline degree (2->9) (enter - default: 4)
          extrapol      extrapolation flag (enter - for default)
                          0: do not extrapolate (default)
                          1: extrapolate last line if needed

        """
        if self.validate_inputs:
            self._validate_MLI_cat(
                MLI_1, MLI_2, MLI1_par, MLI2_par, MLI_3, MLI3_par, dtype, mflg, overlap, interp_mode, degree, extrapol
            )
        if self.mock_outputs:
            self._mock_MLI_cat_outputs(
                MLI_1, MLI_2, MLI1_par, MLI2_par, MLI_3, MLI3_par, dtype, mflg, overlap, interp_mode, degree, extrapol
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.MLI_cat))
        return self._gamma_call("ISP", "MLI_cat", supplied_args)

    def _validate_par_RCM_SLC(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise: Any,
        SLC_par: Path,
        SLC: Path,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        self._validate("par_RCM_SLC", RCM_dir.exists(), f"RCM_dir path does not exist ({RCM_dir})")

    def _mock_par_RCM_SLC_outputs(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise: Any,
        SLC_par: Path,
        SLC: Path,
        noise_pwr: Optional[Path] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()
        if noise_pwr is not None and str(noise_pwr) != "-":
            noise_pwr.touch()

    def par_RCM_SLC(
        self,
        RCM_dir: Path,
        polarization: Any,
        radcal: int,
        noise: Any,
        SLC_par: Path,
        SLC: Path,
        noise_pwr: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for Radarsat Constellation SLC data from GeoTIFF or NITF file


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM2_OK1002260_PK1002436_3_SC50MB_20160417_002427_VH_VV_SLC)
          polarization   image polarization: HH, VV, HV, VH, CH, CV
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise          noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          SLC_par        (output) ISP SLC parameter file (example: yyyymmdd_pp.slc.par)
          SLC            (output) SLC data file (example: yyyymmdd_pp.slc)
          noise_pwr      (output) noise intensity for each SLC sample in slant range using data from noise levels file (enter - for none)
                         NOTE: when the noise_pwr file is specified, noise power correction will NOT be applied to the SLC data values

        """
        if self.validate_inputs:
            self._validate_par_RCM_SLC(RCM_dir, polarization, radcal, noise, SLC_par, SLC, noise_pwr)
        if self.mock_outputs:
            self._mock_par_RCM_SLC_outputs(RCM_dir, polarization, radcal, noise, SLC_par, SLC, noise_pwr)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_SLC))
        return self._gamma_call("ISP", "par_RCM_SLC", supplied_args)

    def _validate_par_ESA_PALSAR_GDH(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
    ) -> None:
        self._validate("par_ESA_PALSAR_GDH", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")
        self._validate("par_ESA_PALSAR_GDH", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")

    def _mock_par_ESA_PALSAR_GDH_outputs(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
    ) -> None:
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()
        if MLI is not None and str(MLI) != "-":
            MLI.touch()
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_ESA_PALSAR_GDH(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        MLI_par: Path,
        MLI: Optional[Path] = None,
        GRD_par: Optional[Path] = None,
        GRD: Optional[Path] = None,
        rps: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate MLI and GRD image and parameter files for PALSAR + PALSAR2 level 1.5 GDH data provided by ESA


        input parameters:
          CEOS_data     (input) CEOS image file for PALSAR or PALSAR-2 Level 1.5 GDH data (IMG...)
          CEOS_leader   (input) CEOS leader file for PALSAR or PALSAR-2 Level 1.5 GDH data (LED...)
          MLI_par       (output) MLI parameter file (example: yyyymmdd_pp.mli.par)
          MLI           (output) MLI data file in slant range geometry (example: yyyymmdd_pp.mli, enter - for none)
          GRD_par       (output) GRD parameter file (example: yyyymmdd_pp.grd.par, enter - for none)
          GRD           (output) GRD data file (example: yyyymmdd_pp.grd, enter - for none)
          rps           slant range pixel spacing (m) (enter - for default: calculated from ground-range parameters)

        """
        if self.validate_inputs:
            self._validate_par_ESA_PALSAR_GDH(CEOS_data, CEOS_leader, MLI_par, MLI, GRD_par, GRD, rps)
        if self.mock_outputs:
            self._mock_par_ESA_PALSAR_GDH_outputs(CEOS_data, CEOS_leader, MLI_par, MLI, GRD_par, GRD, rps)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ESA_PALSAR_GDH))
        return self._gamma_call("ISP", "par_ESA_PALSAR_GDH", supplied_args)

    def _validate_phase_slope(
        self,
        interf: Path,
        slopes: Path,
        width: int,
        win_sz: Optional[Any] = None,
        thres: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        self._validate("phase_slope", interf.exists(), f"interf path does not exist ({interf})")

    def _mock_phase_slope_outputs(
        self,
        interf: Path,
        slopes: Path,
        width: int,
        win_sz: Optional[Any] = None,
        thres: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        if slopes is not None and str(slopes) != "-":
            slopes.touch()

    def phase_slope(
        self,
        interf: Path,
        slopes: Path,
        width: int,
        win_sz: Optional[Any] = None,
        thres: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate interferogram phase slopes in range and azimuth


        input parameters:
          interf  (input) interferogram (fcomplex)
          slopes  (output) range and azimuth phase slopes (fcomplex)
          width   number of samples/row
          win_sz  size of region used for slopes determination (default = 5)
          thres   correlation threshold for accepting slope estimates 0.0 -> 1.0 (default=.4)
          xmin    starting range pixel offset (default = 0)
          xmax    last range pixel offset (default = width-1)
          ymin    starting azimuth row offset (default = 0)
          ymax    last azimuth row offset (default = nlines-1)

        """
        if self.validate_inputs:
            self._validate_phase_slope(interf, slopes, width, win_sz, thres, xmin, xmax, ymin, ymax)
        if self.mock_outputs:
            self._mock_phase_slope_outputs(interf, slopes, width, win_sz, thres, xmin, xmax, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.phase_slope))
        return self._gamma_call("ISP", "phase_slope", supplied_args)

    def _validate_par_CSG_SLC(
        self,
    ) -> None:
        pass

    def _mock_par_CSG_SLC_outputs(
        self,
    ) -> None:
        pass

    def par_CSG_SLC(
        self,
    ) -> Tuple[int, str, str]:
        """

        dyld[47034]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_CSG_SLC'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)
        """
        if self.validate_inputs:
            self._validate_par_CSG_SLC()
        if self.mock_outputs:
            self._mock_par_CSG_SLC_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_CSG_SLC))
        return self._gamma_call("ISP", "par_CSG_SLC", supplied_args)

    def _validate_par_TX_ScanSAR(
        self,
        annot_XML: Path,
        swath: Any,
        SLC_par: Path,
        SLC: Path,
        TOPS_par: Path,
        bwflg: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("par_TX_ScanSAR", annot_XML.exists(), f"annot_XML path does not exist ({annot_XML})")

    def _mock_par_TX_ScanSAR_outputs(
        self,
        annot_XML: Path,
        swath: Any,
        SLC_par: Path,
        SLC: Path,
        TOPS_par: Path,
        bwflg: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()
        if TOPS_par is not None and str(TOPS_par) != "-":
            TOPS_par.touch()

    def par_TX_ScanSAR(
        self,
        annot_XML: Path,
        swath: Any,
        SLC_par: Path,
        SLC: Path,
        TOPS_par: Path,
        bwflg: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC, SLC_par and TOPS_par from a Terrasar-X ScanSAR data set


        input parameters:
          annot_XML  (input) TerraSAR-X ScanSAR product annotation XML file including path
                     NOTE: The path to the image products is determined from the path to the XML annotation
          swath      number specifying the desired ScanSAR swath (1 -> maximum number of swaths (4 or 6))
                     NOTE: The image product name is specified in the XML file
          SLC_par    (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC        (output) SLC ScanSAR data file, example: yyyymmdd.slc (enter - for none, SLC output will not be produced)
          TOPS_par   (output) SLC ScanSAR burst annotation file (example: yyyymmdd_s1.slc.tops_par
          bwflg      burst window flag (enter - for default)
                       0: use first and last annotation line values specified in the annot_XML
                       1: extend first and last valid line to include all data lines (default)
          dtype      output data type (enter - for default)
                       0: same as input (default)
                       1: FCOMPLEX
          NOTE: While TSX ScanSAR data are not acquired in TOPS mode, the same data structure can be used for burst annotation

        """
        if self.validate_inputs:
            self._validate_par_TX_ScanSAR(annot_XML, swath, SLC_par, SLC, TOPS_par, bwflg, dtype)
        if self.mock_outputs:
            self._mock_par_TX_ScanSAR_outputs(annot_XML, swath, SLC_par, SLC, TOPS_par, bwflg, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_TX_ScanSAR))
        return self._gamma_call("ISP", "par_TX_ScanSAR", supplied_args)

    def _validate_ave_image(
        self,
        im_list: Path,
        width: int,
        ave_image: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
        nmin: Optional[int] = None,
    ) -> None:
        self._validate("ave_image", im_list.exists(), f"im_list path does not exist ({im_list})")

    def _mock_ave_image_outputs(
        self,
        im_list: Path,
        width: int,
        ave_image: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
        nmin: Optional[int] = None,
    ) -> None:
        if ave_image is not None and str(ave_image) != "-":
            ave_image.touch()

    def ave_image(
        self,
        im_list: Path,
        width: int,
        ave_image: Path,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zflag: Optional[int] = None,
        nmin: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate average of a set of FLOAT images


        input parameters:
          im_list    (input) list of coregistered images (FLOAT)
          width      number of samples/line
          ave_image  (output) average of images listed in im_list (FLOAT)
          start      starting line (enter - for default: 1)
          nlines     number of lines to process (enter - for default: entire file)
          pixav_x    number of pixels to average in width  (enter - for default: 1)
          pixav_y    number of pixels to average in height (enter - for default: 1)
          zflag      zero flag (enter - for default)
                       0: interpret 0.0 as missing data value (default)
                       1: interpret 0.0 as valid data
          nmin       minimum number of images required to calculate the average if zflag = 0 (enter - for default: 3/4*nfiles)

        """
        if self.validate_inputs:
            self._validate_ave_image(im_list, width, ave_image, start, nlines, pixav_x, pixav_y, zflag, nmin)
        if self.mock_outputs:
            self._mock_ave_image_outputs(im_list, width, ave_image, start, nlines, pixav_x, pixav_y, zflag, nmin)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ave_image))
        return self._gamma_call("ISP", "ave_image", supplied_args)

    def _validate_par_STRIX(
        self, CEOS_leader: Path, SLC_par: Path, CEOS_data: Path, SLC: Optional[Path] = None
    ) -> None:
        self._validate("par_STRIX", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_STRIX", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_STRIX_outputs(
        self, CEOS_leader: Path, SLC_par: Path, CEOS_data: Path, SLC: Optional[Path] = None
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_STRIX(
        self, CEOS_leader: Path, SLC_par: Path, CEOS_data: Path, SLC: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for Synspective StriX SLC data


        input parameters:
          CEOS_leader  (input) CEOS leader file for STRIX-alpha SLC data (LED-STRIXA...)
          SLC_par      (output) ISP image parameter file (example: yyyymmdd.slc.par)
          CEOS_data    (input) STRIX-alpha CEOS format SLC (IMG-pp-STRIXA...)
          SLC          (output) reformatted STRIX SLC (example: yyyymmdd.slc, enter - for none)

        """
        if self.validate_inputs:
            self._validate_par_STRIX(CEOS_leader, SLC_par, CEOS_data, SLC)
        if self.mock_outputs:
            self._mock_par_STRIX_outputs(CEOS_leader, SLC_par, CEOS_data, SLC)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_STRIX))
        return self._gamma_call("ISP", "par_STRIX", supplied_args)

    def _validate_ASAR_LO_phase_drift(self, SLC1_par: Path, SLC2_par: Path, OFF_par: Path, ph_drift: Path) -> None:
        self._validate("ASAR_LO_phase_drift", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("ASAR_LO_phase_drift", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("ASAR_LO_phase_drift", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_ASAR_LO_phase_drift_outputs(self, SLC1_par: Path, SLC2_par: Path, OFF_par: Path, ph_drift: Path) -> None:
        if ph_drift is not None and str(ph_drift) != "-":
            ph_drift.touch()

    def ASAR_LO_phase_drift(
        self, SLC1_par: Path, SLC2_par: Path, OFF_par: Path, ph_drift: Path
    ) -> Tuple[int, str, str]:
        """

        Calculate interferometric phase correction due to drift of the ASAR local oscillator


        input parameters:
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          ph_drift  (output) interferometric phase correction due to drift of the ASAR LO (radians)
        """
        if self.validate_inputs:
            self._validate_ASAR_LO_phase_drift(SLC1_par, SLC2_par, OFF_par, ph_drift)
        if self.mock_outputs:
            self._mock_ASAR_LO_phase_drift_outputs(SLC1_par, SLC2_par, OFF_par, ph_drift)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ASAR_LO_phase_drift))
        return self._gamma_call("ISP", "ASAR_LO_phase_drift", supplied_args)

    def _validate_radcal_pwr_stat(
        self,
        SLC_tab: Path,
        SLC_tab_cal: Path,
        plist: Path,
        MSR_cal: Any,
        PWR_cal: Any,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        plist_out: Optional[Any] = None,
    ) -> None:
        self._validate("radcal_pwr_stat", SLC_tab.exists(), f"SLC_tab path does not exist ({SLC_tab})")
        self._validate("radcal_pwr_stat", SLC_tab_cal.exists(), f"SLC_tab_cal path does not exist ({SLC_tab_cal})")
        self._validate("radcal_pwr_stat", plist.exists(), f"plist path does not exist ({plist})")

    def _mock_radcal_pwr_stat_outputs(
        self,
        SLC_tab: Path,
        SLC_tab_cal: Path,
        plist: Path,
        MSR_cal: Any,
        PWR_cal: Any,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        plist_out: Optional[Any] = None,
    ) -> None:
        pass

    def radcal_pwr_stat(
        self,
        SLC_tab: Path,
        SLC_tab_cal: Path,
        plist: Path,
        MSR_cal: Any,
        PWR_cal: Any,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        plist_out: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate calibrated SLC image files using point targets determined from the Mean/Sigma Ratio and Intensity


        input parameters:
          SLC_tab      (input) two column list of the SLC filenames and SLC parameter filenames of the uncalibrated SLC images
          SLC_tab_cal  (input) two column list of the SLC filenames and SLC parameter filenames of the calibrated SLC images (enter - for none)
          plist        (input) point list for the point to use for calibraton (int, enter - to use the data to determine the calibration points)
          MSR_cal      mean/sigma ratio for point target selection for relative calibration between scenes:    1.500
          PWR_cal      intensity threshold ratio for point target selection for relative calibration between scenes:    1.000
          roff         offset to starting range of section to analyze (default -: 0)
          loff         offset to starting line of section to analyze (default -: 0)
          nr           number of range pixels to analyze (default -: to end of line)
          nl           number of azimuth lines to analyze (default -: to end of file)
          plist_out    point list of points used to determine calibration using MSR_cal and PWR_cal thresholds
        """
        if self.validate_inputs:
            self._validate_radcal_pwr_stat(SLC_tab, SLC_tab_cal, plist, MSR_cal, PWR_cal, roff, loff, nr, nl, plist_out)
        if self.mock_outputs:
            self._mock_radcal_pwr_stat_outputs(
                SLC_tab, SLC_tab_cal, plist, MSR_cal, PWR_cal, roff, loff, nr, nl, plist_out
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.radcal_pwr_stat))
        return self._gamma_call("ISP", "radcal_pwr_stat", supplied_args)

    def _validate_par_ICEYE_SLC(
        self,
    ) -> None:
        pass

    def _mock_par_ICEYE_SLC_outputs(
        self,
    ) -> None:
        pass

    def par_ICEYE_SLC(
        self,
    ) -> Tuple[int, str, str]:
        """

        dyld[47062]: Library not loaded: '/opt/local/lib/libhdf5.200.dylib'
          Referenced from: '/Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/ISP/bin/par_ICEYE_SLC'
          Reason: tried: '/opt/local/lib/libhdf5.200.dylib' (no such file), '/usr/local/lib/libhdf5.200.dylib' (no such file), '/usr/lib/libhdf5.200.dylib' (no such file)
        """
        if self.validate_inputs:
            self._validate_par_ICEYE_SLC()
        if self.mock_outputs:
            self._mock_par_ICEYE_SLC_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ICEYE_SLC))
        return self._gamma_call("ISP", "par_ICEYE_SLC", supplied_args)

    def _validate_offset_SLC_tracking(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rsw: Optional[Any] = None,
        azsw: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[Any] = None,
        rstop: Optional[Any] = None,
        azstart: Optional[Any] = None,
        azstop: Optional[Any] = None,
        ISZ: Optional[Any] = None,
        pflag: Optional[int] = None,
    ) -> None:
        self._validate("offset_SLC_tracking", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("offset_SLC_tracking", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("offset_SLC_tracking", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("offset_SLC_tracking", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("offset_SLC_tracking", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_offset_SLC_tracking_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rsw: Optional[Any] = None,
        azsw: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[Any] = None,
        rstop: Optional[Any] = None,
        azstart: Optional[Any] = None,
        azstop: Optional[Any] = None,
        ISZ: Optional[Any] = None,
        pflag: Optional[int] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if snr is not None and str(snr) != "-":
            snr.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()

    def offset_SLC_tracking(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        snr: Path,
        rsw: Optional[Any] = None,
        azsw: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        thres: Optional[Any] = None,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[Any] = None,
        rstop: Optional[Any] = None,
        azstart: Optional[Any] = None,
        azstop: Optional[Any] = None,
        ISZ: Optional[Any] = None,
        pflag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Offset tracking between SLC images using fringe visibility


        input parameters:
          SLC-1     (input) single-look complex image 1 (reference)
          SLC-2     (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates (fcomplex)
          snr       (output) offset estimation SNR (float)
          rsw       range search window size (range pixels) (enter - for default from offset parameter file)
          azsw      azimuth search window size (azimuth lines) (enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and SNR data in text format, enter - for no output
          n_ovr     SLC over-sampling factor (integer 2**N (1,2,4) default: 2)
          thres     offset estimation quality threshold (enter - for default from offset parameter file)
          rstep     step in range pixels (enter - for default: rsw/2)
          azstep    step in azimuth pixels (enter - for default: azsw/2)
          rstart    starting range pixel (enter - for default: rsw/2)
          rstop     ending range pixel (enter - for default: nr - rsw/2)
          azstart   starting azimuth line (enter - for default: azsw/2)
          azstop    ending azimuth line  (enter - for default: nlines - azsw/2)
          ISZ       search chip interferogram size (in non-oversampled pixels, default: 16)
          pflag     print flag:
                      0: print offset summary  (default)
                      1: print all offset data
        """
        if self.validate_inputs:
            self._validate_offset_SLC_tracking(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                snr,
                rsw,
                azsw,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                ISZ,
                pflag,
            )
        if self.mock_outputs:
            self._mock_offset_SLC_tracking_outputs(
                SLC_1,
                SLC_2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                snr,
                rsw,
                azsw,
                offsets,
                n_ovr,
                thres,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                ISZ,
                pflag,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_SLC_tracking))
        return self._gamma_call("ISP", "offset_SLC_tracking", supplied_args)

    def _validate_tree_cc(
        self,
        flag: Path,
        width: int,
        mbl: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        self._validate("tree_cc", flag.exists(), f"flag path does not exist ({flag})")

    def _mock_tree_cc_outputs(
        self,
        flag: Path,
        width: int,
        mbl: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        pass

    def tree_cc(
        self,
        flag: Path,
        width: int,
        mbl: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Phase unwrapping tree generation with low correlation search (modified ARW algorithm)


        input parameters:
          flag   (input) phase unwrapping flag file
          width  number of samples/row
          mbl    maximum branch length (default=32, maximum=64)
          xmin   starting range pixel offset (default = 0)
          xmax   last range pixel offset (default = width-1)
          ymin   starting azimuth row, relative to start (default = 0)
          ymax   last azimuth row, relative to start (default = nlines-1)

        """
        if self.validate_inputs:
            self._validate_tree_cc(flag, width, mbl, xmin, xmax, ymin, ymax)
        if self.mock_outputs:
            self._mock_tree_cc_outputs(flag, width, mbl, xmin, xmax, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.tree_cc))
        return self._gamma_call("ISP", "tree_cc", supplied_args)

    def _validate_MLI_copy(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        self._validate("MLI_copy", MLI_in.exists(), f"MLI_in path does not exist ({MLI_in})")
        self._validate("MLI_copy", MLI_in_par.exists(), f"MLI_in_par path does not exist ({MLI_in_par})")

    def _mock_MLI_copy_outputs(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> None:
        if MLI_out is not None and str(MLI_out) != "-":
            MLI_out.touch()
        if MLI_out_par is not None and str(MLI_out_par) != "-":
            MLI_out_par.touch()

    def MLI_copy(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Copy MLI data file with options for segment extraction


        input parameters:
          MLI_in       (input) multi-look intensity image (float format)
          MLI_in_par   (input) ISP image parameter file for input MLI
          MLI_out      (output) selected MLI section (float format)
          MLI_out_par  (output) ISP image parameter file for output MLI
          roff         offset to starting range sample (enter - for default: 0)
          nr           number of range samples (enter - for default: to end of line
          loff         offset to starting line (enter - for default: 0)
          nl           number of lines to copy (enter - for default: to end of file)
        """
        if self.validate_inputs:
            self._validate_MLI_copy(MLI_in, MLI_in_par, MLI_out, MLI_out_par, roff, nr, loff, nl)
        if self.mock_outputs:
            self._mock_MLI_copy_outputs(MLI_in, MLI_in_par, MLI_out, MLI_out_par, roff, nr, loff, nl)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.MLI_copy))
        return self._gamma_call("ISP", "MLI_copy", supplied_args)

    def _validate_par_RCM_MLC(self, RCM_dir: Path, radcal: int, noise: Any, root_name: Path) -> None:
        self._validate("par_RCM_MLC", RCM_dir.exists(), f"RCM_dir path does not exist ({RCM_dir})")

    def _mock_par_RCM_MLC_outputs(self, RCM_dir: Path, radcal: int, noise: Any, root_name: Path) -> None:
        if root_name is not None and str(root_name) != "-":
            root_name.touch()

    def par_RCM_MLC(self, RCM_dir: Path, radcal: int, noise: Any, root_name: Path) -> Tuple[int, str, str]:
        """

        Generate parameter and image files for Radarsat Constellation MLC (Multi-Look Complex) data from GeoTIFF or NITF format


        input parameters:
          RCM_dir        (input) Radarsat Constellation main directory path (e.g.: RCM2_OK1782060_PK1782073_2_SC30MCPC_20200504_105537_CH_CV_MLC)
          radcal         radiometric calibration flag (enter - for default)
                           0: none (default)
                           1: Beta Nought
                           2: Sigma Nought
                           3: Gamma
          noise          noise levels flag (enter - for default)
                           0: do not use noise levels file (default)
                           1: use noise levels file
                         NOTE: noise levels file can only be used for radiometrically calibrated data (radcal flag: 1, 2, or 3)
          root_name      (output) root name of the generated output files (example: yyyymmdd)
                         NOTE: the program will automatically complete the root_name and add extensions for each covariance matrix element
                               for both data and parameter files, such as 20210927_CH.mlc, 20210927_CH.mlc.par, 20210927_XC.mlc, etc.

        """
        if self.validate_inputs:
            self._validate_par_RCM_MLC(RCM_dir, radcal, noise, root_name)
        if self.mock_outputs:
            self._mock_par_RCM_MLC_outputs(RCM_dir, radcal, noise, root_name)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RCM_MLC))
        return self._gamma_call("ISP", "par_RCM_MLC", supplied_args)

    def _validate_ORRM_vec(self, SLC_par: Path, ORRM: Path, nstate: Optional[int] = None) -> None:
        self._validate("ORRM_vec", ORRM.exists(), f"ORRM path does not exist ({ORRM})")

    def _mock_ORRM_vec_outputs(self, SLC_par: Path, ORRM: Path, nstate: Optional[int] = None) -> None:
        if not SLC_par.exists():
            SLC_par.touch()

    def ORRM_vec(self, SLC_par: Path, ORRM: Path, nstate: Optional[int] = None) -> Tuple[int, str, str]:
        """

        Calculate state vectors extraction from ORRM file


        input parameters:
          SLC_par  (input/output) ISP SLC/MLI image parameter file
          ORRM     (input) ORRM state vector file
          nstate   number of state vectors (default=5, maximum=1024)

        """
        if self.validate_inputs:
            self._validate_ORRM_vec(SLC_par, ORRM, nstate)
        if self.mock_outputs:
            self._mock_ORRM_vec_outputs(SLC_par, ORRM, nstate)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ORRM_vec))
        return self._gamma_call("ISP", "ORRM_vec", supplied_args)

    def _validate_SLC_ovr(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_ovr: Path,
        SLC_ovr_par: Path,
        r_ovr: Optional[Any] = None,
        az_ovr: Optional[Any] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> None:
        self._validate("SLC_ovr", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("SLC_ovr", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_SLC_ovr_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_ovr: Path,
        SLC_ovr_par: Path,
        r_ovr: Optional[Any] = None,
        az_ovr: Optional[Any] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> None:
        if SLC_ovr is not None and str(SLC_ovr) != "-":
            SLC_ovr.touch()
        if SLC_ovr_par is not None and str(SLC_ovr_par) != "-":
            SLC_ovr_par.touch()

    def SLC_ovr(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_ovr: Path,
        SLC_ovr_par: Path,
        r_ovr: Optional[Any] = None,
        az_ovr: Optional[Any] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
        deramp: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Oversample SLC data in range and azimuth using 2-D Lanczos or B-spline interpolation


        input parameters:
          SLC          (input) SLC image  (FCOMPLEX or SCOMPLEX format)
          SLC_par      (input) SLC image parameter file
          SLC_ovr      (output) oversampled SLC image
          SLC_ovr_par  (output) oversampled SLC image parameter file
          r_ovr        range oversampling factor (enter - for default: 1.0)
          az_ovr       azimuth oversampling factor (enter - for default: 1.0)
          mode         interpolation mode (enter - for default)
                         0: Lanczos interpolation (default)
                         1: B-spline interpolation
          order        Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)
          deramp       deramp flag (enter - for default)
                         0: do not deramp and reramp data
                         1: deramp data before interpolation and reramp afterwards (default)

        """
        if self.validate_inputs:
            self._validate_SLC_ovr(SLC, SLC_par, SLC_ovr, SLC_ovr_par, r_ovr, az_ovr, mode, order, deramp)
        if self.mock_outputs:
            self._mock_SLC_ovr_outputs(SLC, SLC_par, SLC_ovr, SLC_ovr_par, r_ovr, az_ovr, mode, order, deramp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_ovr))
        return self._gamma_call("ISP", "SLC_ovr", supplied_args)

    def _validate_tree_gzw(
        self,
        flag: Path,
        width: int,
        mbl: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        self._validate("tree_gzw", flag.exists(), f"flag path does not exist ({flag})")

    def _mock_tree_gzw_outputs(
        self,
        flag: Path,
        width: int,
        mbl: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        pass

    def tree_gzw(
        self,
        flag: Path,
        width: int,
        mbl: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Phase unwrapping tree generation (GZW algorithm)


        input parameters:
          flag   (input) phase unwrapping flag file
          width  number of samples/row
          mbl    maximum branch length (default=32)
          xmin   starting range pixel offset (default = 0)
          xmax   last range pixel offset (default = width-1)
          ymin   starting azimuth row, relative to start (default = 0)
          ymax   last azimuth row, relative to start (default = nlines-1)

        """
        if self.validate_inputs:
            self._validate_tree_gzw(flag, width, mbl, xmin, xmax, ymin, ymax)
        if self.mock_outputs:
            self._mock_tree_gzw_outputs(flag, width, mbl, xmin, xmax, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.tree_gzw))
        return self._gamma_call("ISP", "tree_gzw", supplied_args)

    def _validate_mcf(
        self,
        interf: Path,
        wgt: Path,
        mask: Path,
        unw: Path,
        width: int,
        tri_mode: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nlines: Optional[int] = None,
        npat_r: Optional[int] = None,
        npat_az: Optional[int] = None,
        ovrlap: Optional[int] = None,
        r_init: Optional[Any] = None,
        az_init: Optional[Any] = None,
        init_flag: Optional[int] = None,
    ) -> None:
        self._validate("mcf", interf.exists(), f"interf path does not exist ({interf})")
        self._validate("mcf", wgt.exists(), f"wgt path does not exist ({wgt})")
        self._validate("mcf", mask.exists(), f"mask path does not exist ({mask})")

    def _mock_mcf_outputs(
        self,
        interf: Path,
        wgt: Path,
        mask: Path,
        unw: Path,
        width: int,
        tri_mode: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nlines: Optional[int] = None,
        npat_r: Optional[int] = None,
        npat_az: Optional[int] = None,
        ovrlap: Optional[int] = None,
        r_init: Optional[Any] = None,
        az_init: Optional[Any] = None,
        init_flag: Optional[int] = None,
    ) -> None:
        if unw is not None and str(unw) != "-":
            unw.touch()

    def mcf(
        self,
        interf: Path,
        wgt: Path,
        mask: Path,
        unw: Path,
        width: int,
        tri_mode: Optional[int] = None,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nlines: Optional[int] = None,
        npat_r: Optional[int] = None,
        npat_az: Optional[int] = None,
        ovrlap: Optional[int] = None,
        r_init: Optional[Any] = None,
        az_init: Optional[Any] = None,
        init_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Phase unwrapping using Minimum Cost Flow (MCF) on a triangular mesh


        input parameters:
          interf     (input) interferogram (*.int,*.diff,*.flt) (FCOMPLEX)
          wgt        (input) weight factors (0 -> 1.0, e.g. coherence map) file (FLOAT) (enter - for uniform weights)
          mask       (input) validity mask (SUN/BMP/TIFF raster format, value 0 -> pixel not used) (enter - if no mask)
          unw        (output) unwrapped phase image (*.unw) (FLOAT)
          width      number of samples/row
          tri_mode   triangulation mode (enter - for default)
                       0: filled triangular mesh
                       1: Delaunay triangulation
                       2: filled triangular mesh, replacing gaps with noise (default)
                       3: filled triangular mesh, replacing gaps and outside boundary with noise
          roff       offset to starting range of section to unwrap (enter - for default: 0)
          loff       offset to starting line of section to unwrap (enter - for default: 0)
          nr         number of range samples of section to unwrap (enter - for default: width - roff)
          nlines     number of lines of section to unwrap (enter - for default: total number of lines - loff)
          npat_r     number of patches in range (enter - for default: 1, enter 0 to automatically define number of patches)
          npat_az    number of patches in azimuth (enter - for default: 1, enter 0 to automatically define number of patches)
          ovrlap     overlap between patches in pixels (overlap >= 7, enter - for default: 1024)
          r_init     phase reference point range offset (enter - for default: center of valid data bounding box)
          az_init    phase reference point azimuth offset (enter - for default: center of valid data bounding box)
          init_flag  flag to set phase at reference point (enter - for default)
                       0: use initial point phase value (default)
                       1: set phase to 0.0 at initial point

        """
        if self.validate_inputs:
            self._validate_mcf(
                interf,
                wgt,
                mask,
                unw,
                width,
                tri_mode,
                roff,
                loff,
                nr,
                nlines,
                npat_r,
                npat_az,
                ovrlap,
                r_init,
                az_init,
                init_flag,
            )
        if self.mock_outputs:
            self._mock_mcf_outputs(
                interf,
                wgt,
                mask,
                unw,
                width,
                tri_mode,
                roff,
                loff,
                nr,
                nlines,
                npat_r,
                npat_az,
                ovrlap,
                r_init,
                az_init,
                init_flag,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mcf))
        return self._gamma_call("ISP", "mcf", supplied_args)

    def _validate_par_ESA_ERS(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_DAT: Optional[Path] = None, SLC: Optional[Path] = None
    ) -> None:
        self._validate(
            "par_ESA_ERS", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )
        if CEOS_DAT is not None:
            self._validate("par_ESA_ERS", CEOS_DAT.exists(), f"CEOS_DAT path does not exist ({CEOS_DAT})")

    def _mock_par_ESA_ERS_outputs(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_DAT: Optional[Path] = None, SLC: Optional[Path] = None
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_ESA_ERS(
        self, CEOS_SAR_leader: Path, SLC_par: Path, CEOS_DAT: Optional[Path] = None, SLC: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        ISP parameter file generation for ERS SLC data from the PGS, VMP, and SPF processors


        input parameters:
        CEOS_SAR_leader  (input) ERS CEOS SAR leader file
        SLC_par          (output) ISP SLC parameter file (example: <date>.slc.par)
        CEOS_DAT         (input) CEOS data file (example: DAT_01.001)
        SLC              (output) SLC data with file and line headers removed (example: <date>.slc)

        """
        if self.validate_inputs:
            self._validate_par_ESA_ERS(CEOS_SAR_leader, SLC_par, CEOS_DAT, SLC)
        if self.mock_outputs:
            self._mock_par_ESA_ERS_outputs(CEOS_SAR_leader, SLC_par, CEOS_DAT, SLC)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ESA_ERS))
        return self._gamma_call("ISP", "par_ESA_ERS", supplied_args)

    def _validate_offset_pwr_tracking_polygons(
        self,
        SLC_par: Path,
        OFF_par: Path,
        rlks: Any,
        azlks: Any,
        rwin: Any,
        azwin: Any,
        polygons: Path,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        rb: Optional[Any] = None,
        azb: Optional[Any] = None,
    ) -> None:
        self._validate("offset_pwr_tracking_polygons", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_offset_pwr_tracking_polygons_outputs(
        self,
        SLC_par: Path,
        OFF_par: Path,
        rlks: Any,
        azlks: Any,
        rwin: Any,
        azwin: Any,
        polygons: Path,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        rb: Optional[Any] = None,
        azb: Optional[Any] = None,
    ) -> None:
        if not OFF_par.exists():
            OFF_par.touch()
        if polygons is not None and str(polygons) != "-":
            polygons.touch()

    def offset_pwr_tracking_polygons(
        self,
        SLC_par: Path,
        OFF_par: Path,
        rlks: Any,
        azlks: Any,
        rwin: Any,
        azwin: Any,
        polygons: Path,
        rstep: Optional[Any] = None,
        azstep: Optional[Any] = None,
        rstart: Optional[int] = None,
        rstop: Optional[int] = None,
        azstart: Optional[int] = None,
        azstop: Optional[int] = None,
        rb: Optional[Any] = None,
        azb: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Offset tracking polygon calculation in MLI coordinates


        input parameters:
          SLC_par   (input) reference SLC ISP image parameter file
          OFF_par   (input/output) ISP offset/interferogram parameter file
          rlks      range decimation factor for MLI geometry  (enter - for default: 1)
          azlks     azimuth decimation factor for the MLI geometry (enter - for default: 1)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          polygons  (output) polygon vertices in text format
          rstep     step in range pixels (enter - for default: rwin/2)
          azstep    step in azimuth pixels (enter - for default: azwin/2)
          rstart    offset to starting range pixel (enter - for default: 0)
          rstop     offset to ending range pixel (enter - for default: nr-1)
          azstart   offset to starting azimuth line (enter - for default: 0)
          azstop    offset to ending azimuth line (enter - for default: nlines-1)
          rb        polygon range border in MLI samples: (enter - for default: 7)
          azb       polygon azimuth border in MLI lines: (enter - for default: 7)

        """
        if self.validate_inputs:
            self._validate_offset_pwr_tracking_polygons(
                SLC_par,
                OFF_par,
                rlks,
                azlks,
                rwin,
                azwin,
                polygons,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                rb,
                azb,
            )
        if self.mock_outputs:
            self._mock_offset_pwr_tracking_polygons_outputs(
                SLC_par,
                OFF_par,
                rlks,
                azlks,
                rwin,
                azwin,
                polygons,
                rstep,
                azstep,
                rstart,
                rstop,
                azstart,
                azstop,
                rb,
                azb,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr_tracking_polygons))
        return self._gamma_call("ISP", "offset_pwr_tracking_polygons", supplied_args)

    def _validate_SLC_interp(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        self._validate("SLC_interp", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("SLC_interp", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("SLC_interp", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("SLC_interp", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_SLC_interp_outputs(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        if SLC_2R is not None and str(SLC_2R) != "-":
            SLC_2R.touch()
        if SLC2R_par is not None and str(SLC2R_par) != "-":
            SLC2R_par.touch()

    def SLC_interp(
        self,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_2R: Path,
        SLC2R_par: Path,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        mode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        SLC complex image resampling using 2-D Lanczos or B-spline interpolation


        input parameters:
          SLC-2      (input) SLC-2 image to be resampled to the geometry of the SLC-1 reference image
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2_par   (input) SLC-2 ISP image parameter file
          OFF_par    (input) ISP offset/interferogram parameter file
          SLC-2R     (output) single-look complex image 2 coregistered to SLC-1
          SLC2R_par  (output) SLC-2R ISP image parameter file for coregistered image
          loff       offset to first valid output line (in SLC-1 lines) (enter - for default: 0)
          nlines     number of valid output lines (enter - or 0 for default: to end of file)
          mode       interpolation mode (enter - for default)
                       0: Lanczos (default)
                       1: B-spline
          order      Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)

        """
        if self.validate_inputs:
            self._validate_SLC_interp(SLC_2, SLC1_par, SLC2_par, OFF_par, SLC_2R, SLC2R_par, loff, nlines, mode, order)
        if self.mock_outputs:
            self._mock_SLC_interp_outputs(
                SLC_2, SLC1_par, SLC2_par, OFF_par, SLC_2R, SLC2R_par, loff, nlines, mode, order
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_interp))
        return self._gamma_call("ISP", "SLC_interp", supplied_args)

    def _validate_par_S1_SLC(
        self,
        GeoTIFF: Path,
        annotation_XML: Path,
        calibration_XML: Path,
        noise_XML: Path,
        SLC_par: Path,
        SLC: Path,
        TOPS_par: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[Any] = None,
        noise_pwr: Optional[Any] = None,
    ) -> None:
        self._validate("par_S1_SLC", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_S1_SLC", annotation_XML.exists(), f"annotation_XML path does not exist ({annotation_XML})")
        self._validate(
            "par_S1_SLC", calibration_XML.exists(), f"calibration_XML path does not exist ({calibration_XML})"
        )
        self._validate("par_S1_SLC", noise_XML.exists(), f"noise_XML path does not exist ({noise_XML})")

    def _mock_par_S1_SLC_outputs(
        self,
        GeoTIFF: Path,
        annotation_XML: Path,
        calibration_XML: Path,
        noise_XML: Path,
        SLC_par: Path,
        SLC: Path,
        TOPS_par: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[Any] = None,
        noise_pwr: Optional[Any] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()
        if TOPS_par is not None and str(TOPS_par) != "-":
            TOPS_par.touch()

    def par_S1_SLC(
        self,
        GeoTIFF: Path,
        annotation_XML: Path,
        calibration_XML: Path,
        noise_XML: Path,
        SLC_par: Path,
        SLC: Path,
        TOPS_par: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[Any] = None,
        noise_pwr: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for Sentinel-1 SLC data


        input parameters:
          GeoTIFF         (input) image data file in GeoTIFF format (enter - for none, *.tiff)
          annotation_XML  (input) Sentinel-1 L1 XML annotation file
          calibration_XML (input) Sentinel-1 L1 radiometric calibration XML file (enter - for no radiometric calibration)
          noise_XML       (input) Sentinel-1 L1 noise XML file (enter - to not subtract thermal noise power level)
          SLC_par         (output) ISP SLC parameter file (example: yyyymmdd_iw1_vv.slc.par)
          SLC             (output) SLC data file (enter - for none, example: yyyymmdd_iw1_vv.slc)
          TOPS_par        (output) SLC burst annotation file, TOPS and EW SLC data only (enter - for none, example: yyyymmdd_iw1_vv.slc.tops_par)
          dtype           output data type (enter - for default)
                            0: FCOMPLEX (default)
                            1: SCOMPLEX
          sc_dB           scale factor for FCOMPLEX -> SCOMPLEX, (enter - for default: HH,VV (dB): 60.0000,  VH,HV: 70.0000)
          noise_pwr       noise intensity for each SLC sample in slant range using data from noise_XML (enter - for none)
                          NOTE: when the noise_pwr file is specified, noise power will NOT be subtracted from the image data values

        """
        if self.validate_inputs:
            self._validate_par_S1_SLC(
                GeoTIFF, annotation_XML, calibration_XML, noise_XML, SLC_par, SLC, TOPS_par, dtype, sc_dB, noise_pwr
            )
        if self.mock_outputs:
            self._mock_par_S1_SLC_outputs(
                GeoTIFF, annotation_XML, calibration_XML, noise_XML, SLC_par, SLC, TOPS_par, dtype, sc_dB, noise_pwr
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_S1_SLC))
        return self._gamma_call("ISP", "par_S1_SLC", supplied_args)

    def _validate_par_ASAR(self, ASAR_or_ERS_file: Path, output_name: Path, K_dB: Optional[Any] = None) -> None:
        self._validate(
            "par_ASAR", ASAR_or_ERS_file.exists(), f"ASAR_or_ERS_file path does not exist ({ASAR_or_ERS_file})"
        )

    def _mock_par_ASAR_outputs(self, ASAR_or_ERS_file: Path, output_name: Path, K_dB: Optional[Any] = None) -> None:
        if output_name is not None and str(output_name) != "-":
            output_name.touch()

    def par_ASAR(self, ASAR_or_ERS_file: Path, output_name: Path, K_dB: Optional[Any] = None) -> Tuple[int, str, str]:
        """

        Extract SLC/MLI image parameters and images from ENVISAT ASAR SLC, WSS, APP, and PRI products


        input parameters:
          ASAR/ERS_file  (input) ASAR or ERS data in ASAR format (SAR_IMS_1P) including header and image as provided by ESA
          output_name    (output) common part of output file names (e.g. YYYMMDD date)
          K_dB           Calibration factor in dB (nominal value for all ASAR modes: 55.0)
                         NOTE: Use - to use the calibration factor provided in the ASAR file header

          NOTE: In the case that a calibration factor is specified on the command line, PRI images are converted
          to radiometrically calibrated ground-range intensity images in float format
        """
        if self.validate_inputs:
            self._validate_par_ASAR(ASAR_or_ERS_file, output_name, K_dB)
        if self.mock_outputs:
            self._mock_par_ASAR_outputs(ASAR_or_ERS_file, output_name, K_dB)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASAR))
        return self._gamma_call("ISP", "par_ASAR", supplied_args)

    def _validate_par_ASF_96(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        self._validate(
            "par_ASF_96", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_par_ASF_96_outputs(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ASF_96(self, CEOS_SAR_leader: Path, SLC_par: Path) -> Tuple[int, str, str]:
        """

        ISP parameter file for ASF data 1996-->present v1.1


        input parameters:
        CEOS_SAR_leader  (input) CEOS SAR leader file
        SLC_par          (output) ISP SLC parameter file (example <orbit>.slc.par)
        """
        if self.validate_inputs:
            self._validate_par_ASF_96(CEOS_SAR_leader, SLC_par)
        if self.mock_outputs:
            self._mock_par_ASF_96_outputs(CEOS_SAR_leader, SLC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_96))
        return self._gamma_call("ISP", "par_ASF_96", supplied_args)

    def _validate_ScanSAR_mosaic_to_burst(self, DATA: Path, MLI_par: Path, DATA_tab: Any) -> None:
        self._validate("ScanSAR_mosaic_to_burst", DATA.exists(), f"DATA path does not exist ({DATA})")

    def _mock_ScanSAR_mosaic_to_burst_outputs(self, DATA: Path, MLI_par: Path, DATA_tab: Any) -> None:
        pass

    def ScanSAR_mosaic_to_burst(self, DATA: Path, MLI_par: Path, DATA_tab: Any) -> Tuple[int, str, str]:
        """

        Resample image data in the MLI mosaic geometry to burst MLI geometry (FLOAT or FCOMPLEX)


        input parameters:
          DATA      (input) data in mosaic geometry (FLOAT or FCOMPLEX data type)
          MLI_par   image parameter file in mosaic geometry
          DATA_tab  3 column list of the output data in burst geometry, swaths are in order from near to far range
                      MLI_tab line entries:  DATA   MLI_par  TOPS_par
                    NOTE: 1.The burst MLI_par and TOPS_par files describing the output geometry must already exist
                          2.The data type (FLOAT or FCOMPLEX) specified in the MLI_par and the burst parameters (TOPS_par) must agree

        """
        if self.validate_inputs:
            self._validate_ScanSAR_mosaic_to_burst(DATA, MLI_par, DATA_tab)
        if self.mock_outputs:
            self._mock_ScanSAR_mosaic_to_burst_outputs(DATA, MLI_par, DATA_tab)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ScanSAR_mosaic_to_burst))
        return self._gamma_call("ISP", "ScanSAR_mosaic_to_burst", supplied_args)

    def _validate_base_ls(
        self,
        SLC_par: Path,
        OFF_par: Path,
        gcp_ph: Path,
        baseline: Path,
        ph_flag: Optional[Any] = None,
        bc_flag: Optional[Any] = None,
        bn_flag: Optional[Any] = None,
        bcdot_flag: Optional[Any] = None,
        bndot_flag: Optional[Any] = None,
        bperp_min: Optional[Any] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> None:
        self._validate("base_ls", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("base_ls", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")
        self._validate("base_ls", gcp_ph.exists(), f"gcp_ph path does not exist ({gcp_ph})")
        self._validate("base_ls", baseline.exists(), f"baseline path does not exist ({baseline})")
        if SLC2R_par is not None:
            self._validate("base_ls", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")

    def _mock_base_ls_outputs(
        self,
        SLC_par: Path,
        OFF_par: Path,
        gcp_ph: Path,
        baseline: Path,
        ph_flag: Optional[Any] = None,
        bc_flag: Optional[Any] = None,
        bn_flag: Optional[Any] = None,
        bcdot_flag: Optional[Any] = None,
        bndot_flag: Optional[Any] = None,
        bperp_min: Optional[Any] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> None:
        pass

    def base_ls(
        self,
        SLC_par: Path,
        OFF_par: Path,
        gcp_ph: Path,
        baseline: Path,
        ph_flag: Optional[Any] = None,
        bc_flag: Optional[Any] = None,
        bn_flag: Optional[Any] = None,
        bcdot_flag: Optional[Any] = None,
        bndot_flag: Optional[Any] = None,
        bperp_min: Optional[Any] = None,
        SLC2R_par: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Least squares baseline estimation using terrain heights


        input parameters:
          SLC_par     (input) ISP parameter file of the reference SLC
          OFF_par     (input) ISP interferogram/offset parameter file
          gcp_ph      (input) ground control point heights + extracted unwrapped phase (text format)
          baseline    (input) baseline parameter file
          ph_flag     restore range phase ramp (default=0: do not restore  1: restore)
          bc_flag     cross-track baseline component estimate (0:orbit derived  1:estimate from data, default=1)
          bn_flag     normal baseline component estimate      (0:orbit derived  1:estimate from data, default=1)
          bcdot_flag  cross-track baseline rate estimate      (0:orbit derived  1:estimate from data, default=1)
          bndot_flag  normal baseline rate estimate           (0:orbit derived  1:estimate from data, default=0)
          bperp_min   minimum perpendicular baseline required for L.S estimation (m, default=  10.0)
          SLC2R_par   (input) parameter file of resampled SLC, required if SLC-2 frequency differs from SLC-1

        """
        if self.validate_inputs:
            self._validate_base_ls(
                SLC_par,
                OFF_par,
                gcp_ph,
                baseline,
                ph_flag,
                bc_flag,
                bn_flag,
                bcdot_flag,
                bndot_flag,
                bperp_min,
                SLC2R_par,
            )
        if self.mock_outputs:
            self._mock_base_ls_outputs(
                SLC_par,
                OFF_par,
                gcp_ph,
                baseline,
                ph_flag,
                bc_flag,
                bn_flag,
                bcdot_flag,
                bndot_flag,
                bperp_min,
                SLC2R_par,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.base_ls))
        return self._gamma_call("ISP", "base_ls", supplied_args)

    def _validate_az_spec_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        spectrum: Path,
        roff: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        self._validate("az_spec_SLC", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("az_spec_SLC", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_az_spec_SLC_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        spectrum: Path,
        roff: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        if spectrum is not None and str(spectrum) != "-":
            spectrum.touch()

    def az_spec_SLC(
        self,
        SLC: Path,
        SLC_par: Path,
        spectrum: Path,
        roff: Optional[int] = None,
        namb: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Doppler centroid estimate from SLC images


        input parameters:
          SLC       (input) SAR image data file (fcomplex or scomplex format)
          SLC_par   (input) ISP SLC image parameter file
          spectrum  (output) Doppler spectrum (text format)
          roff      range sample offset to center of estimation window (enter - for default=center_swath)
          namb      number of multiples of the PRF to add to the estimated centroid (default=0)
          pltflg    azimuth spectrum plotting flag:
                      0: none (default)
                      1: output plot in PNG format

        """
        if self.validate_inputs:
            self._validate_az_spec_SLC(SLC, SLC_par, spectrum, roff, namb, pltflg)
        if self.mock_outputs:
            self._mock_az_spec_SLC_outputs(SLC, SLC_par, spectrum, roff, namb, pltflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.az_spec_SLC))
        return self._gamma_call("ISP", "az_spec_SLC", supplied_args)

    def _validate_SLC_copy(
        self,
        SLC_in: Path,
        SLC_par_in: Path,
        SLC_out: Path,
        SLC_par_out: Path,
        fcase: Optional[int] = None,
        sc: Optional[Any] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swap: Optional[int] = None,
        header_lines: Optional[Any] = None,
    ) -> None:
        self._validate("SLC_copy", SLC_in.exists(), f"SLC_in path does not exist ({SLC_in})")
        self._validate("SLC_copy", SLC_par_in.exists(), f"SLC_par_in path does not exist ({SLC_par_in})")

    def _mock_SLC_copy_outputs(
        self,
        SLC_in: Path,
        SLC_par_in: Path,
        SLC_out: Path,
        SLC_par_out: Path,
        fcase: Optional[int] = None,
        sc: Optional[Any] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swap: Optional[int] = None,
        header_lines: Optional[Any] = None,
    ) -> None:
        if SLC_out is not None and str(SLC_out) != "-":
            SLC_out.touch()
        if SLC_par_out is not None and str(SLC_par_out) != "-":
            SLC_par_out.touch()

    def SLC_copy(
        self,
        SLC_in: Path,
        SLC_par_in: Path,
        SLC_out: Path,
        SLC_par_out: Path,
        fcase: Optional[int] = None,
        sc: Optional[Any] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        loff: Optional[int] = None,
        nl: Optional[int] = None,
        swap: Optional[int] = None,
        header_lines: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Copy SLC with options for data format conversion, segment extraction, and byte swapping


        input parameters:
          SLC_in       (input) SLC (FCOMPLEX or SCOMPLEX format)
          SLC_par_in   (input) ISP SLC parameter file for input SLC
          SLC_out      (output) selected SLC section (FCOMPLEX or SCOMPLEX format)
          SLC_par_out  (output) ISP SLC parameter file of output SLC
          fcase        data format conversion (enter - for default: output format = input format)
                         1: FCOMPLEX --> FCOMPLEX (default sc = 1.0)
                         2: FCOMPLEX --> SCOMPLEX (default sc = 10000.0)
                         3: SCOMPLEX --> FCOMPLEX (default sc = 0.0001)
                         4: SCOMPLEX --> SCOMPLEX (default sc = 1.0)
          sc           scale factor for input SLC data (enter - for default)
          roff         offset to starting range sample (enter - for default: 0)
          nr           number of range samples (enter - for default: to end of line)
          loff         offset to starting line (enter - for default: 0)
          nl           number of lines to copy (enter - for default: to end of file)
          swap         swap data (enter - for default)
                         0: normal (default)
                         1: swap real/imaginary part of complex data
                         2: swap left/right (near/far range)
          header_lines  number of input file header lines (enter - for default: 0)
                        NOTE: CEOS format SLC data have 1 header line
                        NOTE: file offset pointer size (bytes): 8

        """
        if self.validate_inputs:
            self._validate_SLC_copy(
                SLC_in, SLC_par_in, SLC_out, SLC_par_out, fcase, sc, roff, nr, loff, nl, swap, header_lines
            )
        if self.mock_outputs:
            self._mock_SLC_copy_outputs(
                SLC_in, SLC_par_in, SLC_out, SLC_par_out, fcase, sc, roff, nr, loff, nl, swap, header_lines
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_copy))
        return self._gamma_call("ISP", "SLC_copy", supplied_args)

    def _validate_az_integrate(
        self, data: Path, width: int, azi: Path, cflg: int, scale: Optional[Any] = None, lz: Optional[Any] = None
    ) -> None:
        self._validate("az_integrate", data.exists(), f"data path does not exist ({data})")

    def _mock_az_integrate_outputs(
        self, data: Path, width: int, azi: Path, cflg: int, scale: Optional[Any] = None, lz: Optional[Any] = None
    ) -> None:
        if azi is not None and str(azi) != "-":
            azi.touch()

    def az_integrate(
        self, data: Path, width: int, azi: Path, cflg: int, scale: Optional[Any] = None, lz: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        Calculate azimuth integral of float data (unwrapped phase or azimuth offsets)


        input parameters:
          data      (input) input data (example: SBI dtrapped phase) (float)
          width     (input) number of range samples/line
          azi       (output) input data integrated along azimuth (float)
          cflg      integration constant flag:
                       0: set azimuth integral value to 0.0 at specified line
                       1: set average of the azimuth integral to 0.0
          scale     scale factor to apply to the data (enter - for default, default: 1.0)
          lz        line offset where the azimuth integral is set to 0.0 (cflg = 0, enter - for default, default: 0)

        """
        if self.validate_inputs:
            self._validate_az_integrate(data, width, azi, cflg, scale, lz)
        if self.mock_outputs:
            self._mock_az_integrate_outputs(data, width, azi, cflg, scale, lz)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.az_integrate))
        return self._gamma_call("ISP", "az_integrate", supplied_args)

    def _validate_SLC_cat(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_3: Path,
        SLC3_par: Path,
        dopflg: Optional[int] = None,
        iflg: Optional[int] = None,
        phflg: Optional[int] = None,
        gainflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        self._validate("SLC_cat", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("SLC_cat", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("SLC_cat", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("SLC_cat", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("SLC_cat", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_SLC_cat_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_3: Path,
        SLC3_par: Path,
        dopflg: Optional[int] = None,
        iflg: Optional[int] = None,
        phflg: Optional[int] = None,
        gainflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> None:
        if SLC_3 is not None and str(SLC_3) != "-":
            SLC_3.touch()
        if SLC3_par is not None and str(SLC3_par) != "-":
            SLC3_par.touch()

    def SLC_cat(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        SLC_3: Path,
        SLC3_par: Path,
        dopflg: Optional[int] = None,
        iflg: Optional[int] = None,
        phflg: Optional[int] = None,
        gainflg: Optional[int] = None,
        imode: Optional[int] = None,
        order: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Concatenate a pair of SLC images with interpolation of the second scene


        input parameters:
          SLC-1      (input) SLC-1 image (FCOMPLEX or SCOMPLEX)
          SLC-2      (input) SLC-2 image to be appended to SLC-1 (same type as SLC-1)
          SLC1_par   (input) SLC-1 ISP image parameter file
          SLC2_par   (input) SLC-2 ISP image parameter file
          OFF_par    (input) ISP offset parameter file containing offset polynomials between SLC-1 and SLC-2
          SLC-3      (output) concatenated SLC
          SLC3_par   (output) ISP image parameter file for concatenated image
          dopflg     Doppler flag (enter - for default)
                       0: ignore Doppler centroid information, assume 0 Hz Doppler centroid
                       1: use Doppler centroid information for interpolation (default)
          iflg       input data type flag (enter - for default)
                       0: input data are SLC images, use data type specified in SLC_par files (SCOMPLEX or FCOMPLEX) (default)
                       1: input scenes are interferograms, force FCOMPLEX data type
          phflg      phase offset correction flag (enter - for default)
                       0: no phase offset correction for SLC-2 (default)
                       1: apply constant phase offset correction to SLC-2
          gainflg    gain correction flag (enter - for default)
                       0: no gain correction for SLC-2 (default)
                       1: apply gain correction to SLC-2
          imode      interpolation mode for SLC-2 (enter - for default)
                       0: Lanczos interpolation (default)
                       1: B-spline interpolation
          order      Lanczos interpolator order / B-spline degree 4 -> 9 (enter - for default: 4)

        """
        if self.validate_inputs:
            self._validate_SLC_cat(
                SLC_1, SLC_2, SLC1_par, SLC2_par, OFF_par, SLC_3, SLC3_par, dopflg, iflg, phflg, gainflg, imode, order
            )
        if self.mock_outputs:
            self._mock_SLC_cat_outputs(
                SLC_1, SLC_2, SLC1_par, SLC2_par, OFF_par, SLC_3, SLC3_par, dopflg, iflg, phflg, gainflg, imode, order
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_cat))
        return self._gamma_call("ISP", "SLC_cat", supplied_args)

    def _validate_par_NovaSAR_SLC(
        self,
        GeoTIFF: Path,
        XML: Path,
        polarization: Any,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        self._validate("par_NovaSAR_SLC", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_NovaSAR_SLC", XML.exists(), f"XML path does not exist ({XML})")

    def _mock_par_NovaSAR_SLC_outputs(
        self,
        GeoTIFF: Path,
        XML: Path,
        polarization: Any,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_NovaSAR_SLC(
        self,
        GeoTIFF: Path,
        XML: Path,
        polarization: Any,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        radcal: Optional[int] = None,
        noise: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for NovaSAR SLC data


        input parameters:
          GeoTIFF       (input) NovaSAR image data file in GeoTIFF format (enter - for none, *.tif)
          XML           (input) NovaSAR XML annotation file
          polarization  image polarization: HH, VV, HV, VH, CH, CV
          SLC_par       (output) ISP SLC parameter file (example: yyyymmdd_pp.slc.par)
          SLC           (output) SLC data file (enter - for none, example: yyyymmdd_pp.slc)
          dtype         output data type (enter - for default: same as input)
                          0: FCOMPLEX
                          1: SCOMPLEX
          radcal        radiometric calibration flag (enter - for default)
                          0: beta0 (default)
                          1: sigma0
          noise         noise levels flag (enter - for default)
                          0: do not use noise levels (default)
                          1: use noise levels

        """
        if self.validate_inputs:
            self._validate_par_NovaSAR_SLC(GeoTIFF, XML, polarization, SLC_par, SLC, dtype, radcal, noise)
        if self.mock_outputs:
            self._mock_par_NovaSAR_SLC_outputs(GeoTIFF, XML, polarization, SLC_par, SLC, dtype, radcal, noise)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_NovaSAR_SLC))
        return self._gamma_call("ISP", "par_NovaSAR_SLC", supplied_args)

    def _validate_SLC_corners(
        self, SLC_par: Path, terra_alt: Optional[Path] = None, kml: Optional[Path] = None
    ) -> None:
        self._validate("SLC_corners", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        if terra_alt is not None:
            self._validate("SLC_corners", terra_alt.exists(), f"terra_alt path does not exist ({terra_alt})")

    def _mock_SLC_corners_outputs(
        self, SLC_par: Path, terra_alt: Optional[Path] = None, kml: Optional[Path] = None
    ) -> None:
        if kml is not None and str(kml) != "-":
            kml.touch()

    def SLC_corners(
        self, SLC_par: Path, terra_alt: Optional[Path] = None, kml: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Calculate SLC/MLI image corners in geodetic latitude and longitude (deg.)


        input parameters:
          SLC_par   (input) ISP SLC/MLI image parameter file
          terra_alt (input) average terrain altitude (enter - for default: 300.000 meters)
          kml       (output) kml output file (enter - for none)

        """
        if self.validate_inputs:
            self._validate_SLC_corners(SLC_par, terra_alt, kml)
        if self.mock_outputs:
            self._mock_SLC_corners_outputs(SLC_par, terra_alt, kml)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_corners))
        return self._gamma_call("ISP", "SLC_corners", supplied_args)

    def _validate_SLC_deramp(
        self, SLC_1: Path, SLC_par1: Path, SLC_2: Path, SLC_par2: Path, mode: int, dop_ph: Optional[Path] = None
    ) -> None:
        self._validate("SLC_deramp", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("SLC_deramp", SLC_par1.exists(), f"SLC_par1 path does not exist ({SLC_par1})")

    def _mock_SLC_deramp_outputs(
        self, SLC_1: Path, SLC_par1: Path, SLC_2: Path, SLC_par2: Path, mode: int, dop_ph: Optional[Path] = None
    ) -> None:
        if SLC_2 is not None and str(SLC_2) != "-":
            SLC_2.touch()
        if SLC_par2 is not None and str(SLC_par2) != "-":
            SLC_par2.touch()
        if dop_ph is not None and str(dop_ph) != "-":
            dop_ph.touch()

    def SLC_deramp(
        self, SLC_1: Path, SLC_par1: Path, SLC_2: Path, SLC_par2: Path, mode: int, dop_ph: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Calculate and subtract Doppler phase from an SLC image


        input parameters:
          SLC-1     (input) SLC data file (fcomplex or scomplex format)
          SLC_par1  (input) SLC parameter file with Doppler information
          SLC-2     (output) SLC with Doppler phase removed (or added)
          SLC_par2  (output) SLC parameter file for the output SLC
          mode      mode of operation:
                      0: subtract Doppler phase ramp (deramp)
                      1: add Doppler phase ramp (reramp)
          dop_ph   (output) Doppler phase (FLOAT)

        Note: SLC_par1 contains the Doppler polynomial that is used to calculate the Doppler phase ramp
        """
        if self.validate_inputs:
            self._validate_SLC_deramp(SLC_1, SLC_par1, SLC_2, SLC_par2, mode, dop_ph)
        if self.mock_outputs:
            self._mock_SLC_deramp_outputs(SLC_1, SLC_par1, SLC_2, SLC_par2, mode, dop_ph)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_deramp))
        return self._gamma_call("ISP", "SLC_deramp", supplied_args)

    def _validate_residue(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        self._validate("residue", int.exists(), f"int path does not exist ({int})")
        self._validate("residue", flag.exists(), f"flag path does not exist ({flag})")

    def _mock_residue_outputs(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        pass

    def residue(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Determine interferometric phase unwrapping residues


        input parameters:
          int    (input) interferogram (fcomplex)
          flag   (input) flag file (unsigned char)
          width  number of samples/row
          xmin   offset to starting range pixel(default = 0)
          xmax   offset last range pixel (default = width-1)
          ymin   offset to starting azimuth row (default = 0)
          ymax   offset to last azimuth row (default = nlines-1)

        """
        if self.validate_inputs:
            self._validate_residue(int, flag, width, xmin, xmax, ymin, ymax)
        if self.mock_outputs:
            self._mock_residue_outputs(int, flag, width, xmin, xmax, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.residue))
        return self._gamma_call("ISP", "residue", supplied_args)

    def _validate_par_PRI(self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path) -> None:
        self._validate("par_PRI", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})")
        self._validate("par_PRI", CEOS_DAT.exists(), f"CEOS_DAT path does not exist ({CEOS_DAT})")

    def _mock_par_PRI_outputs(self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path) -> None:
        if PRI_par is not None and str(PRI_par) != "-":
            PRI_par.touch()
        if PRI is not None and str(PRI) != "-":
            PRI.touch()

    def par_PRI(self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path) -> Tuple[int, str, str]:
        """

        ISP parameter file generation for ERS PRI data from the PGS and VMP processors


        input parameters:
          CEOS_SAR_leader (input) ERS CEOS SAR leader file for PRI product
          PRI_par         (output) ISP image parameter file (example: <yyyymmdd>.pri.par)
          CEOS_DAT        (input) CEOS data file (example: DAT_01.001)
          PRI             (output) PRI data with file and line headers removed (example: <yyyymmdd>.pri)

        """
        if self.validate_inputs:
            self._validate_par_PRI(CEOS_SAR_leader, PRI_par, CEOS_DAT, PRI)
        if self.mock_outputs:
            self._mock_par_PRI_outputs(CEOS_SAR_leader, PRI_par, CEOS_DAT, PRI)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_PRI))
        return self._gamma_call("ISP", "par_PRI", supplied_args)

    def _validate_create_offset(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        algorithm: Optional[int] = None,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        self._validate("create_offset", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("create_offset", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_create_offset_outputs(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        algorithm: Optional[int] = None,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> None:
        if not OFF_par.exists():
            OFF_par.touch()

    def create_offset(
        self,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        algorithm: Optional[int] = None,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        iflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Create and update ISP offset and interferogram parameter files


        input parameters:
          SLC1_par   (input) SLC-1/MLI-1 ISP image parameter filename (reference)
          SLC2_par   (input) SLC-2/MLI-2 ISP image parameter filename
          OFF_par    (input/output) ISP offset/interferogram parameter file
          algorithm  offset estimation algorithm
                       1: intensity cross-correlation (default)
                       2: fringe visibility
          rlks       number of interferogram range looks (enter -  for default: 1)
          azlks      number of interferogram azimuth looks (enter - for default: 1)
          iflg       interactive mode flag (enter -  for default)
                       0: non-interactive
                       1: interactive (default)

        """
        if self.validate_inputs:
            self._validate_create_offset(SLC1_par, SLC2_par, OFF_par, algorithm, rlks, azlks, iflg)
        if self.mock_outputs:
            self._mock_create_offset_outputs(SLC1_par, SLC2_par, OFF_par, algorithm, rlks, azlks, iflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.create_offset))
        return self._gamma_call("ISP", "create_offset", supplied_args)

    def _validate_multi_look_MLI(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        rlks: Any,
        azlks: Any,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        e_flag: Optional[int] = None,
    ) -> None:
        self._validate("multi_look_MLI", MLI_in.exists(), f"MLI_in path does not exist ({MLI_in})")
        self._validate("multi_look_MLI", MLI_in_par.exists(), f"MLI_in_par path does not exist ({MLI_in_par})")

    def _mock_multi_look_MLI_outputs(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        rlks: Any,
        azlks: Any,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        e_flag: Optional[int] = None,
    ) -> None:
        if MLI_out is not None and str(MLI_out) != "-":
            MLI_out.touch()
        if MLI_out_par is not None and str(MLI_out_par) != "-":
            MLI_out_par.touch()

    def multi_look_MLI(
        self,
        MLI_in: Path,
        MLI_in_par: Path,
        MLI_out: Path,
        MLI_out_par: Path,
        rlks: Any,
        azlks: Any,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
        e_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Multilooking (averaging and decimation) of MLI images


        input parameters:
          MLI_in       (input) multi-look intensity image (MLI) file (float)
          MLI_in_par   (input) MLI parameter file
          MLI_out      (output) multi-looked MLI image (float)
          MLI_out_par  (output) MLI parameter file for output MLI
          rlks         range looks for multi-looking
          azlks        azimuth looks for multi-looking
          loff         offset to starting line (enter - for default: 0)
          nlines       number of input MLI lines to process (enter - for default: entire file)
          scale        scale factor for output MLI (enter - for default: 1.0)
          e_flag       extent flag (enter - for default)
                         0: only permit pixels with the full number of looks (default)
                         1: permit pixels without the full number of looks

        """
        if self.validate_inputs:
            self._validate_multi_look_MLI(
                MLI_in, MLI_in_par, MLI_out, MLI_out_par, rlks, azlks, loff, nlines, scale, e_flag
            )
        if self.mock_outputs:
            self._mock_multi_look_MLI_outputs(
                MLI_in, MLI_in_par, MLI_out, MLI_out_par, rlks, azlks, loff, nlines, scale, e_flag
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_look_MLI))
        return self._gamma_call("ISP", "multi_look_MLI", supplied_args)

    def _validate_multi_real(
        self,
        data_in: Path,
        OFF_par_in: Path,
        data_out: Path,
        OFF_par_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        self._validate("multi_real", data_in.exists(), f"data_in path does not exist ({data_in})")
        self._validate("multi_real", OFF_par_in.exists(), f"OFF_par_in path does not exist ({OFF_par_in})")

    def _mock_multi_real_outputs(
        self,
        data_in: Path,
        OFF_par_in: Path,
        data_out: Path,
        OFF_par_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()
        if not OFF_par_out.exists():
            OFF_par_out.touch()

    def multi_real(
        self,
        data_in: Path,
        OFF_par_in: Path,
        data_out: Path,
        OFF_par_out: Path,
        rlks: Optional[int] = None,
        azlks: Optional[Any] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        roff: Optional[int] = None,
        nsamp: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate multi-look averaged or interpolated 2D image (float data)


        input parameters:
          data_in      (input) input float image file
          OFF_par_in   (input) interferogram/offset parameter file for input image
          data_out     (output) output multi-look or interpolated float data file
          OFF_par_out  (input/output) interferogram/offset parameter file for output, if already existing, used as input
          rlks         number of range looks, values < -1, interpreted as an image oversampling factor (default: 1)
          azlks        number azimuth looks,  values < -1, interpreted as an image oversampling factor (default: 1)
          loff         line offset to starting line (default:0)
          nlines       number of lines (default:0, to end of file)
          roff         offset to starting range sample (default:0)
          nsamp        number of range samples to extract (default:0, to end of line)

        """
        if self.validate_inputs:
            self._validate_multi_real(
                data_in, OFF_par_in, data_out, OFF_par_out, rlks, azlks, loff, nlines, roff, nsamp
            )
        if self.mock_outputs:
            self._mock_multi_real_outputs(
                data_in, OFF_par_in, data_out, OFF_par_out, rlks, azlks, loff, nlines, roff, nsamp
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_real))
        return self._gamma_call("ISP", "multi_real", supplied_args)

    def _validate_SLC_intf2(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        MLI_1: Path,
        MLI_2R: Path,
        MLI1_par: Path,
        MLI2R_par: Path,
        interf: Path,
        cc: Path,
        r_dec: Any,
        az_dec: Any,
        rwin: Optional[int] = None,
        azwin: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
    ) -> None:
        self._validate("SLC_intf2", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("SLC_intf2", SLC_2R.exists(), f"SLC_2R path does not exist ({SLC_2R})")
        self._validate("SLC_intf2", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("SLC_intf2", SLC2R_par.exists(), f"SLC2R_par path does not exist ({SLC2R_par})")
        if sim_phase is not None:
            self._validate("SLC_intf2", sim_phase.exists(), f"sim_phase path does not exist ({sim_phase})")

    def _mock_SLC_intf2_outputs(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        MLI_1: Path,
        MLI_2R: Path,
        MLI1_par: Path,
        MLI2R_par: Path,
        interf: Path,
        cc: Path,
        r_dec: Any,
        az_dec: Any,
        rwin: Optional[int] = None,
        azwin: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
    ) -> None:
        if MLI_1 is not None and str(MLI_1) != "-":
            MLI_1.touch()
        if MLI_2R is not None and str(MLI_2R) != "-":
            MLI_2R.touch()
        if MLI1_par is not None and str(MLI1_par) != "-":
            MLI1_par.touch()
        if MLI2R_par is not None and str(MLI2R_par) != "-":
            MLI2R_par.touch()
        if interf is not None and str(interf) != "-":
            interf.touch()
        if cc is not None and str(cc) != "-":
            cc.touch()

    def SLC_intf2(
        self,
        SLC_1: Path,
        SLC_2R: Path,
        SLC1_par: Path,
        SLC2R_par: Path,
        MLI_1: Path,
        MLI_2R: Path,
        MLI1_par: Path,
        MLI2R_par: Path,
        interf: Path,
        cc: Path,
        r_dec: Any,
        az_dec: Any,
        rwin: Optional[int] = None,
        azwin: Optional[Any] = None,
        wflg: Optional[int] = None,
        n_ovr: Optional[Any] = None,
        sim_phase: Optional[Path] = None,
        lanczos: Optional[Any] = None,
        beta: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate interferogram and MLI images from SLCs with separate averaging window dimensions and decimation factors


        input parameters:
          SLC-1      (input) single-look complex image 1 (reference)
          SLC-2R     (input) single-look complex image 2 coregistered to SLC-1
          SLC1_par   (input) SLC-1 image parameter file
          SLC2R_par  (input) SLC-2R image parameter file for the co-registered image
          MLI-1      (output) multi-look intensity image derived from SLC-1 (enter - for none)
          MLI-2R     (output) multi-look intensity image derived from SLC-2R (enter - for none)
          MLI1_par   (output) MLI image parameter file derived from SLC1_par (enter - for none)
          MLI2R_par  (output) MLI image parameter file derived from SLC2R_par (enter - for none)
          interf     (output) complex interferogram from SLC-1 and SLC-2R  (enter - for none)
          cc         (output) interferometric correlation magnitude of SLC-1 and SLC-2R (enter - for none)
          r_dec      range decimation factor (int)
          az_dec     azimuth decimation factor (int)
          rwin       averaging window width (int) (enter - for default: r_dec)
          azwin      averaging window height (int) (enter - for default: az_dec)
          wflg       window weighting function (enter - for default):
                       0: rectangular (default)
                       1: Kaiser
                       2: circular Gaussian
          n_ovr      oversampling factor 1 -> 2 (enter - for default: 1)
          sim_phase  (input) simulated interferometric phase, coregistered MLI-1 (FLOAT, enter - for none)
          lanczos    Lanczos interpolator order 5 -> 9 (enter - for default: 7)
          beta       Gaussian or Kaiser window parameter (enter - for default: 2.0)

        """
        if self.validate_inputs:
            self._validate_SLC_intf2(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                MLI_1,
                MLI_2R,
                MLI1_par,
                MLI2R_par,
                interf,
                cc,
                r_dec,
                az_dec,
                rwin,
                azwin,
                wflg,
                n_ovr,
                sim_phase,
                lanczos,
                beta,
            )
        if self.mock_outputs:
            self._mock_SLC_intf2_outputs(
                SLC_1,
                SLC_2R,
                SLC1_par,
                SLC2R_par,
                MLI_1,
                MLI_2R,
                MLI1_par,
                MLI2R_par,
                interf,
                cc,
                r_dec,
                az_dec,
                rwin,
                azwin,
                wflg,
                n_ovr,
                sim_phase,
                lanczos,
                beta,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_intf2))
        return self._gamma_call("ISP", "SLC_intf2", supplied_args)

    def _validate_par_ASF_PRI(self, CEOS_leader: Path, CEOS_data: Path, GRD_par: Path, GRD: Path) -> None:
        self._validate("par_ASF_PRI", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_ASF_PRI", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_ASF_PRI_outputs(self, CEOS_leader: Path, CEOS_data: Path, GRD_par: Path, GRD: Path) -> None:
        if GRD_par is not None and str(GRD_par) != "-":
            GRD_par.touch()
        if GRD is not None and str(GRD) != "-":
            GRD.touch()

    def par_ASF_PRI(self, CEOS_leader: Path, CEOS_data: Path, GRD_par: Path, GRD: Path) -> Tuple[int, str, str]:
        """

        ISP parameter file for ASF detected ground range images (L1) Sep 1996 --> present


        input parameters:
          CEOS_leader  (input) CEOS leader file
          CEOS_data    (input) CEOS data file binary
          GRD_par      (output) ISP ground range image parameter file
          GRD          (output) ISP ground range image (enter - for none, FLOAT intensity)

        """
        if self.validate_inputs:
            self._validate_par_ASF_PRI(CEOS_leader, CEOS_data, GRD_par, GRD)
        if self.mock_outputs:
            self._mock_par_ASF_PRI_outputs(CEOS_leader, CEOS_data, GRD_par, GRD)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_PRI))
        return self._gamma_call("ISP", "par_ASF_PRI", supplied_args)

    def _validate_offset_pwr(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        self._validate("offset_pwr", SLC1.exists(), f"SLC1 path does not exist ({SLC1})")
        self._validate("offset_pwr", SLC2.exists(), f"SLC2 path does not exist ({SLC2})")
        self._validate("offset_pwr", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("offset_pwr", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("offset_pwr", OFF_par.exists(), f"OFF_par path does not exist ({OFF_par})")

    def _mock_offset_pwr_outputs(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> None:
        if offs is not None and str(offs) != "-":
            offs.touch()
        if ccp is not None and str(ccp) != "-":
            ccp.touch()
        if offsets is not None and str(offsets) != "-":
            offsets.touch()
        if ccs is not None and str(ccs) != "-":
            ccs.touch()

    def offset_pwr(
        self,
        SLC1: Path,
        SLC2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        OFF_par: Path,
        offs: Path,
        ccp: Path,
        rwin: Optional[Any] = None,
        azwin: Optional[Any] = None,
        offsets: Optional[Path] = None,
        n_ovr: Optional[Any] = None,
        nr: Optional[int] = None,
        naz: Optional[int] = None,
        thres: Optional[Any] = None,
        lanczos: Optional[Any] = None,
        bw_frac: Optional[int] = None,
        deramp: Optional[int] = None,
        int_filt: Optional[int] = None,
        pflag: Optional[int] = None,
        pltflg: Optional[int] = None,
        ccs: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Offset estimation between SLC images using intensity cross-correlation


        input parameters:
          SLC1      (input) single-look complex image 1 (reference)
          SLC2      (input) single-look complex image 2
          SLC1_par  (input) SLC-1 ISP image parameter file
          SLC2_par  (input) SLC-2 ISP image parameter file
          OFF_par   (input) ISP offset/interferogram parameter file
          offs      (output) offset estimates in range and azimuth (fcomplex)
          ccp       (output) cross-correlation of each patch (0.0->1.0) (float)
          rwin      range patch size (range pixels, enter - for default from offset parameter file)
          azwin     azimuth patch size (azimuth lines, enter - for default from offset parameter file)
          offsets   (output) range and azimuth offsets and cross-correlation data in text format, enter - for no output
          n_ovr     SLC oversampling factor (integer 2**N (1,2,4), enter - for default: 2)
          nr        number of offset estimates in range direction (enter - for default from offset parameter file)
          naz       number of offset estimates in azimuth direction (enter - for default from offset parameter file)
          thres     cross-correlation threshold (0.0->1.0) (enter - for default from offset parameter file)
          lanczos   Lanczos interpolator order 5 -> 9 (enter - for default: 5)
          bw_frac   bandwidth fraction of low-pass filter on complex data (0.0->1.0) (enter - for default: 1.0)
          deramp    deramp SLC phase flag (enter - for default)
                      0: no deramp (Doppler centroid close to 0) (default)
                      1: deramp SLC phase
          int_filt  intensity low-pass filter flag (enter - for default)
                      0: no filter
                      1: low-pass filter of intensity data, highly recommended when no oversampling used (default)
          pflag     print flag (enter - for default)
                      0: print offset summary (default)
                      1: print all offset data
          pltflg    plotting flag (enter - for default)
                      0: none (default)
                      1: screen output
                      2: screen output and PNG format plots
                      3: output plots in PDF format
          ccs       (output) cross-correlation standard deviation of each patch (float)

        NOTE: ScanSAR and TOPS data need to be previously deramped

        """
        if self.validate_inputs:
            self._validate_offset_pwr(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        if self.mock_outputs:
            self._mock_offset_pwr_outputs(
                SLC1,
                SLC2,
                SLC1_par,
                SLC2_par,
                OFF_par,
                offs,
                ccp,
                rwin,
                azwin,
                offsets,
                n_ovr,
                nr,
                naz,
                thres,
                lanczos,
                bw_frac,
                deramp,
                int_filt,
                pflag,
                pltflg,
                ccs,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.offset_pwr))
        return self._gamma_call("ISP", "offset_pwr", supplied_args)

    def _validate_par_ATLSCI_ERS(self, CEOS_SAR_leader: Any, CEOS_Image: Path, SLC_par: Path) -> None:
        self._validate("par_ATLSCI_ERS", CEOS_Image.exists(), f"CEOS_Image path does not exist ({CEOS_Image})")

    def _mock_par_ATLSCI_ERS_outputs(self, CEOS_SAR_leader: Any, CEOS_Image: Path, SLC_par: Path) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ATLSCI_ERS(self, CEOS_SAR_leader: Any, CEOS_Image: Path, SLC_par: Path) -> Tuple[int, str, str]:
        """

        ISP parameter file for ATL-SCI ERS SLC data


        input parameters:
        CEOS_SAR_leader (input) CEOS SAR leader file (LEA_01.001)
        CEOS_Image      (input) CEOS image data segment (DAT_01.001)
        SLC_par         (output) ISP SLC parameter file (example <orbit>.slc.par)

        """
        if self.validate_inputs:
            self._validate_par_ATLSCI_ERS(CEOS_SAR_leader, CEOS_Image, SLC_par)
        if self.mock_outputs:
            self._mock_par_ATLSCI_ERS_outputs(CEOS_SAR_leader, CEOS_Image, SLC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ATLSCI_ERS))
        return self._gamma_call("ISP", "par_ATLSCI_ERS", supplied_args)

    def _validate_par_PRI_ESRIN_JERS(self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path) -> None:
        self._validate(
            "par_PRI_ESRIN_JERS", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )
        self._validate("par_PRI_ESRIN_JERS", CEOS_DAT.exists(), f"CEOS_DAT path does not exist ({CEOS_DAT})")

    def _mock_par_PRI_ESRIN_JERS_outputs(self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path) -> None:
        if PRI_par is not None and str(PRI_par) != "-":
            PRI_par.touch()
        if PRI is not None and str(PRI) != "-":
            PRI.touch()

    def par_PRI_ESRIN_JERS(
        self, CEOS_SAR_leader: Path, PRI_par: Path, CEOS_DAT: Path, PRI: Path
    ) -> Tuple[int, str, str]:
        """

        ISP GRD parameter file for ESRIN processed JERS PRI data


        input parameters:
          CEOS_SAR_leader (input) ERS CEOS SAR leader file for PRI product
          PRI_par         (output) ISP image parameter file (example: <yyyymmdd>.pri.par)
          CEOS_DAT        (input) CEOS data file (example: DAT_01.001)
          PRI             (output) PRI data with file and line headers removed (example: <yyyymmdd>.pri)

        """
        if self.validate_inputs:
            self._validate_par_PRI_ESRIN_JERS(CEOS_SAR_leader, PRI_par, CEOS_DAT, PRI)
        if self.mock_outputs:
            self._mock_par_PRI_ESRIN_JERS_outputs(CEOS_SAR_leader, PRI_par, CEOS_DAT, PRI)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_PRI_ESRIN_JERS))
        return self._gamma_call("ISP", "par_PRI_ESRIN_JERS", supplied_args)

    def _validate_par_KC_PALSAR_slr(
        self,
        facter_m: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        pol: Any,
        pls_mode: int,
        KC_data: Path,
        pwr: Optional[Path] = None,
        fdtab: Optional[Path] = None,
    ) -> None:
        self._validate("par_KC_PALSAR_slr", facter_m.exists(), f"facter_m path does not exist ({facter_m})")
        self._validate("par_KC_PALSAR_slr", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_KC_PALSAR_slr", KC_data.exists(), f"KC_data path does not exist ({KC_data})")

    def _mock_par_KC_PALSAR_slr_outputs(
        self,
        facter_m: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        pol: Any,
        pls_mode: int,
        KC_data: Path,
        pwr: Optional[Path] = None,
        fdtab: Optional[Path] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if pwr is not None and str(pwr) != "-":
            pwr.touch()
        if fdtab is not None and str(fdtab) != "-":
            fdtab.touch()

    def par_KC_PALSAR_slr(
        self,
        facter_m: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        pol: Any,
        pls_mode: int,
        KC_data: Path,
        pwr: Optional[Path] = None,
        fdtab: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate ISP parameter file, Doppler table, and images for PALSAR KC Slant-Range data

        input parameters:
          facter_m    (input) PALSAR Kyoto-Carbon parameter file
          CEOS_leader (input) PALSAR Kyoto-Carbon leader file (LED)
          SLC_par     (output) ISP image parameter file (example: yyyymmdd_pp.mli.par)
          pol         polarization e.g. HH or HV
          pls_mode    PALSAR acquisition mode:
                        1: Fine Beam Single
                        2: Fine Beam Double
                        3: Wide Beam
          KC_data     (input) PALSAR Kyoto-Carbon data (named sar_Q*.dat_*)
          pwr         (output) PALSAR Kyoto-Carbon data strip expressed as SAR intensity (enter - for none, example: yyyymmdd_pp.mli)
          fdtab       (output) table of output polynomials, one polynomial/block used as input to gc_map_fd (enter - for none)

        """
        if self.validate_inputs:
            self._validate_par_KC_PALSAR_slr(facter_m, CEOS_leader, SLC_par, pol, pls_mode, KC_data, pwr, fdtab)
        if self.mock_outputs:
            self._mock_par_KC_PALSAR_slr_outputs(facter_m, CEOS_leader, SLC_par, pol, pls_mode, KC_data, pwr, fdtab)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_KC_PALSAR_slr))
        return self._gamma_call("ISP", "par_KC_PALSAR_slr", supplied_args)

    def _validate_ptarg_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: Any,
        az_samp: Any,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        ptr_par: Optional[Path] = None,
        osf: Optional[Any] = None,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        self._validate("ptarg_SLC", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")
        self._validate("ptarg_SLC", SLC.exists(), f"SLC path does not exist ({SLC})")

    def _mock_ptarg_SLC_outputs(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: Any,
        az_samp: Any,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        ptr_par: Optional[Path] = None,
        osf: Optional[Any] = None,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        if ptr_image is not None and str(ptr_image) != "-":
            ptr_image.touch()
        if r_plot is not None and str(r_plot) != "-":
            r_plot.touch()
        if az_plot is not None and str(az_plot) != "-":
            az_plot.touch()
        if ptr_par is not None and str(ptr_par) != "-":
            ptr_par.touch()

    def ptarg_SLC(
        self,
        SLC_par: Path,
        SLC: Path,
        r_samp: Any,
        az_samp: Any,
        ptr_image: Path,
        r_plot: Path,
        az_plot: Path,
        ptr_par: Optional[Path] = None,
        osf: Optional[Any] = None,
        win: Optional[Any] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Point target response analysis and interpolation for SLC images


        input parameters:
          SLC_par    (input) SLC image parameter file
          SLC        (input) SLC image in FCOMPLEX or SCOMPLEX format
          r_samp     point target range sample number
          az_samp    point target azimuth line number
          ptr_image  (output) oversampled point target image (fcomplex, 1024x1024 samples), with and without phase gradient
          r_plot     (output) range point target response plot data (text format)
          az_plot    (output) azimuth point target response plot data (text format)
          ptr_par    (output) measured point target parameters (text format)
          osf        image over-sampling factor, 2, 4, 8, 16, 32, 64 (enter - for default: 16)
          win        maximum search window offset (samples) (enter - for default: 1)
          pltflg     plotting mode flag:
                       0: none
                       1: output plots in PNG format (default)
                       2: screen output
                       3: output plots in PDF format
        """
        if self.validate_inputs:
            self._validate_ptarg_SLC(
                SLC_par, SLC, r_samp, az_samp, ptr_image, r_plot, az_plot, ptr_par, osf, win, pltflg
            )
        if self.mock_outputs:
            self._mock_ptarg_SLC_outputs(
                SLC_par, SLC, r_samp, az_samp, ptr_image, r_plot, az_plot, ptr_par, osf, win, pltflg
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ptarg_SLC))
        return self._gamma_call("ISP", "ptarg_SLC", supplied_args)

    def _validate_par_EORC_PALSAR(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[Any] = None,
    ) -> None:
        self._validate("par_EORC_PALSAR", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_EORC_PALSAR", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")

    def _mock_par_EORC_PALSAR_outputs(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[Any] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_EORC_PALSAR(
        self,
        CEOS_leader: Path,
        SLC_par: Path,
        CEOS_data: Path,
        SLC: Optional[Path] = None,
        dtype: Optional[int] = None,
        sc_dB: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC image and parameter files for PALSAR + PALSAR2 level 1.1 SLC data produced by EORC/JAXA and ESA


        input parameters:
          CEOS_leader  (input) CEOS leader file for PALSAR or PALSAR-2 Level 1.1 SLC data (LED...)
          SLC_par      (output) ISP image parameter file (example: yyyymmdd.slc.par)
          CEOS_data    (input) PALSAR CEOS format Level 1.1 SLC (IMG...)
          SLC          (output) reformatted PALSAR SLC (example: yyyymmdd.slc, enter - for none)
          dtype        output data type (enter - for default)
                         0: FCOMPLEX (default)
                         1: SCOMPLEX
          sc_dB        scale factor for FCOMPLEX -> SCOMPLEX, (enter - for default: HH,VV (dB): 60.0000, VH,HV: 70.0000)

        """
        if self.validate_inputs:
            self._validate_par_EORC_PALSAR(CEOS_leader, SLC_par, CEOS_data, SLC, dtype, sc_dB)
        if self.mock_outputs:
            self._mock_par_EORC_PALSAR_outputs(CEOS_leader, SLC_par, CEOS_data, SLC, dtype, sc_dB)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_EORC_PALSAR))
        return self._gamma_call("ISP", "par_EORC_PALSAR", supplied_args)

    def _validate_S1_burstloc(self, annotation_XML: Path) -> None:
        self._validate("S1_burstloc", annotation_XML.exists(), f"annotation_XML path does not exist ({annotation_XML})")

    def _mock_S1_burstloc_outputs(self, annotation_XML: Path) -> None:
        pass

    def S1_burstloc(self, annotation_XML: Path) -> Tuple[int, str, str]:
        """

        Print Burst information found in the Sentinel-1 annotation file


        input parameters:
          annotation_XML  (input) Sentinel-1 L1 XML annotation file

        """
        if self.validate_inputs:
            self._validate_S1_burstloc(annotation_XML)
        if self.mock_outputs:
            self._mock_S1_burstloc_outputs(annotation_XML)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.S1_burstloc))
        return self._gamma_call("ISP", "S1_burstloc", supplied_args)

    def _validate_par_GF3_SLC(
        self, GeoTIFF: Path, annotation_XML: Path, SLC_par: Path, SLC: Optional[Path] = None
    ) -> None:
        self._validate("par_GF3_SLC", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_GF3_SLC", annotation_XML.exists(), f"annotation_XML path does not exist ({annotation_XML})")

    def _mock_par_GF3_SLC_outputs(
        self, GeoTIFF: Path, annotation_XML: Path, SLC_par: Path, SLC: Optional[Path] = None
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_GF3_SLC(
        self, GeoTIFF: Path, annotation_XML: Path, SLC_par: Path, SLC: Optional[Path] = None
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter file and SLC image from a Gaofen-3 data set in GeoTIFF format


        input parameters:
          GeoTIFF        (input) Gaofen-3 data file in GeoTIFF format (*.tiff) (enter - for none)
          annotation_XML (input) Gaofen-3 annotation file in XML format (*.meta.xml)
          SLC_par        (output) ISP SLC parameter file (example: yyyymmdd.slc.par)
          SLC            (output) ISP SLC data file (example: yyyymmdd.slc) (enter - for none, SLC output will not be produced)

        """
        if self.validate_inputs:
            self._validate_par_GF3_SLC(GeoTIFF, annotation_XML, SLC_par, SLC)
        if self.mock_outputs:
            self._mock_par_GF3_SLC_outputs(GeoTIFF, annotation_XML, SLC_par, SLC)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_GF3_SLC))
        return self._gamma_call("ISP", "par_GF3_SLC", supplied_args)

    def _validate_par_EORC_PALSAR_ScanSAR(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        afmrate: Optional[int] = None,
        flip: Optional[int] = None,
        reramp: Optional[int] = None,
    ) -> None:
        self._validate("par_EORC_PALSAR_ScanSAR", CEOS_data.exists(), f"CEOS_data path does not exist ({CEOS_data})")
        self._validate(
            "par_EORC_PALSAR_ScanSAR", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})"
        )

    def _mock_par_EORC_PALSAR_ScanSAR_outputs(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        afmrate: Optional[int] = None,
        flip: Optional[int] = None,
        reramp: Optional[int] = None,
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()
        if TOPS_par is not None and str(TOPS_par) != "-":
            TOPS_par.touch()

    def par_EORC_PALSAR_ScanSAR(
        self,
        CEOS_data: Path,
        CEOS_leader: Path,
        SLC_par: Path,
        SLC: Optional[Path] = None,
        TOPS_par: Optional[Path] = None,
        afmrate: Optional[int] = None,
        flip: Optional[int] = None,
        reramp: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files from EORC PALSAR2 ScanSAR burst SLC data in CEOS format


        input parameters:
          CEOS_data    (input) CEOS image file for a PALSAR2 ScanSAR burst data subswath (IMG...)
          CEOS_leader  (input) CEOS leader file for PALSAR2 ScanSAR burst data (LED...)
          SLC_par      (output) ISP image parameter file (example: yyyymmdd_b1_hh.slc.par)
          SLC          (output) SLC data file (enter - for none, example: yyyymmdd_b1_hh.slc)
          TOPS_par     (output) SLC burst annotation file (enter - for none, example: yyyymmdd_b1_hh.slc.tops_par)
          afmrate      azimuth FM rate estimation method (enter - for default)
                         0: beam velocity on the ground
                         1: platform velocity (default)
          shift        shift azimuth spectrum by fs/2 (enter - for default)
                         0: no
                         1: yes (default)
          reramp       reramp data using Doppler centroid and azimuth FM rate estimate (enter - for default)
                         0: no
                         1: yes (default)

        """
        if self.validate_inputs:
            self._validate_par_EORC_PALSAR_ScanSAR(
                CEOS_data, CEOS_leader, SLC_par, SLC, TOPS_par, afmrate, flip, reramp
            )
        if self.mock_outputs:
            self._mock_par_EORC_PALSAR_ScanSAR_outputs(
                CEOS_data, CEOS_leader, SLC_par, SLC, TOPS_par, afmrate, flip, reramp
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_EORC_PALSAR_ScanSAR))
        return self._gamma_call("ISP", "par_EORC_PALSAR_ScanSAR", supplied_args)

    def _validate_cc_wave(
        self,
        interf: Path,
        MLI_1: Optional[Path],
        MLI_2: Optional[Path],
        cc: Path,
        width: int,
        bx: Optional[Any] = None,
        by: Optional[Any] = None,
        wflg: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        self._validate("cc_wave", interf.exists(), f"interf path does not exist ({interf})")
        if MLI_1 is not None:
            self._validate("cc_wave", MLI_1.exists(), f"MLI_1 path does not exist ({MLI_1})")
        if MLI_2 is not None:
            self._validate("cc_wave", MLI_2.exists(), f"MLI_2 path does not exist ({MLI_2})")

    def _mock_cc_wave_outputs(
        self,
        interf: Path,
        MLI_1: Optional[Path],
        MLI_2: Optional[Path],
        cc: Path,
        width: int,
        bx: Optional[Any] = None,
        by: Optional[Any] = None,
        wflg: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        if cc is not None and str(cc) != "-":
            cc.touch()

    def cc_wave(
        self,
        interf: Path,
        MLI_1: Optional[Path],
        MLI_2: Optional[Path],
        cc: Path,
        width: int,
        bx: Optional[Any] = None,
        by: Optional[Any] = None,
        wflg: Optional[Any] = None,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Estimate interferometric correlation coefficient


        input parameters:
          interf  (input) normalized complex interferogram (FCOMPLEX)
          MLI-1   (input) multilook intensity image of the first scene (FLOAT) (enter - for none)
          MLI-2   (input) multilook intensity image of the second scene (FLOAT) (enter - for none)
          cc      (output) correlation coefficient (FLOAT)
          width   number of samples/line
          bx      estimation window size in columns (enter - for default: 5.0)
          by      estimation window size in lines (enter - for default: 5.0)
          wflg    estimation window (enter - for default):
                    0: rectangular (default)
                    1: triangular
                    2: Gaussian
                    3: normalized vector sum with rectangular window
                       NOTE: This estimator does not use the MLI data, even when specified
          xmin    starting range pixel offset (enter - for default: 0)
          xmax    last range pixel offset (enter - for default: width - 1)
          ymin    starting azimuth row offset, relative to start (enter -  for default: 0)
          ymax    last azimuth row offset, relative to start (enter - for default: nlines - 1)

        """
        if self.validate_inputs:
            self._validate_cc_wave(interf, MLI_1, MLI_2, cc, width, bx, by, wflg, xmin, xmax, ymin, ymax)
        if self.mock_outputs:
            self._mock_cc_wave_outputs(interf, MLI_1, MLI_2, cc, width, bx, by, wflg, xmin, xmax, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cc_wave))
        return self._gamma_call("ISP", "cc_wave", supplied_args)

    def _validate_par_RSAT2_SLC(
        self, product_XML: Path, lut_XML: Path, GeoTIFF: Path, polarization: Path, SLC_par: Path, SLC: Path
    ) -> None:
        self._validate("par_RSAT2_SLC", product_XML.exists(), f"product_XML path does not exist ({product_XML})")
        self._validate("par_RSAT2_SLC", lut_XML.exists(), f"lut_XML path does not exist ({lut_XML})")
        self._validate("par_RSAT2_SLC", GeoTIFF.exists(), f"GeoTIFF path does not exist ({GeoTIFF})")
        self._validate("par_RSAT2_SLC", polarization.exists(), f"polarization path does not exist ({polarization})")

    def _mock_par_RSAT2_SLC_outputs(
        self, product_XML: Path, lut_XML: Path, GeoTIFF: Path, polarization: Path, SLC_par: Path, SLC: Path
    ) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()
        if SLC is not None and str(SLC) != "-":
            SLC.touch()

    def par_RSAT2_SLC(
        self, product_XML: Path, lut_XML: Path, GeoTIFF: Path, polarization: Path, SLC_par: Path, SLC: Path
    ) -> Tuple[int, str, str]:
        """

        Generate SLC parameter and image files for Radarsat 2 SLC data from GeoTIFF


        input parameters:
          product_XML    (input) Radarsat-2 product annotation XML file (product.xml)
          lut_XML        (input) Radarsat-2 calibration XML file (lutSigma.xml), use - for no calibration
          GeoTIFF        (input) image data file in GeoTIFF format (imagery_PP.tif)
          polarization   (input) image polarization: HH, VV, HV, VH
          SLC_par        (output) ISP SLC parameter file (example: yyyymmdd_pp.slc.par)
          SLC            (output) SLC data file (example: yyyymmdd_pp.slc)
        """
        if self.validate_inputs:
            self._validate_par_RSAT2_SLC(product_XML, lut_XML, GeoTIFF, polarization, SLC_par, SLC)
        if self.mock_outputs:
            self._mock_par_RSAT2_SLC_outputs(product_XML, lut_XML, GeoTIFF, polarization, SLC_par, SLC)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_RSAT2_SLC))
        return self._gamma_call("ISP", "par_RSAT2_SLC", supplied_args)

    def _validate_residue_cc(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        self._validate("residue_cc", int.exists(), f"int path does not exist ({int})")
        self._validate("residue_cc", flag.exists(), f"flag path does not exist ({flag})")

    def _mock_residue_cc_outputs(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> None:
        pass

    def residue_cc(
        self,
        int: Path,
        flag: Path,
        width: int,
        xmin: Optional[int] = None,
        xmax: Optional[int] = None,
        ymin: Optional[int] = None,
        ymax: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Determine interferometric phase unwrapping residues considering low coherence regions


        input parameters:
          int    (input) interferogram (fcomplex)
          flag   (input) flag file (unsigned char)
          width  number of samples/row
          xmin   offset to starting range pixel(default = 0)
          xmax   offset last range pixel (default = width-1)
          ymin   offset to starting azimuth row (default = 0)
          ymax   offset to last azimuth row (default = nlines-1)

        """
        if self.validate_inputs:
            self._validate_residue_cc(int, flag, width, xmin, xmax, ymin, ymax)
        if self.mock_outputs:
            self._mock_residue_cc_outputs(int, flag, width, xmin, xmax, ymin, ymax)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.residue_cc))
        return self._gamma_call("ISP", "residue_cc", supplied_args)

    def _validate_par_PulSAR(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        self._validate(
            "par_PulSAR", CEOS_SAR_leader.exists(), f"CEOS_SAR_leader path does not exist ({CEOS_SAR_leader})"
        )

    def _mock_par_PulSAR_outputs(self, CEOS_SAR_leader: Path, SLC_par: Path) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_PulSAR(self, CEOS_SAR_leader: Path, SLC_par: Path) -> Tuple[int, str, str]:
        """

        ISP parameter file generation for ERS SLC data from the PULSAR SAR processor


        input parameters:
        CEOS_SAR_leader  (input) ERS CEOS SAR leader file
        SLC_par          (output) ISP SLC parameter file (example <orbit>.slc.par)

        """
        if self.validate_inputs:
            self._validate_par_PulSAR(CEOS_SAR_leader, SLC_par)
        if self.mock_outputs:
            self._mock_par_PulSAR_outputs(CEOS_SAR_leader, SLC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_PulSAR))
        return self._gamma_call("ISP", "par_PulSAR", supplied_args)

    def _validate_par_ASF_91(self, CEOS_leader: Path, CEOS_trailer: Path, SLC_par: Path) -> None:
        self._validate("par_ASF_91", CEOS_leader.exists(), f"CEOS_leader path does not exist ({CEOS_leader})")
        self._validate("par_ASF_91", CEOS_trailer.exists(), f"CEOS_trailer path does not exist ({CEOS_trailer})")

    def _mock_par_ASF_91_outputs(self, CEOS_leader: Path, CEOS_trailer: Path, SLC_par: Path) -> None:
        if SLC_par is not None and str(SLC_par) != "-":
            SLC_par.touch()

    def par_ASF_91(self, CEOS_leader: Path, CEOS_trailer: Path, SLC_par: Path) -> Tuple[int, str, str]:
        """

        SLC parameter file for data data from theAlaska SAR Facility (1991-1996)


        input parameters:
          CEOS_leader   (input) ASF CEOS leader file
          CEOS_trailer  (input) ASF CEOS trailer file
          SLC_par       (output) ISP SLC image parameter file

        """
        if self.validate_inputs:
            self._validate_par_ASF_91(CEOS_leader, CEOS_trailer, SLC_par)
        if self.mock_outputs:
            self._mock_par_ASF_91_outputs(CEOS_leader, CEOS_trailer, SLC_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.par_ASF_91))
        return self._gamma_call("ISP", "par_ASF_91", supplied_args)

    def _validate_SLC_RFI_filt2(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[Any] = None,
        method: Optional[int] = None,
        f_bs: Optional[Any] = None,
        bs_width: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        azoff: Optional[int] = None,
        naz: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        self._validate("SLC_RFI_filt2", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("SLC_RFI_filt2", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_SLC_RFI_filt2_outputs(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[Any] = None,
        method: Optional[int] = None,
        f_bs: Optional[Any] = None,
        bs_width: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        azoff: Optional[int] = None,
        naz: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> None:
        if SLC_filt is not None and str(SLC_filt) != "-":
            SLC_filt.touch()

    def SLC_RFI_filt2(
        self,
        SLC: Path,
        SLC_par: Path,
        SLC_filt: Path,
        rfi_thres: Optional[Any] = None,
        method: Optional[int] = None,
        f_bs: Optional[Any] = None,
        bs_width: Optional[int] = None,
        roff: Optional[int] = None,
        nr: Optional[int] = None,
        azoff: Optional[int] = None,
        naz: Optional[int] = None,
        pltflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        RFI filtering for SLC image using a band-stop filter


        input parameters:
          SLC         (input) SLC to be filtered (FCOMPLEX or SCOMPLEX)
          SLC_par     (input) reference SLC parameter file
          SLC_filt    (output) output filtered SLC (same format as SLC)
          rfi_thres   RFI threshold in dB above reference (enter - for default: auto)
          method      RFI detection method (enter - for default)
                        0: threshold above median
                        1: threshold using spectrum symmetry (default)
          f_bs        center or seed frequency of band-stop filter in Hz (-fadc/2.0 <= f_bs < fadc/2.0, enter - for default: auto)
          bs_width    width of band-stop filter in Hz (enter - for default: auto)
          roff        offset to starting range sample to filter (enter - for default: 0)
          nr          number of range samples to filter (enter - for default: to end of line)
          azoff       offset to starting azimuth line to filter (enter - for default: 0)
          naz         number of azimuth lines to filter (enter - for default: to end of file)
          pltflg      range spectrum plotting flag (enter - for default)
                        0: none
                        1: output plot in PNG format (default)
                        2: screen output plot

        """
        if self.validate_inputs:
            self._validate_SLC_RFI_filt2(
                SLC, SLC_par, SLC_filt, rfi_thres, method, f_bs, bs_width, roff, nr, azoff, naz, pltflg
            )
        if self.mock_outputs:
            self._mock_SLC_RFI_filt2_outputs(
                SLC, SLC_par, SLC_filt, rfi_thres, method, f_bs, bs_width, roff, nr, azoff, naz, pltflg
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.SLC_RFI_filt2))
        return self._gamma_call("ISP", "SLC_RFI_filt2", supplied_args)

    def _validate_fspf(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: Optional[int] = None,
        r_max: Optional[Any] = None,
        spf_type: Optional[int] = None,
        MLI_par: Optional[Path] = None,
    ) -> None:
        self._validate("fspf", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_fspf_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: Optional[int] = None,
        r_max: Optional[Any] = None,
        spf_type: Optional[int] = None,
        MLI_par: Optional[Path] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def fspf(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: Optional[int] = None,
        r_max: Optional[Any] = None,
        spf_type: Optional[int] = None,
        MLI_par: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        ISP fspf: Fast spatial filter for 2D data


        input parameters:
          data_in    (input) input image data
          data_out   (output) spatially filtered image data
          width      number of samples/row
          dtype      data type (enter - for default):
                       0: FCOMPLEX
                       1: SCOMPLEX
                       2: FLOAT (default)
          r_max      maximum filter radius (range samples) (enter - for default: 64)
          spf_type   spatial filter type (enter - for default):
                       0: uniform average (default for FCOMPLEX and SCOMPLEX)
                       1: triangular weighted average: 1 - (r/r_max)
                       2: quadratic weighted average: 1 - (r/r_max)^2
                       3: Gaussian weighted average: exp(-2.*(r^2/r_max^2))
                       4: linear least-squares (default for FLOAT data)
                       5: median
          MLI_par    MLI or SLC parameter file with the same number of looks as the input image, required for GPRI data (enter - for none)

        """
        if self.validate_inputs:
            self._validate_fspf(data_in, data_out, width, dtype, r_max, spf_type, MLI_par)
        if self.mock_outputs:
            self._mock_fspf_outputs(data_in, data_out, width, dtype, r_max, spf_type, MLI_par)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.fspf))
        return self._gamma_call("ISP", "fspf", supplied_args)

    def _validate_radcal_SLC(
        self,
        SLC: Path,
        SLC_PAR: Path,
        CSLC: Path,
        CSLC_PAR: Path,
        fcase: Optional[int] = None,
        antenna: Optional[Any] = None,
        rloss_flag: Optional[Any] = None,
        ant_flag: Optional[Any] = None,
        refarea_flag: Optional[Any] = None,
        sc_dB: Optional[Any] = None,
        K_dB: Optional[Any] = None,
        pix_area: Optional[Path] = None,
    ) -> None:
        self._validate("radcal_SLC", SLC.exists(), f"SLC path does not exist ({SLC})")
        self._validate("radcal_SLC", SLC_PAR.exists(), f"SLC_PAR path does not exist ({SLC_PAR})")

    def _mock_radcal_SLC_outputs(
        self,
        SLC: Path,
        SLC_PAR: Path,
        CSLC: Path,
        CSLC_PAR: Path,
        fcase: Optional[int] = None,
        antenna: Optional[Any] = None,
        rloss_flag: Optional[Any] = None,
        ant_flag: Optional[Any] = None,
        refarea_flag: Optional[Any] = None,
        sc_dB: Optional[Any] = None,
        K_dB: Optional[Any] = None,
        pix_area: Optional[Path] = None,
    ) -> None:
        if CSLC is not None and str(CSLC) != "-":
            CSLC.touch()
        if CSLC_PAR is not None and str(CSLC_PAR) != "-":
            CSLC_PAR.touch()
        if pix_area is not None and str(pix_area) != "-":
            pix_area.touch()

    def radcal_SLC(
        self,
        SLC: Path,
        SLC_PAR: Path,
        CSLC: Path,
        CSLC_PAR: Path,
        fcase: Optional[int] = None,
        antenna: Optional[Any] = None,
        rloss_flag: Optional[Any] = None,
        ant_flag: Optional[Any] = None,
        refarea_flag: Optional[Any] = None,
        sc_dB: Optional[Any] = None,
        K_dB: Optional[Any] = None,
        pix_area: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Radiometric calibration of SLC data


        input parameters:
          SLC           (input) SLC (fcomplex or scomplex)
          SLC_PAR       (input) SLC parameter file of input SLC
          CSLC          (output) radiometrically calibrated SLC (fcomplex or scomplex)
          CSLC_PAR      (output) SLC parameter file of output calibrated SLC
          fcase         format case (default = 1)
                          1: fcomplex --> fcomplex (pairs of float)
                          2: fcomplex --> scomplex (pairs of short integer)
                          3: scomplex --> fcomplex
                          4: scomplex --> scomplex
          antenna       1-way antenna gain pattern file or - (if not provided)
          rloss_flag    range spreading loss correction:
                          0: no correction (default)
                          1: apply r^3 correction  (all modes except ASAR APS)
                          2: apply r^4 correction (used only for ASAR APS mode)
                         -1: undo r^3 correction
                         -2: undo r^4 correction)
          ant_flag      antenna pattern correction:
                          0: no correction (default)
                          1: apply antenna pattern correction
                         -1: undo antenna pattern correction)
          refarea_flag  reference pixel area correction:
                          0: no pixel area correction (default)
                          1: calculate sigma0, scale area by sin(inc_ang)/sin(ref_inc_ang)
                          2: calculate gamma0, scale area by sin(inc_ang)/(cos(inc_ang)*sin(ref_inc_ang)
                         -1: undo sigma0 area scaling factor
                         -2: undo gamma0 area scaling factor
          sc_dB         scale factor in dB (default: 0.0)
          K_dB          calibration factor in dB (default: -(value from SLC_PAR) )
          pix_area      (output) ellipsoid-based ground range sigma0 or gamma0 pixel reference area (float)
                          refarea_flag 1 or -1: sigma0 ref. area
                          refarea_flag 2 or -2: gamma0 ref. area

        """
        if self.validate_inputs:
            self._validate_radcal_SLC(
                SLC, SLC_PAR, CSLC, CSLC_PAR, fcase, antenna, rloss_flag, ant_flag, refarea_flag, sc_dB, K_dB, pix_area
            )
        if self.mock_outputs:
            self._mock_radcal_SLC_outputs(
                SLC, SLC_PAR, CSLC, CSLC_PAR, fcase, antenna, rloss_flag, ant_flag, refarea_flag, sc_dB, K_dB, pix_area
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.radcal_SLC))
        return self._gamma_call("ISP", "radcal_SLC", supplied_args)

    def _validate_line_interp(self, width: int, output: Any) -> None:
        pass

    def _mock_line_interp_outputs(self, width: int, output: Any) -> None:
        pass

    def line_interp(self, width: int, output: Any) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/line_interp.c
        1-D linear interpolator to fill data gaps

        input parameters:
          input file   input data containing 0.0 values (float)
          output file  output data with 0.0 values replaced (float)
          width        number of samples/line

        """
        if self.validate_inputs:
            self._validate_line_interp(width, output)
        if self.mock_outputs:
            self._mock_line_interp_outputs(width, output)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.line_interp))
        return self._gamma_call("LAT", "line_interp", supplied_args)

    def _validate_product_cpx(
        self,
        f1: Path,
        f2: Path,
        f_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        conjg_flg: Optional[int] = None,
    ) -> None:
        self._validate("product_cpx", f1.exists(), f"f1 path does not exist ({f1})")
        self._validate("product_cpx", f2.exists(), f"f2 path does not exist ({f2})")

    def _mock_product_cpx_outputs(
        self,
        f1: Path,
        f2: Path,
        f_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        conjg_flg: Optional[int] = None,
    ) -> None:
        if f_out is not None and str(f_out) != "-":
            f_out.touch()

    def product_cpx(
        self,
        f1: Path,
        f2: Path,
        f_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        conjg_flg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/product_cpx.c
        Calculate product of complex value data files


        input parameters:
          f1         (input) data file 1 (fcomplex)
          f2         (input) data file 2 (fcomplex)
          f_out      (output) output file f1 * f2 (fcomplex)
          width      number of data samples/line
          start      starting line (default: 1)
          nlines     number of lines to process (enter - for default, all lines)
          conjg_flg  conjugation flag
                       0: none (default)
                       1: conjugate f2 before multiply
        """
        if self.validate_inputs:
            self._validate_product_cpx(f1, f2, f_out, width, start, nlines, conjg_flg)
        if self.mock_outputs:
            self._mock_product_cpx_outputs(f1, f2, f_out, width, start, nlines, conjg_flg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.product_cpx))
        return self._gamma_call("LAT", "product_cpx", supplied_args)

    def _validate_ras_majority(
        self, ras_in: Path, ras_out: Path, filter_width: Optional[int] = None, LR: Optional[Any] = None
    ) -> None:
        self._validate("ras_majority", ras_in.exists(), f"ras_in path does not exist ({ras_in})")

    def _mock_ras_majority_outputs(
        self, ras_in: Path, ras_out: Path, filter_width: Optional[int] = None, LR: Optional[Any] = None
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_majority(
        self, ras_in: Path, ras_out: Path, filter_width: Optional[int] = None, LR: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program ras_majority.c
        Majority filtering of raster image, SUN, BMP, and TIFF format, 8-bits/pixel


        input parameters:
          ras_in        (input) raster classification image, SUN, BMP, or TIFF format, 8 bits/pixel
          ras_out       (output) raster classification image, SUN, BMP, or TIFF format, 8 bits/pixel
          filter_width  filter width (select from 3, 5, or 7, enter - for default: 3)
          LR            left/right mirror image flag (enter - for default: 1: normal (default), -1: mirror image)

        """
        if self.validate_inputs:
            self._validate_ras_majority(ras_in, ras_out, filter_width, LR)
        if self.mock_outputs:
            self._mock_ras_majority_outputs(ras_in, ras_out, filter_width, LR)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_majority))
        return self._gamma_call("LAT", "ras_majority", supplied_args)

    def _validate_average_filter(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[Any] = None,
        wflg: Optional[int] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        self._validate("average_filter", din.exists(), f"din path does not exist ({din})")

    def _mock_average_filter_outputs(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[Any] = None,
        wflg: Optional[int] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        if dout is not None and str(dout) != "-":
            dout.touch()

    def average_filter(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[Any] = None,
        wflg: Optional[int] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT average_filter: Averaging spatial filter (float data)


        input parameters:
          din     (input) input data file
          dout    (output) output averaged data file (filtered)
          width   number of samples/row
          bx      filter window width (columns): 1,3,5,7...
          by      filter window height (rows): 1,3,5,7.., (enter - for default: bx)
          wflg    weighting function (enter - for default)
                    0: constant weighting function (default)
                    1: linear weighting function
                    2: Gaussian weighting function
          min_pt  minimum number of points required in the filter window to evaluate the average value (enter - for default: (bx*by)/4)
          zflg    zero value flag (enter - for default)
                    0: data values that are equal to 0.0 (no data) are not changed (default)
                    1: data gaps are filled with average values if sufficient valid data points in the filter window

        """
        if self.validate_inputs:
            self._validate_average_filter(din, dout, width, bx, by, wflg, min_pt, zflg)
        if self.mock_outputs:
            self._mock_average_filter_outputs(din, dout, width, bx, by, wflg, min_pt, zflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.average_filter))
        return self._gamma_call("LAT", "average_filter", supplied_args)

    def _validate_mask_class(
        self,
        class_map: Path,
        file_in: Path,
        file_out: Path,
        format_flag: int,
        LR: Any,
        selection_flag: Any,
        n_class: int,
        class_1: Path,
        class_n: Optional[Path] = None,
        null_value: Optional[Any] = None,
    ) -> None:
        self._validate("mask_class", class_map.exists(), f"class_map path does not exist ({class_map})")
        self._validate("mask_class", file_in.exists(), f"file_in path does not exist ({file_in})")

    def _mock_mask_class_outputs(
        self,
        class_map: Path,
        file_in: Path,
        file_out: Path,
        format_flag: int,
        LR: Any,
        selection_flag: Any,
        n_class: int,
        class_1: Path,
        class_n: Optional[Path] = None,
        null_value: Optional[Any] = None,
    ) -> None:
        if file_out is not None and str(file_out) != "-":
            file_out.touch()

    def mask_class(
        self,
        class_map: Path,
        file_in: Path,
        file_out: Path,
        format_flag: int,
        LR: Any,
        selection_flag: Any,
        n_class: int,
        class_1: Path,
        class_n: Optional[Path] = None,
        null_value: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program mask_class.c
        Set image data values belonging to a single class or set of classes or the complement to a user-defined value


        input parameters:
          class_map       (input) class map (8-bit SUN raster(*.ras), BMP (*.bmp), TIFF (*.tif) class map file)
          file_in         (input) input data file
          file_out        (output) output data file
          format_flag     input/output data format flag
                            0: FLOAT
                            1: FCOMPLEX
                            2: SUN (*.ras), BMP (*.bmp), TIFF (*.tif) raster image
                            3: UNSIGNED CHAR
          LR              left/right mirror image flag (enter - for default: 1: normal (default), -1: mirror image)
          selection_flag  flag for mask behavior
                            1: mask is the region belonging to the selected classes
                           -1: mask is the complement of the region belonging to the selected classes
          n_class         number of classes to consider, up to 20 classes can be defined
          class_1         class map value 1
          ...             <n_class> class map values must be entered
          class_n         class map value n
          null_value      value written within the masked region:
                            FLOAT: default = 0.0
                            FCOMPLEX specify real and imaginary components: default = 0.0 0.0
                            SUN, BMP, TIFF raster image specify RGB: default RGB = 0 0 0
                            UNSIGNED CHAR: default = 0

        """
        if self.validate_inputs:
            self._validate_mask_class(
                class_map, file_in, file_out, format_flag, LR, selection_flag, n_class, class_1, class_n, null_value
            )
        if self.mock_outputs:
            self._mock_mask_class_outputs(
                class_map, file_in, file_out, format_flag, LR, selection_flag, n_class, class_1, class_n, null_value
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mask_class))
        return self._gamma_call("LAT", "mask_class", supplied_args)

    def _validate_ras_ratio_dB(
        self,
        pwr1: Path,
        pwr2: Path,
        width: int,
        start_pwr1: Optional[Any] = None,
        start_pwr2: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        min_cc: Optional[Any] = None,
        max_cc: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        LR: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        self._validate("ras_ratio_dB", pwr1.exists(), f"pwr1 path does not exist ({pwr1})")
        self._validate("ras_ratio_dB", pwr2.exists(), f"pwr2 path does not exist ({pwr2})")

    def _mock_ras_ratio_dB_outputs(
        self,
        pwr1: Path,
        pwr2: Path,
        width: int,
        start_pwr1: Optional[Any] = None,
        start_pwr2: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        min_cc: Optional[Any] = None,
        max_cc: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        LR: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras_ratio_dB(
        self,
        pwr1: Path,
        pwr2: Path,
        width: int,
        start_pwr1: Optional[Any] = None,
        start_pwr2: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        min_cc: Optional[Any] = None,
        max_cc: Optional[Any] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        LR: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/ras_ratio_dB.c
        Ratio of 2 intensity images (dB scale) --> raster image (SUN, BMP, or TIFF format)


        input parameters:
          pwr1        (input) intensity image 1
          pwr2        (input)intensity image 2
          width       number of samples/row
          start_pwr1  starting line of intensity 1  image file (default=1)
          start_pwr2  starting line of intensity 2  image file (default=1)
          nlines      number of lines to display (default=0: entire file)
          pixavr      number of pixels to average in range (default=1)
          pixavaz     number of pixels to average in azimuth (default=1)
          min_value   min dB value displayed (default=-3.0)
          max_value   max dB value displayed (default= 3.0)
          dB_offset   dB value subtracted from ratio (default=0.0)
          LR          L=1 normal, LR= -1 mirror image (default=1)
          abs_flag    abs_flag=0 normal, abs_flag=1 absolute value(ratio) (default=0)
          rasf        (output) ratio raster file: *.ras SUN raster format, *.bmp BMP format, *.tif TIFF format

        """
        if self.validate_inputs:
            self._validate_ras_ratio_dB(
                pwr1, pwr2, width, start_pwr1, start_pwr2, nlines, pixavr, pixavaz, min_cc, max_cc, scale, exp, LR, rasf
            )
        if self.mock_outputs:
            self._mock_ras_ratio_dB_outputs(
                pwr1, pwr2, width, start_pwr1, start_pwr2, nlines, pixavr, pixavaz, min_cc, max_cc, scale, exp, LR, rasf
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_ratio_dB))
        return self._gamma_call("LAT", "ras_ratio_dB", supplied_args)

    def _validate_linear_to_dB(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        inverse_flag: Optional[int] = None,
        null_value: Optional[Any] = None,
    ) -> None:
        self._validate("linear_to_dB", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_linear_to_dB_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        inverse_flag: Optional[int] = None,
        null_value: Optional[Any] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def linear_to_dB(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        inverse_flag: Optional[int] = None,
        null_value: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/linear_to_dB.c
        Conversion of data between linear and dB scale


        input parameters:
          data_in       (input) image data file (float)
          data_out      (output) output image data file (float)
          width         number of samples/line
          inverse_flag  flag indicating direction of conversion (default=0)
                          0: converts linear scale (input) to dB scale (output)
                          1: converts dB values (input) to linear scale (output))
          null_value    null value to use for values that are <= 0 in linear scale, default=0.0)

        """
        if self.validate_inputs:
            self._validate_linear_to_dB(data_in, data_out, width, inverse_flag, null_value)
        if self.mock_outputs:
            self._mock_linear_to_dB_outputs(data_in, data_out, width, inverse_flag, null_value)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.linear_to_dB))
        return self._gamma_call("LAT", "linear_to_dB", supplied_args)

    def _validate_histogram(
        self,
        data_in: Path,
        width: int,
        polygon: Path,
        hist: Path,
        stat: Path,
        min: Any,
        max: Any,
        nbins: Optional[int] = None,
        mode: Optional[int] = None,
        lin_log: Optional[int] = None,
    ) -> None:
        self._validate("histogram", data_in.exists(), f"data_in path does not exist ({data_in})")
        self._validate("histogram", polygon.exists(), f"polygon path does not exist ({polygon})")

    def _mock_histogram_outputs(
        self,
        data_in: Path,
        width: int,
        polygon: Path,
        hist: Path,
        stat: Path,
        min: Any,
        max: Any,
        nbins: Optional[int] = None,
        mode: Optional[int] = None,
        lin_log: Optional[int] = None,
    ) -> None:
        if hist is not None and str(hist) != "-":
            hist.touch()
        if stat is not None and str(stat) != "-":
            stat.touch()

    def histogram(
        self,
        data_in: Path,
        width: int,
        polygon: Path,
        hist: Path,
        stat: Path,
        min: Any,
        max: Any,
        nbins: Optional[int] = None,
        mode: Optional[int] = None,
        lin_log: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/histogram.c
        Calculate histogram for a set of polygonal regions (FLOAT)


        input parameters:
          data_in     (input) input data (float)
          width       number of samples/line
          polygon     (input) polygon data file containing vertices of N polygons (enter - to use all the input data)
          hist        (output) histogram values as a table (text format)
                      format: data_value  data_fraction[0]  data_fraction[1]....data_fraction[N-1]
          stat        (output) mean, standard deviation, and sum of values (text format)
                      format: POLYGON:  ID   mean   standard_deviation  sum
          min         minimum histogram value
          max         maximum histogram value
          nbins       number of histogram bins (enter - for default: 50)
          mode        processing mode (enter - for default)
                        0: histogram and statistics are calculated for each polygonal region (default)
                        1: histogram and statistics are calculated for samples within the union of all the polygonal regions
          lin_log     data scaling (enter - for default)
                        0: linear scaling (default)
                        1: data are logarithmic scale (dB values)

        """
        if self.validate_inputs:
            self._validate_histogram(data_in, width, polygon, hist, stat, min, max, nbins, mode, lin_log)
        if self.mock_outputs:
            self._mock_histogram_outputs(data_in, width, polygon, hist, stat, min, max, nbins, mode, lin_log)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.histogram))
        return self._gamma_call("LAT", "histogram", supplied_args)

    def _validate_gamma_map(
        self, input_data: Path, output_data: Path, width: int, nlooks: int, bx: Any, by: Optional[Any] = None
    ) -> None:
        self._validate("gamma_map", input_data.exists(), f"input_data path does not exist ({input_data})")

    def _mock_gamma_map_outputs(
        self, input_data: Path, output_data: Path, width: int, nlooks: int, bx: Any, by: Optional[Any] = None
    ) -> None:
        if output_data is not None and str(output_data) != "-":
            output_data.touch()

    def gamma_map(
        self, input_data: Path, output_data: Path, width: int, nlooks: int, bx: Any, by: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        LAT gamma_map: Gamma Map Filter (Lopes et al., 1990)


        input parameters:
          input_data   (input) input intensity file
          output_data  (output) output intensity file (filtered)
          width        number of samples/row
          nlooks       effective number of look of the input data
          bx           filter size in x direction (columns) (1,3,5...)
          by           filter size in y direction (rows) (1,3,5...) (enter - for default: by = bx)

        """
        if self.validate_inputs:
            self._validate_gamma_map(input_data, output_data, width, nlooks, bx, by)
        if self.mock_outputs:
            self._mock_gamma_map_outputs(input_data, output_data, width, nlooks, bx, by)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.gamma_map))
        return self._gamma_call("LAT", "gamma_map", supplied_args)

    def _validate_m_chi(self, s0: Path, m: Path, s2chi: Path, S_par: Path, c1: Path, c3: Path) -> None:
        self._validate("m-chi", s0.exists(), f"s0 path does not exist ({s0})")
        self._validate("m-chi", m.exists(), f"m path does not exist ({m})")
        self._validate("m-chi", s2chi.exists(), f"s2chi path does not exist ({s2chi})")
        self._validate("m-chi", S_par.exists(), f"S_par path does not exist ({S_par})")

    def _mock_m_chi_outputs(self, s0: Path, m: Path, s2chi: Path, S_par: Path, c1: Path, c3: Path) -> None:
        if c1 is not None and str(c1) != "-":
            c1.touch()
        if c3 is not None and str(c3) != "-":
            c3.touch()

    def m_chi(self, s0: Path, m: Path, s2chi: Path, S_par: Path, c1: Path, c3: Path) -> Tuple[int, str, str]:
        """

        Calculate m-chi decomposition from Stokes parameters


        input parameters:
          s0     (input) Stokes parameter for the total power in the H and V polarizations <|E_h|**2 + |E_v|**2>
          m      (input) degree of polarization: sqrt(s1**2 + s2**2 + s3**2)/s0 (float)
          s2chi  (input) sin(2*chi) = s3/(m*s0), 2*chi: latitude of the Stokes vector on the Poincare sphere
                    sin(2*chi) > 0  measured field is LCP
                    sin(2*chi) < 0  measured field is RCP
          S_par  (input) MLI image parameter file associated with the Stokes parameter data files
          c1     (output) s0 * m * (1 + sin(2*chi))/2 (float)
          c2     (output) s0 * (1.0-m) depolarized component (float)
          c3     (output) s0 * m * (1 - sin(2*chi))/2 (float)
        """
        if self.validate_inputs:
            self._validate_m_chi(s0, m, s2chi, S_par, c1, c3)
        if self.mock_outputs:
            self._mock_m_chi_outputs(s0, m, s2chi, S_par, c1, c3)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.m_chi))
        return self._gamma_call("LAT", "m-chi", supplied_args)

    def _validate_reallks(
        self,
        image: Path,
        ML_image: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        r_start: Optional[Any] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        self._validate("reallks", image.exists(), f"image path does not exist ({image})")

    def _mock_reallks_outputs(
        self,
        image: Path,
        ML_image: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        r_start: Optional[Any] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        if ML_image is not None and str(ML_image) != "-":
            ML_image.touch()

    def reallks(
        self,
        image: Path,
        ML_image: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[int] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        r_start: Optional[Any] = None,
        nsamp: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/reallks.c

        Multilooking for real valued image data


        input parameters:
          image     (input) 4-byte/value float input file
          ML_image  (output) 4-byte/value float output file
          width     width of image
          rlks      number of range looks (default=1)
          azlks     number of azimuth looks (default=1)
          start     starting line (default=1)
          nlines    number of lines (default=entire file, 0 for entire file)
          r_start   starting range (default=1)
          nsamp     number of range samples to extract (default = to end of line)

        """
        if self.validate_inputs:
            self._validate_reallks(image, ML_image, width, rlks, azlks, start, nlines, r_start, nsamp)
        if self.mock_outputs:
            self._mock_reallks_outputs(image, ML_image, width, rlks, azlks, start, nlines, r_start, nsamp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.reallks))
        return self._gamma_call("LAT", "reallks", supplied_args)

    def _validate_frost(
        self,
        pwr1: Path,
        pwr1_frost: Path,
        width: int,
        fx: Optional[Any] = None,
        sx: Optional[Any] = None,
        power: Optional[Any] = None,
    ) -> None:
        self._validate("frost", pwr1.exists(), f"pwr1 path does not exist ({pwr1})")

    def _mock_frost_outputs(
        self,
        pwr1: Path,
        pwr1_frost: Path,
        width: int,
        fx: Optional[Any] = None,
        sx: Optional[Any] = None,
        power: Optional[Any] = None,
    ) -> None:
        if pwr1_frost is not None and str(pwr1_frost) != "-":
            pwr1_frost.touch()

    def frost(
        self,
        pwr1: Path,
        pwr1_frost: Path,
        width: int,
        fx: Optional[Any] = None,
        sx: Optional[Any] = None,
        power: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT frost: Minimum mean square error filter (similar to Frost et al., 1982)


        input parameters:
          pwr1        (input) intensity image (float)
          pwr1_frost  (output) filtered intensity image (float)
          width       number of samples/row
          fx          filter size (enter - for default: 5)
          sx          window size used for statistics (enter - for default: 5)
          power       exponent applied to window size parameter alpha (enter - for default: 1.0 for model by Frost et al., 1982)

        """
        if self.validate_inputs:
            self._validate_frost(pwr1, pwr1_frost, width, fx, sx, power)
        if self.mock_outputs:
            self._mock_frost_outputs(pwr1, pwr1_frost, width, fx, sx, power)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.frost))
        return self._gamma_call("LAT", "frost", supplied_args)

    def _validate_mt_lee_filt(
        self,
        im_list: Path,
        ref_image: Path,
        width: int,
        winsz: Any,
        L_ref: int,
        L: Any,
        cthres: Any,
        out_list: Path,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> None:
        self._validate("mt_lee_filt", im_list.exists(), f"im_list path does not exist ({im_list})")
        self._validate("mt_lee_filt", ref_image.exists(), f"ref_image path does not exist ({ref_image})")
        self._validate("mt_lee_filt", out_list.exists(), f"out_list path does not exist ({out_list})")

    def _mock_mt_lee_filt_outputs(
        self,
        im_list: Path,
        ref_image: Path,
        width: int,
        winsz: Any,
        L_ref: int,
        L: Any,
        cthres: Any,
        out_list: Path,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> None:
        if ref_out is not None and str(ref_out) != "-":
            ref_out.touch()
        if b_coeff is not None and str(b_coeff) != "-":
            b_coeff.touch()
        if filt_num is not None and str(filt_num) != "-":
            filt_num.touch()
        if msr is not None and str(msr) != "-":
            msr.touch()
        if ctr is not None and str(ctr) != "-":
            ctr.touch()

    def mt_lee_filt(
        self,
        im_list: Path,
        ref_image: Path,
        width: int,
        winsz: Any,
        L_ref: int,
        L: Any,
        cthres: Any,
        out_list: Path,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/mt_lee_filt
        Multi-temporal direction Lee adaptive filter


        input parameters:
          im_list    (input) text file with names of co-registered FLOAT images including path (enter - for none)
          ref_image  (input) reference image used to generate the filter weights (FLOAT)
                     NOTE: the reference scene should have the same dimensions as the data files in the im_list
          width      number of samples/line
          winsz      size of the Lee filter window (valid values: 7, 13, 19)
          L_ref      effective number of looks (ENL) in the reference image (FLOAT)
          L          ENL of the images in the im_list used for local determination of the MMSE weight for each image in the im_list (FLOAT)
                     NOTE: enter - to use the MMSE filter weight derived from the reference image for all images in the im_list
          cthres     directional contrast threshold to determine if the directional filter should be applied (0->4) (enter - for default: 1.500)
                     NOTE: setting cthres=0.0, forces the directional filter to be used at all times, setting cthres=4.0 blocks all directional filtering
          out_list   (input) list of filtered output data files, number of entries in the im_list and out_list must match (enter - for none)
          ref_out    (output) filtered reference image (FLOAT) (enter - for none)
          b_coeff    (output) MMSE weighting coefficient calculated from the mean to sigma ratio and L for each sample (FLOAT) (enter - for none)
          filt_num   (output) selected structural filter number (0-->7) (BYTE) (enter - for none)
          msr        (output) mean/sigma ratio where the mean is the local mean and sigma the local standard deviation of the intensity image in the filter window (enter - for none)
          ctr        (output) directional contrast estimate used to determine if the directional filter is applied (enter - for none)

        """
        if self.validate_inputs:
            self._validate_mt_lee_filt(
                im_list, ref_image, width, winsz, L_ref, L, cthres, out_list, ref_out, b_coeff, filt_num, msr, ctr
            )
        if self.mock_outputs:
            self._mock_mt_lee_filt_outputs(
                im_list, ref_image, width, winsz, L_ref, L, cthres, out_list, ref_out, b_coeff, filt_num, msr, ctr
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mt_lee_filt))
        return self._gamma_call("LAT", "mt_lee_filt", supplied_args)

    def _validate_multi_stat(
        self, im_list: Path, width: int, im_out: Path, mode: int, rank: Any, nmin: Optional[int] = None
    ) -> None:
        self._validate("multi_stat", im_list.exists(), f"im_list path does not exist ({im_list})")

    def _mock_multi_stat_outputs(
        self, im_list: Path, width: int, im_out: Path, mode: int, rank: Any, nmin: Optional[int] = None
    ) -> None:
        if im_out is not None and str(im_out) != "-":
            im_out.touch()

    def multi_stat(
        self, im_list: Path, width: int, im_out: Path, mode: int, rank: Any, nmin: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/multi_stat
        Sort MLI image values in a stack and specify the rank of the output image


        input parameters:
          im_list  (input) text file with names of co-registered FLOAT images including path
          width    number of samples/line
          im_out   (output) output filtered image (FLOAT)
          mode     data selection mode:
                     0: average
                     1: median
                     2: rank relative to minimum, rank=1 for minimum
                     3: rank relative to maximum, rank=1 for maximum
                     4: percentile, 0 (minimum) --> 100 (maximum)
          rank     rank value in modes 2 and 3, percentile in mode 4 (0-->100), ignored for average or median
          nmin     minimum number of valid image values required to sort (enter - for default: nfiles/2)

        """
        if self.validate_inputs:
            self._validate_multi_stat(im_list, width, im_out, mode, rank, nmin)
        if self.mock_outputs:
            self._mock_multi_stat_outputs(im_list, width, im_out, mode, rank, nmin)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_stat))
        return self._gamma_call("LAT", "multi_stat", supplied_args)

    def _validate_trigo(self, data1: Path, func: int, data2: Path, width: int) -> None:
        self._validate("trigo", data1.exists(), f"data1 path does not exist ({data1})")

    def _mock_trigo_outputs(self, data1: Path, func: int, data2: Path, width: int) -> None:
        if data2 is not None and str(data2) != "-":
            data2.touch()

    def trigo(self, data1: Path, func: int, data2: Path, width: int) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/trigo.c

        Compute trigonometric functions of an input file


        input parameters:
          data1  (input) angle data in radians (float)
          func   1: sin, 2: cos, 3: tan, 4: asin, 5: acos, 6:atan
          data2  (output) data calculated as func(data1) (float)
          width  number of samples/line

        """
        if self.validate_inputs:
            self._validate_trigo(data1, func, data2, width)
        if self.mock_outputs:
            self._mock_trigo_outputs(data1, func, data2, width)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.trigo))
        return self._gamma_call("LAT", "trigo", supplied_args)

    def _validate_temp_filt(
        self,
        data_tab: Path,
        width: int,
        wy: Optional[Any] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("temp_filt", data_tab.exists(), f"data_tab path does not exist ({data_tab})")

    def _mock_temp_filt_outputs(
        self,
        data_tab: Path,
        width: int,
        wy: Optional[Any] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        pass

    def temp_filt(
        self,
        data_tab: Path,
        width: int,
        wy: Optional[Any] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/temp_filt
        Multi-temporal filtering of registered data sets of FLOAT format data

        input parameters:
          data_tab   (input) two column list of the names of input and output data files (FLOAT)
                       input file 1   output file 1
                       input file 2   output file 2
                        ...            ...
          width      number of samples/row
          wy         spatial averaging filter height (enter - for default:  5.00)
          wx         spatial averaging filter width (enter - for default:  5.00)
          wt_flag    weighting function flag (enter - for default)
                       0: uniform (default)
                       1: linear
                       2: Gaussian
          zflag      zero data flag (enter - for default)
                       0: 0.0 interpreted as missing value (default)
                       1: 0.0 interpreted as valid data value
          loff       number of lines offset to starting line (enter - for default: 0)
          nlines     number of lines to process (enter - or 0 for default: entire file)

        """
        if self.validate_inputs:
            self._validate_temp_filt(data_tab, width, wy, wx, wt_flag, zflag, loff, nlines)
        if self.mock_outputs:
            self._mock_temp_filt_outputs(data_tab, width, wy, wx, wt_flag, zflag, loff, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.temp_filt))
        return self._gamma_call("LAT", "temp_filt", supplied_args)

    def _validate_cpxlks(
        self,
        CMPLX: Path,
        ML_CMPLX: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        r_start: Optional[Any] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        self._validate("cpxlks", CMPLX.exists(), f"CMPLX path does not exist ({CMPLX})")

    def _mock_cpxlks_outputs(
        self,
        CMPLX: Path,
        ML_CMPLX: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        r_start: Optional[Any] = None,
        nsamp: Optional[int] = None,
    ) -> None:
        if ML_CMPLX is not None and str(ML_CMPLX) != "-":
            ML_CMPLX.touch()

    def cpxlks(
        self,
        CMPLX: Path,
        ML_CMPLX: Path,
        width: int,
        rlks: Optional[int] = None,
        azlks: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        r_start: Optional[Any] = None,
        nsamp: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT cpxlks: Multilooking of complex valued image


        input parameters:
          CMPLX     (input) fcomplex image file
          ML_CMPLX  (output) output multilook fcomplex image file
          width     width of complex image
          rlks      number of range looks (default=1)
          azlks     number azimuth looks (default=1)
          start     starting line (default=1)
          nlines    number of lines (default=entire file, 0 for entire file)
          r_start   starting range (default=1)
          nsamp     number of range samples to extract (default = to end of line)

        """
        if self.validate_inputs:
            self._validate_cpxlks(CMPLX, ML_CMPLX, width, rlks, azlks, start, nlines, r_start, nsamp)
        if self.mock_outputs:
            self._mock_cpxlks_outputs(CMPLX, ML_CMPLX, width, rlks, azlks, start, nlines, r_start, nsamp)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cpxlks))
        return self._gamma_call("LAT", "cpxlks", supplied_args)

    def _validate_ras_to_rgb(
        self,
        red_channel: Path,
        green_channel: Path,
        blue_channel: Path,
        ras_out: Path,
        LR: Optional[Any] = None,
        null_flag: Optional[int] = None,
    ) -> None:
        pass

    def _mock_ras_to_rgb_outputs(
        self,
        red_channel: Path,
        green_channel: Path,
        blue_channel: Path,
        ras_out: Path,
        LR: Optional[Any] = None,
        null_flag: Optional[int] = None,
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_to_rgb(
        self,
        red_channel: Path,
        green_channel: Path,
        blue_channel: Path,
        ras_out: Path,
        LR: Optional[Any] = None,
        null_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program ras_to_rgb.c
        Combine 3 raster images (SUN, BMP, or TIFF format)  into a composite 24-bit RGB (red/green/blue) image


        input parameters:
          red channel     (input) red channel 8-bit raster image (SUN, BMP, or TIFF format)
          green channel   (input) green channel 8-bit raster image (SUN, BMP, or TIFF format)
          blue channel    (input) blue channel 8-bit raster image (SUN, BMP, or TIFF format)
          ras_out         (output) RGB 24-bit composite raster image (SUN, BMP, or TIFF format)
          LR              image mirror flag (enter - for default)
                            1: normal (default)
                           -1: mirror image
          null_flag       zero value flag (enter - for default)
                            0: same as other data (default)
                            1: if one channel is 0, set to (0,0,0)

        """
        if self.validate_inputs:
            self._validate_ras_to_rgb(red_channel, green_channel, blue_channel, ras_out, LR, null_flag)
        if self.mock_outputs:
            self._mock_ras_to_rgb_outputs(red_channel, green_channel, blue_channel, ras_out, LR, null_flag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_to_rgb))
        return self._gamma_call("LAT", "ras_to_rgb", supplied_args)

    def _validate_ave2pwr(
        self, pwr1: Path, pwr2: Path, pwr_out: Path, width: int, scale_factor: Optional[Any] = None
    ) -> None:
        self._validate("ave2pwr", pwr1.exists(), f"pwr1 path does not exist ({pwr1})")
        self._validate("ave2pwr", pwr2.exists(), f"pwr2 path does not exist ({pwr2})")

    def _mock_ave2pwr_outputs(
        self, pwr1: Path, pwr2: Path, pwr_out: Path, width: int, scale_factor: Optional[Any] = None
    ) -> None:
        if pwr_out is not None and str(pwr_out) != "-":
            pwr_out.touch()

    def ave2pwr(
        self, pwr1: Path, pwr2: Path, pwr_out: Path, width: int, scale_factor: Optional[Any] = None
    ) -> Tuple[int, str, str]:
        """

        LAT ave2pwr: Averaging of two co-registered intensity images


        input parameters:
          pwr1          (input) intensity image 1 (float)
          pwr2          (input) intensity image 2 (float)
          pwr_out       (output) output file: (pwr1 + scale_factor*pwr2)/2.
          width         number of samples/row for the input files
          scale_factor  scale factor for image 2 (absolute value, not dB) (default: 1.0)

        """
        if self.validate_inputs:
            self._validate_ave2pwr(pwr1, pwr2, pwr_out, width, scale_factor)
        if self.mock_outputs:
            self._mock_ave2pwr_outputs(pwr1, pwr2, pwr_out, width, scale_factor)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ave2pwr))
        return self._gamma_call("LAT", "ave2pwr", supplied_args)

    def _validate_ras_m_chi(
        self,
        s1: Path,
        c1: Path,
        c2: Path,
        c3: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        self._validate("ras_m-chi", s1.exists(), f"s1 path does not exist ({s1})")
        self._validate("ras_m-chi", c1.exists(), f"c1 path does not exist ({c1})")
        self._validate("ras_m-chi", c2.exists(), f"c2 path does not exist ({c2})")
        self._validate("ras_m-chi", c3.exists(), f"c3 path does not exist ({c3})")

    def _mock_ras_m_chi_outputs(
        self,
        s1: Path,
        c1: Path,
        c2: Path,
        c3: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> None:
        if rasf is not None and str(rasf) != "-":
            rasf.touch()

    def ras_m_chi(
        self,
        s1: Path,
        c1: Path,
        c2: Path,
        c3: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixavr: Optional[int] = None,
        pixavaz: Optional[int] = None,
        scale: Optional[Any] = None,
        exp: Optional[Any] = None,
        rasf: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/ras_m-chi
        Generate 24-bit RGB raster image of the polarimetric m-chi decomposition


        input parameters:
          s1       (input) Stokes parameter for the total power in the H and V polarizations <|E_h|**2 + |E_v|**2>
          c1       (input) CRTLR double-bounce scattering fraction component: m*(1+sin(2*chi))/2) (red channel)
          c2       (input) random polarized fraction component: (1.0-m) (green channel)
          c3       (input) CRTLR single-bounce scattering fraction component: m*(1-sin(2*chi))/2 (blue channel)
          width    number of samples/row in the input data files
          start    starting line (enter - for default: 1
          nlines   number of lines (enter - for default: to end of file)
          pixavr   number of pixels to average in range (default: 1)
          pixavaz  number of pixels to average in azimuth (default: 1)
          scale    pwr display scale factor (default: 1.)
          exp      pwr display exponent (default: 0.5)
          rasf     (output) image filename, enter - for default, extension determines format:
                     *.ras Sun raster format
                     *.bmp BMP format
                     *.tif TIFF format

        """
        if self.validate_inputs:
            self._validate_ras_m_chi(s1, c1, c2, c3, width, start, nlines, pixavr, pixavaz, scale, exp, rasf)
        if self.mock_outputs:
            self._mock_ras_m_chi_outputs(s1, c1, c2, c3, width, start, nlines, pixavr, pixavaz, scale, exp, rasf)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_m_chi))
        return self._gamma_call("LAT", "ras_m-chi", supplied_args)

    def _validate_sigma2gamma(self, sigma0: Path, inc: Path, gamma0: Path, width: int) -> None:
        self._validate("sigma2gamma", sigma0.exists(), f"sigma0 path does not exist ({sigma0})")
        self._validate("sigma2gamma", inc.exists(), f"inc path does not exist ({inc})")

    def _mock_sigma2gamma_outputs(self, sigma0: Path, inc: Path, gamma0: Path, width: int) -> None:
        if gamma0 is not None and str(gamma0) != "-":
            gamma0.touch()

    def sigma2gamma(self, sigma0: Path, inc: Path, gamma0: Path, width: int) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/sigma2gamma.c

        Compute backscatter coefficient gamma0 (sigma0)/cos(inc)


        input parameters:
          sigma0  (input)  normalized radar cross-section sigma0
          inc     (input)  local incidence angles (radians)
          gamma0  (output) normalized radar cross-section gamma0 = sigma0 / cos(inc)
          width   number of samples/line
        """
        if self.validate_inputs:
            self._validate_sigma2gamma(sigma0, inc, gamma0, width)
        if self.mock_outputs:
            self._mock_sigma2gamma_outputs(sigma0, inc, gamma0, width)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.sigma2gamma))
        return self._gamma_call("LAT", "sigma2gamma", supplied_args)

    def _validate_hsi_color_scale(
        self,
        file_out: Path,
        nval: Optional[int] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        height: Optional[int] = None,
    ) -> None:
        pass

    def _mock_hsi_color_scale_outputs(
        self,
        file_out: Path,
        nval: Optional[int] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        height: Optional[int] = None,
    ) -> None:
        if file_out is not None and str(file_out) != "-":
            file_out.touch()

    def hsi_color_scale(
        self,
        file_out: Path,
        nval: Optional[int] = None,
        chip_width: Optional[int] = None,
        gap: Optional[int] = None,
        height: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program hsi_color_scale.c
        Generate color scale for hue/saturation/intensity (HSI) images


        input parameters:
          file_out     (output) (24-bit) SUN/BMP/TIFF format raster image
          nval         number of discrete color values to display (enter - for default)
                         0: continuous color wheel (default)
          chip_width   width of color chips (enter - for default: 16)
          gap          number of pixels between color chips (enter - for default: 2)
          height       height of color scale (enter - for default: chip_width)

        """
        if self.validate_inputs:
            self._validate_hsi_color_scale(file_out, nval, chip_width, gap, height)
        if self.mock_outputs:
            self._mock_hsi_color_scale_outputs(file_out, nval, chip_width, gap, height)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.hsi_color_scale))
        return self._gamma_call("LAT", "hsi_color_scale", supplied_args)

    def _validate_unw_to_cpx(self, unw: Path, cpx: Path, width: int) -> None:
        self._validate("unw_to_cpx", unw.exists(), f"unw path does not exist ({unw})")

    def _mock_unw_to_cpx_outputs(self, unw: Path, cpx: Path, width: int) -> None:
        if cpx is not None and str(cpx) != "-":
            cpx.touch()

    def unw_to_cpx(self, unw: Path, cpx: Path, width: int) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/unw_to_cpx.c
        convert unwrapped phase to an fcomplex interferogram


        input parameters:
          unw    (input) unwrapped phase (float)
          cpx    (output) interferogram file (fcomplex)
          width  samples per row
        """
        if self.validate_inputs:
            self._validate_unw_to_cpx(unw, cpx, width)
        if self.mock_outputs:
            self._mock_unw_to_cpx_outputs(unw, cpx, width)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.unw_to_cpx))
        return self._gamma_call("LAT", "unw_to_cpx", supplied_args)

    def _validate_polyx(
        self,
    ) -> None:
        pass

    def _mock_polyx_outputs(
        self,
    ) -> None:
        pass

    def polyx(
        self,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/polyx
        Calculate statistics of data within polygonal regions


          input parameters:
          data    (input) data file (float)
          width   image width in range pixels
          poly    (input) polygon description file
          report  (output) report on region statistics (text format)
          mode    report print mode
                     0: i, mean, stdev (linear scale) (default)
                     1: i, mean, stdev (dB scale)
                     2: i, mean (linear scale)
                     3: i, mean (dB scale)
                     4: mean    (linear scale)
                     5: mean    (dB scale)
                     6: stdev   (linear scale)
                     7: stdev   (dB scale)
                     8: i, mean, stdev (linear scale, with exponent)
        """
        if self.validate_inputs:
            self._validate_polyx()
        if self.mock_outputs:
            self._mock_polyx_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polyx))
        return self._gamma_call("LAT", "polyx", supplied_args)

    def _validate_pauli(
        self, SLC_HH: Path, SLC_VV: Path, SLC_HV: Path, SLC_HH_par: Path, SLC_VV_par: Path, SLC_HV_par: Path, P: Path
    ) -> None:
        self._validate("pauli", SLC_HH.exists(), f"SLC_HH path does not exist ({SLC_HH})")
        self._validate("pauli", SLC_VV.exists(), f"SLC_VV path does not exist ({SLC_VV})")
        self._validate("pauli", SLC_HV.exists(), f"SLC_HV path does not exist ({SLC_HV})")
        self._validate("pauli", SLC_HH_par.exists(), f"SLC_HH_par path does not exist ({SLC_HH_par})")
        self._validate("pauli", SLC_VV_par.exists(), f"SLC_VV_par path does not exist ({SLC_VV_par})")
        self._validate("pauli", SLC_HV_par.exists(), f"SLC_HV_par path does not exist ({SLC_HV_par})")

    def _mock_pauli_outputs(
        self, SLC_HH: Path, SLC_VV: Path, SLC_HV: Path, SLC_HH_par: Path, SLC_VV_par: Path, SLC_HV_par: Path, P: Path
    ) -> None:
        if P is not None and str(P) != "-":
            P.touch()

    def pauli(
        self, SLC_HH: Path, SLC_VV: Path, SLC_HV: Path, SLC_HH_par: Path, SLC_VV_par: Path, SLC_HV_par: Path, P: Path
    ) -> Tuple[int, str, str]:
        """

        Calculate Pauli polarimetric decomposition from HH, VV, and HV SLC images


        input parameters:
          SLC_HH      (input) HH single-look complex image (scomplex or fcomplex format)
          SLC_VV      (input) VV single-look complex image coregistered with SLC_HH (scomplex or fcomplex format)
          SLC_HV      (input) HV single-look complex image coregistered with SLC_HH (scomplex or fcomplex format)
          SLC_HH_par  (input) SLC_HH image parameter file
          SLC_VV_par  (input) SLC_VV image parameter file
          SLC_HV_par  (input) SLC_HV image parameter file
          P           (output) root file name of Pauli decomposition images: P_alpha.slc, P_beta.slc, P_gamma.slc (fcomplex format)
                        alpha: (S_HH + S_VV)/sqrt(2.0)
                        beta:  (S_HH - S_VV)/sqrt(2.0)
                        gamma: sqrt(2.0)*S_HV
          Note: SLC image parameter files are generated: P_alpha.slc.par, P_beta.slc.par, P_gamma.slc.par
        """
        if self.validate_inputs:
            self._validate_pauli(SLC_HH, SLC_VV, SLC_HV, SLC_HH_par, SLC_VV_par, SLC_HV_par, P)
        if self.mock_outputs:
            self._mock_pauli_outputs(SLC_HH, SLC_VV, SLC_HV, SLC_HH_par, SLC_VV_par, SLC_HV_par, P)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.pauli))
        return self._gamma_call("LAT", "pauli", supplied_args)

    def _validate_m_alpha(self, s0: Path, m: Path, alpha: Path, S_par: Path, c1: Path, c3: Path) -> None:
        self._validate("m-alpha", s0.exists(), f"s0 path does not exist ({s0})")
        self._validate("m-alpha", m.exists(), f"m path does not exist ({m})")
        self._validate("m-alpha", alpha.exists(), f"alpha path does not exist ({alpha})")
        self._validate("m-alpha", S_par.exists(), f"S_par path does not exist ({S_par})")

    def _mock_m_alpha_outputs(self, s0: Path, m: Path, alpha: Path, S_par: Path, c1: Path, c3: Path) -> None:
        if c1 is not None and str(c1) != "-":
            c1.touch()
        if c3 is not None and str(c3) != "-":
            c3.touch()

    def m_alpha(self, s0: Path, m: Path, alpha: Path, S_par: Path, c1: Path, c3: Path) -> Tuple[int, str, str]:
        """

        Calculate m-alpha decomposition from Stokes parameters


        input parameters:
          s0     (input) Stokes parameter for the total power in the H and V polarizations <|E_h|**2 + |E_v|**2>
          m      (input) degree of polarization: sqrt(s1**2 + s2**2 + s3**2)/s0 (float)
          alpha  (input) 0.5*atan(sqrt(s1**2 + s2**2)/s3):
                    0.0  < alpha < PI/4 LCP
                    PI/4 < alpha < PI/2 RCP
          S_par  (input) MLI image parameter file associated with the Stokes parameter data files
          c1     (output) s0 * m * (1 + cos(2*alpha))/2 (float)
          c2     (output) s0 * (1.0-m) depolarized component (float)
          c3     (output) s0 * m * (1 - cos(2*alpha))/2 (float)
        """
        if self.validate_inputs:
            self._validate_m_alpha(s0, m, alpha, S_par, c1, c3)
        if self.mock_outputs:
            self._mock_m_alpha_outputs(s0, m, alpha, S_par, c1, c3)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.m_alpha))
        return self._gamma_call("LAT", "m-alpha", supplied_args)

    def _validate_stokes(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        S: Path,
        S_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("stokes", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("stokes", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("stokes", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("stokes", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_stokes_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        S: Path,
        S_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        if S is not None and str(S) != "-":
            S.touch()
        if S_par is not None and str(S_par) != "-":
            S_par.touch()

    def stokes(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        S: Path,
        S_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate Stokes parameters from SLC images with H and V receive polarization and same transmit polarization


        input parameters:
          SLC-1     (input) HH, VV, RH, LH single-look complex image (SCOMPLEX or FCOMPLEX format)
          SLC-2     (input) HV, VH, RV, LV single-look complex image coregistered with SLC-1 (SCOMPLEX or FCOMPLEX format)
                    NOTE: 1. SLC images must be a co-pol and cross-pol pair with the same transmit polarization
                             and linear receive polarization (HH, HV), (VV, VH), (RH, RV), or (LH, LV)
                          2. SCOMPLEX SLC data are scaled according to the calibration gains indicated in the SLC parameter files
          SLC1_par  (input) SLC image parameter file of SLC-1
          SLC2_par  (input) SLC image parameter file of SLC-2 coregistered with SLC-1
          S         (output) root file name of 4 Stokes parameter files with extensions .s0, .s1, .s2, .s3 (FLOAT)
                    NOTE: expressed in the H,V polarization basis, BSA convention, the Stokes parameters are given by:
                       s0: <|E_H|**2 + |E_V|**2>
                       s1: <|E_H|**2 - |E_V|**2>
                       s2: 2Re<E_H E_V*>
                       s3: 2Im<E_H E_V*>
          S_par     (output) MLI image parameter file associated with the Stokes parameter data files (enter - for none)
          rlks      number of range looks used to calculate Stokes parameters
          azlks     number of azimuth looks used to calculate Stokes parameters
          loff      offset to starting line (enter - for default: 0)
          nlines    number of SLC lines to process (enter - for default: entire file)

        """
        if self.validate_inputs:
            self._validate_stokes(SLC_1, SLC_2, SLC1_par, SLC2_par, S, S_par, rlks, azlks, loff, nlines)
        if self.mock_outputs:
            self._mock_stokes_outputs(SLC_1, SLC_2, SLC1_par, SLC2_par, S, S_par, rlks, azlks, loff, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.stokes))
        return self._gamma_call("LAT", "stokes", supplied_args)

    def _validate_histogram_ras(
        self,
        ras_in: Path,
        polygon: Any,
        histograms: Any,
        mean_or_stdev: Any,
        percent: Any,
        lr_flag: Optional[Any] = None,
        start: Optional[Any] = None,
        stop: Optional[Any] = None,
    ) -> None:
        self._validate("histogram_ras", ras_in.exists(), f"ras_in path does not exist ({ras_in})")

    def _mock_histogram_ras_outputs(
        self,
        ras_in: Path,
        polygon: Any,
        histograms: Any,
        mean_or_stdev: Any,
        percent: Any,
        lr_flag: Optional[Any] = None,
        start: Optional[Any] = None,
        stop: Optional[Any] = None,
    ) -> None:
        pass

    def histogram_ras(
        self,
        ras_in: Path,
        polygon: Any,
        histograms: Any,
        mean_or_stdev: Any,
        percent: Any,
        lr_flag: Optional[Any] = None,
        start: Optional[Any] = None,
        stop: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/histogram_ras.c
        Calculation of histograms for polygon regions for a SUN raster or BMP format image


        input parameters:
          ras_in        (input) raster image, SUN raster *.ras, BMP *.bmp, or TIFF *.tif format, 8 bits/pixel
          polygon       polygon data file
          histograms    calculated histograms (output)
          mean/stdev    calculated mean/stdev (output)
          percent       histogram in terms of percent of total pixels (output)
          lr_flag       input left/right flipped (default=1: flipped; -1: not flipped)
          start         first histogram class (default=0)
          stop          last histogram class (default=all values)

        """
        if self.validate_inputs:
            self._validate_histogram_ras(ras_in, polygon, histograms, mean_or_stdev, percent, lr_flag, start, stop)
        if self.mock_outputs:
            self._mock_histogram_ras_outputs(ras_in, polygon, histograms, mean_or_stdev, percent, lr_flag, start, stop)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.histogram_ras))
        return self._gamma_call("LAT", "histogram_ras", supplied_args)

    def _validate_product(
        self,
        data_1: Path,
        data_2: Path,
        product: Path,
        width: int,
        bx: Optional[Any] = None,
        by: Optional[Any] = None,
        wgt_flag: Optional[int] = None,
    ) -> None:
        self._validate("product", data_1.exists(), f"data_1 path does not exist ({data_1})")
        self._validate("product", data_2.exists(), f"data_2 path does not exist ({data_2})")

    def _mock_product_outputs(
        self,
        data_1: Path,
        data_2: Path,
        product: Path,
        width: int,
        bx: Optional[Any] = None,
        by: Optional[Any] = None,
        wgt_flag: Optional[int] = None,
    ) -> None:
        if product is not None and str(product) != "-":
            product.touch()

    def product(
        self,
        data_1: Path,
        data_2: Path,
        product: Path,
        width: int,
        bx: Optional[Any] = None,
        by: Optional[Any] = None,
        wgt_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/product
        Calculate product of two images: (image 1)*(image 2)


        input parameters:
          data_1   (input) data file 1 (float)
          data_2   (input) data file 2 (float)
          product  (output) product data_1 * data_2 (float)
          width    number of samples/row
          bx       box size in range for averaging (before multiplication, default = 5)
          by       box size in azimuth for averaging (before multiplication, default = bx
          wgt_flg  weighting mode
                     0: no weighting (default)
                     1: linear weighting
                     2: gaussian weighting

        """
        if self.validate_inputs:
            self._validate_product(data_1, data_2, product, width, bx, by, wgt_flag)
        if self.mock_outputs:
            self._mock_product_outputs(data_1, data_2, product, width, bx, by, wgt_flag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.product))
        return self._gamma_call("LAT", "product", supplied_args)

    def _validate_mt_lee_filt_cpx(
        self,
        cpx_list: Path,
        ref_image: Path,
        width: int,
        winsz: Any,
        L_ref: int,
        cthres: Any,
        out_list: Path,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> None:
        self._validate("mt_lee_filt_cpx", cpx_list.exists(), f"cpx_list path does not exist ({cpx_list})")
        self._validate("mt_lee_filt_cpx", ref_image.exists(), f"ref_image path does not exist ({ref_image})")
        self._validate("mt_lee_filt_cpx", out_list.exists(), f"out_list path does not exist ({out_list})")

    def _mock_mt_lee_filt_cpx_outputs(
        self,
        cpx_list: Path,
        ref_image: Path,
        width: int,
        winsz: Any,
        L_ref: int,
        cthres: Any,
        out_list: Path,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> None:
        if ref_out is not None and str(ref_out) != "-":
            ref_out.touch()
        if b_coeff is not None and str(b_coeff) != "-":
            b_coeff.touch()
        if filt_num is not None and str(filt_num) != "-":
            filt_num.touch()
        if msr is not None and str(msr) != "-":
            msr.touch()
        if ctr is not None and str(ctr) != "-":
            ctr.touch()

    def mt_lee_filt_cpx(
        self,
        cpx_list: Path,
        ref_image: Path,
        width: int,
        winsz: Any,
        L_ref: int,
        cthres: Any,
        out_list: Path,
        ref_out: Optional[Path] = None,
        b_coeff: Optional[Path] = None,
        filt_num: Optional[Path] = None,
        msr: Optional[Path] = None,
        ctr: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/mt_lee_filt_cpx
        Multi-temporal Lee directional adaptive filter for complex data


        input parameters:
          cpx_list   (input) text file with names of co-registered FCOMPLEX data files including path (enter - for none)
          ref_image  (input) reference intensity image used to generate the filter weights (FLOAT)
                     NOTE: the reference scene should have the same dimensions as the data files in the cpx_list
          width      number of samples/line
          winsz      size of the Lee filter window (valid values: 7, 13, 19)
          L_ref      effective number of looks in the reference image (FLOAT)
          cthres     directional contrast threshold to determine if the directional filter should be applied (0->4)(enter - for default: 1.500)
                     NOTE: setting cthres=0.0, forces the directional filter to be used at all times, setting cthres=4.0 blocks all directional filtering
          out_list   (input) list of filtered output data files, number of entries in the cpx_list and out_list must match (enter - for none)
          ref_out    (output) filtered reference image (FLOAT) (enter - for none)
          b_coeff    (output) MMSE weighting coefficient calculated from the mean to sigma ratio and L for each sample in the reference image (FLOAT) (enter - for none)
          filt_num   (output) selected structural filter number (0-->7) (BYTE) (enter - for none)
          msr        (output) mean/sigma ratio where the mean is the local mean and sigma the local standard deviation of the intensity image in the filter window (enter - for none)
          ctr        (output) directional contrast estimate used to determine if the directional filter is applied (enter - for none)

        """
        if self.validate_inputs:
            self._validate_mt_lee_filt_cpx(
                cpx_list, ref_image, width, winsz, L_ref, cthres, out_list, ref_out, b_coeff, filt_num, msr, ctr
            )
        if self.mock_outputs:
            self._mock_mt_lee_filt_cpx_outputs(
                cpx_list, ref_image, width, winsz, L_ref, cthres, out_list, ref_out, b_coeff, filt_num, msr, ctr
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mt_lee_filt_cpx))
        return self._gamma_call("LAT", "mt_lee_filt_cpx", supplied_args)

    def _validate_polcovar(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        C: Path,
        C_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("polcovar", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("polcovar", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("polcovar", SLC_3.exists(), f"SLC_3 path does not exist ({SLC_3})")
        self._validate("polcovar", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("polcovar", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("polcovar", SLC3_par.exists(), f"SLC3_par path does not exist ({SLC3_par})")

    def _mock_polcovar_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        C: Path,
        C_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        if C is not None and str(C) != "-":
            C.touch()
        if C_par is not None and str(C_par) != "-":
            C_par.touch()

    def polcovar(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        C: Path,
        C_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate covariance matrix C elements from HH, HV, and VV SLC data


        input parameters:
          SLC-1     (input) HH single-look complex image (scomplex or fcomplex format)
          SLC-2     (input) HV single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC-3     (input) VV single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC1_par  (input) HH SLC image parameter file of SLC-1
          SLC2_par  (input) HV SLC image parameter file of SLC-2 coregistered with SLC-1
          SLC3_par  (input) VV SLC image parameter file of SLC-3 coregistered with SLC-1
          C         (output) root file name of covariance matrix C_3 elements (e.g. scene_id): .c11, .c22, .c33 (float), .c12, .c13, .c23 (fcomplex)
          C_par     (output) MLI image parameter file associated with the covariance matrix element data files
          rlks      number of range looks used to calculate covariances
          azlks     number of azimuth looks used to calculate covariance
          loff      offset to starting line (default: 0)
          nlines    number of SLC lines to process (enter - for default: entire file)

        """
        if self.validate_inputs:
            self._validate_polcovar(
                SLC_1, SLC_2, SLC_3, SLC1_par, SLC2_par, SLC3_par, C, C_par, rlks, azlks, loff, nlines
            )
        if self.mock_outputs:
            self._mock_polcovar_outputs(
                SLC_1, SLC_2, SLC_3, SLC1_par, SLC2_par, SLC3_par, C, C_par, rlks, azlks, loff, nlines
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polcovar))
        return self._gamma_call("LAT", "polcovar", supplied_args)

    def _validate_stokes_qm(
        self,
        S: Path,
        S_par: Path,
        m: Optional[Path] = None,
        s2chi: Optional[Path] = None,
        s2psi: Optional[Path] = None,
        m_l: Optional[Path] = None,
        m_c: Optional[Path] = None,
        lp_ratio: Optional[Path] = None,
        cp_ratio: Optional[Path] = None,
        mu: Optional[Path] = None,
        delta: Optional[Path] = None,
        alpha: Optional[Path] = None,
        phi: Optional[Path] = None,
    ) -> None:
        self._validate("stokes_qm", S.exists(), f"S path does not exist ({S})")
        self._validate("stokes_qm", S_par.exists(), f"S_par path does not exist ({S_par})")

    def _mock_stokes_qm_outputs(
        self,
        S: Path,
        S_par: Path,
        m: Optional[Path] = None,
        s2chi: Optional[Path] = None,
        s2psi: Optional[Path] = None,
        m_l: Optional[Path] = None,
        m_c: Optional[Path] = None,
        lp_ratio: Optional[Path] = None,
        cp_ratio: Optional[Path] = None,
        mu: Optional[Path] = None,
        delta: Optional[Path] = None,
        alpha: Optional[Path] = None,
        phi: Optional[Path] = None,
    ) -> None:
        if m is not None and str(m) != "-":
            m.touch()
        if s2chi is not None and str(s2chi) != "-":
            s2chi.touch()
        if s2psi is not None and str(s2psi) != "-":
            s2psi.touch()
        if m_l is not None and str(m_l) != "-":
            m_l.touch()
        if m_c is not None and str(m_c) != "-":
            m_c.touch()
        if lp_ratio is not None and str(lp_ratio) != "-":
            lp_ratio.touch()
        if cp_ratio is not None and str(cp_ratio) != "-":
            cp_ratio.touch()
        if mu is not None and str(mu) != "-":
            mu.touch()
        if delta is not None and str(delta) != "-":
            delta.touch()
        if alpha is not None and str(alpha) != "-":
            alpha.touch()
        if phi is not None and str(phi) != "-":
            phi.touch()

    def stokes_qm(
        self,
        S: Path,
        S_par: Path,
        m: Optional[Path] = None,
        s2chi: Optional[Path] = None,
        s2psi: Optional[Path] = None,
        m_l: Optional[Path] = None,
        m_c: Optional[Path] = None,
        lp_ratio: Optional[Path] = None,
        cp_ratio: Optional[Path] = None,
        mu: Optional[Path] = None,
        delta: Optional[Path] = None,
        alpha: Optional[Path] = None,
        phi: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate quantitative measures derived from Stokes parameters (e.g. degree of polarization)


        input parameters:
          S         (input) root file name of 4 Stokes parameter files with extensions .s0, .s1, .s2, .s3 (FLOAT)
          S_par     (input) image parameter file associated with the Stokes parameter data files
          m         (output) degree of polarization: sqrt(s1**2 + s2**2 + s3**2)/s0 (enter - for none) (FLOAT)
          s2chi     (output) sine of the latitude of the Stokes vector on the Poincare sphere: sin(2*chi) = s3/(m*s0)
          s2psi     (output) sine of the longitude of the Stokes vector on the Poincare sphere: sin(2*psi) = s2/sqrt(s1**2 + s2**2))
          m_l       (output) degree of linear polarization: sqrt(s1**2 + s2**2)/s0  (enter - for none) (FLOAT)
          m_c       (output) degree of circular polarization: s3/s0 (enter - for none) (FLOAT)
          lp_ratio  (output) linear polarization ratio: (s0 - s1)/(s0 + s1), 0 <= lp_ratio (enter - for none) (FLOAT)
          cp_ratio  (output) circular polarization ratio: (s0 - s3)/(s0 + s3), 0 <= cp_ratio (enter - for none) (FLOAT)
          mu        (output) coherency parameter |mu_xy|: sqrt(s2**2 + s3**2)/sqrt(s0**2 - s1**2) (enter - for none) (FLOAT)
          delta     (output) relative H and V phase difference atan(s3/s2) (enter - for none) (radians, FLOAT)
          alpha     (output) alpha parameter in the compact H/alpha decomposition: 0.5*atan(sqrt(s1**2 + s2**2)/s3) (enter - for none) (radians, FLOAT)
          phi       (output) longitude of Stokes vector 2*psi: atan(s2/s1) (enter - for none) (radians, FLOAT)

        """
        if self.validate_inputs:
            self._validate_stokes_qm(S, S_par, m, s2chi, s2psi, m_l, m_c, lp_ratio, cp_ratio, mu, delta, alpha, phi)
        if self.mock_outputs:
            self._mock_stokes_qm_outputs(S, S_par, m, s2chi, s2psi, m_l, m_c, lp_ratio, cp_ratio, mu, delta, alpha, phi)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.stokes_qm))
        return self._gamma_call("LAT", "stokes_qm", supplied_args)

    def _validate_frame(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: int,
        dx1: int,
        dx2: int,
        dy1: int,
        dy2: int,
        null_flag: Optional[int] = None,
        all_flag: Optional[int] = None,
        null_value: Optional[Path] = None,
        frame_value: Optional[Path] = None,
    ) -> None:
        self._validate("frame", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_frame_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: int,
        dx1: int,
        dx2: int,
        dy1: int,
        dy2: int,
        null_flag: Optional[int] = None,
        all_flag: Optional[int] = None,
        null_value: Optional[Path] = None,
        frame_value: Optional[Path] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def frame(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        dtype: int,
        dx1: int,
        dx2: int,
        dy1: int,
        dy2: int,
        null_flag: Optional[int] = None,
        all_flag: Optional[int] = None,
        null_value: Optional[Path] = None,
        frame_value: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT frame: Replace values near the image edges with a user-defined value


        input parameters:
          data_in      (input) image data file
          data_out     (output) image data file
          width        width of input data (samples/line)
          dtype        data type:
                         0: FLOAT    (REAL*4)
                         1: FCOMPLEX (REAL*4, REAL*4)
                         2: INTEGER  (INTEGER*4)
                         3: SHORT    (INTEGER*2)
                         4: BYTE     (UNSIGNED CHAR)
                         5: SUN/BMP/TIFF format raster image (8 or 24 bits/pixel)
          dx1          left side frame width (samples)
          dx2          right side frame width (samples)
          dy1          top side frame width (lines)
          dy2          bottom side frame width (lines)
          null_flag    specify how a new fame is added to the existing border around the image (enter - for default)
                         0: absolute border does not depend on the existing image pixel values (default)
                         1: border is added to the existing image border
          all_flag     specify classification of null values in SUN raster and BMP format files (enter - for default)
                         0: require only one component of the pixel RGB value to be NULL in order to belong to the NULL class (default)
                         1: require that all components of the pixel RGB value to be NULL in order to belong to the NULL class
          null_value   NULL value:
                         FLOAT, INTEGER, SHORT, BYTE default: 0.0
                         FCOMPLEX default: 0.0, 0.0
                         SUN/BMP/TIFF raster image default (RGB): 0 0 0
          frame_value  FRAME value:
                         FLOAT, INTEGER, SHORT, BYTE default: 0.0
                         FCOMPLEX default: 0.0 0.0
                         SUN/BMP/TIFF raster image default (RGB): 0 0 0

        """
        if self.validate_inputs:
            self._validate_frame(
                data_in, data_out, width, dtype, dx1, dx2, dy1, dy2, null_flag, all_flag, null_value, frame_value
            )
        if self.mock_outputs:
            self._mock_frame_outputs(
                data_in, data_out, width, dtype, dx1, dx2, dy1, dy2, null_flag, all_flag, null_value, frame_value
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.frame))
        return self._gamma_call("LAT", "frame", supplied_args)

    def _validate_looks(
        self,
    ) -> None:
        pass

    def _mock_looks_outputs(
        self,
    ) -> None:
        pass

    def looks(
        self,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/looks.c
        Equivalent number of looks (ENL) estimation for test areas (polygon regions)


          input parameters:
          pwr      (input) input intensity image file (floating point)
          width    image width in range pixels
          polygon  polygon data file
        """
        if self.validate_inputs:
            self._validate_looks()
        if self.mock_outputs:
            self._mock_looks_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.looks))
        return self._gamma_call("LAT", "looks", supplied_args)

    def _validate_polcoh(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        T: Path,
        T_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("polcoh", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("polcoh", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("polcoh", SLC_3.exists(), f"SLC_3 path does not exist ({SLC_3})")
        self._validate("polcoh", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("polcoh", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")
        self._validate("polcoh", SLC3_par.exists(), f"SLC3_par path does not exist ({SLC3_par})")

    def _mock_polcoh_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        T: Path,
        T_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        if T is not None and str(T) != "-":
            T.touch()
        if T_par is not None and str(T_par) != "-":
            T_par.touch()

    def polcoh(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC_3: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        SLC3_par: Path,
        T: Path,
        T_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate coherence matrix T elements from Pauli decomposition alpha, beta, gamma


        input parameters:
          SLC-1     (input) alpha single-look complex image (scomplex or fcomplex format)
          SLC-2     (input) beta single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC-3     (input) gamma single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC1_par  (input) SLC image parameter file of SLC-1
          SLC2_par  (input) SLC image parameter file of SLC-2 coregistered with SLC-1
          SLC3_par  (input) SLC image parameter file of SLC-3 coregistered with SLC-1
          T         (output) root file name of coherence matrix elements (e.g. scene_id): .t11, .t22, .t33 (float), .t12, .t13, .t23 (fcomplex)
          T_par     (output) MLI image parameter file associated with the coherence matrix element data files
          rlks      number of range looks used to calculate coherences
          azlks     number of azimuth looks used to calculate coherence
          loff      offset to starting line (default: 0)
          nlines    number of SLC lines to process (enter - for default: entire file)

        """
        if self.validate_inputs:
            self._validate_polcoh(
                SLC_1, SLC_2, SLC_3, SLC1_par, SLC2_par, SLC3_par, T, T_par, rlks, azlks, loff, nlines
            )
        if self.mock_outputs:
            self._mock_polcoh_outputs(
                SLC_1, SLC_2, SLC_3, SLC1_par, SLC2_par, SLC3_par, T, T_par, rlks, azlks, loff, nlines
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polcoh))
        return self._gamma_call("LAT", "polcoh", supplied_args)

    def _validate_lin_comb(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant: Any,
        factor1: Any,
        factor2: Any,
        f_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> None:
        self._validate("lin_comb", f1.exists(), f"f1 path does not exist ({f1})")
        self._validate("lin_comb", f2.exists(), f"f2 path does not exist ({f2})")

    def _mock_lin_comb_outputs(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant: Any,
        factor1: Any,
        factor2: Any,
        f_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> None:
        if f_out is not None and str(f_out) != "-":
            f_out.touch()

    def lin_comb(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant: Any,
        factor1: Any,
        factor2: Any,
        f_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/lin_comb.c
        Calculate linear combination of float data files


        input parameters:
          nfiles     number of input data files
          f1         (input) 1. input data file (float)
          f2         (input) 2. input data file (float)
          ...        (input) further input files
          constant   constant value to add to output
          factor1    factor1 to multiply with f1
          factor2    factor2 to multiply with f2
          ...        factors for further input files
          f_out      (output) output file (float)
          width      number of samples/row
          start      starting line (default: 1)
          nlines     number of lines to display (default 0: entire file)
          pixav_x    number of pixels to average in width (default: 1)
          pixav_y    number of pixels to average in height (default: 1)
          zero_flag  interpretation of 0.0 values:
                       0: interpreted as missing value (default)
                       1: 0.0 is valid data value

        """
        if self.validate_inputs:
            self._validate_lin_comb(
                nfiles, f1, f2, constant, factor1, factor2, f_out, width, start, nlines, pixav_x, pixav_y, zero_flag
            )
        if self.mock_outputs:
            self._mock_lin_comb_outputs(
                nfiles, f1, f2, constant, factor1, factor2, f_out, width, start, nlines, pixav_x, pixav_y, zero_flag
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lin_comb))
        return self._gamma_call("LAT", "lin_comb", supplied_args)

    def _validate_multi_class_mapping(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        fn: Path,
        classf: Path,
        ras_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[Any] = None,
        color_flag: Optional[int] = None,
    ) -> None:
        self._validate("multi_class_mapping", f1.exists(), f"f1 path does not exist ({f1})")
        self._validate("multi_class_mapping", f2.exists(), f"f2 path does not exist ({f2})")
        self._validate("multi_class_mapping", fn.exists(), f"fn path does not exist ({fn})")
        self._validate("multi_class_mapping", classf.exists(), f"classf path does not exist ({classf})")

    def _mock_multi_class_mapping_outputs(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        fn: Path,
        classf: Path,
        ras_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[Any] = None,
        color_flag: Optional[int] = None,
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def multi_class_mapping(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        fn: Path,
        classf: Path,
        ras_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[Any] = None,
        color_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program multi_class_mapping.c
        Classification based on multiple input files using threshold table


        input parameters:
          nfiles      number of input data files
          f1          (input) 1. input data file (float)
          f2          (input) 2. input data file (float)
          ...         (input) further input files
          fn          (input) last input data file (float)
          classf      (input) decision thresholds (text format)
                      each line contains thresholds for a single class for each input file lower and upper thresholds are requested
          ras_out     (output) 8-bit raster image file (SUN raster: *.ras,  BMP: *.bmp, TIFF: *.tif)
          width       number of samples/row
          start       starting line (enter - for default: 1)
          nlines      number of lines to display (enter - for default: 0=entire file)
          pixav_x     number of pixels to average in width (enter - for default: 1)
          pixav_y     number of pixels to average in height (enter - for default: 1)
          LR          left/right mirror image flag (enter - for default: 1: normal (default), -1: mirror image)
          color_flag  flag indicating if a color table is defined in file classf (enter - for default)
                        0: no color table defined (default)
                        1: color table defined

        """
        if self.validate_inputs:
            self._validate_multi_class_mapping(
                nfiles, f1, f2, fn, classf, ras_out, width, start, nlines, pixav_x, pixav_y, LR, color_flag
            )
        if self.mock_outputs:
            self._mock_multi_class_mapping_outputs(
                nfiles, f1, f2, fn, classf, ras_out, width, start, nlines, pixav_x, pixav_y, LR, color_flag
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.multi_class_mapping))
        return self._gamma_call("LAT", "multi_class_mapping", supplied_args)

    def _validate_takecut(
        self, data_in: Path, width: int, report: Path, mode: int, pos: Any, pr_flag: Optional[int] = None
    ) -> None:
        self._validate("takecut", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_takecut_outputs(
        self, data_in: Path, width: int, report: Path, mode: int, pos: Any, pr_flag: Optional[int] = None
    ) -> None:
        if report is not None and str(report) != "-":
            report.touch()

    def takecut(
        self, data_in: Path, width: int, report: Path, mode: int, pos: Any, pr_flag: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/takecut
        Extract data values along a line or vertical cut of a float data file


        input parameters:
          data_in  (input) input data file (float)
          width    samples per row of data_in
          report   (output) text file containing extracted values
          mode     data extraction mode (enter - for default)
                     0: extract values along a line (default)
                     1: extract values along a vertical cut
          pos      line or across-track sample number (starting with 0)
          pr_flag  print option (enter - for default)
                     0: print values at all positions (default)
                     1: print only positions with valid data (data != 0.0)

        """
        if self.validate_inputs:
            self._validate_takecut(data_in, width, report, mode, pos, pr_flag)
        if self.mock_outputs:
            self._mock_takecut_outputs(data_in, width, report, mode, pos, pr_flag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.takecut))
        return self._gamma_call("LAT", "takecut", supplied_args)

    def _validate_polyx_phase(self, data: Path, width: int, polygon: Path, report: Path) -> None:
        self._validate("polyx_phase", data.exists(), f"data path does not exist ({data})")
        self._validate("polyx_phase", polygon.exists(), f"polygon path does not exist ({polygon})")

    def _mock_polyx_phase_outputs(self, data: Path, width: int, polygon: Path, report: Path) -> None:
        if report is not None and str(report) != "-":
            report.touch()

    def polyx_phase(self, data: Path, width: int, polygon: Path, report: Path) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/polyx_phase
        Extraction of phase for polygon regions of complex valued image


        input parameters:
          data     (input) input data file (fcomplex)
          width    width in pixels
          polygon  (input) polygon data file
          report   (output) report on region statistics (text format)

        """
        if self.validate_inputs:
            self._validate_polyx_phase(data, width, polygon, report)
        if self.mock_outputs:
            self._mock_polyx_phase_outputs(data, width, polygon, report)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.polyx_phase))
        return self._gamma_call("LAT", "polyx_phase", supplied_args)

    def _validate_temp_lin_var(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[Any] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        norm_pow: Optional[Any] = None,
    ) -> None:
        self._validate("temp_lin_var", data_tab.exists(), f"data_tab path does not exist ({data_tab})")

    def _mock_temp_lin_var_outputs(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[Any] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        norm_pow: Optional[Any] = None,
    ) -> None:
        if mean is not None and str(mean) != "-":
            mean.touch()
        if stdev is not None and str(stdev) != "-":
            stdev.touch()

    def temp_lin_var(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[Any] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        norm_pow: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/temp_lin_var

        Calculation of temporal mean and variability (defined as stdev/pow(mean, norm_pow) of multiple data sets


        input parameters:
          data_tab   (input) single column list of the names of input data files (FLOAT)
          mean       (output) temporal mean (linear scale) (FLOAT)
          stdev      (output) temporal variability (stdev/pow(mean,norm_pow))(FLOAT)
          width      number of samples/row
          wy         spatial averaging filter height (enter - for default: 1.0)
          wx         spatial averaging filter width (enter - for default: 1.0)
          wt_flag    weighting function (enter - for default)
                       0: uniform (default)
                       1: linear
                       2: Gaussian
          zflag      zero data flag (enter - for default)
                       0: 0.0 interpreted as missing value (default)
                       1: 0.0 interpreted as valid data value
          loff       offset to starting line (enter - for default: 0)
          nlines     number of lines to process (enter - or 0 for default: entire file)
          norm_pow   temporal stdev is normalized with POW(mean,norm_pow) (enter - for default)
                       0.0: normalized with 1.0
                       1.0: normalized with backscatter intensity (default)

        """
        if self.validate_inputs:
            self._validate_temp_lin_var(data_tab, mean, stdev, width, wy, wx, wt_flag, zflag, loff, nlines, norm_pow)
        if self.mock_outputs:
            self._mock_temp_lin_var_outputs(
                data_tab, mean, stdev, width, wy, wx, wt_flag, zflag, loff, nlines, norm_pow
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.temp_lin_var))
        return self._gamma_call("LAT", "temp_lin_var", supplied_args)

    def _validate_mask_op(self, mask_1: Path, mask_2: Path, mask_out: Path, mode: int) -> None:
        self._validate("mask_op", mask_1.exists(), f"mask_1 path does not exist ({mask_1})")
        self._validate("mask_op", mask_2.exists(), f"mask_2 path does not exist ({mask_2})")

    def _mock_mask_op_outputs(self, mask_1: Path, mask_2: Path, mask_out: Path, mode: int) -> None:
        if mask_out is not None and str(mask_out) != "-":
            mask_out.touch()

    def mask_op(self, mask_1: Path, mask_2: Path, mask_out: Path, mode: int) -> Tuple[int, str, str]:
        """

        Pixel based logical mask operations on a pixel by pixel basis


        input parameters:
          mask-1    (input) mask 1 raster file SUN raster *.ras, BMP *.bmp, or TIFF *.tif 8-bits/pixel
          mask-2    (input) mask 2 raster file SUN raster *.ras, BMP *.bmp, or TIFF *.tif 8-bits/pixel
          mask_out  (output) output mask SUN raster *.ras, BMP *.bmp, or TIFF *.tif format
          mode      logical operations on a pixel by pixel basis:
                      0: if mask-1 > 0 AND mask-2 > 0 then mask_out = mask-1
                      1: if mask-1 > 0 then mask_out = mask-1, OR if mask-2 > 0 then mask_out = mask-2, otherwise mask_out = 0
                      2: if mask-1 > 0 then mask_out = 0, and if mask-1 == 0 then mask_out = 255

        """
        if self.validate_inputs:
            self._validate_mask_op(mask_1, mask_2, mask_out, mode)
        if self.mock_outputs:
            self._mock_mask_op_outputs(mask_1, mask_2, mask_out, mode)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.mask_op))
        return self._gamma_call("LAT", "mask_op", supplied_args)

    def _validate_quad2cp(
        self,
        SLC_HH: Path,
        SLC_HV: Path,
        SLC_VH: Path,
        SLC_VV: Path,
        SLC_HH_par: Path,
        SLC_HV_par: Path,
        SLC_VH_par: Path,
        SLC_VV_par: Path,
        CP: Path,
        TX_pol: int,
    ) -> None:
        self._validate("quad2cp", SLC_HH.exists(), f"SLC_HH path does not exist ({SLC_HH})")
        self._validate("quad2cp", SLC_HV.exists(), f"SLC_HV path does not exist ({SLC_HV})")
        self._validate("quad2cp", SLC_VH.exists(), f"SLC_VH path does not exist ({SLC_VH})")
        self._validate("quad2cp", SLC_VV.exists(), f"SLC_VV path does not exist ({SLC_VV})")
        self._validate("quad2cp", SLC_HH_par.exists(), f"SLC_HH_par path does not exist ({SLC_HH_par})")
        self._validate("quad2cp", SLC_HV_par.exists(), f"SLC_HV_par path does not exist ({SLC_HV_par})")
        self._validate("quad2cp", SLC_VH_par.exists(), f"SLC_VH_par path does not exist ({SLC_VH_par})")
        self._validate("quad2cp", SLC_VV_par.exists(), f"SLC_VV_par path does not exist ({SLC_VV_par})")

    def _mock_quad2cp_outputs(
        self,
        SLC_HH: Path,
        SLC_HV: Path,
        SLC_VH: Path,
        SLC_VV: Path,
        SLC_HH_par: Path,
        SLC_HV_par: Path,
        SLC_VH_par: Path,
        SLC_VV_par: Path,
        CP: Path,
        TX_pol: int,
    ) -> None:
        if CP is not None and str(CP) != "-":
            CP.touch()

    def quad2cp(
        self,
        SLC_HH: Path,
        SLC_HV: Path,
        SLC_VH: Path,
        SLC_VV: Path,
        SLC_HH_par: Path,
        SLC_HV_par: Path,
        SLC_VH_par: Path,
        SLC_VV_par: Path,
        CP: Path,
        TX_pol: int,
    ) -> Tuple[int, str, str]:
        """

        Synthesize Compact Polarization Data from quad-pol HH, VV, HV, VH SLC data
        Transmit polarization: RCP or LCP, receive polarization: H and V linear


        input parameters:
          SLC_HH      (input) HH single-look complex image (scomplex or fcomplex format)
          SLC_HV      (input) HV single-look complex image (coregistered with SLC_HH)(scomplex or fcomplex format)
          SLC_VH      (input) VH single-look complex image (coregistered with SLC_HH)(scomplex or fcomplex format)
          SLC_VV      (input) VV single-look complex image (coregistered with SLC_HH)(scomplex or fcomplex format)
          SLC_HH_par  (input) SLC_HH image parameter file
          SLC_HV_par  (input) SLC_HV image parameter file
          SLC_VH_par  (input) SLC_VH image parameter file
          SLC_VV_par  (input) SLC_VV image parameter file
          CP          (output) root file name of the 2 linearly polarized images (H,V): (fcomplex format)
                      RCP transmit: *_RH: 1/(sqrt(2) (S_HH - iS_HV)
                                    *_RV: 1/(sqrt(2) (S_VH - iS_VV)
                      LCP transmit: *_LH: 1/(sqrt(2) (S_HH + iS_HV)
                                    *_LV: 1/(sqrt(2) (S_VH + iS_VV)
          Note: SLC parameter files are created from the CP SLC name + .par
          TX_pol      transmit polarization of synthesized compact mode data:
                        0: RCP Right Circular Polarziation
                        1: LCP Left  Circular Polarziation

        """
        if self.validate_inputs:
            self._validate_quad2cp(
                SLC_HH, SLC_HV, SLC_VH, SLC_VV, SLC_HH_par, SLC_HV_par, SLC_VH_par, SLC_VV_par, CP, TX_pol
            )
        if self.mock_outputs:
            self._mock_quad2cp_outputs(
                SLC_HH, SLC_HV, SLC_VH, SLC_VV, SLC_HH_par, SLC_HV_par, SLC_VH_par, SLC_VV_par, CP, TX_pol
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.quad2cp))
        return self._gamma_call("LAT", "quad2cp", supplied_args)

    def _validate_poly_math(
        self,
    ) -> None:
        pass

    def _mock_poly_math_outputs(
        self,
    ) -> None:
        pass

    def poly_math(
        self,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/poly_math
        Mathematical operations on polygonal regions (float data)


          input parameters:
          data_in       (input) input data file (float)
          data_out      (output) output data file (float)
          width         number of samples/line
          polygon       text file containing polygon vertices
          offset_scale  text file containing offset and scale factors for data in each polygon
                        enter - to read offset and scale from the command line
          mode          data masking mode:
                          0: copy all data
                          1: copy data only within polygons, set the background to 0.0
          offset        constant offset applied for all data within polygons, (default: 0.0)
          scale         scale factor for all output polygon (default: 1.0)

        """
        if self.validate_inputs:
            self._validate_poly_math()
        if self.mock_outputs:
            self._mock_poly_math_outputs()
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.poly_math))
        return self._gamma_call("LAT", "poly_math", supplied_args)

    def _validate_single_class_mapping(
        self,
        nfiles: int,
        f1: Path,
        lt1: Any,
        fn: Any,
        ltn: Path,
        utn: Any,
        ras_out: Any,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[Any] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[Any] = None,
    ) -> None:
        self._validate("single_class_mapping", f1.exists(), f"f1 path does not exist ({f1})")
        self._validate("single_class_mapping", ltn.exists(), f"ltn path does not exist ({ltn})")

    def _mock_single_class_mapping_outputs(
        self,
        nfiles: int,
        f1: Path,
        lt1: Any,
        fn: Any,
        ltn: Path,
        utn: Any,
        ras_out: Any,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[Any] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[Any] = None,
    ) -> None:
        pass

    def single_class_mapping(
        self,
        nfiles: int,
        f1: Path,
        lt1: Any,
        fn: Any,
        ltn: Path,
        utn: Any,
        ras_out: Any,
        width: int,
        start: Optional[int] = None,
        nlines: Optional[Any] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program single_class_mapping.c
        Classification based on multiple input files with thresholds defined on the command line


        input parameters:
          nfiles    number of input data files
          f1        (input) 1. input data file (float)
          lt1       lower threshold for file 1
          ut1       upper threshold for file 1
          ...       (input) further input files
          fn        (input) last input data file (float)
          ltn       lower threshold for last file
          utn       upper threshold for last file
          ras_out   (output) 8-bit raster image file (SUN raster: *.ras,  BMP: *.bmp, TIFF: *.tif)
          width     number of samples/row
          start     starting line (enter - for default: 1)
          nlines    number of lines to display (enter - for default: 0=entire file)
          pixav_x   number of pixels to average in width (enter - for default: 1)
          pixav_y   number of pixels to average in height (enter - for default: 1)
          LR        left/right mirror image flag (enter - for default: 1: normal (default), -1: mirror image)

        """
        if self.validate_inputs:
            self._validate_single_class_mapping(
                nfiles, f1, lt1, fn, ltn, utn, ras_out, width, start, nlines, pixav_x, pixav_y, LR
            )
        if self.mock_outputs:
            self._mock_single_class_mapping_outputs(
                nfiles, f1, lt1, fn, ltn, utn, ras_out, width, start, nlines, pixav_x, pixav_y, LR
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.single_class_mapping))
        return self._gamma_call("LAT", "single_class_mapping", supplied_args)

    def _validate_drawthat(
        self,
        ras_in: Path,
        ras_out: Path,
        pt_list: Path,
        mode: Optional[int] = None,
        r: Optional[Any] = None,
        g: Optional[Any] = None,
        b: Optional[Any] = None,
        xs: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        self._validate("drawthat", ras_in.exists(), f"ras_in path does not exist ({ras_in})")
        self._validate("drawthat", pt_list.exists(), f"pt_list path does not exist ({pt_list})")

    def _mock_drawthat_outputs(
        self,
        ras_in: Path,
        ras_out: Path,
        pt_list: Path,
        mode: Optional[int] = None,
        r: Optional[Any] = None,
        g: Optional[Any] = None,
        b: Optional[Any] = None,
        xs: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def drawthat(
        self,
        ras_in: Path,
        ras_out: Path,
        pt_list: Path,
        mode: Optional[int] = None,
        r: Optional[Any] = None,
        g: Optional[Any] = None,
        b: Optional[Any] = None,
        xs: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT drawthat: Draw an arc, polygon, cross, or point on a SUN/BMP/TIFF raster image


        input parameters:
          ras_in   (input) raster image (SUN, BMP, or TIFF format)
          ras_out  (output) raster image with features drawn at points (SUN, BMP, or TIFF format)
          pt_list  (input) point list (text)
          mode     drawing mode (enter - for default)
                     0: draw an arc connecting points (default)
                     1: draw a filled polygon specified by the points
                     2: draw cross
          r        line color value red   (0 --> 255) (enter - for default: 255)
          g        line color value green (0 --> 255) (enter - for default: 255)
          b        line color value blue  (0 --> 255) (enter - for default: 0)
          xs       size of cross in pixels, set to 1 for single points (enter - for default: 1)
          zflg     zero image flag (enter - for default)
                     0: retain image values (default)
                     1: set all image values to 0 except points

        """
        if self.validate_inputs:
            self._validate_drawthat(ras_in, ras_out, pt_list, mode, r, g, b, xs, zflg)
        if self.mock_outputs:
            self._mock_drawthat_outputs(ras_in, ras_out, pt_list, mode, r, g, b, xs, zflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.drawthat))
        return self._gamma_call("LAT", "drawthat", supplied_args)

    def _validate_m_delta(self, s0: Path, m: Path, delta: Path, S_par: Path, c1: Path, c3: Path) -> None:
        self._validate("m-delta", s0.exists(), f"s0 path does not exist ({s0})")
        self._validate("m-delta", m.exists(), f"m path does not exist ({m})")
        self._validate("m-delta", delta.exists(), f"delta path does not exist ({delta})")
        self._validate("m-delta", S_par.exists(), f"S_par path does not exist ({S_par})")

    def _mock_m_delta_outputs(self, s0: Path, m: Path, delta: Path, S_par: Path, c1: Path, c3: Path) -> None:
        if c1 is not None and str(c1) != "-":
            c1.touch()
        if c3 is not None and str(c3) != "-":
            c3.touch()

    def m_delta(self, s0: Path, m: Path, delta: Path, S_par: Path, c1: Path, c3: Path) -> Tuple[int, str, str]:
        """

        Calculate m-delta decomposition from Stokes parameters


        input parameters:
          s0     (input) Stokes parameter for the total power in the H and V polarizations <|E_h|**2 + |E_v|**2>
          m      (input) degree of polarization: sqrt(s1**2 + s2**2 + s3**2)/s0 (float)
          delta  (input) relative H-V phase: atan(s3/s2):
          S_par  (input) MLI image parameter file associated with the Stokes parameter data files
          c1     (output) s0 * m * (1 + sin(delta))/2 (float)
          c2     (output) s0 * (1.0-m) depolarized component (float)
          c3     (output) s0 * m * (1 - sin(delta))/2 (float)
        """
        if self.validate_inputs:
            self._validate_m_delta(s0, m, delta, S_par, c1, c3)
        if self.mock_outputs:
            self._mock_m_delta_outputs(s0, m, delta, S_par, c1, c3)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.m_delta))
        return self._gamma_call("LAT", "m-delta", supplied_args)

    def _validate_temp_filt_ad(
        self,
        data_tab: Path,
        width: int,
        zflag: Optional[int] = None,
        loffset: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("temp_filt_ad", data_tab.exists(), f"data_tab path does not exist ({data_tab})")

    def _mock_temp_filt_ad_outputs(
        self,
        data_tab: Path,
        width: int,
        zflag: Optional[int] = None,
        loffset: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        pass

    def temp_filt_ad(
        self,
        data_tab: Path,
        width: int,
        zflag: Optional[int] = None,
        loffset: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/temp_filt_ad
        Multi-temporal filtering of registered data sets using adaptive spatial mean estimate


        input parameters:
          data_tab   (input) three column list of the names of input and output data files (FLOAT)
                       input file 1  spatially filtered file 1  output file 1
                       input file 2  spatially filtered file 2  output file 2
                        ...              ...                   ...
          width      number of samples/row
          zflag      zero data flag (enter - for default)
                       0: 0.0 interpreted as missing value (default)
                       1: 0.0 interpreted as valid data value
          loffset    number of lines offset to starting line (enter - for default: 0)
          nlines     number of lines to process (enter - or 0 for default: entire file)

        """
        if self.validate_inputs:
            self._validate_temp_filt_ad(data_tab, width, zflag, loffset, nlines)
        if self.mock_outputs:
            self._mock_temp_filt_ad_outputs(data_tab, width, zflag, loffset, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.temp_filt_ad))
        return self._gamma_call("LAT", "temp_filt_ad", supplied_args)

    def _validate_bm3d(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        profile: Optional[int] = None,
        looks: Optional[int] = None,
        sigma: Optional[Any] = None,
        block_size: Optional[Any] = None,
        s_dist: Optional[Any] = None,
        step: Optional[Any] = None,
        d_max: Optional[int] = None,
        t1d: Optional[int] = None,
    ) -> None:
        self._validate("bm3d", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_bm3d_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        profile: Optional[int] = None,
        looks: Optional[int] = None,
        sigma: Optional[Any] = None,
        block_size: Optional[Any] = None,
        s_dist: Optional[Any] = None,
        step: Optional[Any] = None,
        d_max: Optional[int] = None,
        t1d: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def bm3d(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        profile: Optional[int] = None,
        looks: Optional[int] = None,
        sigma: Optional[Any] = None,
        block_size: Optional[Any] = None,
        s_dist: Optional[Any] = None,
        step: Optional[Any] = None,
        d_max: Optional[int] = None,
        t1d: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Denoising using Block-Matching and 3D filtering (BM3D)


        input parameters:
          data_in     (input) input data file
          width       width of input data
          data_out    (output) output data file (same type as input)
          dtype       input and output data type (enter - for default)
                        0: FLOAT (default)
                        1: FCOMPLEX (profiles 2 and 6 only)
                        2: SUN/BMP/TIFF 8 or 24-bit raster image
          profile     profile types (enter - for default)
                        0: SAR-BM3D (fast), filtering on data (default)
                        1: SAR-BM3D (fine), filtering on data
                        2: BM3D, direct filtering on data (default for FCOMPLEX)
                        3: BM3D, filtering on sqrt(data)
                        4: BM3D, filtering on log(data)
                        5: C-BM3D, filtering color images (SUN/BMP/TIFF raster images only)
                        6: InSAR-BM3D, filtering on wrapped interferogram (FCOMPLEX only)
          looks       equivalent number of looks (necessary for SAR-BM3D and InSAR-BM3D, enter - for default: 10)
          sigma       estimated noise parameter (enter - or 0 for default: automatic estimation)
                      NOTE: for InSAR-BM3D, sigma is a factor multiplying the estimated standard deviation
          block_size  block size (enter - for default: 8)
          s_dist      maximum search distance (enter - for default: 16)
          step        step between reference blocks (enter - for default: 3)
          d_max       maximum pixel value distance in block matching (not available for SAR-BM3D and INSAR-BM3D, enter - for default)
                        0: estimated from data (default)
                        1: infinite
          t1d         type of transform in the third dimension (enter - for default)
                        0: Haar (default)
                        1: DCT

        """
        if self.validate_inputs:
            self._validate_bm3d(
                data_in, width, data_out, dtype, profile, looks, sigma, block_size, s_dist, step, d_max, t1d
            )
        if self.mock_outputs:
            self._mock_bm3d_outputs(
                data_in, width, data_out, dtype, profile, looks, sigma, block_size, s_dist, step, d_max, t1d
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.bm3d))
        return self._gamma_call("LAT", "bm3d", supplied_args)

    def _validate_restore_float(self, width: int, interpolation_limit: Optional[Any] = None) -> None:
        pass

    def _mock_restore_float_outputs(self, width: int, interpolation_limit: Optional[Any] = None) -> None:
        pass

    def restore_float(self, width: int, interpolation_limit: Optional[Any] = None) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/restore_float.c

        Interpolator to fill NULL values by interpolation


        input parameters:
          input file    (input) data containing 0.0 values (float)
          output file   (output) data with 0.0 values replaced (float)
          width         line width (samples)
          interp_limit  max. gap that is interpolated (default:10 samples)

        """
        if self.validate_inputs:
            self._validate_restore_float(width, interpolation_limit)
        if self.mock_outputs:
            self._mock_restore_float_outputs(width, interpolation_limit)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.restore_float))
        return self._gamma_call("LAT", "restore_float", supplied_args)

    def _validate_haalpha(
        self,
        alpha: Path,
        beta: Path,
        gamma: Path,
        SLC_par: Path,
        anisotropy: Path,
        entropy: Path,
        lambda1: Path,
        lambda2: Path,
        lambda3: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("haalpha", beta.exists(), f"beta path does not exist ({beta})")
        self._validate("haalpha", gamma.exists(), f"gamma path does not exist ({gamma})")
        self._validate("haalpha", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_haalpha_outputs(
        self,
        alpha: Path,
        beta: Path,
        gamma: Path,
        SLC_par: Path,
        anisotropy: Path,
        entropy: Path,
        lambda1: Path,
        lambda2: Path,
        lambda3: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        if alpha is not None and str(alpha) != "-":
            alpha.touch()
        if anisotropy is not None and str(anisotropy) != "-":
            anisotropy.touch()
        if entropy is not None and str(entropy) != "-":
            entropy.touch()
        if lambda1 is not None and str(lambda1) != "-":
            lambda1.touch()
        if lambda2 is not None and str(lambda2) != "-":
            lambda2.touch()
        if lambda3 is not None and str(lambda3) != "-":
            lambda3.touch()
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def haalpha(
        self,
        alpha: Path,
        beta: Path,
        gamma: Path,
        SLC_par: Path,
        anisotropy: Path,
        entropy: Path,
        lambda1: Path,
        lambda2: Path,
        lambda3: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/haalpha
        Calculate H/A/alpha (Entropy, Anisotropy, and alpha) decomposition from the 3D Pauli feature vector


        input parameters:
          alpha       (input) Pauli decomposition alpha component: (S_HH + S_VV)/sqrt(2) (fcomplex format)
          beta        (input) Pauli decomposition beta component:  (S_HH - S_VV)/sqrt(2) (fcomplex format)
          gamma       (input) Pauli decomposition gamma component: sqrt(2) * S_HV        (fcomplex format)
          SLC_par     (input) Pauli data SLC image parameter file
          anisotropy  (output) multi-look anisotropy component (enter - for none)
          alpha       (output) multi-look alpha component (enter - for none)
          entropy     (output) multi-look entropy component (enter - for none)
          lambda1     (output) multi-look lambda1 eigenvalue (enter - for none)
          lambda2     (output) multi-look lambda2 eigenvalue (enter - for none)
          lambda3     (output) multi-look lambda3 eigenvalue (enter - for none)
          MLI_par     (output) MLI ISP image parameter file
          rlks        number of range looks (default: 1)
          azlks       number of azimuth looks (default: 1)
          loff        offset to starting line (default: 0)
          nlines      number of SLC lines to process (default: entire file)
        """
        if self.validate_inputs:
            self._validate_haalpha(
                alpha,
                beta,
                gamma,
                SLC_par,
                anisotropy,
                entropy,
                lambda1,
                lambda2,
                lambda3,
                MLI_par,
                rlks,
                azlks,
                loff,
                nlines,
            )
        if self.mock_outputs:
            self._mock_haalpha_outputs(
                alpha,
                beta,
                gamma,
                SLC_par,
                anisotropy,
                entropy,
                lambda1,
                lambda2,
                lambda3,
                MLI_par,
                rlks,
                azlks,
                loff,
                nlines,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.haalpha))
        return self._gamma_call("LAT", "haalpha", supplied_args)

    def _validate_wolf(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        J: Path,
        J_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("wolf", SLC_1.exists(), f"SLC_1 path does not exist ({SLC_1})")
        self._validate("wolf", SLC_2.exists(), f"SLC_2 path does not exist ({SLC_2})")
        self._validate("wolf", SLC1_par.exists(), f"SLC1_par path does not exist ({SLC1_par})")
        self._validate("wolf", SLC2_par.exists(), f"SLC2_par path does not exist ({SLC2_par})")

    def _mock_wolf_outputs(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        J: Path,
        J_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        if J is not None and str(J) != "-":
            J.touch()
        if J_par is not None and str(J_par) != "-":
            J_par.touch()

    def wolf(
        self,
        SLC_1: Path,
        SLC_2: Path,
        SLC1_par: Path,
        SLC2_par: Path,
        J: Path,
        J_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Calculate Wolf coherence matrix from H and V polarized SLC images


        input parameters:
          SLC-1     (input) H polarized (HH or VH) single-look complex image (scomplex or fcomplex format)
          SLC-2     (input) V polarized (VV or HV) single-look complex image coregistered with SLC-1 (scomplex or fcomplex format)
          SLC1_par  (input) SLC image parameter file of SLC-1
          SLC2_par  (input) SLC image parameter file of SLC-2 coregistered with SLC-1
          J         (output) root file name of Wolf coherence matrix elements (e.g. scene_id): .j11, .j22, (float), .j12 (fcomplex)
          J_par     (output) MLI image parameter file associated with the Wolf coherence matrix element data files
          rlks      number of range looks used to calculate coherence
          azlks     number of azimuth looks used to calculate coherence
          loff      offset to starting line (default: 0)
          nlines    number of SLC lines to process (enter - for default: entire file)

        """
        if self.validate_inputs:
            self._validate_wolf(SLC_1, SLC_2, SLC1_par, SLC2_par, J, J_par, rlks, azlks, loff, nlines)
        if self.mock_outputs:
            self._mock_wolf_outputs(SLC_1, SLC_2, SLC1_par, SLC2_par, J, J_par, rlks, azlks, loff, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.wolf))
        return self._gamma_call("LAT", "wolf", supplied_args)

    def _validate_poly_mask(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        polygon: Any,
        mode: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        self._validate("poly_mask", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_poly_mask_outputs(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        polygon: Any,
        mode: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()

    def poly_mask(
        self,
        data_in: Path,
        data_out: Path,
        width: int,
        polygon: Any,
        mode: Optional[int] = None,
        dtype: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/poly_mask
        Mask data using polygonal image regions


        input parameters:
          data_in       (input) input data file
          data_out      (output) output data file
          width         number of samples/line
          polygon       text file containing polygon vertices
          mode          data masking mode (enter - for default)
                          0: copy data within polygons, set areas outside polygons to 0 (default)
                          1: copy data outside polygons, set areas within polygons to 0
          dtype         input and output data type (enter - for default)
                          0: FLOAT (default)
                          1: FCOMPLEX
                          2: Sun/BMP/TIFF 8 or 24-bit raster image
                          3: UNSIGNED CHAR
                          4: SHORT
                          5: SCOMPLEX
                          6: DOUBLE
                          7: INTEGER

        """
        if self.validate_inputs:
            self._validate_poly_mask(data_in, data_out, width, polygon, mode, dtype)
        if self.mock_outputs:
            self._mock_poly_mask_outputs(data_in, data_out, width, polygon, mode, dtype)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.poly_mask))
        return self._gamma_call("LAT", "poly_mask", supplied_args)

    def _validate_lee(
        self, input_data: Path, output_data: Path, width: int, nlooks: int, bx: int, by: Optional[int] = None
    ) -> None:
        self._validate("lee", input_data.exists(), f"input_data path does not exist ({input_data})")

    def _mock_lee_outputs(
        self, input_data: Path, output_data: Path, width: int, nlooks: int, bx: int, by: Optional[int] = None
    ) -> None:
        if output_data is not None and str(output_data) != "-":
            output_data.touch()

    def lee(
        self, input_data: Path, output_data: Path, width: int, nlooks: int, bx: int, by: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program lee.c
        Lee Filter (Lee, 1980)


        input parameters:
          input_data   (input) input intensity file
          output_data  (output) output intensity file (filtered)
          width        number of samples/row
          nlooks       number of looks
          bx           filter size in x direction (number of cols)
          by           filter size in y direction (number of rows) (enter - for default: by = bx)

        """
        if self.validate_inputs:
            self._validate_lee(input_data, output_data, width, nlooks, bx, by)
        if self.mock_outputs:
            self._mock_lee_outputs(input_data, output_data, width, nlooks, bx, by)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lee))
        return self._gamma_call("LAT", "lee", supplied_args)

    def _validate_enh_lee(
        self, input_data: Path, output_data: Path, width: int, nlooks: int, damp: Any, bx: int, by: Optional[int] = None
    ) -> None:
        self._validate("enh_lee", input_data.exists(), f"input_data path does not exist ({input_data})")

    def _mock_enh_lee_outputs(
        self, input_data: Path, output_data: Path, width: int, nlooks: int, damp: Any, bx: int, by: Optional[int] = None
    ) -> None:
        if output_data is not None and str(output_data) != "-":
            output_data.touch()

    def enh_lee(
        self, input_data: Path, output_data: Path, width: int, nlooks: int, damp: Any, bx: int, by: Optional[int] = None
    ) -> Tuple[int, str, str]:
        """

        LAT enh_lee: Enhanced Lee Filter (Lopes et al., 1990)


        input parameters:
          input_data   (input) input intensity file
          output_data  (output) output intensity file (filtered)
          width        number of samples/row
          nlooks       number of looks
          damp         damping constant of filter
          bx           filter size in x direction (number of cols)
          by           filter size in y direction (number of rows) (enter - for default: by = bx)

        """
        if self.validate_inputs:
            self._validate_enh_lee(input_data, output_data, width, nlooks, damp, bx, by)
        if self.mock_outputs:
            self._mock_enh_lee_outputs(input_data, output_data, width, nlooks, damp, bx, by)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.enh_lee))
        return self._gamma_call("LAT", "enh_lee", supplied_args)

    def _validate_ratio(
        self,
        d1: Path,
        d2: Path,
        ratio: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
        wgt_flag: Optional[int] = None,
    ) -> None:
        self._validate("ratio", d1.exists(), f"d1 path does not exist ({d1})")
        self._validate("ratio", d2.exists(), f"d2 path does not exist ({d2})")

    def _mock_ratio_outputs(
        self,
        d1: Path,
        d2: Path,
        ratio: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
        wgt_flag: Optional[int] = None,
    ) -> None:
        if ratio is not None and str(ratio) != "-":
            ratio.touch()

    def ratio(
        self,
        d1: Path,
        d2: Path,
        ratio: Path,
        width: int,
        bx: Optional[int] = None,
        by: Optional[int] = None,
        wgt_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT ratio: Estimate ratio of image data values: d1/d2 (float data)


        input parameters:
          d1       (input) data file 1 (float)
          d2       (input) data file 2 (float)
          ratio    (output) ratio: d1/d2  (float)
          width    number of samples/row of the input image
          bx       number of range samples to average before evaluating ratio (odd number, enter - for default: 5)
          by       number of azimuth lines to average before evaluating ratio (odd number, enter - for default: bx)
          wgt_flg  weighting flag (enter - for default)
                     0: no weighting function applied (default)
                     1: linear weighting function
                     2: Gaussian weighting function

        """
        if self.validate_inputs:
            self._validate_ratio(d1, d2, ratio, width, bx, by, wgt_flag)
        if self.mock_outputs:
            self._mock_ratio_outputs(d1, d2, ratio, width, bx, by, wgt_flag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ratio))
        return self._gamma_call("LAT", "ratio", supplied_args)

    def _validate_cc_ad(
        self,
        interf: Path,
        pwr1: Path,
        pwr2: Path,
        slope: Path,
        texture: Path,
        cc_ad: Path,
        width: int,
        box_min: Optional[Any] = None,
        box_max: Optional[Any] = None,
        wgt_flag: Optional[int] = None,
        loff: Optional[Any] = None,
        nl: Optional[int] = None,
    ) -> None:
        self._validate("cc_ad", interf.exists(), f"interf path does not exist ({interf})")
        self._validate("cc_ad", pwr1.exists(), f"pwr1 path does not exist ({pwr1})")
        self._validate("cc_ad", pwr2.exists(), f"pwr2 path does not exist ({pwr2})")
        self._validate("cc_ad", slope.exists(), f"slope path does not exist ({slope})")
        self._validate("cc_ad", texture.exists(), f"texture path does not exist ({texture})")

    def _mock_cc_ad_outputs(
        self,
        interf: Path,
        pwr1: Path,
        pwr2: Path,
        slope: Path,
        texture: Path,
        cc_ad: Path,
        width: int,
        box_min: Optional[Any] = None,
        box_max: Optional[Any] = None,
        wgt_flag: Optional[int] = None,
        loff: Optional[Any] = None,
        nl: Optional[int] = None,
    ) -> None:
        if cc_ad is not None and str(cc_ad) != "-":
            cc_ad.touch()

    def cc_ad(
        self,
        interf: Path,
        pwr1: Path,
        pwr2: Path,
        slope: Path,
        texture: Path,
        cc_ad: Path,
        width: int,
        box_min: Optional[Any] = None,
        box_max: Optional[Any] = None,
        wgt_flag: Optional[int] = None,
        loff: Optional[Any] = None,
        nl: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT cc_ad: Adaptive coherence estimation with consideration of phase slope and texture


        input parameters:
          interf    (input) complex interferogram
          pwr1      (input) intensity image of first scene (enter - for none)
          pwr2      (input) intensity image of second scene (enter - for none)
          slope     (input) phase slope data (enter - for none)
          texture   (input) backscatter texture data (enter - for none)
          cc_ad     (output) adaptive coherence estimate
          width     number of samples/row
          box_min   smallest correlation average box size (enter - for default: 3.0)
          box_max   largest correlation average box size  (enter - for default: 9.0)
          wgt_flag  weighting function (enter - for default)
                      0: constant (default)
                      1: gaussian
          loff      offset in lines to starting line (enter - for default: 0)
          nl        number of lines to process (enter - for default: 0, to end of file)

        """
        if self.validate_inputs:
            self._validate_cc_ad(interf, pwr1, pwr2, slope, texture, cc_ad, width, box_min, box_max, wgt_flag, loff, nl)
        if self.mock_outputs:
            self._mock_cc_ad_outputs(
                interf, pwr1, pwr2, slope, texture, cc_ad, width, box_min, box_max, wgt_flag, loff, nl
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cc_ad))
        return self._gamma_call("LAT", "cc_ad", supplied_args)

    def _validate_lin_comb_cpx(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant_r: Any,
        constant_i: Any,
        factor1_r: Any,
        factor1_i: Any,
        factor2_r: Any,
        factor2_i: Any,
        f_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> None:
        self._validate("lin_comb_cpx", f1.exists(), f"f1 path does not exist ({f1})")
        self._validate("lin_comb_cpx", f2.exists(), f"f2 path does not exist ({f2})")

    def _mock_lin_comb_cpx_outputs(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant_r: Any,
        constant_i: Any,
        factor1_r: Any,
        factor1_i: Any,
        factor2_r: Any,
        factor2_i: Any,
        f_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> None:
        if f_out is not None and str(f_out) != "-":
            f_out.touch()

    def lin_comb_cpx(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        constant_r: Any,
        constant_i: Any,
        factor1_r: Any,
        factor1_i: Any,
        factor2_r: Any,
        factor2_i: Any,
        f_out: Path,
        width: int,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        zero_flag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/lin_comb_cpx.c
        Calculate linear combination of fcomplex data files


        input parameters:
          nfiles      number of input data files
          f1          (input) 1. input data file (fcomplex)
          f2          (input) 2. input data file (fcomplex)
          ...         (input) further input files
          constant_r  constant value (real part) to add to output
          constant_i  constant value (imaginary part) to add to output
          factor1_r   factor1 (real part) to multiply with f1
          factor1_i   factor1 (imaginary part) to multiply with f1
          factor2_r   factor2 (real part) to multiply with f2
          factor2_i   factor2 (imaginary part) to multiply with f2
          ...         factors for further input files
          f_out       (output) output file (fcomplex)
          width       number of samples/row
          start       starting line (default=1)
          nlines      number of lines to display (default: 0=entire file)
          pixav_x     number of pixels to average in width (default=1)
          pixav_y     number of pixels to average in height (default=1)
          zero_flag   interpretation of 0.0 values:
                        0: interpreted as missing value (default)
                        1: 0.0 is valid data value

        """
        if self.validate_inputs:
            self._validate_lin_comb_cpx(
                nfiles,
                f1,
                f2,
                constant_r,
                constant_i,
                factor1_r,
                factor1_i,
                factor2_r,
                factor2_i,
                f_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                zero_flag,
            )
        if self.mock_outputs:
            self._mock_lin_comb_cpx_outputs(
                nfiles,
                f1,
                f2,
                constant_r,
                constant_i,
                factor1_r,
                factor1_i,
                factor2_r,
                factor2_i,
                f_out,
                width,
                start,
                nlines,
                pixav_x,
                pixav_y,
                zero_flag,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lin_comb_cpx))
        return self._gamma_call("LAT", "lin_comb_cpx", supplied_args)

    def _validate_median_filter(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[Any] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        self._validate("median_filter", din.exists(), f"din path does not exist ({din})")

    def _mock_median_filter_outputs(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[Any] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> None:
        if dout is not None and str(dout) != "-":
            dout.touch()

    def median_filter(
        self,
        din: Path,
        dout: Path,
        width: int,
        bx: int,
        by: Optional[Any] = None,
        min_pt: Optional[int] = None,
        zflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program median_filter.c
        Median filter (float data)


        input parameters:
          din     (input) input data file
          dout    (output) output data file (filtered)
          width   number of samples/row
          bx      filter window width (columns): 1,3,5,7...
          by      filter window height (rows): 1,3,5,7.., (enter - for default: bx)
          min_pt  minimum number of points required in the filter window to evaluate the median value (enter - for default: (bx*by)/4)
          zflg    zero value flag (enter - for default)
                    0: data values that are equal to 0.0 (no data) are not changed (default)
                    1: data gaps can be filled with median values

        """
        if self.validate_inputs:
            self._validate_median_filter(din, dout, width, bx, by, min_pt, zflg)
        if self.mock_outputs:
            self._mock_median_filter_outputs(din, dout, width, bx, by, min_pt, zflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.median_filter))
        return self._gamma_call("LAT", "median_filter", supplied_args)

    def _validate_cc_monitoring(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        ras_out: Path,
        width: int,
        cc_thresh: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[Any] = None,
    ) -> None:
        self._validate("cc_monitoring", f1.exists(), f"f1 path does not exist ({f1})")
        self._validate("cc_monitoring", f2.exists(), f"f2 path does not exist ({f2})")

    def _mock_cc_monitoring_outputs(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        ras_out: Path,
        width: int,
        cc_thresh: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[Any] = None,
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def cc_monitoring(
        self,
        nfiles: int,
        f1: Path,
        f2: Path,
        ras_out: Path,
        width: int,
        cc_thresh: Optional[Any] = None,
        start: Optional[Any] = None,
        nlines: Optional[int] = None,
        pixav_x: Optional[int] = None,
        pixav_y: Optional[int] = None,
        LR: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT cc_monitoring: Classification based on multiple input files using single threshold


        input parameters:
          nfiles     number of input data files
          f1         (input) 1. input data file (float)
          f2         (input) 2. input data file (float)
          ...        (input) further input files
          ras_out    (output) output 8-bit image file (SUN: *.ras, BMP: *.bmp, TIFF: *.tif)
          width      number of samples/row
          cc_thresh  classification threshold (enter - for default: 0.5)
          start      starting line (enter - for default: 1)
          nlines     number of lines to display (enter - for default: 0=entire file)
          pixav_x    number of pixels to average in width (enter - for default: 1)
          pixav_y    number of pixels to average in height (enter - for default: 1)
          LR         flip image left/right (1: normal (default), -1: mirror image) (enter - for default)

        """
        if self.validate_inputs:
            self._validate_cc_monitoring(nfiles, f1, f2, ras_out, width, cc_thresh, start, nlines, pixav_x, pixav_y, LR)
        if self.mock_outputs:
            self._mock_cc_monitoring_outputs(
                nfiles, f1, f2, ras_out, width, cc_thresh, start, nlines, pixav_x, pixav_y, LR
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.cc_monitoring))
        return self._gamma_call("LAT", "cc_monitoring", supplied_args)

    def _validate_temp_log_var(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[Any] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        self._validate("temp_log_var", data_tab.exists(), f"data_tab path does not exist ({data_tab})")

    def _mock_temp_log_var_outputs(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[Any] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> None:
        if mean is not None and str(mean) != "-":
            mean.touch()
        if stdev is not None and str(stdev) != "-":
            stdev.touch()

    def temp_log_var(
        self,
        data_tab: Path,
        mean: Path,
        stdev: Path,
        width: int,
        wy: Optional[Any] = None,
        wx: Optional[int] = None,
        wt_flag: Optional[int] = None,
        zflag: Optional[int] = None,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/temp_log_var

        Calculation of log-mean and log-stdev (temporal variability) of multiple data sets


        input parameters:
          data_tab   (input) single column list of the names of input data files (FLOAT)
          mean       (output) temporal mean in dB (FLOAT)
          stdev      (output) temporal variability, standard deviation in dB (FLOAT)
          width      number of samples/row
          wy         spatial averaging filter height (enter - for default: 1.0)
          wx         spatial averaging filter width (enter - for default: 1.0)
          wt_flag    weighting function (enter - for default)
                       0: uniform (default)
                       1: linear
                       2: Gaussian
          zflag      zero data flag (enter - for default)
                       0: 0.0 interpreted as missing value (default)
                       1: 0.0 interpreted as valid data value
          loff       offset to starting line (enter - for default: 0)
          nlines     number of lines to process (enter - or 0 for default: entire file)

        """
        if self.validate_inputs:
            self._validate_temp_log_var(data_tab, mean, stdev, width, wy, wx, wt_flag, zflag, loff, nlines)
        if self.mock_outputs:
            self._mock_temp_log_var_outputs(data_tab, mean, stdev, width, wy, wx, wt_flag, zflag, loff, nlines)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.temp_log_var))
        return self._gamma_call("LAT", "temp_log_var", supplied_args)

    def _validate_ras_to_hsi(
        self,
        HUE: Path,
        SATURATION: Path,
        INTENSITY: Path,
        ras_out: Path,
        LR: Optional[Any] = None,
        cflg: Optional[int] = None,
    ) -> None:
        self._validate("ras_to_hsi", HUE.exists(), f"HUE path does not exist ({HUE})")
        self._validate("ras_to_hsi", SATURATION.exists(), f"SATURATION path does not exist ({SATURATION})")
        self._validate("ras_to_hsi", INTENSITY.exists(), f"INTENSITY path does not exist ({INTENSITY})")

    def _mock_ras_to_hsi_outputs(
        self,
        HUE: Path,
        SATURATION: Path,
        INTENSITY: Path,
        ras_out: Path,
        LR: Optional[Any] = None,
        cflg: Optional[int] = None,
    ) -> None:
        if ras_out is not None and str(ras_out) != "-":
            ras_out.touch()

    def ras_to_hsi(
        self,
        HUE: Path,
        SATURATION: Path,
        INTENSITY: Path,
        ras_out: Path,
        LR: Optional[Any] = None,
        cflg: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program ras_to_hsi.c
        Combine 3 raster images (SUN, BMP, or TIFF format) into a HSI (hue/saturation/intensity) 24-bit raster image

        input parameters:
          HUE         (input) HUE channel 8-bit raster image (SUN, BMP, or TIFF format)
          SATURATION  (input) SATURATION channel 8-bit raster image (SUN, BMP, or TIFF format)
          INTENSITY   (input) INTENSITY channel 8-bit raster image (SUN, BMP, or TIFF format)
          ras_out     (output) HUE/SATURATION/INTENSITY 24-bit composite raster image (SUN, BMP, or TIFF format)
          LR          image mirror flag (enter - for default)
                        1: normal (default)
                       -1: mirror image
          cflg        color table flag (enter - for default)
                        0: use (red+green+blue)/3 as value (default)
                        1: scale input values linearly to 255

        """
        if self.validate_inputs:
            self._validate_ras_to_hsi(HUE, SATURATION, INTENSITY, ras_out, LR, cflg)
        if self.mock_outputs:
            self._mock_ras_to_hsi_outputs(HUE, SATURATION, INTENSITY, ras_out, LR, cflg)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.ras_to_hsi))
        return self._gamma_call("LAT", "ras_to_hsi", supplied_args)

    def _validate_edge_detection(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        op_flg: Optional[int] = None,
        sigma_x: Optional[Any] = None,
        sigma_y: Optional[Any] = None,
        T1: Optional[Any] = None,
        T2: Optional[Any] = None,
        min_seg_size: Optional[Any] = None,
        max_reg_len: Optional[Any] = None,
        max_reg_std: Optional[Any] = None,
        max_reg_dist: Optional[Any] = None,
        seg_out: Optional[Path] = None,
        line_filt: Optional[int] = None,
        max_line_std: Optional[Any] = None,
    ) -> None:
        self._validate("edge_detection", data_in.exists(), f"data_in path does not exist ({data_in})")

    def _mock_edge_detection_outputs(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        op_flg: Optional[int] = None,
        sigma_x: Optional[Any] = None,
        sigma_y: Optional[Any] = None,
        T1: Optional[Any] = None,
        T2: Optional[Any] = None,
        min_seg_size: Optional[Any] = None,
        max_reg_len: Optional[Any] = None,
        max_reg_std: Optional[Any] = None,
        max_reg_dist: Optional[Any] = None,
        seg_out: Optional[Path] = None,
        line_filt: Optional[int] = None,
        max_line_std: Optional[Any] = None,
    ) -> None:
        if data_out is not None and str(data_out) != "-":
            data_out.touch()
        if seg_out is not None and str(seg_out) != "-":
            seg_out.touch()

    def edge_detection(
        self,
        data_in: Path,
        width: int,
        data_out: Path,
        dtype: Optional[int] = None,
        op_flg: Optional[int] = None,
        sigma_x: Optional[Any] = None,
        sigma_y: Optional[Any] = None,
        T1: Optional[Any] = None,
        T2: Optional[Any] = None,
        min_seg_size: Optional[Any] = None,
        max_reg_len: Optional[Any] = None,
        max_reg_std: Optional[Any] = None,
        max_reg_dist: Optional[Any] = None,
        seg_out: Optional[Path] = None,
        line_filt: Optional[int] = None,
        max_line_std: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        Detection of edges in an image using a Canny edge detector - extraction of line segments


        input parameters:
          data_in       (input) input data file
          width         width of input data
          data_out      (output) output data file (FLOAT type)
          dtype         input data type (enter - for default)
                          0: FLOAT (default)
                          1: SUN/BMP/TIFF 8 or 24-bit raster image
          op_flg        operation before computing edges (enter - for default)
                          0: none (default)
                          1: sqrt
                          2: log
          sigma_x       Gaussian filter sigma parameter in horizontal direction (enter - for default: 1.00)
          sigma_y       Gaussian filter sigma parameter in vertical direction (enter - for default: same as sigma_x)
          T1            low gradient value for hysteresis thresholding relative to maximum gradient (0 < T1 < 1, enter - for default: 0.01)
          T2            high gradient value for hysteresis thresholding relative to maximum gradient (T1 < T2 < 1, enter - for default: 0.10)
          min_seg_size  minimum segment size (enter - for default: 0)
                        NOTE: only segments with a limited curvature will be kept if [min_seg_size] > 1,
                              the curvature is defined by [max_reg_len] [max_reg_std] and [max_reg_dist] values
          max_reg_len   maximum linear regression length (must be >= 3, enter - for default: 9)
          max_reg_std   maximum standard deviation of segment linear regression (enter - for default: 1.00)
          max_reg_dist  maximum distance between candidate pixel and linear regression (enter - for default: 2.00)
          seg_out       (output) output text file containing the detected line segments (requires [min_seg_size] > 1, enter - for none)
          line_filt     flag for filtering out non-straight lines (enter - for default)
                          0: no filter (default)
                          1: keep only straight lines (requires [min_seg_size] > 1)
          max_line_std  maximum standard deviation of line linear regression (enter - for default: 1.00)

        """
        if self.validate_inputs:
            self._validate_edge_detection(
                data_in,
                width,
                data_out,
                dtype,
                op_flg,
                sigma_x,
                sigma_y,
                T1,
                T2,
                min_seg_size,
                max_reg_len,
                max_reg_std,
                max_reg_dist,
                seg_out,
                line_filt,
                max_line_std,
            )
        if self.mock_outputs:
            self._mock_edge_detection_outputs(
                data_in,
                width,
                data_out,
                dtype,
                op_flg,
                sigma_x,
                sigma_y,
                T1,
                T2,
                min_seg_size,
                max_reg_len,
                max_reg_std,
                max_reg_dist,
                seg_out,
                line_filt,
                max_line_std,
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.edge_detection))
        return self._gamma_call("LAT", "edge_detection", supplied_args)

    def _validate_texture(
        self,
        data_in: Path,
        format_flag: Any,
        texture: Path,
        width: int,
        type: Optional[int] = None,
        bx: Optional[Any] = None,
        by: Optional[Any] = None,
        r_looks: Optional[Any] = None,
        az_looks: Optional[Any] = None,
        weights_flag: Optional[int] = None,
        data_in_mean: Optional[Path] = None,
    ) -> None:
        self._validate("texture", data_in.exists(), f"data_in path does not exist ({data_in})")
        if data_in_mean is not None:
            self._validate("texture", data_in_mean.exists(), f"data_in_mean path does not exist ({data_in_mean})")

    def _mock_texture_outputs(
        self,
        data_in: Path,
        format_flag: Any,
        texture: Path,
        width: int,
        type: Optional[int] = None,
        bx: Optional[Any] = None,
        by: Optional[Any] = None,
        r_looks: Optional[Any] = None,
        az_looks: Optional[Any] = None,
        weights_flag: Optional[int] = None,
        data_in_mean: Optional[Path] = None,
    ) -> None:
        if texture is not None and str(texture) != "-":
            texture.touch()

    def texture(
        self,
        data_in: Path,
        format_flag: Any,
        texture: Path,
        width: int,
        type: Optional[int] = None,
        bx: Optional[Any] = None,
        by: Optional[Any] = None,
        r_looks: Optional[Any] = None,
        az_looks: Optional[Any] = None,
        weights_flag: Optional[int] = None,
        data_in_mean: Optional[Path] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: Program texture.c
        Estimation of image texture defined as stdev/mean or log<I>-<logI>


        input parameters:
          data_in      (input) data file (float, fcomplex, or scomplex)
          format_flag  format of data_in: 0: float, 1: fcomplex, 2: scomplex)
          texture      (output) image texture (float) defined as normalized second moment
          width        number of samples/row
          type         texture measure flag (enter - for default)
                         0: texture defined as stdev/mean (default)
                         1: log<I>-<logI>
          bx           estimation window size in input image range pixels (enter - for default: 15)
          by           estimation window size in input image azimuth pixels (default - for default: bx)
          r_looks      range multilooking (in range pixels) (enter - for default: 1)
          az_looks     azimuth multilooking (in azimuth pixels) (enter - for default: 1)
          wgt_flag     weighting function: (enter - for default)
                         0: no weighting function applied (default)
                         1: linear weighting function
                         2: Gaussian weighting function
          data_in_mean (input) first moment of input data file (float) (enter - for none)

        """
        if self.validate_inputs:
            self._validate_texture(
                data_in, format_flag, texture, width, type, bx, by, r_looks, az_looks, weights_flag, data_in_mean
            )
        if self.mock_outputs:
            self._mock_texture_outputs(
                data_in, format_flag, texture, width, type, bx, by, r_looks, az_looks, weights_flag, data_in_mean
            )
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.texture))
        return self._gamma_call("LAT", "texture", supplied_args)

    def _validate_diplane_helix(
        self,
        LL: Path,
        RR: Path,
        SLC_par: Path,
        diplane: Path,
        helix: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
    ) -> None:
        self._validate("diplane_helix", LL.exists(), f"LL path does not exist ({LL})")
        self._validate("diplane_helix", RR.exists(), f"RR path does not exist ({RR})")
        self._validate("diplane_helix", SLC_par.exists(), f"SLC_par path does not exist ({SLC_par})")

    def _mock_diplane_helix_outputs(
        self,
        LL: Path,
        RR: Path,
        SLC_par: Path,
        diplane: Path,
        helix: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
    ) -> None:
        if diplane is not None and str(diplane) != "-":
            diplane.touch()
        if helix is not None and str(helix) != "-":
            helix.touch()
        if MLI_par is not None and str(MLI_par) != "-":
            MLI_par.touch()

    def diplane_helix(
        self,
        LL: Path,
        RR: Path,
        SLC_par: Path,
        diplane: Path,
        helix: Path,
        MLI_par: Path,
        rlks: int,
        azlks: int,
        loff: Optional[int] = None,
        nlines: Optional[int] = None,
        scale: Optional[Any] = None,
    ) -> Tuple[int, str, str]:
        """

        LAT diplane_helix: Calculate Helix and Diplane composition from RR and LL circular components


        input parameters:
          LL          (input) single-look complex image with LL circular component
          RR          (input) single-look complex image with RR circular component
          SLC_par     (input) SLC ISP image parameter file
          diplane     (output) multi-look intensity image with diplane component
          helix       (output) multi-look intensity image with helix component
          MLI_par     (output) MLI ISP image parameter file
          rlks        number of range looks
          azlks       number of azimuth looks
          loff        offset to starting line (default: 0)
          nlines      number of SLC lines to process (default: entire file)
          scale       scale factor for output MLI (default: 1.0)

        """
        if self.validate_inputs:
            self._validate_diplane_helix(LL, RR, SLC_par, diplane, helix, MLI_par, rlks, azlks, loff, nlines, scale)
        if self.mock_outputs:
            self._mock_diplane_helix_outputs(LL, RR, SLC_par, diplane, helix, MLI_par, rlks, azlks, loff, nlines, scale)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.diplane_helix))
        return self._gamma_call("LAT", "diplane_helix", supplied_args)

    def _validate_lin_comb_ref(
        self,
        f1: Path,
        f2: Path,
        constant: Any,
        factor1: Any,
        factor2: Any,
        f_out: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        self._validate("lin_comb_ref", f1.exists(), f"f1 path does not exist ({f1})")
        self._validate("lin_comb_ref", f2.exists(), f"f2 path does not exist ({f2})")

    def _mock_lin_comb_ref_outputs(
        self,
        f1: Path,
        f2: Path,
        constant: Any,
        factor1: Any,
        factor2: Any,
        f_out: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> None:
        if f_out is not None and str(f_out) != "-":
            f_out.touch()

    def lin_comb_ref(
        self,
        f1: Path,
        f2: Path,
        constant: Any,
        factor1: Any,
        factor2: Any,
        f_out: Path,
        width: int,
        roff: Optional[int] = None,
        loff: Optional[int] = None,
        nr: Optional[int] = None,
        nl: Optional[int] = None,
        zflag: Optional[int] = None,
    ) -> Tuple[int, str, str]:
        """

        Land Application Tools: /Users/daleroberts/Work/GAMMA_SOFTWARE-20221129/LAT/bin/lin_comb_ref.c
        Calculate linear combination of 2 images (float) with option to add or subtract the scaled average of a specified reference region


        input parameters:
          f1         (input) input data file 1 (float)
          f2         (input) input data file 2,  reference scene if this mode selected by selecting a region with roff and loff (float)
          constant   constant value to add to output
          factor1    factor1 to multiply with f1
          factor2    factor2 to multiply with f2, or reference region average, set to -1.0 to subtract reference region value
          f_out      (output) output file (float)
          width      number of samples/row
          roff       range pixel offset to center of the reference region in f2, (default: -1, otherwise center of reference region)
          loff       line offset to center of the reference region
          nr         number of range pixels to average in the reference region (enter - for default = 16)
          nl         number of lines average in the reference region (enter - for default= 16)
          zflag      interpretation of 0.0 data values:
                       0: interpreted as missing value (default)
                       1: 0.0 is valid data value

        """
        if self.validate_inputs:
            self._validate_lin_comb_ref(f1, f2, constant, factor1, factor2, f_out, width, roff, loff, nr, nl, zflag)
        if self.mock_outputs:
            self._mock_lin_comb_ref_outputs(f1, f2, constant, factor1, factor2, f_out, width, roff, loff, nr, nl, zflag)
        supplied_args = self._clean_call_args(locals(), inspect.signature(self.lin_comb_ref))
        return self._gamma_call("LAT", "lin_comb_ref", supplied_args)
